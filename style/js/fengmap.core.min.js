/*! Released Version 2.7.2,BUILD 22. Fengmap Javascript SDK, see: https://www.fengmap.com for details */
var b, c;
b = this, c = function () {
    return (n = [function (e, t, n) {
        e.exports = n(256)
    }, function (e) {
        function t(e) {
            return e && e.__esModule ? e : {
                default: e
            }
        }
        e.exports = t
    }, function (e) {
        function t(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        e.exports = t
    }, function (e, t, n) {
        var i = n(0);

        function r(e, t) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), i(e, r.key, r)
            }
        }

        function a(e, t, n) {
            return t && r(e.prototype, t), n && r(e, n), e
        }
        e.exports = a
    }, function (e, t, n) {
        var r = n(47),
            i = n(104);

        function a(e, t) {
            return !t || "object" !== r(t) && "function" != typeof t ? i(e) : t
        }
        e.exports = a
    }, function (t, e, n) {
        var r = n(306),
            i = n(190);

        function a(e) {
            return t.exports = a = i ? r : function (e) {
                return e.__proto__ || r(e)
            }, a(e)
        }
        t.exports = a
    }, function (e, t, n) {
        var r = n(31),
            i = n(314);

        function a(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
            e.prototype = r(t && t.prototype, {
                constructor: {
                    value: e,
                    writable: !0,
                    configurable: !0
                }
            }), t && i(e, t)
        }
        e.exports = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function n(e, t) {
                    (0, a.default)(this, n), this._eid = e, this._groupId = e, this.parent = null, this._nodeType = t, this._x = 0, this._y = 0, this._z = 0, this._height = 0, this._alwaysShow = !1, this._show = !0, this.needAvoid = !0, this.renderNodeInited = !1, this.tryInit = !1, this._visible = !0
                }
                return (0, o.default)(n, [{
                    key: "findParent",
                    value: function (e) {
                        for (var t = this.parent; t;) {
                            if (t instanceof e) return t;
                            t = t.parent
                        }
                        return !1
                    }
                }, {
                    key: "avoid",
                    value: function (e) {
                        this.needAvoid = e, e || (this.show = !0)
                    }
                }, {
                    key: "alwaysShow",
                    value: function () {
                        var e;
                        this._alwaysShow = !0;
                        for (var t = this.parent; t;) {
                            if (t.isGroup) {
                                e = t;
                                break
                            }
                            t = t.parent
                        }
                        e && this.renderNode && e.alwaysShowMarkers.push(this.renderNode)
                    }
                }, {
                    key: "isAlwaysShow",
                    get: function () {
                        return this._alwaysShow
                    }
                }, {
                    key: "groupID",
                    get: function () {
                        if (this.isGroup) return this._eid;
                        for (var e, t = this.parent; t;) {
                            if (t.isGroup) {
                                e = t;
                                break
                            }
                            t = t.parent
                        }
                        return e ? e.eid : 0
                    }
                }, {
                    key: "height",
                    set: function (e) {
                        this._height = e
                    },
                    get: function () {
                        return this._height
                    }
                }, {
                    key: "mapCoord",
                    set: function (e) {
                        this._mapCoord = e
                    },
                    get: function () {
                        return {
                            x: this._x,
                            y: this._y,
                            z: this._height
                        }
                    }
                }, {
                    key: "nodeType",
                    set: function (e) {
                        this._nodeType = e
                    },
                    get: function () {
                        return this._nodeType
                    }
                }, {
                    key: "show",
                    set: function (e) {
                        this._show = e, this._renderNode && (this._renderNode.visible = e)
                    },
                    get: function () {
                        return this._show
                    }
                }, {
                    key: "x",
                    set: function (e) {
                        this._x = e
                    },
                    get: function () {
                        return this._x
                    }
                }, {
                    key: "y",
                    set: function (e) {
                        this._y = e
                    },
                    get: function () {
                        return this._y
                    }
                }, {
                    key: "z",
                    set: function (e) {
                        this._z = e
                    },
                    get: function () {
                        return this._z
                    }
                }, {
                    key: "eid",
                    get: function () {
                        return this._eid
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }]), n
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        var r = n(33).f,
            i = Function.prototype,
            a = /^\s*function ([^ (]*)/,
            o = "name";
        o in i || n(23) && r(i, o, {
            configurable: !0,
            get: function () {
                try {
                    return ("" + this).match(a)[1]
                } catch (e) {
                    return ""
                }
            }
        })
    }, function (e) {
        var t = e.exports = {
            version: "2.6.11"
        };
        "number" == typeof __e && (__e = t)
    }, function (e, t, n) {
        var g = n(14),
            m = n(9),
            v = n(36),
            y = n(43),
            _ = n(45),
            A = "prototype",
            x = function (e, t, n) {
                var r, i, a, o = e & x.F,
                    s = e & x.G,
                    l = e & x.S,
                    u = e & x.P,
                    h = e & x.B,
                    c = e & x.W,
                    d = s ? m : m[t] || (m[t] = {}),
                    f = d[A],
                    p = s ? g : l ? g[t] : (g[t] || {})[A];
                for (r in s && (n = t), n) i = !o && p && void 0 !== p[r], i && _(d, r) || (a = i ? p[r] : n[r], d[r] = s && "function" != typeof p[r] ? n[r] : h && i ? v(a, g) : c && p[r] == a ? function (r) {
                    var e = function (e, t, n) {
                        if (this instanceof r) {
                            switch (arguments.length) {
                                case 0:
                                    return new r;
                                case 1:
                                    return new r(e);
                                case 2:
                                    return new r(e, t)
                            }
                            return new r(e, t, n)
                        }
                        return r.apply(this, arguments)
                    };
                    return e[A] = r[A], e
                }(a) : u && "function" == typeof a ? v(Function.call, a) : a, u && ((d.virtual || (d.virtual = {}))[r] = a, e & x.R && f && !f[r] && y(f, r, a)))
            };
        x.F = 1, x.G = 2, x.S = 4, x.P = 8, x.B = 16, x.W = 32, x.U = 64, x.R = 128, e.exports = x
    }, function (e, t, n) {
        e.exports = n(346)
    }, function (e, t, n) {
        e.exports = n(373)
    }, function (e, t, n) {
        "use strict";
        var c = n(164),
            _ = n(30),
            A = n(188),
            x = n(142),
            C = n(34),
            I = n(96),
            d = n(132),
            r = n(18),
            w = Math.min,
            f = [].push,
            o = "split",
            p = "length",
            g = "lastIndex",
            M = 4294967295,
            b = !r(function () {
                RegExp(M, "y")
            });
        n(98)("split", 2, function (i, a, m, v) {
            var y;
            return y = "c" == "abbc" [o](/(b)*/)[1] || 4 != "test" [o](/(?:)/, -1)[p] || 2 != "ab" [o](/(?:ab)*/)[p] || 4 != "." [o](/(.?)(.?)/)[p] || 1 < "." [o](/()()/)[p] || "" [o](/.?/)[p] ? function (e, t) {
                var n = String(this);
                if (void 0 === e && 0 === t) return [];
                if (!c(e)) return m.call(n, e, t);
                for (var r, i, a, o = [], s = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), l = 0, u = void 0 === t ? M : t >>> 0, h = new RegExp(e.source, s + "g");
                    (r = d.call(h, n)) && (i = h[g], !(l < i && (o.push(n.slice(l, r.index)), 1 < r[p] && r.index < n[p] && f.apply(o, r.slice(1)), a = r[0][p], l = i, o[p] >= u)));) h[g] === r.index && h[g]++;
                return l === n[p] ? !a && h.test("") || o.push("") : o.push(n.slice(l)), o[p] > u ? o.slice(0, u) : o
            } : "0" [o](void 0, 0)[p] ? function (e, t) {
                return void 0 === e && 0 === t ? [] : m.call(this, e, t)
            } : m, [function (e, t) {
                var n = i(this),
                    r = null == e ? void 0 : e[a];
                return void 0 !== r ? r.call(e, n, t) : y.call(String(n), e, t)
            }, function (e, t) {
                var n = v(y, e, this, t, y !== m);
                if (n.done) return n.value;
                var r = _(e),
                    i = String(this),
                    a = A(r, RegExp),
                    o = r.unicode,
                    s = (r.ignoreCase ? "i" : "") + (r.multiline ? "m" : "") + (r.unicode ? "u" : "") + (b ? "y" : "g"),
                    l = new a(b ? r : "^(?:" + r.source + ")", s),
                    u = void 0 === t ? M : t >>> 0;
                if (0 === u) return [];
                if (0 === i.length) return null === I(l, i) ? [i] : [];
                for (var h = 0, c = 0, d = []; c < i.length;) {
                    l.lastIndex = b ? c : 0;
                    var f, p = I(l, b ? i : i.slice(c));
                    if (null === p || (f = w(C(l.lastIndex + (b ? 0 : c)), i.length)) === h) c = x(i, c, o);
                    else {
                        if (d.push(i.slice(h, c)), d.length === u) return d;
                        for (var g = 1; g <= p.length - 1; g++)
                            if (d.push(p[g]), d.length === u) return d;
                        c = h = f
                    }
                }
                return d.push(i.slice(h)), d
            }]
        })
    }, function (e) {
        var t = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = t)
    }, function (e, t, n) {
        var r = n(118)("wks"),
            i = n(73),
            a = n(24).Symbol,
            o = "function" == typeof a,
            s = e.exports = function (e) {
                return r[e] || (r[e] = o && a[e] || (o ? a : i)("Symbol." + e))
            };
        s.store = r
    }, function (e, t, n) {
        e.exports = n(333)
    }, function (e) {
        e.exports = function (e) {
            return "object" == typeof e ? null !== e : "function" == typeof e
        }
    }, function (e) {
        e.exports = function (e) {
            try {
                return !!e()
            } catch (e) {
                return !0
            }
        }
    }, function (e, t, n) {
        var r = n(129)("wks"),
            i = n(94),
            a = n(14).Symbol,
            o = "function" == typeof a,
            s = e.exports = function (e) {
                return r[e] || (r[e] = o && a[e] || (o ? a : i)("Symbol." + e))
            };
        s.store = r
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(68), n(8);
        var P = r(n(16));
        n(13);
        var D = r(n(11)),
            A = r(n(54)),
            O = r(n(12)),
            F = r(n(35)),
            a = r(n(2)),
            o = r(n(3)),
            s = r(n(150)),
            B = r(n(42)),
            l = r(n(394)),
            g = r(n(228)),
            m = r(n(398)),
            u = r(n(400)),
            h = r(n(411)),
            G = r(n(57)),
            b = r(n(81)),
            _ = r(n(80)),
            U = n(412),
            z = n(413),
            c = function () {
                function n(e, t) {
                    (0, a.default)(this, n), this._scenes = {}, this._materialManager = new l.default(e.font), this._raycaster = new fm.Raycaster, this._focusAlphaMode = e._focusAlphaMode, this._focusAlpha = e._focusAlpha, this._map = t, this._externalModelUrl = e.mapServerURL + "/models/", this._externalLoader = new u.default(this._externalModelUrl, "fengmap" == e.mapServerURL, e.key), this._dynamicLoader = new h.default, this._externalLoader.setLoadedBack(function () {
                        t.dispatchEvent({
                            type: "externalLoaded"
                        }), t.dispatchEvent({
                            type: "gltfLoaded"
                        }), t.checkNode(), t.setRenderList()
                    }), this.isNeedSweep = t.MapOptions.isNeedSweep, this.sweepMax = t.MapOptions.sweepMax, this.sweepMin = t.MapOptions.sweepMin
                }
                return (0, o.default)(n, [{
                    key: "createCompassNode",
                    value: function (e, t, n, r, i) {
                        var a = 0 < arguments.length && void 0 !== e ? arguments[0] : 1,
                            o = 1 < arguments.length ? t : void 0,
                            s = 2 < arguments.length ? n : void 0,
                            l = 3 < arguments.length ? r : void 0,
                            u = 4 < arguments.length ? i : void 0,
                            h = o || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAGhUlEQVR4nOWbzW/cRBjGn7HHY7u7m8RLojIF8SFUUQECFQqnimsF/wAgEIiWKEqgH+LjAJxRDwjU0kIEpZWASvQvAM6IEy1IILUqogiEaKZVluxu1tv1ztgeDvHSELLJfno3yU/KIfaM93kfjz2ej5fMzc2hEzjnLZUTQowCeBzAgwDuBbALAAfgAcgkxaoASgDmAFwG8AuAnwF8yzkvdySwRUg/DBBC3APgOQBPEEIeZYzVKKV1SqmklErTNEPDMGJCSAwAWmsjjmMjiiIahiFL/mwppau1Pg/gawBnOee/dSR2DXpmgBDCBPA0gGnTNB9zHGfRcZwqYyzoRqCU0gmCIBMEwUgURd8DmAVwjnMedXPdBl0bkAR+GMB7juNUtm3bVrJtu9YLcSup1+vujRs3xoIgyAF4DcDxbo3oygAhxEsATrmuW85mswuUUtWNmFYJw9DyfT9fq9VGAUxyzj/t9FqdGnAfgBnLsg6MjIxcZ4zVOxXQDVJKe3FxcbtS6jSAjzjnl9q9RicGzBBCTmaz2flsNltqt3I/8H1/zPf9Ca31K5zzj9qp264BR03TfNXzPGFZ1kDuejOUUnaxWORRFL3HOX+r1XpGG79xjDF2aHx8/M9hCx4ALMuqj4+P/8kYOyyEONZqvVYNOGHb9v58Pn/VMIy4Q419xzCMOJ/PX7Vte78Q4kRLdVooc8y27Rfy+bwghOguNfYdQojO5/PCtu0XWmkJ6xlwlDE26XnetR7pSw3P864xxiaFEEfXKreWATPJC29uI9z5lRBCtOd5c6ZpviqEmGlWrpkBDxBCTnqeJ4b5mV8PwzBiz/MEIeSkEOL+Vcs0qTudy+Xmh/Ft3y6WZdVzudw8gOnVzq9mwIxlWS9mMpmh+MjpBZlMpmRZ1gEhxOTKcys/hCgAOax9fTcopexCoXAnALp8ALWyBRx2XXdxswUPLD0KruuWsTRy/ZflLYACkBMTE3+kNapLmzAMrfn5+bsAMM55CPy3BTzrOE5lswYPAJRS5TiOD+DZxrHlBkxvphdfMzKZTBHLeoSGAfdRSnd3O321EWCMBZTS3Y3vgoYBTzuOUxmgrlRJYn0KuGnAPtu2q4OTlC5JrPuAJQPGCCF7tkLzb8AYCwghe4QQYwaAvYyxvsziDjNJzHsNAA9RSjfdh896JDE/ZADYRSmVgxaUNknMuwwAO7ewATsNALebphkOWlDaJDHfbgAY2ciTHp2SxDxqAMg1Vmm3EknM2XbWBTYVWmsCQBoAKlrrLWdEEnPFALAYx/GWMyCJuWIA+CuKIjpoQWkTx7EJ4LoB4NcwDNmgBaVNEvOvBoDLW9iAywaAn8IwtActKG2SmH8yAHwnpXQHLShtkpi/MwCUtNYXpJTOoEWlhZTS0Vpf4JyXGt3f1/V6PbNmrU1EEus3wM0psbO1Wm1kcJLSJYn1C+CmAVeiKDq/Fd4FUko3iqLznPMrwH/XBWar1erogHSlRhLjbOP/5QacC4IgF4ahlb6sdAjD0Ep2mZ5rHFtuQAjgDd/386krS4kkttcb64LA/1eHj9VqtVGl1Kb7MFJK2cnW2uPLj680IAIwVS6Xt6emLCWSmKZWbq5ebRj8iVLqdLVaHUtHWv/xfX9MKXWac/7JynPN5gFmK5XKhFJqww+SlFK27/sTAFbdQ9zMgIta60PFYnHHRp4siePYKBaLO7TWU812kq8V3Mkoit5PLkD6pLFvaK1JsVjckWyePtWs3Hp3900p5alSqXRrj/X1nVKpdKuU8hTn/M21yrXSvI8EQfBZsVjkG6ElJHeeB0HwGef8yHrlW32+DwZBcGZhYeG2YX4nxHFsLCws3BYEwRnO+cFW6rQTzBEp5QeFQuGOYewdlFKsUCjcIaX8oJU736CTlJmXCSEncrnc/LBsqqpWq2OVSmVCa32Qc/5hO3U7TZq6H8C0ZVkHRkdHrw9qY6VSyi6Xy42kqVnO+cV2r9Ft2twkgI9d113M5XJ/p7XKHEURrVQqtyQTG1NrdXPr0YvESQrgDQDvOI5TyWQypX7tN5JSOtVqtZE4+TaAd5eP7Dqhl6mzDMAzAKZM09zjuu6ibds9SZ2t1+uZWq02EkXRBQAfA/iSc96TTR39TJ5+HsCThJCHGWM3LMuqJ4nTaq3k6SiKrDAMmVLKllJu01r/COArAJ8PdfJ0M4QQY1hKn38ESxmndwPYjtXT568B+B3AJQA/YCl9vq89zT/uIvNLxH1bgwAAAABJRU5ErkJggg==",
                            c = s || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5nmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMwNjcgNzkuMTU3NzQ3LCAyMDE1LzAzLzMwLTIzOjQwOjQyICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDIwLTExLTEzVDE0OjI4OjI5KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMjAtMTEtMTNUMTQ6Mjk6MjUrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDIwLTExLTEzVDE0OjI5OjI1KzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjE4MjQ1YjY4LThkNDAtNzY0Ni04OTI0LTdkZDA2ZDYzZTM4MDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo4Nzc2QTE5MUEzRDAxMUU2QjhGOTlFMTYyOEIzMUI4MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDozRkM2NUZGNUEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MDwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDozRkM2NUZGNkEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MDwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjg3NzZBMTkxQTNEMDExRTZCOEY5OUUxNjI4QjMxQjgwPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoxODI0NWI2OC04ZDQwLTc2NDYtODkyNC03ZGQwNmQ2M2UzODA8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMjAtMTEtMTNUMTQ6Mjk6MjUrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT42NTUzNTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PtblBDkAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAnJJREFUeNrsmz9r20AYxh8lzpGhkE6d3DRzB7fQrZ/A5A8Opl/DQ/MBWmi8t07ivZ0SJylkMPQbSM5Qg09OWpeQaCoYMpVCh8ZSB9kg26os2dYpd3oPDPLdey/H73neu5PBmuM4SHNbQMobASAABIAAEAACQAAIAAFIa8vElfhnqTQp5IVWr+uPAPzZ3HwJ4GtQ8IP9fbkA4O4ueJzzM1gWWwTAms2zv7nc4zSVwCsYRnbwhbnPxfQAaLXew/sa7jhYarUqaQFQxPl5drSTuX1F9QFwXoFtj/fbNpY4r6gOoIhGI/u/QeaObasBQNPGP5x/8FV/2AV7vnMVcEABjcbEo465MQX1SoDzvUD1R12gGIAtGMZq2GDmxm6pA8A0D0Kp73WBaR6oAmADur4adRJz52zIfwpEVX/YBVXZT4F16PratJOZrj8BsC6lAzR3569Opf7wiVCVdQ/Iz6K+xwVrAPLyAbCsNzOp73HB4s3NW/kAXF09m1eqzPV1Lq5lxveL0O3t8ljfysq4wGFyOQ6TD0C7/UsDHk68IXe7YbL9fi7hJmjd01zCAHy5p7mEAfgIoDeHPD0An2QE8APA4RzyHAHoyHoVLs/ogh6AXZnfBjsAajPMr8WpvqjX4Xdhj3ufK8Ju3IsTAaDTr+Npav+7CgAGe4EdUf2yiIWJAvAt4l5Q689RBkAUFwip/SQAXAI4DhF3LEp90QDCuEBY7ScF4ALAScD4ST9GWQBBLhBa+0kCaAM49ek/Fa1+UgD8XCC89pMGYAL4PKK+mcRCMkiuvQbwtP+8k9QiNPrPUMobASAABIAAEAACQAAIAAFIa/s3AKynv4ToD/dyAAAAAElFTkSuQmCC",
                            d = new m.default;
                        d.uniforms.scale = {
                            value: a
                        }, d.uniforms.offset = {
                            value: new fm.Vector2(l, u)
                        }, d.uniforms.mapfront = {
                            value: this._materialManager.loadTexture(c, function () {
                                d.needsUpdate = !0
                            })
                        }, d.uniforms.mapBack = {
                            value: this._materialManager.loadTexture(h, function () {
                                d.needsUpdate = !0
                            })
                        }, d.transparent = !0;
                        var f = new g.default,
                            p = new fm.Mesh(f, d);
                        return p.userData.coord = {
                            x: l,
                            y: u
                        }, p.userData.width = .5 * a, p.frustumCulled = !1, p
                    }
                }, {
                    key: "getModel",
                    value: function (e, t, n, r) {
                        var i = this._scenes[e];
                        if (!i) return [];
                        var a = i.getGroupsModels(t);
                        this._raycaster.setFromCamera(n, r);
                        var o = this._raycaster.intersectObjects(a);
                        return o
                    }
                }, {
                    key: "getExternalModels",
                    value: function (e, t, n, r) {
                        var i = this._scenes[e];
                        if (!i) return [];
                        var a = i.getGroupsExternalModels(t);
                        this._raycaster.setFromCamera(n, r);
                        var o = this._raycaster.intersectObjects(a);
                        return o
                    }
                }, {
                    key: "getModelExternal",
                    value: function (e, t, n, r) {
                        var i = this._scenes[e];
                        if (!i) return [];
                        var a = i.getGroupsModels(t),
                            o = i.getGroupsExternalModels(t),
                            s = a.concat(o);
                        this._raycaster.setFromCamera(n, r);
                        var l = this._raycaster.intersectObjects(s);
                        return l
                    }
                }, {
                    key: "getMarkers",
                    value: function (e, t, n, r) {
                        var i = this._scenes[e];
                        if (!i) return [];
                        for (var a = [], o = 0; o < t.length; o++)
                            for (var s = i.getAllImageMarker(t[o]), l = 0; l < s.length; l++) a.push(s[l]);
                        this._raycaster.setFromCamera(n, r), this._raycaster.perspective = "PerspectiveCamera" === r.type;
                        var u = this._raycaster.intersectObjects(a);
                        return u
                    }
                }, {
                    key: "getNode",
                    value: function (e, t, n, r, i) {
                        var a = this._scenes[e];
                        if (!a) return [];
                        for (var o = a.getNodesExceptFacility(t, i), s = [], l = 0; l < o.length; l++) {
                            var u = o[l].mapNode;
                            u ? u.visible && u.show && s.push(o[l]) : s.push(o[l])
                        }
                        var h = a.getDynnodes(i, t);
                        this._raycaster.setFromCamera(n, r), this._raycaster.perspective = "PerspectiveCamera" === r.type;
                        var c = this._raycaster.intersectObjects(s),
                            d = this._raycaster.intersectObjects(h, !0);
                        if (d[0])
                            for (var f = d[0].object; f.parent;) {
                                if (f.parent.mapNode) {
                                    d[0].object = f.parent;
                                    break
                                }
                                f = f.parent
                            }
                        return d[0] && c[0] ? d[0].distance > c.distance ? c : d : d[0] ? d : c[0] ? c : []
                    }
                }, {
                    key: "getFacility",
                    value: function (e, t, n, r, i) {
                        var a = this._scenes[e];
                        if (!a) return [];
                        var o = a.getFacilityByFilter(t, i);
                        this._raycaster.setFromCamera(n, r), this._raycaster.perspective = "PerspectiveCamera" === r.type;
                        for (var s = this._raycaster.intersectObjects(o), l = 0; l < s.length; l++)
                            if (l) {
                                if (!(s[l].distance - s[l - 1].distance < 1e-6)) break;
                                if ("number" == typeof s[l].object.material.priority && "number" != typeof s[l - 1].object.material.priority) {
                                    var u = s[l],
                                        h = s[l - 1];
                                    s[l - 1] = u, s[l] = h
                                } else if ("number" == typeof s[l].object.material.priority && "number" == typeof s[l - 1].object.material.priority)
                                    for (var c = 0, d = 1; d <= l && s[l - c].object.material.priority > s[l - d].object.material.priority; d++) {
                                        var f = s[l - c],
                                            p = s[l - d];
                                        s[l - d] = f, s[l] = p, c++
                                    }
                            } for (var g = [], m = 0; m < s.length; m++) {
                            var v = s[m].object.mapNode;
                            v.nodeType !== fengmap.FMNodeType.IMAGE_MARKER && v.nodeType !== fengmap.FMNodeType.TEXT_MARKER || g.push(s[m])
                        }
                        for (var y = 0; y < s.length; y++) {
                            var _ = s[y].object.mapNode;
                            _.nodeType === fengmap.FMNodeType.FACILITY && g.push(s[y])
                        }
                        return g
                    }
                }, {
                    key: "getGroupLength",
                    value: function (e) {
                        return this._scenes["" + e].groupLength
                    }
                }, {
                    key: "getGroupIds",
                    value: function (e) {
                        return this._scenes["" + e].groupIds
                    }
                }, {
                    key: "getGroup",
                    value: function (e, t) {
                        return this._scenes["" + e].groups[t + ""]
                    }
                }, {
                    key: "getRenderList",
                    value: function () {
                        if (this._scenes) {
                            var e = [];
                            for (var t in this._scenes) {
                                var n = this._scenes[t].getRenderGroup();
                                e.push(n)
                            }
                            return e
                        }
                    }
                }, {
                    key: "conformatScene",
                    value: function (e, t, n) {
                        var r = new s.default(t, e, this);
                        r.parent = this, this._scenes[t + ""] = r, this._scenes[t + ""].theme = n
                    }
                }, {
                    key: "checkMaterialAlpha",
                    value: function (e, t) {
                        if (e)
                            if (this._focusAlphaMode && t !== this._map.currentFocusGroup && this._map.otherFocus.indexOf(t) < 0) {
                                if ((0, F.default)(e.material)) {
                                    var n = !0,
                                        r = !1,
                                        i = void 0;
                                    try {
                                        for (var a, o = (0, O.default)(e.material); !(n = (a = o.next()).done); n = !0) {
                                            var s = a.value;
                                            s.opacity = this._focusAlpha
                                        }
                                    } catch (e) {
                                        r = !0, i = e
                                    } finally {
                                        try {
                                            n || null == o.return || o.return()
                                        } finally {
                                            if (r) throw i
                                        }
                                    }
                                } else if (e.material)
                                    if (void 0 === e.material.length) e.material.opacity !== this._focusAlpha && (e.material.opacity = this._focusAlpha);
                                    else
                                        for (var l = 0; l < e.material.length; l++) e.material[l].opacity !== this._focusAlpha && (e.material[l].opacity = this._focusAlpha)
                            } else if ((0, F.default)(e.material)) {
                            var u = !0,
                                h = !1,
                                c = void 0;
                            try {
                                for (var d, f = (0, O.default)(e.material); !(u = (d = f.next()).done); u = !0) {
                                    var p = d.value;
                                    "number" == typeof p.userData.opacity && (p.opacity = p.userData.opacity)
                                }
                            } catch (e) {
                                h = !0, c = e
                            } finally {
                                try {
                                    u || null == f.return || f.return()
                                } finally {
                                    if (h) throw c
                                }
                            }
                        } else void 0 !== e.material && "number" == typeof e.material.userData.opacity && (e.material.opacity = e.material.userData.opacity)
                    }
                }, {
                    key: "checkNodeByFrustum",
                    value: function (e, u, t, h, c) {
                        var d = this;
                        if (d._scenes[c + ""]) {
                            var f = d._scenes[c + ""].theme,
                                p = this._scenes["" + c].center.x,
                                g = this._scenes["" + c].center.y,
                                m = this._scenes["" + c].mapcenter.x,
                                v = this._scenes["" + c].mapcenter.y,
                                y = this._map.labelLanguage;
                            b.default[this._map.uuid].bbox = this._scenes["" + c].bboxTh, b.default[this._map.uuid].bbox.uuid = this._map.uuid;
                            var n = this._scenes["" + c].groups,
                                r = (0, A.default)(n);
                            try {
                                var i = !0,
                                    a = !1,
                                    o = void 0;
                                try {
                                    for (var s, l = function () {
                                            var e = s.value,
                                                l = n[e];
                                            if (t.indexOf(l.eid) <= -1) return l.visible = !1, "continue";
                                            l.visible = !0, l.traverseByAlias(["extent", "model", "label", "facility", "externalModel"], function (r, e) {
                                                var t = r.bdata,
                                                    n = -1 === t.minlevel || -1 === t.maxlevel || 0 !== t.minlevel && !t.minlevel || !t.maxlevel || t.minlevel <= h && t.maxlevel > h;
                                                if (n) {
                                                    switch (e) {
                                                        case "extent":
                                                            r.renderNodeInited ? d.checkMaterialAlpha(r.renderNode, l.eid) : d.createExtent(r, c, l.eid);
                                                            break;
                                                        case "model":
                                                            r.renderNodeInited ? (d.checkMaterialAlpha(r.renderNode, l.eid), d.checkMaterialAlpha(r.line, l.eid)) : d.createModel(r, c, l.eid);
                                                            break;
                                                        case "label":
                                                            r.renderNodeInited ? d.checkMaterialAlpha(r._renderNode, l.eid) : r.tryInit || d.createLabel(r, c, y, l.eid);
                                                            break;
                                                        case "facility":
                                                            r.renderNodeInited ? d.checkMaterialAlpha(r._renderNode, l.eid) : d.createFacility(r, c, l.eid);
                                                            break;
                                                        case "externalModel":
                                                            if (r.renderNodeInited) d.checkMaterialAlpha(r._renderNode, l.eid);
                                                            else {
                                                                var i = r.bdata,
                                                                    a = r.gdata,
                                                                    o = f.getExteralModelTheme(i.fid);
                                                                if (!o) return;
                                                                d._externalLoader.preLoadModels[o.normalid] || (d._externalLoader.preLoadModels[o.normalid] = {
                                                                    loaded: !1,
                                                                    isLoading: !1,
                                                                    modelUrl: o.model,
                                                                    model: null,
                                                                    geometry: null,
                                                                    material: null
                                                                });
                                                                var s = d._externalLoader.preLoadModels[o.normalid];
                                                                s.loaded ? d.createExterModel(s.geometry, s.material, a, i, o, r, p, g, l.height, m, v, s.isGltf) : (d._externalLoader.waitingBacks[o.normalid] ? d._externalLoader.addWaitingBacks(o.normalid, function (e, t, n) {
                                                                    d.createExterModel(e, t, a, i, o, r, p, g, l.height, m, v, "js" !== n)
                                                                }, i.fid) : d._externalLoader.addWaitingBacks(o.normalid, function (e, t, n) {
                                                                    d.createExterModel(e, t, a, i, o, r, p, g, l.height, m, v, "js" !== n)
                                                                }, i.fid), s.isLoading || d._externalLoader.load(o.normalid))
                                                            }
                                                    }
                                                    r.checkByFrustum(u)
                                                } else null !== r.renderNode && (r.visible = !1)
                                            })
                                        }, _ = (0, O.default)(r); !(i = (s = _.next()).done); i = !0) l()
                                } catch (e) {
                                    a = !0, o = e
                                } finally {
                                    try {
                                        i || null == _.return || _.return()
                                    } finally {
                                        if (a) throw o
                                    }
                                }
                            } catch (e) {}
                        }
                    }
                }, {
                    key: "createModel",
                    value: function (e, t, n) {
                        var r, i = this._scenes["" + t].center.x,
                            a = this._scenes["" + t].center.y,
                            o = this._scenes["" + t].mapcenter.x,
                            s = this._scenes["" + t].mapcenter.y,
                            l = this._scenes["" + t].theme,
                            u = e.gdata,
                            h = e.bdata;
                        this._map.MapOptions.useStoreApply && (r = l.getStoreApplyTheme(h.fid)), r = r || l.getModelTheme(h);
                        var c = null;
                        c = 1 === this._map.dataManager.file_ver ? B.default.convertGeo2Geometry(u.geo) : B.default.convertArray2Geometry(u.idxs, u.pts), e._data = c;
                        var d = u.height && -1 !== u.height ? u.height : 2,
                            f = this.createGeometry(c, d, t),
                            p = this._materialManager.createNormalMaterial(r);
                        e._geometry = f;
                        var g = this.isNeedSweep;
                        if (this.isNeedSweep && (fm.ShaderLib.physical.vertexShader = U.vertexShader, fm.ShaderLib.physical.fragmentShader = z.fragmentShader, (0, D.default)(fm.ShaderLib.physical.uniforms, {
                                maxPos: {
                                    value: this.sweepMax
                                },
                                minPos: {
                                    value: this.sweepMin
                                },
                                relativeModelMatrix: {
                                    value: void 0
                                }
                            })), e.initMesh(p, new fm.Vector3(i, a + d, 0), g), e.x = o, e.y = s, e.height = d, e.currHeight = d, this.checkMaterialAlpha(e.renderNode, n), e.initLine(this._materialManager.createLineMaterial(r), u.height), this.checkMaterialAlpha(e.line, n), r.image && r.sizes) {
                            var m = r.sizes.split(","),
                                v = [];
                            r.coords && (v = r.coords.split(",")), e.addStoreImage({
                                image: r.image ? this._map.MapOptions.mapThemeURL + "/" + this._map.MapOptions.defaultThemeName + "/" + r.image : "",
                                angle: r.angle ? r.angle : 0,
                                size: [(0, P.default)(m[0]), (0, P.default)(m[1])],
                                mapCoord: r.coords ? new fm.Vector2((0, P.default)(v[0]), (0, P.default)(v[1])) : void 0
                            })
                        }
                    }
                }, {
                    key: "createExtent",
                    value: function (e, t, n) {
                        var r = e.gdata,
                            i = this._scenes[t + ""].theme,
                            a = this._scenes["" + t].center.x,
                            o = this._scenes["" + t].center.y,
                            s = this._scenes["" + t].mapcenter.x,
                            l = this._scenes["" + t].mapcenter.y,
                            u = null;
                        u = 1 === this._map.dataManager.file_ver ? B.default.convertGeo2Geometry(r.geo) : B.default.convertArray2Geometry(r.idxs, r.pts);
                        var h = this.createGeometry(u, r.height ? r.height : 1, t);
                        e._geometry = h, e.x = s, e.y = l;
                        var c = this._materialManager.createNormalMaterial();
                        e.initMesh(c, new fm.Vector3(a, o, 0), i.floorColor, i.floorOpacity), this.checkMaterialAlpha(e.renderNode, n)
                    }
                }, {
                    key: "createLabel",
                    value: function (e, t, n, r) {
                        var i = e.gdata,
                            a = e.bdata,
                            o = this._scenes["" + t].mapcenter.x,
                            s = this._scenes["" + t].mapcenter.y,
                            l = this._scenes["" + t].center.x,
                            u = this._scenes["" + t].center.y,
                            h = this._scenes[t + ""].theme,
                            c = null;
                        c = 1 === this._map.dataManager.file_ver ? B.default.convertGeo2Points(i.geo) : B.default.convertArrayPoints(i.idxs, i.pts);
                        var d = -1 === i.height ? 2.2 : i.height,
                            f = new fm.Vector3(c.vertices[0].x - o, -c.vertices[0].y + s, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, "XYZ")).add(new fm.Vector3(l, u + d, 0)),
                            p = a.ename,
                            g = a.name,
                            m = n === _.default.ZH ? g : p;
                        e.x = c.vertices[0].x, e.y = c.vertices[0].y, e.height = d, e.pos = f, e.tryInit = !0;
                        var v = h.getLabelTheme(a);
                        if (v && (e.theme = v, e.size = 1.4 * v.fontsize, m)) {
                            var y = this._materialManager.createLabelMaterial(m, v);
                            e.initSprite(y, (new fm.Vector3).copy(f)), this.checkMaterialAlpha(e._renderNode, r), e.setSize()
                        }
                    }
                }, {
                    key: "createFacility",
                    value: function (e, t, n) {
                        var r = e.gdata,
                            i = e.bdata,
                            a = this._scenes["" + t].center.x,
                            o = this._scenes["" + t].center.y,
                            s = this._scenes["" + t].mapcenter.x,
                            l = this._scenes["" + t].mapcenter.y,
                            u = this._scenes[t + ""].theme,
                            h = null;
                        h = 1 === this._map.dataManager.file_ver ? B.default.convertGeo2Points(r.geo) : B.default.convertArrayPoints(r.idxs, r.pts);
                        var c = -1 === r.height ? 2.2 : r.height,
                            d = new fm.Vector3(h.vertices[0].x - s, -h.vertices[0].y + l, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, "XYZ")).add(new fm.Vector3(a, o + c, 0)),
                            f = u.getPoiTheme(i),
                            p = this._materialManager.createPoiMaterial(f);
                        e.x = h.vertices[0].x, e.y = h.vertices[0].y, e.height = c, e.pos = d, f.height && (e.size = f.height), e.initSprite(p, (new fm.Vector3).copy(d)), this.checkMaterialAlpha(e._renderNode, n), e.setSize()
                    }
                }, {
                    key: "everGroup",
                    value: function (e, t) {
                        for (var n = 0; n < e.biz.length; n++) {
                            for (var r = 0; r < e.biz[n].extentLayer.length; r++) t(e.geo[n].extentLayer[r], "extentLayer", e.biz[n].extentLayer[r]);
                            for (var i = 0; i < e.biz[n].labelLayer.length; i++) t(e.geo[n].labelLayer[i], "labelLayer", e.biz[n].labelLayer[i]);
                            for (var a = 0; a < e.biz[n].modelLayer.length; a++) t(e.geo[n].modelLayer[a], "modelLayer", e.biz[n].modelLayer[a]);
                            for (var o = 0; o < e.biz[n].poiLayer.length; o++) t(e.geo[n].poiLayer[o], "poiLayer", e.biz[n].poiLayer[o]);
                            for (var s = 0; s < e.biz[n].stairLayer.length; s++) t(e.geo[n].stairLayer[s], "stairLayer", e.biz[n].stairLayer[s]);
                            for (var l = 0; l < e.biz[n].externalModelLayer.length; l++) t(e.geo[n].externalModelLayer[l], "externalModelLayer", e.biz[n].externalModelLayer[l])
                        }
                    }
                }, {
                    key: "createGeometry",
                    value: function (e, t, n) {
                        var r = e.vertices;

                        function i(e) {
                            for (var t = [], n = 0; n < e.length; n += 2) {
                                var r = (e.length - n) / 2;
                                t[2 * (r - 1)] = e[n], t[2 * (r - 1) + 1] = e[n + 1]
                            }
                            return t
                        }
                        var a = B.default.checkClockwise(r);
                        if (a || (r = i(r), e.vertices = r), 6 <= r.length) {
                            var o, s = new fm.Shape,
                                l = this._scenes["" + n].mapcenter.x,
                                u = this._scenes["" + n].mapcenter.y;
                            if (e.holes && 0 < e.holes.length) {
                                var h = {};
                                for (var c in e.holes) {
                                    var d = e.holes[c],
                                        f = B.default.checkClockwise(d);
                                    f || (d = i(d), e.holes[c] = d);
                                    for (var p = 0; p < d.length; p += 2) {
                                        var g = d[p] + "-" + d[p + 1];
                                        h[g] = !0
                                    }
                                }
                                for (this.forEachVertForShape(r, function (e, t, n) {
                                        e ? s.moveTo(t - l, n - u) : h[t + "-" + n] || s.lineTo(t - l, n - u)
                                    }), c = 0; c < e.holes.length; c++) {
                                    d = e.holes[c];
                                    var m = new fm.Path;
                                    this.forEachVertForShape(d, function (e, t, n) {
                                        e ? m.moveTo(t - l, n - u) : m.lineTo(t - l, n - u)
                                    }), s.holes.push(m)
                                }
                            } else this.forEachVertForShape(r, function (e, t, n) {
                                e ? s.moveTo(t - l, n - u) : s.lineTo(t - l, n - u)
                            });
                            o = 0 == t ? new fm.ShapeGeometry(s) : new fm.ExtrudeGeometry(s, {
                                depth: t,
                                bevelEnabled: !1
                            });
                            var v = b.default[this._map.uuid].bbox.min.x,
                                y = b.default[this._map.uuid].bbox.min.y,
                                _ = b.default[this._map.uuid].bbox.max.x - b.default[this._map.uuid].bbox.min.x,
                                A = b.default[this._map.uuid].bbox.max.y - b.default[this._map.uuid].bbox.min.y,
                                x = o.faces,
                                C = x.length;
                            for (c = 0; c < C; c++) {
                                var I = o.vertices[x[c].a],
                                    w = o.vertices[x[c].b],
                                    M = o.vertices[x[c].c];
                                o.faceVertexUvs[0][c][0].x = (I.x - v) / _, o.faceVertexUvs[0][c][0].y = (I.y - y) / A, o.faceVertexUvs[0][c][1].x = (w.x - v) / _, o.faceVertexUvs[0][c][1].y = (w.y - y) / A, o.faceVertexUvs[0][c][2].x = (M.x - v) / _, o.faceVertexUvs[0][c][2].y = (M.y - y) / A
                            }
                            return o.computeBoundingSphere(), {
                                geometry: o,
                                shape: s
                            }
                        }
                        return null
                    }
                }, {
                    key: "createExterModel",
                    value: function (e, t, n, r, i, a, o, s, l, u, h, c) {
                        var d = this,
                            f = null;
                        f = 1 === this._map.dataManager.file_ver ? B.default.convertGeo2Points(n.geo) : B.default.convertArrayPoints(n.idxs, n.pts);
                        var p = new fm.Vector3(f.vertices[0].x - u, -f.vertices[0].y + h, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, "XYZ")).add(new fm.Vector3(o, s + (-1 === n.height ? 2.2 : n.height), 0));
                        if (c) {
                            var g = e.scene,
                                m = null;
                            0 < e.animations.length ? (m = g, this._map.animaModels.push({
                                model: g,
                                animations: e.animations
                            })) : m = g.clone(), m.traverse(function (e) {
                                if (e instanceof fm.Mesh) {
                                    if (e.isGltf = !0, void 0 !== e.material.length)
                                        for (var t = 0; t < e.material.length; t++) e.material[t] = e.material[t].clone(), e.material[t].color = new fm.Color(G.default.toColor(i.color)), e.material[t].needsUpdate = !0, e.material[t].userData.opacity = e.material[t].opacity;
                                    else e.material = e.material.clone(), d.isNeedSweep && (fm.ShaderLib.physical.vertexShader = U.vertexShader, fm.ShaderLib.physical.fragmentShader = z.fragmentShader, (0, D.default)(fm.ShaderLib.physical.uniforms, {
                                        sweepW: {
                                            value: 0
                                        },
                                        sweepH: {
                                            value: 0
                                        },
                                        se2N: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        se2RN: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        moveP: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        relativeModelMatrix: {
                                            value: void 0
                                        },
                                        isNeedSweep: {
                                            value: !0
                                        },
                                        isRect: {
                                            value: !1
                                        },
                                        isAnnulus: {
                                            value: !1
                                        },
                                        circleC: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        maxR: {
                                            value: 0
                                        },
                                        minR: {
                                            value: 0
                                        }
                                    }), e.name = "isNeedSweep", e.material.uniforms = {
                                        sweepW: {
                                            value: 0
                                        },
                                        sweepH: {
                                            value: 0
                                        },
                                        se2N: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        se2RN: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        moveP: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        relativeModelMatrix: {
                                            value: e.matrixWorld
                                        },
                                        isNeedSweep: {
                                            value: !1
                                        },
                                        isRect: {
                                            value: !1
                                        },
                                        isAnnulus: {
                                            value: !1
                                        },
                                        circleC: {
                                            value: new fm.Vector2(0, 0)
                                        },
                                        maxR: {
                                            value: 0
                                        },
                                        minR: {
                                            value: 0
                                        }
                                    }), e.material.transparent = !0, e.material.color = new fm.Color(G.default.toColor(i.color)), e.material.needsUpdate = !0, e.material.userData.opacity = e.material.opacity;
                                    e.renderOrder = r.eid
                                }
                            });
                            var v = i.scale.split(","),
                                y = i.rotate.split(","),
                                _ = i.translate.split(","),
                                A = new fm.Vector3;
                            if (A.set((0, P.default)(y[0]) * fm.Math.DEG2RAD, (0, P.default)(y[2]) * fm.Math.DEG2RAD, (0, P.default)(y[1]) * fm.Math.DEG2RAD), m.rotation.setFromVector3(A, "YXZ"), m.scale.set((0, P.default)(v[0]), (0, P.default)(v[2]), (0, P.default)(v[1])), p.add(new fm.Vector3((0, P.default)(_[0]), (0, P.default)(_[2]), (0, P.default)(_[1]))), m.position.set(p.x, p.y, p.z), a.renderNode = m, a.x = f.vertices[0].x + (0, P.default)(_[0]), a.y = f.vertices[0].y + (0, P.default)(_[1]), a.height = -1 === n.height ? 2.2 : n.height, !a._renderNode) return;
                            a._renderNode.frustumCulled = !1, a.renderNodeInited = !0
                        } else {
                            if ((0, F.default)(t)) {
                                var x = !0,
                                    C = !1,
                                    I = void 0;
                                try {
                                    for (var w, M = (0, O.default)(t); !(x = (w = M.next()).done); x = !0) {
                                        var b = w.value;
                                        b.color = new fm.Color(G.default.toColor(i.color)), b.transparent = !0, b.map && (b.map.wrapS = fm.RepeatWrapping, b.map.wrapT = fm.RepeatWrapping, b.color.setScalar(1)), b.userData.opacity = b.opacity
                                    }
                                } catch (e) {
                                    C = !0, I = e
                                } finally {
                                    try {
                                        x || null == M.return || M.return()
                                    } finally {
                                        if (C) throw I
                                    }
                                }
                            } else t.color = new fm.Color(G.default.toColor(i.color)), t.transparent = !0, t.map && (t.map.wrapS = fm.RepeatWrapping, t.map.wrapT = fm.RepeatWrapping, t.color.setScalar(1)), t.userData.opacity = t.opacity;
                            var S = [];
                            if (void 0 !== t.length)
                                for (var E = 0; E < t.length; E++) S.push(t[E].clone());
                            else S.push(t.clone());
                            var T = new fm.Mesh(e, S),
                                L = i.scale.split(","),
                                N = i.rotate.split(","),
                                R = i.translate.split(",");
                            T.scale.set((0, P.default)(L[0]), (0, P.default)(L[2]), (0, P.default)(L[1]));
                            var k = new fm.Vector3;
                            if (k.set((0, P.default)(N[0]) * fm.Math.DEG2RAD, (0, P.default)(N[2]) * fm.Math.DEG2RAD, (0, P.default)(N[1]) * fm.Math.DEG2RAD), T.rotation.setFromVector3(k, "YXZ"), p.add(new fm.Vector3((0, P.default)(R[0]), (0, P.default)(R[2]), (0, P.default)(R[1]))), T.position.set(p.x, p.y, p.z), T.renderOrder = r.eid, a.renderNode = T, a.x = f.vertices[0].x + (0, P.default)(R[0]), a.y = f.vertices[0].y + (0, P.default)(R[1]), a.height = -1 === n.height ? 2.2 : n.height, !a._renderNode) return;
                            a._renderNode.frustumCulled = !1, a.renderNodeInited = !0
                        }
                    }
                }, {
                    key: "findGltfMesh",
                    value: function (e, t) {
                        if (e instanceof fm.Mesh) t(e);
                        else {
                            var n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = (0, O.default)(e.children); !(n = (a = o.next()).done); n = !0) {
                                    var s = a.value;
                                    this.findGltfMesh(s, t)
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                        }
                    }
                }, {
                    key: "getDynLoader",
                    value: function () {
                        return this._dynamicLoader
                    }
                }, {
                    key: "getSceneCenter",
                    value: function (e) {
                        return (new fm.Vector3).copy(this._scenes[e + ""].center)
                    }
                }, {
                    key: "forEachVertForShape",
                    value: function (e, t) {
                        var n = 0;
                        for (t(!0, e[n], e[n + 1]), n = 2; n < e.length; n += 2) t(!1, e[n], e[n + 1]);
                        n = 0, t(!1, e[n], e[n + 1])
                    }
                }, {
                    key: "getCurrentNodeCenter",
                    value: function (e, t) {
                        for (var n = this._scenes[t], r = n.center, i = 0, a = 0; a < e.length; a++) i += e[a] * n.space;
                        return new fm.Vector3(r.x, r.y + i / e.length, 0)
                    }
                }, {
                    key: "getHeight",
                    value: function (e, t) {
                        return this._scenes["" + e].getHeight(t)
                    }
                }, {
                    key: "getSceneById",
                    value: function (e) {
                        return this._scenes["" + e]
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._materialManager.dispose(), this._scenes) this._scenes[e].dispose(), this._scenes[e].parent = void 0;
                        this._map = void 0, this._scenes = void 0, this._materialManager = void 0
                    }
                }, {
                    key: "disposeById",
                    value: function (e) {
                        this._scenes[e].dispose(), this._scenes[e].parent = void 0, this._scenes[e] = void 0
                    }
                }, {
                    key: "map",
                    get: function () {
                        return this._map
                    }
                }, {
                    key: "materialManager",
                    get: function () {
                        return this._materialManager
                    }
                }]), n
            }(),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                NONE: 0,
                EXTENT: 4,
                FLOOR: 4,
                MODEL: 5,
                DYNMODEL: 6,
                FACILITY: 11,
                LABEL: 12,
                LINE: 21,
                IMAGE_MARKER: 31,
                TEXT_MARKER: 32,
                LOCATION_MARKER: 33,
                SURFACEIMAGE_MARKER: 34,
                EXTERANL_MODEL: 35,
                EXTERNAL_MODEL: 35,
                POLYGON_MARKER: 36,
                WATER_MARKER: 37,
                EXTRUDE_MARKER: 38,
                GRADIENT_POLYGON_MARKER: 39,
                EDGES_LINES_TYPE: 40,
                ALL: 65535,
                ELEMENT: 100
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        var g = n(24),
            m = n(83),
            v = n(32),
            y = n(38),
            _ = n(86),
            A = "prototype",
            x = function (e, t, n) {
                var r, i, a, o, s = e & x.F,
                    l = e & x.G,
                    u = e & x.S,
                    h = e & x.P,
                    c = e & x.B,
                    d = l ? g : u ? g[t] || (g[t] = {}) : (g[t] || {})[A],
                    f = l ? m : m[t] || (m[t] = {}),
                    p = f[A] || (f[A] = {});
                for (r in l && (n = t), n) i = !s && d && void 0 !== d[r], a = (i ? d : n)[r], o = c && i ? _(a, g) : h && "function" == typeof a ? _(Function.call, a) : a, d && y(d, r, a, e & x.U), f[r] != a && v(f, r, o), h && p[r] != a && (p[r] = a)
            };
        g.core = m, x.F = 1, x.G = 2, x.S = 4, x.P = 8, x.B = 16, x.W = 32, x.U = 64, x.R = 128, e.exports = x
    }, function (e, t, n) {
        e.exports = !n(18)(function () {
            return 7 != Object.defineProperty({}, "a", {
                get: function () {
                    return 7
                }
            }).a
        })
    }, function (e) {
        var t = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = t)
    }, function (e, t, n) {
        n(40)("Float32", 4, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        e.exports = !n(44)(function () {
            return 7 != Object.defineProperty({}, "a", {
                get: function () {
                    return 7
                }
            }).a
        })
    }, function (e, t, n) {
        e.exports = n(330)
    }, function (e, t, n) {
        var r = n(29),
            i = n(156),
            a = n(117),
            o = Object.defineProperty;
        t.f = n(26) ? Object.defineProperty : function (e, t, n) {
            if (r(e), t = a(t, !0), r(n), i) try {
                return o(e, t, n)
            } catch (e) {}
            if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
            return "value" in n && (e[t] = n.value), e
        }
    }, function (e, t, n) {
        var r = n(17);
        e.exports = function (e) {
            if (!r(e)) throw TypeError(e + " is not an object!");
            return e
        }
    }, function (e, t, n) {
        var r = n(37);
        e.exports = function (e) {
            if (!r(e)) throw TypeError(e + " is not an object!");
            return e
        }
    }, function (e, t, n) {
        e.exports = n(312)
    }, function (e, t, n) {
        var r = n(33),
            i = n(84);
        e.exports = n(23) ? function (e, t, n) {
            return r.f(e, t, i(1, n))
        } : function (e, t, n) {
            return e[t] = n, e
        }
    }, function (e, t, n) {
        var r = n(30),
            i = n(158),
            a = n(72),
            o = Object.defineProperty;
        t.f = n(23) ? Object.defineProperty : function (e, t, n) {
            if (r(e), t = a(t, !0), r(n), i) try {
                return o(e, t, n)
            } catch (e) {}
            if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
            return "value" in n && (e[t] = n.value), e
        }
    }, function (e, t, n) {
        var r = n(46),
            i = Math.min;
        e.exports = function (e) {
            return 0 < e ? i(r(e), 9007199254740991) : 0
        }
    }, function (e, t, n) {
        e.exports = n(338)
    }, function (e, t, n) {
        var a = n(70);
        e.exports = function (r, i, e) {
            if (a(r), void 0 === i) return r;
            switch (e) {
                case 1:
                    return function (e) {
                        return r.call(i, e)
                    };
                case 2:
                    return function (e, t) {
                        return r.call(i, e, t)
                    };
                case 3:
                    return function (e, t, n) {
                        return r.call(i, e, t, n)
                    }
            }
            return function () {
                return r.apply(i, arguments)
            }
        }
    }, function (e) {
        e.exports = function (e) {
            return "object" == typeof e ? null !== e : "function" == typeof e
        }
    }, function (e, t, n) {
        var a = n(24),
            o = n(32),
            s = n(50),
            l = n(73)("src"),
            r = n(260),
            i = "toString",
            u = ("" + r).split(i);
        n(83).inspectSource = function (e) {
            return r.call(e)
        }, (e.exports = function (e, t, n, r) {
            var i = "function" == typeof n;
            i && (s(n, "name") || o(n, "name", t)), e[t] !== n && (i && (s(n, l) || o(n, l, e[t] ? "" + e[t] : u.join(String(t)))), e === a ? e[t] = n : r ? e[t] ? e[t] = n : o(e, t, n) : (delete e[t], o(e, t, n)))
        })(Function.prototype, i, function () {
            return "function" == typeof this && this[l] || r.call(this)
        })
    }, function (e, t, n) {
        var r = n(51);
        e.exports = function (e) {
            return Object(r(e))
        }
    }, function (e, t, n) {
        "use strict";
        if (n(23)) {
            var _ = n(85),
                A = n(24),
                x = n(18),
                C = n(22),
                I = n(191),
                r = n(319),
                p = n(86),
                w = n(193),
                i = n(84),
                M = n(32),
                a = n(192),
                o = n(46),
                b = n(34),
                S = n(194),
                s = n(89),
                l = n(72),
                u = n(50),
                E = n(97),
                T = n(37),
                g = n(39),
                m = n(320),
                L = n(133),
                N = n(177),
                R = n(88).f,
                v = n(321),
                h = n(73),
                c = n(15),
                d = n(322),
                f = n(163),
                y = n(188),
                k = n(62),
                P = n(63),
                D = n(326),
                O = n(165),
                F = n(143),
                B = n(327),
                G = n(33),
                U = n(120),
                z = G.f,
                V = U.f,
                H = A.RangeError,
                W = A.TypeError,
                j = A.Uint8Array,
                Y = "ArrayBuffer",
                q = "Shared" + Y,
                X = "BYTES_PER_ELEMENT",
                Z = "prototype",
                J = Array[Z],
                K = r.ArrayBuffer,
                Q = r.DataView,
                $ = d(0),
                ee = d(2),
                te = d(3),
                ne = d(4),
                re = d(5),
                ie = d(6),
                ae = f(!0),
                oe = f(!1),
                se = k.values,
                le = k.keys,
                ue = k.entries,
                he = J.lastIndexOf,
                ce = J.reduce,
                de = J.reduceRight,
                fe = J.join,
                pe = J.sort,
                ge = J.slice,
                me = J.toString,
                ve = J.toLocaleString,
                ye = c("iterator"),
                _e = c("toStringTag"),
                Ae = h("typed_constructor"),
                xe = h("def_constructor"),
                Ce = I.CONSTR,
                Ie = I.TYPED,
                we = I.VIEW,
                Me = "Wrong length!",
                be = d(1, function (e, t) {
                    return Ne(y(e, e[xe]), t)
                }),
                Se = x(function () {
                    return 1 === new j(new Uint16Array([1]).buffer)[0]
                }),
                Ee = !!j && !!j[Z].set && x(function () {
                    new j(1).set({})
                }),
                Te = function (e, t) {
                    var n = o(e);
                    if (n < 0 || n % t) throw H("Wrong offset!");
                    return n
                },
                Le = function (e) {
                    if (T(e) && Ie in e) return e;
                    throw W(e + " is not a typed array!")
                },
                Ne = function (e, t) {
                    if (!(T(e) && Ae in e)) throw W("It is not a typed array constructor!");
                    return new e(t)
                },
                Re = function (e, t) {
                    return ke(y(e, e[xe]), t)
                },
                ke = function (e, t) {
                    for (var n = 0, r = t.length, i = Ne(e, r); n < r;) i[n] = t[n++];
                    return i
                },
                Pe = function (e, t, n) {
                    z(e, t, {
                        get: function () {
                            return this._d[n]
                        }
                    })
                },
                De = function (e, t, n) {
                    var r, i, a, o, s, l, u = g(e),
                        h = arguments.length,
                        c = 1 < h ? t : void 0,
                        d = void 0 !== c,
                        f = v(u);
                    if (null != f && !m(f)) {
                        for (l = f.call(u), a = [], r = 0; !(s = l.next()).done; r++) a.push(s.value);
                        u = a
                    }
                    for (d && 2 < h && (c = p(c, n, 2)), r = 0, i = b(u.length), o = Ne(this, i); r < i; r++) o[r] = d ? c(u[r], r) : u[r];
                    return o
                },
                Oe = function () {
                    for (var e = 0, t = arguments.length, n = Ne(this, t); e < t;) n[e] = arguments[e++];
                    return n
                },
                Fe = !!j && x(function () {
                    ve.call(new j(1))
                }),
                Be = function () {
                    return ve.apply(Fe ? ge.call(Le(this)) : Le(this), arguments)
                },
                Ge = {
                    copyWithin: function (e, t, n) {
                        return B.call(Le(this), e, t, 2 < arguments.length ? n : void 0)
                    },
                    every: function (e, t) {
                        return ne(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    fill: function () {
                        return F.apply(Le(this), arguments)
                    },
                    filter: function (e, t) {
                        return Re(this, ee(Le(this), e, 1 < arguments.length ? t : void 0))
                    },
                    find: function (e, t) {
                        return re(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    findIndex: function (e, t) {
                        return ie(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    forEach: function (e, t) {
                        $(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    indexOf: function (e, t) {
                        return oe(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    includes: function (e, t) {
                        return ae(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    join: function () {
                        return fe.apply(Le(this), arguments)
                    },
                    lastIndexOf: function () {
                        return he.apply(Le(this), arguments)
                    },
                    map: function (e, t) {
                        return be(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    reduce: function () {
                        return ce.apply(Le(this), arguments)
                    },
                    reduceRight: function () {
                        return de.apply(Le(this), arguments)
                    },
                    reverse: function () {
                        for (var e, t = this, n = Le(t).length, r = Math.floor(n / 2), i = 0; i < r;) e = t[i], t[i++] = t[--n], t[n] = e;
                        return t
                    },
                    some: function (e, t) {
                        return te(Le(this), e, 1 < arguments.length ? t : void 0)
                    },
                    sort: function (e) {
                        return pe.call(Le(this), e)
                    },
                    subarray: function (e, t) {
                        var n = Le(this),
                            r = n.length,
                            i = s(e, r);
                        return new(y(n, n[xe]))(n.buffer, n.byteOffset + i * n.BYTES_PER_ELEMENT, b((void 0 === t ? r : s(t, r)) - i))
                    }
                },
                Ue = function (e, t) {
                    return Re(this, ge.call(Le(this), e, t))
                },
                ze = function (e, t) {
                    Le(this);
                    var n = Te(t, 1),
                        r = this.length,
                        i = g(e),
                        a = b(i.length),
                        o = 0;
                    if (r < a + n) throw H(Me);
                    for (; o < a;) this[n + o] = i[o++]
                },
                Ve = {
                    entries: function () {
                        return ue.call(Le(this))
                    },
                    keys: function () {
                        return le.call(Le(this))
                    },
                    values: function () {
                        return se.call(Le(this))
                    }
                },
                He = function (e, t) {
                    return T(e) && e[Ie] && "symbol" != typeof t && t in e && String(+t) == String(t)
                },
                We = function (e, t) {
                    return He(e, t = l(t, !0)) ? i(2, e[t]) : V(e, t)
                },
                je = function (e, t, n) {
                    return !(He(e, t = l(t, !0)) && T(n) && u(n, "value")) || u(n, "get") || u(n, "set") || n.configurable || u(n, "writable") && !n.writable || u(n, "enumerable") && !n.enumerable ? z(e, t, n) : (e[t] = n.value, e)
                };
            Ce || (U.f = We, G.f = je), C(C.S + C.F * !Ce, "Object", {
                getOwnPropertyDescriptor: We,
                defineProperty: je
            }), x(function () {
                me.call({})
            }) && (me = ve = function () {
                return fe.call(this)
            });
            var Ye = a({}, Ge);
            a(Ye, Ve), M(Ye, ye, Ve.values), a(Ye, {
                slice: Ue,
                set: ze,
                constructor: function () {},
                toString: me,
                toLocaleString: Be
            }), Pe(Ye, "buffer", "b"), Pe(Ye, "byteOffset", "o"), Pe(Ye, "byteLength", "l"), Pe(Ye, "length", "e"), z(Ye, _e, {
                get: function () {
                    return this[Ie]
                }
            }), e.exports = function (e, c, t, i) {
                i = !!i;
                var d = e + (i ? "Clamped" : "") + "Array",
                    r = "get" + e,
                    a = "set" + e,
                    f = A[d],
                    o = f || {},
                    n = f && N(f),
                    s = !f || !I.ABV,
                    l = {},
                    u = f && f[Z],
                    h = function (e, t) {
                        var n = e._d;
                        return n.v[r](t * c + n.o, Se)
                    },
                    p = function (e, t, n) {
                        var r = e._d;
                        i && (n = (n = Math.round(n)) < 0 ? 0 : 255 < n ? 255 : 255 & n), r.v[a](t * c + r.o, n, Se)
                    },
                    g = function (e, t) {
                        z(e, t, {
                            get: function () {
                                return h(this, t)
                            },
                            set: function (e) {
                                return p(this, t, e)
                            },
                            enumerable: !0
                        })
                    };
                s ? (f = t(function (e, t, n, r) {
                    w(e, f, d, "_d");
                    var i, a, o, s, l = 0,
                        u = 0;
                    if (T(t)) {
                        if (!(t instanceof K || (s = E(t)) == Y || s == q)) return Ie in t ? ke(f, t) : De.call(f, t);
                        i = t, u = Te(n, c);
                        var h = t.byteLength;
                        if (void 0 === r) {
                            if (h % c) throw H(Me);
                            if (a = h - u, a < 0) throw H(Me)
                        } else if (a = b(r) * c, h < a + u) throw H(Me);
                        o = a / c
                    } else o = S(t), a = o * c, i = new K(a);
                    for (M(e, "_d", {
                            b: i,
                            o: u,
                            l: a,
                            e: o,
                            v: new Q(i)
                        }); l < o;) g(e, l++)
                }), u = f[Z] = L(Ye), M(u, "constructor", f)) : x(function () {
                    f(1)
                }) && x(function () {
                    new f(-1)
                }) && D(function (e) {
                    new f, new f(null), new f(1.5), new f(e)
                }, !0) || (f = t(function (e, t, n, r) {
                    var i;
                    return w(e, f, d), T(t) ? t instanceof K || (i = E(t)) == Y || i == q ? void 0 !== r ? new o(t, Te(n, c), r) : void 0 !== n ? new o(t, Te(n, c)) : new o(t) : Ie in t ? ke(f, t) : De.call(f, t) : new o(S(t))
                }), $(n !== Function.prototype ? R(o).concat(R(n)) : R(o), function (e) {
                    e in f || M(f, e, o[e])
                }), f[Z] = u, _ || (u.constructor = f));
                var m = u[ye],
                    v = !!m && ("values" == m.name || null == m.name),
                    y = Ve.values;
                M(f, Ae, !0), M(u, Ie, d), M(u, we, !0), M(u, xe, f), (i ? new f(1)[_e] == d : _e in u) || z(u, _e, {
                    get: function () {
                        return d
                    }
                }), l[d] = f, C(C.G + C.W + C.F * (f != o), l), C(C.S, d, {
                    BYTES_PER_ELEMENT: c
                }), C(C.S + C.F * x(function () {
                    o.of.call(f, 1)
                }), d, {
                    from: De,
                    of: Oe
                }), X in u || M(u, X, c), C(C.P, d, Ge), O(d), C(C.P + C.F * Ee, d, {
                    set: ze
                }), C(C.P + C.F * !v, d, Ve), _ || u.toString == me || (u.toString = me), C(C.P + C.F * x(function () {
                    new f(1).slice()
                }), d, {
                    slice: Ue
                }), C(C.P + C.F * (x(function () {
                    return [1, 2].toLocaleString() != new f([1, 2]).toLocaleString()
                }) || !x(function () {
                    u.toLocaleString.call([1, 2])
                })), d, {
                    toLocaleString: Be
                }), P[d] = v ? m : y, _ || v || M(u, ye, y)
            }
        } else e.exports = function () {}
    }, function (e, t, n) {
        var r = n(367),
            i = n(368),
            a = n(372);

        function o(e) {
            return r(e) || i(e) || a()
        }
        e.exports = o
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(55), n(56);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(376)),
            l = r(n(207)),
            u = r(n(208)),
            h = function () {
                function e() {
                    (0, a.default)(this, e), this._sceneRawData = {}, this._sceneDecodeData = {}, this._reader = new s.default, this.file_ver = 1
                }
                return (0, o.default)(e, [{
                    key: "putRawScene",
                    value: function (e, t) {
                        this.sceneRawData[t + ""] = e
                    }
                }, {
                    key: "removeRawScene",
                    value: function (e) {
                        this.sceneRawData[e + ""] = void 0
                    }
                }, {
                    key: "parseScene",
                    value: function (e, t, n) {
                        var r;
                        if (r = t ? this._reader.sceneDecode(this.sceneRawData[e + ""], n, e) : this._reader.mapDecode(this.sceneRawData[e + ""], n, e), r) {
                            t && (r = {
                                scene: r,
                                floors: []
                            });
                            for (var i = r.scene.layerGroups, a = 0; a < i.length; a++) {
                                var o = i[a];
                                o.elevation = o.height
                            }
                            return r
                        }
                    }
                }, {
                    key: "parseFloor",
                    value: function (e, t, n) {
                        var r = this._reader.floorGeoDecode(e),
                            i = this._reader.floorBizDecode(t),
                            a = this._reader.floorNaviDecode(n);
                        return [r, i, a]
                    }
                }, {
                    key: "isSceneHasZone",
                    value: function (e) {
                        if (!e) return !1;
                        var t = this._sceneDecodeData[e + ""];
                        if (!t) return !1;
                        var n = !1;
                        return t.floors.forEach(function (e) {
                            0 < e.navi[0].naviZones.length && (n = !0)
                        }), n
                    }
                }, {
                    key: "putDecodeScene",
                    value: function (e, t) {
                        this.file_ver = e.scene.file_ver, this.sceneDecodeData[t + ""] = e
                    }
                }, {
                    key: "removeDecodeScene",
                    value: function (e) {
                        this.sceneDecodeData[e + ""] = void 0
                    }
                }, {
                    key: "getRawScene",
                    value: function (e) {
                        return this.sceneRawData[e + ""]
                    }
                }, {
                    key: "getDecodeScene",
                    value: function (e) {
                        return this.sceneDecodeData[e + ""]
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._reader.dispose(), this.sceneRawData) this.sceneRawData[e] = void 0;
                        for (var t in this.sceneDecodeData) this.sceneDecodeData[t] = void 0;
                        this.sceneRawData = void 0, this.sceneDecodeData = void 0
                    }
                }, {
                    key: "disposeById",
                    value: function (e) {
                        this.sceneRawData[e] = void 0, this.sceneDecodeData[e] = void 0
                    }
                }, {
                    key: "sceneRawData",
                    get: function () {
                        return this._sceneRawData
                    },
                    set: function (e) {
                        this._sceneRawData = e
                    }
                }, {
                    key: "sceneDecodeData",
                    get: function () {
                        return this._sceneDecodeData
                    },
                    set: function (e) {
                        this._sceneDecodeData = e
                    }
                }], [{
                    key: "convertGeo2Geometry",
                    value: function (e) {
                        var t = (new l.default).parse(e),
                            n = {
                                vertices: t.toStrip(!0)
                            };
                        return t.hasHoles() && (n.holes = t.toStripHoles(!0)), n
                    }
                }, {
                    key: "convertArr2Geometry",
                    value: function (e, t) {
                        for (var n = e[0].idxs[0], r = [], i = 0; i < n - 2; i += 2) r.push(t[i]), r.push(t[i + 1]);
                        var a = {
                            vertices: r
                        };
                        if (1 < e.length) {
                            for (var o = [], s = 1; s < e.length; s++) {
                                for (var l = e[s - 1], u = e[s], h = [], c = l; c < u - 2; c += 2) h.push(t[c]), h.push(t[c + 1]);
                                o.push(h)
                            }
                            a.holes = o
                        }
                        return a
                    }
                }, {
                    key: "convertArray2Geometry",
                    value: function (e, t) {
                        var n = (new u.default).parseGeometry(e, t),
                            r = {
                                vertices: n.toStrip(!0)
                            };
                        return n.hasHoles() && (r.holes = n.toStripHoles(!0)), r
                    }
                }, {
                    key: "convertGeo2Points",
                    value: function (e) {
                        var t = (new l.default).parse(e),
                            n = {
                                vertices: t.points
                            };
                        return n
                    }
                }, {
                    key: "convertArrayPoints",
                    value: function (e, t) {
                        var n = (new u.default).parse(e, t),
                            r = {
                                vertices: n.points
                            };
                        return r
                    }
                }, {
                    key: "checkClockwise",
                    value: function (e) {
                        for (var t = Number.NEGATIVE_INFINITY, n = 0, r = 0, i = 0, a = 0; a < e.length; a += 2) e[a] > t && (t = e[a], n = a);
                        var o = new fm.Vector3(e[n], e[n + 1], 0);
                        r = 0 === n ? e.length - 2 : n - 2, i = n === e.length - 2 ? 0 : n + 2;
                        var s = new fm.Vector3(e[r], e[r + 1], 0),
                            l = new fm.Vector3(e[i], e[i + 1], 0),
                            u = (new fm.Vector3).copy(o).sub(s),
                            h = (new fm.Vector3).copy(l).sub(o),
                            c = u.cross(h);
                        return 0 < c.z
                    }
                }]), e
            }(),
            c = h;
        t.default = c
    }, function (e, t, n) {
        var r = n(28),
            i = n(71);
        e.exports = n(26) ? function (e, t, n) {
            return r.f(e, t, i(1, n))
        } : function (e, t, n) {
            return e[t] = n, e
        }
    }, function (e) {
        e.exports = function (e) {
            try {
                return !!e()
            } catch (e) {
                return !0
            }
        }
    }, function (e) {
        var n = {}.hasOwnProperty;
        e.exports = function (e, t) {
            return n.call(e, t)
        }
    }, function (e) {
        var t = Math.ceil,
            n = Math.floor;
        e.exports = function (e) {
            return isNaN(e = +e) ? 0 : (0 < e ? n : t)(e)
        }
    }, function (t, e, n) {
        var r = n(279),
            i = n(283);

        function a(e) {
            return t.exports = a = "function" == typeof i && "symbol" == typeof r ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof i && e.constructor === i && e !== i.prototype ? "symbol" : typeof e
            }, a(e)
        }
        t.exports = a
    }, function (e, t, n) {
        "use strict";
        var w = n(30),
            r = n(39),
            M = n(34),
            b = n(46),
            S = n(142),
            E = n(96),
            T = Math.max,
            L = Math.min,
            d = Math.floor,
            f = /\$([$&`']|\d\d?|<[^>]*>)/g,
            p = /\$([$&`']|\d\d?)/g,
            N = function (e) {
                return void 0 === e ? e : String(e)
            };
        n(98)("replace", 2, function (i, a, x, C) {
            return [function (e, t) {
                var n = i(this),
                    r = null == e ? void 0 : e[a];
                return void 0 !== r ? r.call(e, n, t) : x.call(String(n), e, t)
            }, function (e, t) {
                var n = C(x, e, this, t);
                if (n.done) return n.value;
                var r = w(e),
                    i = String(this),
                    a = "function" == typeof t;
                a || (t = String(t));
                var o = r.global;
                if (o) {
                    var s = r.unicode;
                    r.lastIndex = 0
                }
                for (var l = [];;) {
                    var u = E(r, i);
                    if (null === u) break;
                    if (l.push(u), !o) break;
                    var h = String(u[0]);
                    "" === h && (r.lastIndex = S(i, M(r.lastIndex), s))
                }
                for (var c = "", d = 0, f = 0; f < l.length; f++) {
                    u = l[f];
                    for (var p = String(u[0]), g = T(L(b(u.index), i.length), 0), m = [], v = 1; v < u.length; v++) m.push(N(u[v]));
                    var y = u.groups;
                    if (a) {
                        var _ = [p].concat(m, g, i);
                        void 0 !== y && _.push(y);
                        var A = String(t.apply(void 0, _))
                    } else A = I(p, i, g, m, y, t);
                    d <= g && (c += i.slice(d, g) + A, d = g + p.length)
                }
                return c + i.slice(d)
            }];

            function I(a, o, s, l, u, e) {
                var h = s + a.length,
                    c = l.length,
                    t = p;
                return void 0 !== u && (u = r(u), t = f), x.call(e, t, function (e, t) {
                    var n;
                    switch (t.charAt(0)) {
                        case "$":
                            return "$";
                        case "&":
                            return a;
                        case "`":
                            return o.slice(0, s);
                        case "'":
                            return o.slice(h);
                        case "<":
                            n = u[t.slice(1, -1)];
                            break;
                        default:
                            var r = +t;
                            if (0 === r) return e;
                            if (c < r) {
                                var i = d(r / 10);
                                return 0 === i ? e : i <= c ? void 0 === l[i - 1] ? t.charAt(1) : l[i - 1] + t.charAt(1) : e
                            }
                            n = l[r - 1]
                    }
                    return void 0 === n ? "" : n
                })
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(53), n(56);
        var a = r(n(2)),
            o = r(n(3)),
            L = 1e-5,
            _ = 1e-5,
            V = .001,
            s = .01,
            l = function () {
                function z() {
                    (0, a.default)(this, z)
                }
                return (0, o.default)(z, null, [{
                    key: "epsilon",
                    value: function () {
                        return V
                    }
                }, {
                    key: "isZero",
                    value: function (e) {
                        return e < L && -L < e
                    }
                }, {
                    key: "gtZero",
                    value: function (e) {
                        return L < e
                    }
                }, {
                    key: "ltZero",
                    value: function (e) {
                        return e < -L
                    }
                }, {
                    key: "pointDistanceToLine",
                    value: function (e, t, n, r) {
                        var i, a = t.x,
                            o = t.y,
                            s = n.x,
                            l = n.y,
                            u = e.x,
                            h = e.y,
                            c = s - a,
                            d = l - o,
                            f = Math.sqrt(c * c + d * d),
                            p = u - a,
                            g = h - o,
                            m = Math.sqrt(p * p + g * g);
                        if (z.isZero(f)) return r.x = t.x, r.y = t.y, i = z.isZero(m) ? 0 : m, i;
                        var v = c / f,
                            y = d / f,
                            _ = v * p + y * g;
                        if (!z.gtZero(_)) return r.x = t.x, r.y = t.y, i = m, i;
                        if (!z.ltZero(_ - f)) {
                            var A = u - s,
                                x = h - l,
                                C = Math.sqrt(A * A + x * x);
                            return r.x = n.x, r.y = n.y, i = C, i
                        }
                        var I = a + _ * v,
                            w = o + _ * y,
                            M = u - I,
                            b = h - w,
                            S = Math.sqrt(M * M + b * b);
                        return r.x = I, r.y = w, i = S, i
                    }
                }, {
                    key: "distanceOfTwoPoints",
                    value: function (e, t) {
                        return e && t ? Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y)) : Number.NaN
                    }
                }, {
                    key: "isSamePoint",
                    value: function (e, t) {
                        return Math.abs(e.x - t.x) <= _ && Math.abs(e.y - t.y) <= _
                    }
                }, {
                    key: "isNearlySamePoint",
                    value: function (e, t) {
                        return Math.abs(e.x - t.x) <= s && Math.abs(e.y - t.y) <= s
                    }
                }, {
                    key: "getPolygonInnerPoint",
                    value: function (e) {
                        if (e && 0 == e.length) return {
                            x: 0,
                            y: 0
                        };
                        var t = e.length;
                        if (t < 3) return e[0];
                        var n = e[0],
                            r = e[1],
                            i = {
                                x: (n.x + r.x) / 2,
                                y: (n.y + r.y) / 2
                            },
                            a = Math.atan2(r.y - n.y, r.x - n.x);
                        a -= Math.PI / 2;
                        for (var o = 3; .5 < o;) {
                            var s = {
                                x: i.x + o * Math.cos(a),
                                y: i.y + o * Math.sin(a)
                            };
                            if (z.isInPolygon(s, e)) return s;
                            o /= 2
                        }
                        for (a += Math.PI, o = 3; .5 < o;) {
                            var l = {
                                x: i.x + o * Math.cos(a),
                                y: i.y + o * Math.sin(a)
                            };
                            if (z.isInPolygon(l, e)) return l;
                            o /= 2
                        }
                        return {
                            x: 0,
                            y: 0
                        }
                    }
                }, {
                    key: "isInPolygon",
                    value: function (e, t) {
                        for (var n = !1, r = t.length, i = 0, a = r - 1; i < r; a = i, ++i) {
                            var o = t[i].x,
                                s = t[i].y,
                                l = t[a].x,
                                u = t[a].y;
                            if (o == e.x && s == e.y || l == e.x && u == e.y) return !0;
                            if (s < e.y && u >= e.y || s >= e.y && u < e.y) {
                                var h = o + (e.y - s) * (l - o) / (u - s);
                                if (h == e.x) return !0;
                                h > e.x && (n = !n)
                            }
                        }
                        return n
                    }
                }, {
                    key: "isInCircle",
                    value: function (e, t, n, r) {
                        if (e.x < r[0] && e.x > r[1]) return !1;
                        if (e.y < r[2] && e.y > r[3]) return !1;
                        var i = n * n,
                            a = e.x,
                            o = e.y,
                            s = t.x,
                            l = t.y,
                            u = s - a,
                            h = l - o,
                            c = u * u + h * h;
                        return c < i
                    }
                }, {
                    key: "isRectCross",
                    value: function (e, t, n, r) {
                        return !(Math.max(e.x, t.x) < Math.min(n.x, r.x) || Math.max(e.y, t.y) < Math.min(n.y, r.y) || Math.max(n.x, r.x) < Math.min(e.x, t.x) || Math.max(n.y, r.y) < Math.min(e.y, t.y))
                    }
                }, {
                    key: "pointIsInRect",
                    value: function (e, t, n, r) {
                        return Math.abs(e.x - t.x) < n && Math.abs(e.y - t.y) < r
                    }
                }, {
                    key: "pointIsInRect1",
                    value: function (e, t, n) {
                        var r = Math.min(t.x, n.x),
                            i = Math.max(t.x, n.x),
                            a = Math.min(t.y, n.y),
                            o = Math.max(t.y, n.y);
                        return !(e.x < r || e.x > i || e.y < a || e.y > o)
                    }
                }, {
                    key: "cross",
                    value: function (e, t, n) {
                        return (e.x - n.x) * (t.y - n.y) - (t.x - n.x) * (e.y - n.y)
                    }
                }, {
                    key: "isLineSegmentCross",
                    value: function (e, t, n, r) {
                        return !(Math.max(e.x, t.x) < Math.min(n.x, r.x) || Math.max(e.y, t.y) < Math.min(n.y, r.y) || Math.max(n.x, r.x) < Math.min(e.x, t.x) || Math.max(n.y, r.y) < Math.min(e.y, t.y) || z.cross(n, t, e) * z.cross(t, r, e) < 0 || z.cross(e, r, n) * z.cross(r, t, n) < 0)
                    }
                }, {
                    key: "rayCrossSegment",
                    value: function (e, t, n, r, i) {
                        var a = Math.min(e.x, n.x, r.x),
                            o = Math.max(e.x, n.x, r.x),
                            s = Math.min(e.y, n.y, r.y),
                            l = Math.max(e.y, n.y, r.y),
                            u = Math.sqrt((o - a) * (o - a) + (l - s) * (l - s)),
                            h = t / 180 * Math.PI,
                            c = u * Math.cos(h) + e.x,
                            d = u * Math.sin(h) + e.y;
                        return 1 == this.calcCrossPoint(e, {
                            x: c,
                            y: d
                        }, n, r, i)
                    }
                }, {
                    key: "calcCrossPoint",
                    value: function (e, t, n, r, i) {
                        return 1 != z.isLineSegmentCross(e, t, n, r) ? 0 : (a = (r.x - n.x) * (e.y - t.y) - (t.x - e.x) * (n.y - r.y), o = (e.y - n.y) * (t.x - e.x) * (r.x - n.x) + n.x * (r.y - n.y) * (t.x - e.x) - e.x * (t.y - e.y) * (r.x - n.x), i.x = o / a, a = (e.x - t.x) * (r.y - n.y) - (t.y - e.y) * (n.x - r.x), o = t.y * (e.x - t.x) * (r.y - n.y) + (r.x - t.x) * (r.y - n.y) * (e.y - t.y) - r.y * (n.x - r.x) * (t.y - e.y), i.y = o / a, 1);
                        var a, o
                    }
                }, {
                    key: "pointInPolygon2d",
                    value: function (e, t, n) {
                        for (var r = !1, i = null, a = null, o = 0; o < n; o++) i = e[o], a = e[(o + 1) % n], (i.y < t.y && a.y >= t.y || a.y < t.y && i.y >= t.y) && (i.x <= t.x || a.x <= t.x) && i.x + (t.y - i.y) / (a.y - i.y) * (a.x - i.x) < t.x && (r = !r);
                        return r
                    }
                }, {
                    key: "pointInPolygon2d1",
                    value: function (e, t, n) {
                        for (var r = 0, i = null, a = null, o = null, s = 0; s < n; s++)
                            if (i = e[s], a = e[(s + 1) % n], (i.y < t.y && a.y >= t.y || a.y < t.y && i.y >= t.y) && (i.x <= t.x || a.x <= t.x)) {
                                if (o = i.x + (t.y - i.y) / (a.y - i.y) * (a.x - i.x), Math.abs(o - t.x) <= V) return 2;
                                o < t.x && (r = !r)
                            } return r
                    }
                }, {
                    key: "pointInPolygonVector2d",
                    value: function (e, t, n) {
                        for (var r = !1, i = null, a = null, o = 0, s = n / 2, l = 0; l < s; l++) o = 2 * l, i = {
                            x: e[o],
                            y: e[o + 1]
                        }, a = {
                            x: e[(o + 2) % n],
                            y: e[(o + 3) % n]
                        }, (i.y < t.y && a.y >= t.y || a.y < t.y && i.y >= t.y) && (i.x <= t.x || a.x <= t.x) && i.x + (t.y - i.y) / (a.y - i.y) * (a.x - i.x) < t.x && (r = !r);
                        return r
                    }
                }, {
                    key: "pointToSegmentDistance",
                    value: function (e, t, n) {
                        var r = e.x,
                            i = e.y,
                            a = t.x,
                            o = t.y,
                            s = n.x,
                            l = n.y,
                            u = (s - a) * (r - a) + (l - o) * (i - o);
                        if (u <= 0) return Math.sqrt((r - a) * (r - a) + (i - o) * (i - o));
                        var h = (s - a) * (s - a) + (l - o) * (l - o);
                        if (h <= u) return Math.sqrt((r - s) * (r - s) + (i - l) * (i - l));
                        var c = u / h,
                            d = a + (s - a) * c,
                            f = o + (l - o) * c;
                        return Math.sqrt((r - d) * (r - d) + (f - i) * (f - i))
                    }
                }, {
                    key: "pointToPolygon2d",
                    value: function (e, t, n) {
                        for (var r = null, i = null, a = Number.MAX_VALUE, o = 0; o < n; o++) {
                            r = e[o], i = e[(o + 1) % n];
                            var s = z.pointToSegmentDistance(t, r, i);
                            s < a && (a = s)
                        }
                        return a
                    }
                }, {
                    key: "lineInCircle2d",
                    value: function (e, t, n, r, i) {
                        if (e.x < i[0] && t.x < i[0]) return !1;
                        if (e.x > i[1] && t.x > i[1]) return !1;
                        if (e.y < i[2] && t.y < i[2]) return !1;
                        if (e.y > i[3] && t.y > i[3]) return !1;
                        var a = r * r,
                            o = e.x,
                            s = e.y,
                            l = t.x,
                            u = t.y,
                            h = n.x,
                            c = n.y,
                            d = l - o,
                            f = u - s,
                            p = d * d + f * f,
                            g = h - o,
                            m = c - s,
                            v = g * g + m * m;
                        if (z.isZero(p)) return !!z.isZero(v) || v < a;
                        p = Math.sqrt(p);
                        var y = d / p,
                            _ = f / p,
                            A = y * g + _ * m;
                        if (!z.gtZero(A)) return v < a;
                        if (!z.ltZero(A - p)) {
                            var x = h - l,
                                C = c - u,
                                I = x * x + C * C;
                            return I < a
                        }
                        var w = o + A * y,
                            M = s + A * _,
                            b = h - w,
                            S = c - M,
                            E = b * b + S * S;
                        return E < a
                    }
                }, {
                    key: "lineInPolygon2d",
                    value: function (e, t, n, r) {
                        if (e.x < r[0] && t.x < r[0]) return !1;
                        if (e.x > r[1] && t.x > r[1]) return !1;
                        if (e.y < r[2] && t.y < r[2]) return !1;
                        if (e.y > r[3] && t.y > r[3]) return !1;
                        var i = n.length;
                        if (z.pointInPolygon2d(n, e, i)) return !0;
                        if (z.pointInPolygon2d(n, t, i)) return !0;
                        for (var a = 0; a < i; a++) {
                            var o = (a + 1) % i;
                            if (z.isLineSegmentCross(e, t, n[a], n[o])) return !0
                        }
                        return !1
                    }
                }, {
                    key: "calcLineCircleCrossPoints2d",
                    value: function (e, t, n, r, i) {
                        if (e.x < i[0] && t.x < i[0]) return null;
                        if (e.x > i[1] && t.x > i[1]) return null;
                        if (e.y < i[2] && t.y < i[2]) return null;
                        if (e.y > i[3] && t.y > i[3]) return null;
                        var a = {
                                isContain: !1,
                                crossPoints: []
                            },
                            o = r * r,
                            s = e.x,
                            l = e.y,
                            u = t.x,
                            h = t.y,
                            c = n.x,
                            d = n.y,
                            f = u - s,
                            p = h - l,
                            g = f * f + p * p,
                            m = c - s,
                            v = d - l,
                            y = m * m + v * v,
                            _ = c - u,
                            A = d - h,
                            x = _ * _ + A * A;
                        if (z.isZero(g)) return z.isZero(y) ? (a.isContain = !0, a.crossPoints = [e, t]) : y < o && (a.isContain = !0, a.crossPoints = [e, t]), a;
                        if (y < o && x < o) return a.isContain = !0, a.crossPoints = [e, t], a;
                        var C = Math.sqrt(g),
                            I = f / C,
                            w = p / C,
                            M = m * I + v * w,
                            b = M * M,
                            S = m * m + v * v;
                        if (o - S + b < 0) return null;
                        var E = Math.sqrt(o - S + b),
                            T = M - E;
                        return -L < +T && T - C < L && a.crossPoints.push({
                            x: s + T * I,
                            y: l + T * w
                        }), T = M + E, -L < +T && T - C < L && a.crossPoints.push({
                            x: s + T * I,
                            y: l + T * w
                        }), a
                    }
                }, {
                    key: "calcLinePolygonCrossPoints2d",
                    value: function (e, t, n, r) {
                        if (e.x < r[0] && t.x < r[0]) return null;
                        if (e.x > r[1] && t.x > r[1]) return null;
                        if (e.y < r[2] && t.y < r[2]) return null;
                        if (e.y > r[3] && t.y > r[3]) return null;
                        var i = {
                                containType: 0,
                                crossPoints: []
                            },
                            a = n.length;
                        z.pointInPolygon2d(n, e, a) && (i.containType |= 1), z.pointInPolygon2d(n, t, a) && (i.containType |= 2);
                        for (var o = [], s = 0; s < a; s++) {
                            var l = (s + 1) % a,
                                u = {};
                            if (z.calcCrossPoint(e, t, n[s], n[l], u)) {
                                var h = u.x - e.x,
                                    c = u.y - e.y;
                                o.push({
                                    dis2: h * h + c * c,
                                    point: u
                                })
                            }
                        }
                        if (0 == o.length) return null;
                        o.sort(function (e, t) {
                            return t.dis2 - e.dis2
                        });
                        for (var d = 0; d < o.length; d++) i.crossPoints.push(o[d].point);
                        return i
                    }
                }, {
                    key: "calcCenterOfGravityPoint",
                    value: function (e, t) {
                        for (var n = 0, r = 0, i = 0, a = 0; a < t; a++) {
                            var o = e[a],
                                s = e[(a + 1) % t],
                                l = (o.x * s.y - o.y * s.x) / 2;
                            n += l, r += l * (o.x + s.x) / 3, i += l * (o.y + s.y) / 3
                        }
                        return r /= n, i /= n, {
                            x: r,
                            y: i
                        }
                    }
                }, {
                    key: "calcPolygonArea2d",
                    value: function (e) {
                        var t = e.length;
                        if (t < 3) return 0;
                        for (var n = 0, r = 0; r < t; ++r) {
                            var i = e[r],
                                a = e[(r + 1) % t];
                            n += i.x * a.y - i.y * a.x
                        }
                        return Math.abs(n / 2)
                    }
                }, {
                    key: "quickRayIntersect",
                    value: function (e, t, n, r, i) {
                        var a = Math.min(n.x, r.x),
                            o = Math.max(n.x, r.x),
                            s = Math.min(n.y, r.y),
                            l = Math.max(n.y, r.y),
                            u = e.x,
                            h = e.y,
                            c = n.x,
                            d = n.y,
                            f = r.x,
                            p = r.y;
                        if (90 == t) {
                            if (e.x < a || e.x > o) return !1;
                            var g = (p - d) / (f - c),
                                m = g * (u - c) + d;
                            return i.y = m, i.x = u, !(m < h || !z.pointIsInRect1(i, n, r))
                        }
                        if (270 == t) {
                            if (e.x < a || e.x > o) return !1;
                            var v = (p - d) / (f - c),
                                y = v * (u - c) + d;
                            return i.y = y, i.x = u, !(h < y || !z.pointIsInRect1(i, n, r))
                        }
                        if (270 != t && 90 != t && o - a < V) {
                            var _ = a,
                                A = Math.tan(t / 180 * Math.PI),
                                x = A * (_ - u) + h;
                            if (i.y = x, i.x = _, z.pointIsInRect1(i, n, r)) {
                                var C = _ - u,
                                    I = x - h,
                                    w = C / Math.sqrt(C * C + I * I),
                                    M = Math.cos(t / 180 * Math.PI);
                                return 0 < w * M
                            }
                        }
                        if (l - s <= 1e-6) {
                            var b = s,
                                S = Math.tan(t / 180 * Math.PI),
                                E = 1 / S * (b - h) + u;
                            if (i.x = E, i.y = b, z.pointIsInRect1(i, n, r)) {
                                var T = E - u,
                                    L = b - h,
                                    N = T / Math.sqrt(T * T + L * L),
                                    R = Math.cos(t / 180 * Math.PI);
                                return 0 < N * R
                            }
                            return !1
                        }
                        var k = Math.tan(t / 180 * Math.PI),
                            P = (p - d) / (f - c),
                            D = (d - h - (P * c - k * u)) / (k - P),
                            O = h + k * (D - u);
                        if (i.x = D, i.y = O, z.pointIsInRect1(i, n, r)) {
                            var F = D - u,
                                B = O - h,
                                G = F / Math.sqrt(F * F + B * B),
                                U = Math.cos(t / 180 * Math.PI);
                            return 0 < G * U
                        }
                        return !1
                    }
                }, {
                    key: "calcFootOfUpright",
                    value: function (e, t, n, r) {
                        var i = Math.min(t.x, n.x),
                            a = Math.max(t.x, n.x),
                            o = Math.min(t.y, n.y),
                            s = Math.max(t.y, n.y),
                            l = e.x,
                            u = e.y,
                            h = t.x,
                            c = t.y,
                            d = n.x,
                            f = n.y;
                        if (Math.abs(h - d) < _) return r.x = h, r.y = u, o <= u && u <= s;
                        if (Math.abs(c - f) < _) return r.x = l, r.y = c, i <= l && l <= a;
                        var p = (f - c) / (d - h),
                            g = -1 / p,
                            m = (f - c) / (d - h),
                            v = (c - u - (m * h - g * l)) / (g - m),
                            y = u + g * (v - l);
                        return r.x = v, r.y = y, !!z.pointIsInRect1(r, t, n)
                    }
                }, {
                    key: "vectorCross",
                    value: function (e, t) {
                        return {
                            x: e.y * t.z - e.z * t.y,
                            y: e.z * t.x - e.x * t.z,
                            z: e.x * t.y - e.y * t.x
                        }
                    }
                }, {
                    key: "vectorDot",
                    value: function (e, t) {
                        return e.x * t.x + e.y * t.y + e.z * t.z
                    }
                }, {
                    key: "vectorLength",
                    value: function (e) {
                        return Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z)
                    }
                }, {
                    key: "vector2DDot",
                    value: function (e, t) {
                        return e.x * t.x + e.y * t.y
                    }
                }, {
                    key: "vector2DLength",
                    value: function (e) {
                        return Math.sqrt(e.x * e.x + e.y * e.y)
                    }
                }, {
                    key: "calcRotateAngle",
                    value: function (e, t) {
                        var n = {
                                x: e.x,
                                y: e.y,
                                z: 0
                            },
                            r = {
                                x: t.x,
                                y: t.y,
                                z: 0
                            },
                            i = z.vectorCross(n, r),
                            a = z.vector2DDot(e, t),
                            o = Math.acos(a / (z.vector2DLength(e) * z.vector2DLength(t)));
                        return 0 < i.z ? o / Math.PI * 180 : 360 - o / Math.PI * 180
                    }
                }, {
                    key: "isPointOnSegment",
                    value: function (e, t, n) {
                        return (e.x - t.x) * (n.y - t.y) == (n.x - t.x) * (e.y - t.y) && Math.min(t.x, n.x) <= e.x && e.x <= Math.max(t.x, n.x) && Math.min(t.y, n.y) <= e.y && e.y <= Math.max(t.y, n.y)
                    }
                }, {
                    key: "segCrossPolygon",
                    value: function (e, t, n, r) {
                        for (var i = 0; i < n.length; i++) {
                            var a = n[i],
                                o = n[(i + 1) % n.length];
                            if (1 == this.calcCrossPoint(e, t, a, o, r)) return !0
                        }
                        return !1
                    }
                }]), z
            }(),
            u = l;
        t.default = u
    }, function (e) {
        var n = {}.hasOwnProperty;
        e.exports = function (e, t) {
            return n.call(e, t)
        }
    }, function (e) {
        e.exports = function (e) {
            if (null == e) throw TypeError("Can't call method on  " + e);
            return e
        }
    }, function (e, t, n) {
        var r = n(91);
        e.exports = function (e) {
            return Object(r(e))
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(22),
            i = n(119),
            a = n(39),
            o = n(18),
            s = [].sort,
            l = [1, 2, 3];
        r(r.P + r.F * (o(function () {
            l.sort(void 0)
        }) || !o(function () {
            l.sort(null)
        }) || !n(315)(s)), "Array", {
            sort: function (e) {
                return void 0 === e ? s.call(a(this)) : s.call(a(this), i(e))
            }
        })
    }, function (e, t, n) {
        e.exports = n(316)
    }, function (e, t, n) {
        "use strict";
        n(106)("sub", function (e) {
            return function () {
                return e(this, "sub", "", "")
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(24),
            i = n(50),
            a = n(74),
            o = n(160),
            h = n(72),
            s = n(18),
            l = n(88).f,
            u = n(120).f,
            c = n(33).f,
            d = n(357).trim,
            f = "Number",
            p = r[f],
            g = p,
            m = p.prototype,
            v = a(n(133)(m)) == f,
            y = "trim" in String.prototype,
            _ = function (e) {
                var t = h(e, !1);
                if ("string" == typeof t && 2 < t.length) {
                    t = y ? t.trim() : d(t, 3);
                    var n, r, i, a = t.charCodeAt(0);
                    if (43 === a || 45 === a) {
                        if (n = t.charCodeAt(2), 88 === n || 120 === n) return NaN
                    } else if (48 === a) {
                        switch (t.charCodeAt(1)) {
                            case 66:
                            case 98:
                                r = 2, i = 49;
                                break;
                            case 79:
                            case 111:
                                r = 8, i = 55;
                                break;
                            default:
                                return +t
                        }
                        for (var o, s = t.slice(2), l = 0, u = s.length; l < u; l++)
                            if (o = s.charCodeAt(l), o < 48 || i < o) return NaN;
                        return parseInt(s, r)
                    }
                }
                return +t
            };
        if (!p(" 0o1") || !p("0b1") || p("+0x1")) {
            p = function (e) {
                var t = arguments.length < 1 ? 0 : e,
                    n = this;
                return n instanceof p && (v ? s(function () {
                    m.valueOf.call(n)
                }) : a(n) != f) ? o(new g(_(t)), n, p) : _(t)
            };
            for (var A, x = n(23) ? l(g) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), C = 0; x.length > C; C++) i(g, A = x[C]) && !i(p, A) && c(p, A, u(g, A));
            p.prototype = m, m.constructor = p, n(38)(r, f, p)
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(27));
        n(13);
        var o = r(n(2)),
            s = r(n(3)),
            l = function () {
                function e() {
                    (0, o.default)(this, e)
                }
                return (0, s.default)(e, null, [{
                    key: "toColor",
                    value: function (e) {
                        if ("number" == typeof e) return e;
                        var t = e.split(",");
                        return 3 <= t.length ? (0, a.default)(t[0]) << 16 | (0, a.default)(t[1]) << 8 | (0, a.default)(t[2]) : (console.error("color format error", e), 0)
                    }
                }, {
                    key: "toRgba",
                    value: function (e) {
                        if ("number" == typeof e) return "rgba(" + (0, a.default)(255 * new fm.Color(e).r) + "," + (0, a.default)(255 * new fm.Color(e).g) + "," + (0, a.default)(255 * new fm.Color(e).b) + ",1)";
                        var t = e.split(",");
                        return 3 <= t.length ? "rgba(" + (0, a.default)(t[0]) + "," + (0, a.default)(t[1]) + "," + (0, a.default)(t[2]) + ",1)" : e
                    }
                }, {
                    key: "bindEvent",
                    value: function (e, a, t, o) {
                        e.addEventListener(t, function (e) {
                            var t = e || window.event,
                                n = t.target || t.srcElement,
                                r = t.currentTarget;
                            for (Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (e) {
                                    for (var t = (this.document || this.ownerDocument).querySelectorAll(e), n = t.length; 0 <= --n && t.item(n) !== this;);
                                    return -1 < n
                                }); n !== r;) {
                                if (n.matches(a)) {
                                    var i = n;
                                    o.call(i, t)
                                }
                                n = n.parentNode
                            }
                        })
                    }
                }, {
                    key: "toSceneCoord",
                    value: function (e, t) {
                        var n = 0;
                        return t.groupID && (n = e.getFMGroup(t.groupID).height), new fm.Vector3(t.x - e.center.x, e.center.y + n, -t.y + e.center.y)
                    }
                }, {
                    key: "removeFormArray",
                    value: function (e, t) {
                        var n = e.indexOf(t); - 1 < n && e.splice(n, 1)
                    }
                }, {
                    key: "scrollTopAnFun",
                    value: function () {
                        var g, m = !1;
                        return function t(n) {
                            var r = n.el,
                                i = n.to,
                                e = n.form,
                                a = (n.time, i < e ? "up" : "bottom"),
                                o = e < i ? i - e : i == e ? 0 : e - i,
                                s = 10,
                                l = o / s,
                                u = 0,
                                h = function (e) {
                                    var t = e.val,
                                        n = e.nbak,
                                        r = e.n,
                                        i = e.elTop;
                                    return "up" == a ? i + (n - r) * t : i - (n - r) * t
                                };

                            function c() {
                                g = 0, window.setTimeout(function () {
                                    var e = Object(n, {
                                        to: r.scrollTop
                                    });
                                    m = !1, t(e)
                                }, s + 1)
                            }
                            var d = function () {
                                    m = !1, g = !1, 0 == e && (r.scrollTop = 0)
                                },
                                f = function e() {
                                    if (g--, g <= 0) d();
                                    else {
                                        var t = function () {
                                            !1 !== g && (u = h({
                                                val: s,
                                                nbak: l,
                                                n: g,
                                                elTop: i,
                                                VDIRECTIONE: a
                                            }), u && (r.scrollTop = u), e())
                                        };
                                        window.setTimeout(t, s)
                                    }
                                };

                            function p() {
                                m ? c() : (m = !0, g = l, f())
                            }
                            p()
                        }
                    }
                }, {
                    key: "toVector",
                    value: function (e) {
                        return e.hasOwnProperty("z") ? new fm.Vector3(e.x, e.y, e.z) : new fm.Vector2(e.x, e.y)
                    }
                }, {
                    key: "sleep",
                    value: function (e) {
                        for (var t = (new Date).getTime(), n = 0; n < 1e7 && !((new Date).getTime() - t > e); n++);
                    }
                }]), e
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var u = r(n(11)),
            h = r(n(2)),
            a = r(n(3)),
            o = function () {
                function l(e, t, n, r, i) {
                    var a = 2 < arguments.length && void 0 !== n ? arguments[2] : 1e3,
                        o = 3 < arguments.length ? r : void 0,
                        s = 4 < arguments.length ? i : void 0;
                    (0, h.default)(this, l), this._left = (0, u.default)({}, e), this._right = (0, u.default)({}, t), this._time = a, this._enable = !1, this._countTime = 0, this._endBack = o, this._runBack = s, this.speed = 1, this._result = (0, u.default)({}, e)
                }
                return (0, a.default)(l, [{
                    key: "run",
                    value: function (e) {
                        var t = e * this.speed,
                            n = {};
                        if (this._countTime + t > this._time) {
                            for (var r in this._left) {
                                var i = (this._right[r] - this._left[r]) * (this._time - this._countTime) / this._time;
                                this._result[r] += i, n[r] = i
                            }
                            return this._enable = !1, this._runBack(this._result, n), this._endBack(this._result, n), this._result = {}, void(this._countTime = 0)
                        }
                        for (var a in this._left) {
                            var o = (this._right[a] - this._left[a]) * t / this._time;
                            this._result[a] += o, n[a] = o
                        }
                        this._countTime += t, this._runBack(this._result, n)
                    }
                }, {
                    key: "pause",
                    value: function () {
                        return this._enable = !1, this
                    }
                }, {
                    key: "resume",
                    value: function () {
                        return this._enable = !0, this
                    }
                }, {
                    key: "stop",
                    value: function () {
                        return this._enable = !1, this._countTime = 0, this._result = (0, u.default)({}, this._left), this
                    }
                }, {
                    key: "start",
                    value: function () {
                        return this._enable = !0, this
                    }
                }, {
                    key: "enable",
                    get: function () {
                        return this._enable
                    },
                    set: function (e) {
                        this._enable = e
                    }
                }]), l
            }(),
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(264)(!0);
        n(125)(String, "String", function (e) {
            this._t = String(e), this._i = 0
        }, function () {
            var e, t = this._t,
                n = this._i;
            return n >= t.length ? {
                value: void 0,
                done: !0
            } : (e = r(t, n), this._i += e.length, {
                value: e,
                done: !1
            })
        })
    }, function (e) {
        e.exports = {}
    }, function (e, t, n) {
        var r = n(127),
            i = n(91);
        e.exports = function (e) {
            return r(i(e))
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(175),
            i = n(272),
            a = n(63),
            o = n(87);
        e.exports = n(176)(Array, "Array", function (e, t) {
            this._t = o(e), this._i = 0, this._k = t
        }, function () {
            var e = this._t,
                t = this._k,
                n = this._i++;
            return !e || n >= e.length ? (this._t = void 0, i(1)) : i(0, "keys" == t ? n : "values" == t ? e[n] : [n, e[n]])
        }, "values"), a.Arguments = a.Array, r("keys"), r("values"), r("entries")
    }, function (e) {
        e.exports = {}
    }, function (e, t, n) {
        var r = n(94)("meta"),
            i = n(17),
            a = n(45),
            o = n(28).f,
            s = 0,
            l = Object.isExtensible || function () {
                return !0
            },
            u = !n(44)(function () {
                return l(Object.preventExtensions({}))
            }),
            h = function (e) {
                o(e, r, {
                    value: {
                        i: "O" + ++s,
                        w: {}
                    }
                })
            },
            c = function (e, t) {
                if (!i(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
                if (!a(e, r)) {
                    if (!l(e)) return "F";
                    if (!t) return "E";
                    h(e)
                }
                return e[r].i
            },
            d = function (e, t) {
                if (!a(e, r)) {
                    if (!l(e)) return !0;
                    if (!t) return !1;
                    h(e)
                }
                return e[r].w
            },
            f = function (e) {
                return u && p.NEED && l(e) && !a(e, r) && h(e), e
            },
            p = e.exports = {
                KEY: r,
                NEED: !1,
                fastKey: c,
                getWeak: d,
                onFreeze: f
            }
    }, function (e, t, n) {
        n(281);
        for (var r = n(14), i = n(43), a = n(60), o = n(19)("toStringTag"), s = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), l = 0; l < s.length; l++) {
            var u = s[l],
                h = r[u],
                c = h && h.prototype;
            c && !c[o] && i(c, o, u), a[u] = a.Array
        }
    }, function (e, t, n) {
        var d = n(36),
            f = n(171),
            p = n(172),
            g = n(29),
            m = n(93),
            v = n(131),
            y = {},
            _ = {};
        t = e.exports = function (e, t, n, r, i) {
            var a, o, s, l, u = i ? function () {
                    return e
                } : v(e),
                h = d(n, r, t ? 2 : 1),
                c = 0;
            if ("function" != typeof u) throw TypeError(e + " is not iterable!");
            if (p(u)) {
                for (a = m(e.length); c < a; c++)
                    if (l = t ? h(g(o = e[c])[0], o[1]) : h(e[c]), l === y || l === _) return l
            } else
                for (s = u.call(e); !(o = s.next()).done;)
                    if (l = f(s, h, o.value, t), l === y || l === _) return l
        }, t.BREAK = y, t.RETURN = _
    }, function (e, t, n) {
        "use strict";
        var r = n(97),
            i = {};
        i[n(15)("toStringTag")] = "z", i + "" != "[object z]" && n(38)(Object.prototype, "toString", function () {
            return "[object " + r(this) + "]"
        }, !0)
    }, function (e, t, n) {
        "use strict";
        n(106)("fontsize", function (t) {
            return function (e) {
                return t(this, "font", "size", e)
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.mapOptionMessage = t.tileMessage = t.cerityMessage = void 0;
        var i = {
            warn_nokey: "key%E5%80%BC%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82",
            warn_noappname: "%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82",
            warn_nomapid: "%E5%9C%B0%E5%9B%BEID%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9B%BEID%E3%80%82",
            warn_keynotright: "%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%AD%A4%E5%BA%94%E7%94%A8%E4%B8%8B%E7%9A%84key%E5%80%BC%E3%80%82",
            warn_offline: "%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%88%96key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82",
            warn_openerror: "%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5",
            warn_connecterror: "%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%9C%82%E9%B8%9F%E4%BA%91",
            warn_downloaderror: "%E4%BB%8E%E8%9C%82%E9%B8%9F%E4%BA%91%E4%B8%8A%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5",
            warn_local: "%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5"
        };
        t.cerityMessage = i;
        var a = {
            noGroup: "id",
            noFocus: ""
        };
        t.tileMessage = a;
        var o = {
            defaultViewCenterError: "fengmap.FMMapdefaultViewCenter"
        };
        t.mapOptionMessage = o
    }, function (e) {
        e.exports = function (e) {
            if ("function" != typeof e) throw TypeError(e + " is not a function!");
            return e
        }
    }, function (e) {
        e.exports = function (e, t) {
            return {
                enumerable: !(1 & e),
                configurable: !(2 & e),
                writable: !(4 & e),
                value: t
            }
        }
    }, function (e, t, n) {
        var i = n(37);
        e.exports = function (e, t) {
            if (!i(e)) return e;
            var n, r;
            if (t && "function" == typeof (n = e.toString) && !i(r = n.call(e))) return r;
            if ("function" == typeof (n = e.valueOf) && !i(r = n.call(e))) return r;
            if (!t && "function" == typeof (n = e.toString) && !i(r = n.call(e))) return r;
            throw TypeError("Can't convert object to primitive value")
        }
    }, function (e) {
        var t = 0,
            n = Math.random();
        e.exports = function (e) {
            return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++t + n).toString(36))
        }
    }, function (e) {
        var t = {}.toString;
        e.exports = function (e) {
            return t.call(e).slice(8, -1)
        }
    }, function (e) {
        e.exports = !0
    }, function (e, t, n) {
        var r = n(168),
            i = n(130);
        e.exports = Object.keys || function (e) {
            return r(e, i)
        }
    }, function (e) {
        var t = {}.toString;
        e.exports = function (e) {
            return t.call(e).slice(8, -1)
        }
    }, function (e, t, n) {
        var r = n(28).f,
            i = n(45),
            a = n(19)("toStringTag");
        e.exports = function (e, t, n) {
            e && !i(e = n ? e : e.prototype, a) && r(e, a, {
                configurable: !0,
                value: t
            })
        }
    }, function (e, t, n) {
        var r = n(17);
        e.exports = function (e, t) {
            if (!r(e) || e._t !== t) throw TypeError("Incompatible receiver, " + t + " required!");
            return e
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                ZH: "zh",
                EN: "en",
                CHN: "zh"
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e), this.currentModel = null, this.isToggleViewMode = !1, this.externalLoadingCount = 0
                }
                return (0, o.default)(e, [{
                    key: "dispose",
                    value: function (e) {
                        for (var t in this[e]) this[e][t] = void 0
                    }
                }]), e
            }(),
            l = new s,
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.AmbientLight = Pp, t.AmbientLightProbe = ig, t.AnimationClip = kf, t.AnimationLoader = Vf, t.AnimationMixer = Ug, t.AnimationObjectGroup = Bg, t.ArcCurve = Jf, t.ArrayCamera = Oh, t.ArrowHelper = Tm, t.Audio = pg, t.AudioAnalyser = Ag, t.AudioListener = fg, t.AudioLoader = eg, t.AxesHelper = Lm, t.AxisHelper = Hv, t.BinaryTextureLoader = Xv, t.Bone = pc, t.BooleanKeyframeTrack = bf, t.BoundingBoxHelper = Wv, t.Box2 = Zg, t.Box3 = ui, t.Box3Helper = wm, t.BoxHelper = Im, t.BufferAttribute = Xi, t.BufferGeometry = fa, t.BufferGeometryLoader = Up, t.Camera = qa, t.CameraHelper = Am, t.CanvasRenderer = Kv, t.CanvasTexture = Uc, t.CatmullRomCurve3 = np, t.CircleBufferGeometry = sf, t.CircleGeometry = of , t.Clock = lg, t.ClosedSplineCurve3 = Uv, t.Color = Gi, t.ColorKeyframeTrack = Sf, t.CompressedTexture = Gc, t.CompressedTextureLoader = Hf, t.ConeBufferGeometry = af, t.ConeGeometry = rf, t.CubeCamera = Ka, t.CubeTexture = zl, t.CubeTextureLoader = Yf, t.CubicBezierCurve = fp, t.CubicBezierCurve3 = pp, t.CubicInterpolant = Cf, t.Curve = Xf, t.CurvePath = xp, t.CylinderBufferGeometry = nf, t.CylinderGeometry = tf, t.Cylindrical = qg, t.DataTexture = $a, t.DataTexture2DArray = Vl, t.DataTexture3D = Hl, t.DataTextureLoader = Wf, t.DepthTexture = zc, t.DirectionalLight = kp, t.DirectionalLightHelper = vm, t.DirectionalLightShadow = Rp, t.DiscreteInterpolant = wf, t.DodecahedronBufferGeometry = ed, t.DodecahedronGeometry = $c, t.DynamicBufferAttribute = Lv, t.EdgesGeometry = ef, t.EdgesHelper = jv, t.EllipseCurve = Zf, t.Euler = kr, t.EventDispatcher = or, t.ExtrudeBufferGeometry = Ud, t.ExtrudeGeometry = Gd, t.Face3 = Hi, t.Face4 = gv, t.FileLoader = zf, t.Float32Attribute = Bv, t.Float32BufferAttribute = na, t.Float64Attribute = Gv, t.Float64BufferAttribute = ra, t.Fog = zh, t.FogExp2 = Uh, t.Font = Zp, t.FontLoader = Qp, t.Frustum = no, t.Geometry = Ba, t.GridHelper = dm, t.Group = Fh, t.HemisphereLight = Mp, t.HemisphereLightHelper = cm, t.HemisphereLightProbe = rg, t.IcosahedronBufferGeometry = Qc, t.IcosahedronGeometry = Kc, t.ImageBitmapLoader = qp, t.ImageLoader = jf, t.ImmediateRenderObject = $g, t.InstancedBufferAttribute = Gp, t.InstancedBufferGeometry = Bp, t.InstancedInterleavedBuffer = Vg, t.InstancedMesh = _c, t.Int16Attribute = Pv, t.Int16BufferAttribute = Qi, t.Int32Attribute = Ov, t.Int32BufferAttribute = ea, t.Int8Attribute = Nv, t.Int8BufferAttribute = Zi, t.InterleavedBuffer = Vh, t.InterleavedBufferAttribute = jh, t.Interpolant = xf, t.JSONLoader = Qv, t.KeyframeTrack = Mf, t.LOD = uc, t.LatheBufferGeometry = Jd, t.LatheGeometry = Zd, t.Layers = Pr, t.LensFlare = ey, t.Light = wp, t.LightProbe = ng, t.LightShadow = bp, t.Line = bc, t.Line3 = Qg, t.LineBasicMaterial = Ac, t.LineCurve = gp, t.LineCurve3 = mp, t.LineDashedMaterial = yf, t.LineLoop = Lc, t.LineSegments = Tc, t.LinearInterpolant = If, t.Loader = Gf, t.LoadingManager = Ff, t.Material = ji, t.MaterialLoader = Op, t.Matrix3 = dr, t.Matrix4 = Lr, t.Mesh = Na, t.MeshBasicMaterial = Yi, t.MeshDepthMaterial = Eh, t.MeshDistanceMaterial = Th, t.MeshFaceMaterial = xv, t.MeshLambertMaterial = mf, t.MeshMatcapMaterial = vf, t.MeshNormalMaterial = gf, t.MeshPhongMaterial = ff, t.MeshPhysicalMaterial = df, t.MeshStandardMaterial = cf, t.MeshToonMaterial = pf, t.MultiMaterial = Cv, t.NumberKeyframeTrack = Ef, t.Object3D = Xr, t.ObjectLoader = Vp, t.OctahedronBufferGeometry = Jc, t.OctahedronGeometry = Zc, t.OrthographicCamera = Np, t.PMREMGenerator = Qm, t.ParametricBufferGeometry = Wc, t.ParametricGeometry = Hc, t.Particle = wv, t.ParticleBasicMaterial = Sv, t.ParticleSystem = Mv, t.ParticleSystemMaterial = Ev, t.Path = Cp, t.PerspectiveCamera = Xa, t.Plane = wi, t.PlaneBufferGeometry = so, t.PlaneGeometry = oo, t.PlaneHelper = Mm, t.PointCloud = Iv, t.PointCloudMaterial = bv, t.PointLight = Lp, t.PointLightHelper = sm, t.Points = Oc, t.PointsMaterial = Nc, t.PolarGridHelper = fm, t.PolyhedronBufferGeometry = Yc, t.PolyhedronGeometry = jc, t.PositionalAudio = _g, t.PropertyBinding = Fg, t.PropertyMixer = xg, t.QuadraticBezierCurve = vp, t.QuadraticBezierCurve3 = yp, t.Quaternion = _r, t.QuaternionKeyframeTrack = Lf, t.QuaternionLinearInterpolant = Tf, t.RawShaderMaterial = hf, t.Ray = Ai, t.Raycaster = Hg, t.RectAreaLight = Dp, t.RingBufferGeometry = Xd, t.RingGeometry = qd, t.Scene = Zr, t.ShaderMaterial = Ya, t.ShadowMaterial = uf, t.Shape = Ip, t.ShapeBufferGeometry = Qd, t.ShapeGeometry = Kd, t.ShapePath = Xp, t.Skeleton = fc, t.SkeletonHelper = om, t.SkinnedMesh = hc, t.Sphere = di, t.SphereBufferGeometry = Yd, t.SphereGeometry = jd, t.Spherical = Yg, t.SphericalHarmonics3 = tg, t.Spline = Vv, t.SplineCurve = _p, t.SplineCurve3 = zv, t.SpotLight = Ep, t.SpotLightHelper = tm, t.SpotLightShadow = Sp, t.Sprite = ac, t.SpriteMaterial = Yh, t.StereoCamera = sg, t.StringKeyframeTrack = Nf, t.TetrahedronBufferGeometry = Xc, t.TetrahedronGeometry = qc, t.TextBufferGeometry = Wd, t.TextGeometry = Hd, t.Texture = gr, t.TextureLoader = qf, t.TorusBufferGeometry = od, t.TorusGeometry = ad, t.TorusKnotBufferGeometry = id, t.TorusKnotGeometry = rd, t.Triangle = Di, t.TubeBufferGeometry = nd, t.TubeGeometry = td, t.Uint16Attribute = Dv, t.Uint16BufferAttribute = $i, t.Uint32Attribute = Fv, t.Uint32BufferAttribute = ta, t.Uint8Attribute = Rv, t.Uint8BufferAttribute = Ji, t.Uint8ClampedAttribute = kv, t.Uint8ClampedBufferAttribute = Ki, t.Uniform = zg, t.Vector2 = cr, t.Vector3 = Cr, t.Vector4 = mr, t.VectorKeyframeTrack = Rf, t.Vertex = Tv, t.VideoTexture = Bc, t.WebGLCubeRenderTarget = Qa, t.WebGLMultisampleRenderTarget = yr, t.WebGLRenderTarget = vr, t.WebGLRenderTargetCube = Zv, t.WebGLRenderer = Gh, t.WebGLUtils = Dh, t.WireframeGeometry = Vc, t.WireframeHelper = Yv, t.XHRLoader = qv, t.NeverDepth = t.NearestMipmapNearestFilter = t.NearestMipmapLinearFilter = t.NearestMipMapNearestFilter = t.NearestMipMapLinearFilter = t.NearestFilter = t.MultiplyOperation = t.MultiplyBlending = t.MixOperation = t.MirroredRepeatWrapping = t.MinEquation = t.MaxEquation = t.MathUtils = t.Math = t.MOUSE = t.LuminanceFormat = t.LuminanceAlphaFormat = t.LoopRepeat = t.LoopPingPong = t.LoopOnce = t.LogLuvEncoding = t.LoaderUtils = t.LinearToneMapping = t.LinearMipmapNearestFilter = t.LinearMipmapLinearFilter = t.LinearMipMapNearestFilter = t.LinearMipMapLinearFilter = t.LinearFilter = t.LinearEncoding = t.LineStrip = t.LinePieces = t.LessStencilFunc = t.LessEqualStencilFunc = t.LessEqualDepth = t.LessDepth = t.KeepStencilOp = t.InvertStencilOp = t.InterpolateSmooth = t.InterpolateLinear = t.InterpolateDiscrete = t.IntType = t.IncrementWrapStencilOp = t.IncrementStencilOp = t.ImageUtils = t.HalfFloatType = t.GreaterStencilFunc = t.GreaterEqualStencilFunc = t.GreaterEqualDepth = t.GreaterDepth = t.GeometryUtils = t.GammaEncoding = t.FrontSide = t.FrontFaceDirectionCW = t.FrontFaceDirectionCCW = t.FloatType = t.FlatShading = t.FaceColors = t.EquirectangularRefractionMapping = t.EquirectangularReflectionMapping = t.EqualStencilFunc = t.EqualDepth = t.DynamicReadUsage = t.DynamicDrawUsage = t.DynamicCopyUsage = t.DstColorFactor = t.DstAlphaFactor = t.DoubleSide = t.DepthStencilFormat = t.DepthFormat = t.DefaultLoadingManager = t.DecrementWrapStencilOp = t.DecrementStencilOp = t.CustomBlending = t.CullFaceNone = t.CullFaceFrontBack = t.CullFaceFront = t.CullFaceBack = t.CubeUVRefractionMapping = t.CubeUVReflectionMapping = t.CubeRefractionMapping = t.CubeReflectionMapping = t.ClampToEdgeWrapping = t.CineonToneMapping = t.Cache = t.ByteType = t.CubeGeometry = t.BoxGeometry = t.BoxBufferGeometry = t.BasicShadowMap = t.BasicDepthPacking = t.BackSide = t.AudioContext = t.AnimationUtils = t.AlwaysStencilFunc = t.AlwaysDepth = t.AlphaFormat = t.AdditiveBlending = t.AddOperation = t.AddEquation = t.ACESFilmicToneMapping = void 0, t.UniformsLib = t.Uncharted2ToneMapping = t.UVMapping = t.TrianglesDrawMode = t.TriangleStripDrawMode = t.TriangleFanDrawMode = t.TangentSpaceNormalMap = t.TOUCH = t.SubtractiveBlending = t.SubtractEquation = t.StreamReadUsage = t.StreamDrawUsage = t.StreamCopyUsage = t.StaticReadUsage = t.StaticDrawUsage = t.StaticCopyUsage = t.SrcColorFactor = t.SrcAlphaSaturateFactor = t.SrcAlphaFactor = t.SphericalReflectionMapping = t.SmoothShading = t.ShortType = t.ShapeUtils = t.ShaderLib = t.ShaderChunk = t.SceneUtils = t.SRGB8_ALPHA8_ASTC_8x8_Format = t.SRGB8_ALPHA8_ASTC_8x6_Format = t.SRGB8_ALPHA8_ASTC_8x5_Format = t.SRGB8_ALPHA8_ASTC_6x6_Format = t.SRGB8_ALPHA8_ASTC_6x5_Format = t.SRGB8_ALPHA8_ASTC_5x5_Format = t.SRGB8_ALPHA8_ASTC_5x4_Format = t.SRGB8_ALPHA8_ASTC_4x4_Format = t.SRGB8_ALPHA8_ASTC_12x12_Format = t.SRGB8_ALPHA8_ASTC_12x10_Format = t.SRGB8_ALPHA8_ASTC_10x8_Format = t.SRGB8_ALPHA8_ASTC_10x6_Format = t.SRGB8_ALPHA8_ASTC_10x5_Format = t.SRGB8_ALPHA8_ASTC_10x10_Format = t.ReverseSubtractEquation = t.ReplaceStencilOp = t.RepeatWrapping = t.ReinhardToneMapping = t.RedIntegerFormat = t.RedFormat = t.RGIntegerFormat = t.RGFormat = t.RGB_S3TC_DXT1_Format = t.RGB_PVRTC_4BPPV1_Format = t.RGB_PVRTC_2BPPV1_Format = t.RGB_ETC2_Format = t.RGB_ETC1_Format = t.RGBM7Encoding = t.RGBM16Encoding = t.RGBIntegerFormat = t.RGBFormat = t.RGBEFormat = t.RGBEEncoding = t.RGBDEncoding = t.RGBA_S3TC_DXT5_Format = t.RGBA_S3TC_DXT3_Format = t.RGBA_S3TC_DXT1_Format = t.RGBA_PVRTC_4BPPV1_Format = t.RGBA_PVRTC_2BPPV1_Format = t.RGBA_ETC2_EAC_Format = t.RGBA_BPTC_Format = t.RGBA_ASTC_8x8_Format = t.RGBA_ASTC_8x6_Format = t.RGBA_ASTC_8x5_Format = t.RGBA_ASTC_6x6_Format = t.RGBA_ASTC_6x5_Format = t.RGBA_ASTC_5x5_Format = t.RGBA_ASTC_5x4_Format = t.RGBA_ASTC_4x4_Format = t.RGBA_ASTC_12x12_Format = t.RGBA_ASTC_12x10_Format = t.RGBA_ASTC_10x8_Format = t.RGBA_ASTC_10x6_Format = t.RGBA_ASTC_10x5_Format = t.RGBA_ASTC_10x10_Format = t.RGBAIntegerFormat = t.RGBAFormat = t.RGBADepthPacking = t.REVISION = t.PCFSoftShadowMap = t.PCFShadowMap = t.OneMinusSrcColorFactor = t.OneMinusSrcAlphaFactor = t.OneMinusDstColorFactor = t.OneMinusDstAlphaFactor = t.OneFactor = t.ObjectSpaceNormalMap = t.NotEqualStencilFunc = t.NotEqualDepth = t.NormalBlending = t.NoToneMapping = t.NoColors = t.NoBlending = t.NeverStencilFunc = void 0, t.sRGBEncoding = t.ZeroStencilOp = t.ZeroSlopeEnding = t.ZeroFactor = t.ZeroCurvatureEnding = t.WrapAroundEnding = t.VertexColors = t.VSMShadowMap = t.UnsignedShortType = t.UnsignedShort565Type = t.UnsignedShort5551Type = t.UnsignedShort4444Type = t.UnsignedIntType = t.UnsignedInt248Type = t.UnsignedByteType = t.UniformsUtils = void 0, n(259), n(261);
        var d = r(n(166));
        n(174), n(99), n(62);
        var a = r(n(276)),
            o = r(n(47)),
            S = r(n(181)),
            pe = r(n(186));
        n(48), n(13);
        var te = r(n(300)),
            u = r(n(104)),
            h = r(n(2)),
            c = r(n(4)),
            f = r(n(5)),
            p = r(n(6));
        n(53);
        var g = r(n(54));
        n(318), n(25), n(195), n(328), n(144), n(196), n(329), n(145), n(197);
        var m = r(n(27)),
            ge = r(n(16));
        n(336);
        var v = r(n(105));
        n(55);
        var He = r(n(35)),
            s = r(n(31));
        n(147), n(8);
        var l = r(n(107));
        n(343);
        var We = r(n(11));
        n(108), n(67), n(199);
        var y = r(n(0));
        n(349), n(351);
        var _ = r(n(353));
        n(56), n(359);
        var A, ie = r(n(360));
        void 0 === ie.default && (Number.EPSILON = Math.pow(2, -52)), void 0 === _.default && (Number.isInteger = function (e) {
            return "number" == typeof e && isFinite(e) && Math.floor(e) === e
        }), void 0 === Math.sign && (Math.sign = function (e) {
            return e < 0 ? -1 : 0 < e ? 1 : +e
        }), "name" in Function.prototype == 0 && (0, y.default)(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === We.default && (Object.assign = function (e) {
            if (null == e) throw new TypeError("Cannot convert undefined or null to object");
            for (var t = Object(e), n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                if (null != r)
                    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
            }
            return t
        });
        var x = "115";
        t.REVISION = x;
        var C = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        };
        t.MOUSE = C;
        var I = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        };
        t.TOUCH = I;
        var me = 0;
        t.CullFaceNone = me;
        var ve = 1;
        t.CullFaceBack = ve;
        var ye = 2;
        t.CullFaceFront = ye;
        var w = 3;
        t.CullFaceFrontBack = w;
        var M = 0;
        t.FrontFaceDirectionCW = M;
        var b = 1;
        t.FrontFaceDirectionCCW = b;
        var E = 0;
        t.BasicShadowMap = E;
        var N = 1;
        t.PCFShadowMap = N;
        var T = 2;
        t.PCFSoftShadowMap = T;
        var R = 3;
        t.VSMShadowMap = R;
        var k = 0;
        t.FrontSide = k;
        var je = 1;
        t.BackSide = je;
        var _e = 2;
        t.DoubleSide = _e;
        var L = 1;
        t.FlatShading = L;
        var P = 2;
        t.SmoothShading = P;
        var Ae = 0;
        t.NoBlending = Ae;
        var xe = 1;
        t.NormalBlending = xe;
        var Ce = 2;
        t.AdditiveBlending = Ce;
        var Ie = 3;
        t.SubtractiveBlending = Ie;
        var we = 4;
        t.MultiplyBlending = we;
        var Me = 5;
        t.CustomBlending = Me;
        var be = 100;
        t.AddEquation = be;
        var Se = 101;
        t.SubtractEquation = Se;
        var Ee = 102;
        t.ReverseSubtractEquation = Ee;
        var Te = 103;
        t.MinEquation = Te;
        var Le = 104;
        t.MaxEquation = Le;
        var Ne = 200;
        t.ZeroFactor = Ne;
        var Re = 201;
        t.OneFactor = Re;
        var ke = 202;
        t.SrcColorFactor = ke;
        var Pe = 203;
        t.OneMinusSrcColorFactor = Pe;
        var De = 204;
        t.SrcAlphaFactor = De;
        var Oe = 205;
        t.OneMinusSrcAlphaFactor = Oe;
        var Fe = 206;
        t.DstAlphaFactor = Fe;
        var Be = 207;
        t.OneMinusDstAlphaFactor = Be;
        var Ge = 208;
        t.DstColorFactor = Ge;
        var Ue = 209;
        t.OneMinusDstColorFactor = Ue;
        var ze = 210;
        t.SrcAlphaSaturateFactor = ze;
        var Ve = 0;
        t.NeverDepth = Ve;
        var Ye = 1;
        t.AlwaysDepth = Ye;
        var qe = 2;
        t.LessDepth = qe;
        var Xe = 3;
        t.LessEqualDepth = Xe;
        var Ze = 4;
        t.EqualDepth = Ze;
        var Je = 5;
        t.GreaterEqualDepth = Je;
        var Ke = 6;
        t.GreaterDepth = Ke;
        var Qe = 7;
        t.NotEqualDepth = Qe;
        var D = 0;
        t.MultiplyOperation = D;
        var O = 1;
        t.MixOperation = O;
        var F = 2;
        t.AddOperation = F;
        var B = 0;
        t.NoToneMapping = B;
        var $e = 1;
        t.LinearToneMapping = $e;
        var G = 2;
        t.ReinhardToneMapping = G;
        var U = 3;
        t.Uncharted2ToneMapping = U;
        var z = 4;
        t.CineonToneMapping = z;
        var V = 5;
        t.ACESFilmicToneMapping = V;
        var H = 300;
        t.UVMapping = H;
        var W = 301;
        t.CubeReflectionMapping = W;
        var j = 302;
        t.CubeRefractionMapping = j;
        var Y = 303;
        t.EquirectangularReflectionMapping = Y;
        var q = 304;
        t.EquirectangularRefractionMapping = q;
        var X = 305;
        t.SphericalReflectionMapping = X;
        var Z = 306;
        t.CubeUVReflectionMapping = Z;
        var J = 307;
        t.CubeUVRefractionMapping = J;
        var ne = 1e3;
        t.RepeatWrapping = ne;
        var re = 1001;
        t.ClampToEdgeWrapping = re;
        var ae = 1002;
        t.MirroredRepeatWrapping = ae;
        var oe = 1003;
        t.NearestFilter = oe;
        var se = 1004;
        t.NearestMipmapNearestFilter = se;
        var K = 1004;
        t.NearestMipMapNearestFilter = K;
        var le = 1005;
        t.NearestMipmapLinearFilter = le;
        var Q = 1005;
        t.NearestMipMapLinearFilter = Q;
        var ue = 1006;
        t.LinearFilter = ue;
        var he = 1007;
        t.LinearMipmapNearestFilter = he;
        var $ = 1007;
        t.LinearMipMapNearestFilter = $;
        var ce = 1008;
        t.LinearMipmapLinearFilter = ce;
        var ee = 1008;
        t.LinearMipMapLinearFilter = ee;
        var et = 1009;
        t.UnsignedByteType = et;
        var de = 1010;
        t.ByteType = de;
        var fe = 1011;
        t.ShortType = fe;
        var tt = 1012;
        t.UnsignedShortType = tt;
        var nt = 1013;
        t.IntType = nt;
        var rt = 1014;
        t.UnsignedIntType = rt;
        var it = 1015;
        t.FloatType = it;
        var at = 1016;
        t.HalfFloatType = at;
        var ot = 1017;
        t.UnsignedShort4444Type = ot;
        var st = 1018;
        t.UnsignedShort5551Type = st;
        var lt = 1019;
        t.UnsignedShort565Type = lt;
        var ut = 1020;
        t.UnsignedInt248Type = ut;
        var ht = 1021;
        t.AlphaFormat = ht;
        var ct = 1022;
        t.RGBFormat = ct;
        var dt = 1023;
        t.RGBAFormat = dt;
        var ft = 1024;
        t.LuminanceFormat = ft;
        var pt = 1025;
        t.LuminanceAlphaFormat = pt;
        var gt = dt;
        t.RGBEFormat = gt;
        var mt = 1026;
        t.DepthFormat = mt;
        var vt = 1027;
        t.DepthStencilFormat = vt;
        var yt = 1028;
        t.RedFormat = yt;
        var _t = 1029;
        t.RedIntegerFormat = _t;
        var At = 1030;
        t.RGFormat = At;
        var xt = 1031;
        t.RGIntegerFormat = xt;
        var Ct = 1032;
        t.RGBIntegerFormat = Ct;
        var It = 1033;
        t.RGBAIntegerFormat = It;
        var wt = 33776;
        t.RGB_S3TC_DXT1_Format = wt;
        var Mt = 33777;
        t.RGBA_S3TC_DXT1_Format = Mt;
        var bt = 33778;
        t.RGBA_S3TC_DXT3_Format = bt;
        var St = 33779;
        t.RGBA_S3TC_DXT5_Format = St;
        var Et = 35840;
        t.RGB_PVRTC_4BPPV1_Format = Et;
        var Tt = 35841;
        t.RGB_PVRTC_2BPPV1_Format = Tt;
        var Lt = 35842;
        t.RGBA_PVRTC_4BPPV1_Format = Lt;
        var Nt = 35843;
        t.RGBA_PVRTC_2BPPV1_Format = Nt;
        var Rt = 36196;
        t.RGB_ETC1_Format = Rt;
        var kt = 37492;
        t.RGB_ETC2_Format = kt;
        var Pt = 37496;
        t.RGBA_ETC2_EAC_Format = Pt;
        var Dt = 37808;
        t.RGBA_ASTC_4x4_Format = Dt;
        var Ot = 37809;
        t.RGBA_ASTC_5x4_Format = Ot;
        var Ft = 37810;
        t.RGBA_ASTC_5x5_Format = Ft;
        var Bt = 37811;
        t.RGBA_ASTC_6x5_Format = Bt;
        var Gt = 37812;
        t.RGBA_ASTC_6x6_Format = Gt;
        var Ut = 37813;
        t.RGBA_ASTC_8x5_Format = Ut;
        var zt = 37814;
        t.RGBA_ASTC_8x6_Format = zt;
        var Vt = 37815;
        t.RGBA_ASTC_8x8_Format = Vt;
        var Ht = 37816;
        t.RGBA_ASTC_10x5_Format = Ht;
        var Wt = 37817;
        t.RGBA_ASTC_10x6_Format = Wt;
        var jt = 37818;
        t.RGBA_ASTC_10x8_Format = jt;
        var Yt = 37819;
        t.RGBA_ASTC_10x10_Format = Yt;
        var qt = 37820;
        t.RGBA_ASTC_12x10_Format = qt;
        var Xt = 37821;
        t.RGBA_ASTC_12x12_Format = Xt;
        var Zt = 36492;
        t.RGBA_BPTC_Format = Zt;
        var Jt = 37840;
        t.SRGB8_ALPHA8_ASTC_4x4_Format = Jt;
        var Kt = 37841;
        t.SRGB8_ALPHA8_ASTC_5x4_Format = Kt;
        var Qt = 37842;
        t.SRGB8_ALPHA8_ASTC_5x5_Format = Qt;
        var $t = 37843;
        t.SRGB8_ALPHA8_ASTC_6x5_Format = $t;
        var en = 37844;
        t.SRGB8_ALPHA8_ASTC_6x6_Format = en;
        var tn = 37845;
        t.SRGB8_ALPHA8_ASTC_8x5_Format = tn;
        var nn = 37846;
        t.SRGB8_ALPHA8_ASTC_8x6_Format = nn;
        var rn = 37847;
        t.SRGB8_ALPHA8_ASTC_8x8_Format = rn;
        var an = 37848;
        t.SRGB8_ALPHA8_ASTC_10x5_Format = an;
        var on = 37849;
        t.SRGB8_ALPHA8_ASTC_10x6_Format = on;
        var sn = 37850;
        t.SRGB8_ALPHA8_ASTC_10x8_Format = sn;
        var ln = 37851;
        t.SRGB8_ALPHA8_ASTC_10x10_Format = ln;
        var un = 37852;
        t.SRGB8_ALPHA8_ASTC_12x10_Format = un;
        var hn = 37853;
        t.SRGB8_ALPHA8_ASTC_12x12_Format = hn;
        var cn = 2200;
        t.LoopOnce = cn;
        var dn = 2201;
        t.LoopRepeat = dn;
        var fn = 2202;
        t.LoopPingPong = fn;
        var pn = 2300;
        t.InterpolateDiscrete = pn;
        var gn = 2301;
        t.InterpolateLinear = gn;
        var mn = 2302;
        t.InterpolateSmooth = mn;
        var vn = 2400;
        t.ZeroCurvatureEnding = vn;
        var yn = 2401;
        t.ZeroSlopeEnding = yn;
        var _n = 2402;
        t.WrapAroundEnding = _n;
        var An = 0;
        t.TrianglesDrawMode = An;
        var xn = 1;
        t.TriangleStripDrawMode = xn;
        var Cn = 2;
        t.TriangleFanDrawMode = Cn;
        var In = 3e3;
        t.LinearEncoding = In;
        var wn = 3001;
        t.sRGBEncoding = wn;
        var Mn = 3007;
        t.GammaEncoding = Mn;
        var bn = 3002;
        t.RGBEEncoding = bn;
        var Sn = 3003;
        t.LogLuvEncoding = Sn;
        var En = 3004;
        t.RGBM7Encoding = En;
        var Tn = 3005;
        t.RGBM16Encoding = Tn;
        var Ln = 3006;
        t.RGBDEncoding = Ln;
        var Nn = 3200;
        t.BasicDepthPacking = Nn;
        var Rn = 3201;
        t.RGBADepthPacking = Rn;
        var kn = 0;
        t.TangentSpaceNormalMap = kn;
        var Pn = 1;
        t.ObjectSpaceNormalMap = Pn;
        var Dn = 0;
        t.ZeroStencilOp = Dn;
        var On = 7680;
        t.KeepStencilOp = On;
        var Fn = 7681;
        t.ReplaceStencilOp = Fn;
        var Bn = 7682;
        t.IncrementStencilOp = Bn;
        var Gn = 7683;
        t.DecrementStencilOp = Gn;
        var Un = 34055;
        t.IncrementWrapStencilOp = Un;
        var zn = 34056;
        t.DecrementWrapStencilOp = zn;
        var Vn = 5386;
        t.InvertStencilOp = Vn;
        var Hn = 512;
        t.NeverStencilFunc = Hn;
        var Wn = 513;
        t.LessStencilFunc = Wn;
        var jn = 514;
        t.EqualStencilFunc = jn;
        var Yn = 515;
        t.LessEqualStencilFunc = Yn;
        var qn = 516;
        t.GreaterStencilFunc = qn;
        var Xn = 517;
        t.NotEqualStencilFunc = Xn;
        var Zn = 518;
        t.GreaterEqualStencilFunc = Zn;
        var Jn = 519;
        t.AlwaysStencilFunc = Jn;
        var Kn = 35044;
        t.StaticDrawUsage = Kn;
        var Qn = 35048;
        t.DynamicDrawUsage = Qn;
        var $n = 35040;
        t.StreamDrawUsage = $n;
        var er = 35045;
        t.StaticReadUsage = er;
        var tr = 35049;
        t.DynamicReadUsage = tr;
        var nr = 35041;
        t.StreamReadUsage = nr;
        var rr = 35046;
        t.StaticCopyUsage = rr;
        var ir = 35050;
        t.DynamicCopyUsage = ir;
        var ar = 35042;

        function or() {}
        t.StreamCopyUsage = ar, (0, We.default)(or.prototype, {
            addEventListener: function (e, t) {
                void 0 === this._listeners && (this._listeners = {});
                var n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
            },
            hasEventListener: function (e, t) {
                if (void 0 === this._listeners) return !1;
                var n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            },
            removeEventListener: function (e, t) {
                if (void 0 !== this._listeners) {
                    var n = this._listeners,
                        r = n[e];
                    if (void 0 !== r) {
                        var i = r.indexOf(t); - 1 !== i && r.splice(i, 1)
                    }
                }
            },
            dispatchEvent: function (e) {
                if (void 0 !== this._listeners) {
                    var t = this._listeners,
                        n = t[e.type];
                    if (void 0 !== n) {
                        e.target = this;
                        for (var r = n.slice(0), i = 0, a = r.length; i < a; i++) r[i].call(this, e)
                    }
                }
            }
        });
        for (var sr = [], lr = 0; lr < 256; lr++) sr[lr] = (lr < 16 ? "0" : "") + lr.toString(16);
        var ur, hr = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                var e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0,
                    i = sr[255 & e] + sr[e >> 8 & 255] + sr[e >> 16 & 255] + sr[e >> 24 & 255] + "-" + sr[255 & t] + sr[t >> 8 & 255] + "-" + sr[t >> 16 & 15 | 64] + sr[t >> 24 & 255] + "-" + sr[63 & n | 128] + sr[n >> 8 & 255] + "-" + sr[n >> 16 & 255] + sr[n >> 24 & 255] + sr[255 & r] + sr[r >> 8 & 255] + sr[r >> 16 & 255] + sr[r >> 24 & 255];
                return i.toUpperCase()
            },
            clamp: function (e, t, n) {
                return Math.max(t, Math.min(n, e))
            },
            euclideanModulo: function (e, t) {
                return (e % t + t) % t
            },
            mapLinear: function (e, t, n, r, i) {
                return r + (e - t) * (i - r) / (n - t)
            },
            lerp: function (e, t, n) {
                return (1 - n) * e + n * t
            },
            smoothstep: function (e, t, n) {
                return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
            },
            smootherstep: function (e, t, n) {
                return e <= t ? 0 : n <= e ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
            },
            randInt: function (e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function (e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function (e) {
                return e * (.5 - Math.random())
            },
            degToRad: function (e) {
                return e * hr.DEG2RAD
            },
            radToDeg: function (e) {
                return e * hr.RAD2DEG
            },
            isPowerOfTwo: function (e) {
                return 0 == (e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function (e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function (e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function (e, t, n, r, i) {
                var a = Math.cos,
                    o = Math.sin,
                    s = a(n / 2),
                    l = o(n / 2),
                    u = a((t + r) / 2),
                    h = o((t + r) / 2),
                    c = a((t - r) / 2),
                    d = o((t - r) / 2),
                    f = a((r - t) / 2),
                    p = o((r - t) / 2);
                "XYX" === i ? e.set(s * h, l * c, l * d, s * u) : "YZY" === i ? e.set(l * d, s * h, l * c, s * u) : "ZXZ" === i ? e.set(l * c, l * d, s * h, s * u) : "XZX" === i ? e.set(s * h, l * p, l * f, s * u) : "YXY" === i ? e.set(l * f, s * h, l * p, s * u) : "ZYZ" === i ? e.set(l * p, l * f, s * h, s * u) : console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.")
            }
        };

        function cr(e, t) {
            this.x = e || 0, this.y = t || 0
        }

        function dr() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        t.MathUtils = t.Math = hr, (0, l.default)(cr.prototype, {
            width: {
                get: function () {
                    return this.x
                },
                set: function (e) {
                    this.x = e
                }
            },
            height: {
                get: function () {
                    return this.y
                },
                set: function (e) {
                    this.y = e
                }
            }
        }), (0, We.default)(cr.prototype, {
            isVector2: !0,
            set: function (e, t) {
                return this.x = e, this.y = t, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            },
            multiply: function (e) {
                return this.x *= e.x, this.y *= e.y, this
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this
            },
            divide: function (e) {
                return this.x /= e.x, this.y /= e.y, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            applyMatrix3: function (e) {
                var t = this.x,
                    n = this.y,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y
            },
            cross: function (e) {
                return this.x * e.y - this.y * e.x
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            angle: function () {
                var e = Math.atan2(-this.y, -this.x) + Math.PI;
                return e
            },
            distanceTo: function (e) {
                return Math.sqrt(this.distanceToSquared(e))
            },
            distanceToSquared: function (e) {
                var t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            },
            manhattanDistanceTo: function (e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
            },
            rotateAround: function (e, t) {
                var n = Math.cos(t),
                    r = Math.sin(t),
                    i = this.x - e.x,
                    a = this.y - e.y;
                return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this
            }
        }), (0, We.default)(dr.prototype, {
            isMatrix3: !0,
            set: function (e, t, n, r, i, a, o, s, l) {
                var u = this.elements;
                return u[0] = e, u[1] = r, u[2] = o, u[3] = t, u[4] = i, u[5] = s, u[6] = n, u[7] = a, u[8] = l, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            },
            extractBasis: function (e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            },
            setFromMatrix4: function (e) {
                var t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            },
            multiply: function (e) {
                return this.multiplyMatrices(this, e)
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this)
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[3],
                    s = n[6],
                    l = n[1],
                    u = n[4],
                    h = n[7],
                    c = n[2],
                    d = n[5],
                    f = n[8],
                    p = r[0],
                    g = r[3],
                    m = r[6],
                    v = r[1],
                    y = r[4],
                    _ = r[7],
                    A = r[2],
                    x = r[5],
                    C = r[8];
                return i[0] = a * p + o * v + s * A, i[3] = a * g + o * y + s * x, i[6] = a * m + o * _ + s * C, i[1] = l * p + u * v + h * A, i[4] = l * g + u * y + h * x, i[7] = l * m + u * _ + h * C, i[2] = c * p + d * v + f * A, i[5] = c * g + d * y + f * x, i[8] = c * m + d * _ + f * C, this
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    a = e[4],
                    o = e[5],
                    s = e[6],
                    l = e[7],
                    u = e[8];
                return t * a * u - t * o * l - n * i * u + n * o * s + r * i * l - r * a * s
            },
            getInverse: function (e, t) {
                void 0 !== t && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
                var n = e.elements,
                    r = this.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    l = n[4],
                    u = n[5],
                    h = n[6],
                    c = n[7],
                    d = n[8],
                    f = d * l - u * c,
                    p = u * h - d * s,
                    g = c * s - l * h,
                    m = i * f + a * p + o * g;
                if (0 === m) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                var v = 1 / m;
                return r[0] = f * v, r[1] = (o * c - d * a) * v, r[2] = (u * a - o * l) * v, r[3] = p * v, r[4] = (d * i - o * h) * v, r[5] = (o * s - u * i) * v, r[6] = g * v, r[7] = (a * h - c * i) * v, r[8] = (l * i - a * s) * v, this
            },
            transpose: function () {
                var e, t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            },
            getNormalMatrix: function (e) {
                return this.setFromMatrix4(e).getInverse(this).transpose()
            },
            transposeIntoArray: function (e) {
                var t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            },
            setUvTransform: function (e, t, n, r, i, a, o) {
                var s = Math.cos(i),
                    l = Math.sin(i);
                this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1)
            },
            scale: function (e, t) {
                var n = this.elements;
                return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
            },
            rotate: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e),
                    r = this.elements,
                    i = r[0],
                    a = r[3],
                    o = r[6],
                    s = r[1],
                    l = r[4],
                    u = r[7];
                return r[0] = t * i + n * s, r[3] = t * a + n * l, r[6] = t * o + n * u, r[1] = -n * i + t * s, r[4] = -n * a + t * l, r[7] = -n * o + t * u, this
            },
            translate: function (e, t) {
                var n = this.elements;
                return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                    if (t[r] !== n[r]) return !1;
                return !0
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
        });
        var fr = {
            getDataURL: function (e) {
                var t;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === ur && (ur = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ur.width = e.width, ur.height = e.height;
                    var n = ur.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = ur
                }
                return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
            }
        };
        t.ImageUtils = fr;
        var pr = 0;

        function gr(e, t, n, r, i, a, o, s, l, u) {
            (0, y.default)(this, "id", {
                value: pr++
            }), this.uuid = hr.generateUUID(), this.name = "", this.image = void 0 !== e ? e : gr.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : gr.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : re, this.wrapT = void 0 !== r ? r : re, this.magFilter = void 0 !== i ? i : ue, this.minFilter = void 0 !== a ? a : ce, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : dt, this.internalFormat = null, this.type = void 0 !== s ? s : et, this.offset = new cr(0, 0), this.repeat = new cr(1, 1), this.center = new cr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new dr, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : In, this.version = 0, this.onUpdate = null
        }

        function mr(e, t, n, r) {
            this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
        }

        function vr(e, t, n) {
            this.width = e, this.height = t, this.scissor = new mr(0, 0, e, t), this.scissorTest = !1, this.viewport = new mr(0, 0, e, t), n = n || {}, this.texture = new gr(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ue, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        function yr(e, t, n) {
            vr.call(this, e, t, n), this.samples = 4
        }

        function _r(e, t, n, r) {
            this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
        }
        gr.DEFAULT_IMAGE = void 0, gr.DEFAULT_MAPPING = H, gr.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: gr,
            isTexture: !0,
            updateMatrix: function () {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var r = this.image;
                    if (void 0 === r.uuid && (r.uuid = hr.generateUUID()), !t && void 0 === e.images[r.uuid]) {
                        var i;
                        if ((0, He.default)(r)) {
                            i = [];
                            for (var a = 0, o = r.length; a < o; a++) i.push(fr.getDataURL(r[a]))
                        } else i = fr.getDataURL(r);
                        e.images[r.uuid] = {
                            uuid: r.uuid,
                            url: i
                        }
                    }
                    n.image = r.uuid
                }
                return t || (e.textures[this.uuid] = n), n
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function (e) {
                if (this.mapping !== H) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                    case ne:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case re:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case ae:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                    case ne:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case re:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case ae:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
        }), (0, y.default)(gr.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), (0, l.default)(mr.prototype, {
            width: {
                get: function () {
                    return this.z
                },
                set: function (e) {
                    this.z = e
                }
            },
            height: {
                get: function () {
                    return this.w
                },
                set: function (e) {
                    this.w = e
                }
            }
        }), (0, We.default)(mr.prototype, {
            isVector4: !0,
            set: function (e, t, n, r) {
                return this.x = e, this.y = t, this.z = n, this.w = r, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setZ: function (e) {
                return this.z = e, this
            },
            setW: function (e) {
                return this.w = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            },
            applyMatrix4: function (e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = this.w,
                    a = e.elements;
                return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            setAxisAngleFromQuaternion: function (e) {
                this.w = 2 * Math.acos(e.w);
                var t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            },
            setAxisAngleFromRotationMatrix: function (e) {
                var t, n, r, i, a = .01,
                    o = .1,
                    s = e.elements,
                    l = s[0],
                    u = s[4],
                    h = s[8],
                    c = s[1],
                    d = s[5],
                    f = s[9],
                    p = s[2],
                    g = s[6],
                    m = s[10];
                if (Math.abs(u - c) < a && Math.abs(h - p) < a && Math.abs(f - g) < a) {
                    if (Math.abs(u + c) < o && Math.abs(h + p) < o && Math.abs(f + g) < o && Math.abs(l + d + m - 3) < o) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    var v = (l + 1) / 2,
                        y = (d + 1) / 2,
                        _ = (m + 1) / 2,
                        A = (u + c) / 4,
                        x = (h + p) / 4,
                        C = (f + g) / 4;
                    return y < v && _ < v ? i = v < a ? (n = 0, r = .707106781, .707106781) : (n = Math.sqrt(v), r = A / n, x / n) : _ < y ? i = y < a ? (n = .707106781, r = 0, .707106781) : (r = Math.sqrt(y), n = A / r, C / r) : _ < a ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(_), n = x / i, r = C / i), this.set(n, r, i, t), this
                }
                var I = Math.sqrt((g - f) * (g - f) + (h - p) * (h - p) + (c - u) * (c - u));
                return Math.abs(I) < .001 && (I = 1), this.x = (g - f) / I, this.y = (h - p) / I, this.z = (c - u) / I, this.w = Math.acos((l + d + m - 1) / 2), this
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
        }), vr.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: vr,
            isWebGLRenderTarget: !0,
            setSize: function (e, t) {
                this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), yr.prototype = (0, We.default)((0, s.default)(vr.prototype), {
            constructor: yr,
            isWebGLMultisampleRenderTarget: !0,
            copy: function (e) {
                return vr.prototype.copy.call(this, e), this.samples = e.samples, this
            }
        }), (0, We.default)(_r, {
            slerp: function (e, t, n, r) {
                return n.copy(e).slerp(t, r)
            },
            slerpFlat: function (e, t, n, r, i, a, o) {
                var s = n[r + 0],
                    l = n[r + 1],
                    u = n[r + 2],
                    h = n[r + 3],
                    c = i[a + 0],
                    d = i[a + 1],
                    f = i[a + 2],
                    p = i[a + 3];
                if (h !== p || s !== c || l !== d || u !== f) {
                    var g = 1 - o,
                        m = s * c + l * d + u * f + h * p,
                        v = 0 <= m ? 1 : -1,
                        y = 1 - m * m;
                    if (y > ie.default) {
                        var _ = Math.sqrt(y),
                            A = Math.atan2(_, m * v);
                        g = Math.sin(g * A) / _, o = Math.sin(o * A) / _
                    }
                    var x = o * v;
                    if (s = s * g + c * x, l = l * g + d * x, u = u * g + f * x, h = h * g + p * x, g === 1 - o) {
                        var C = 1 / Math.sqrt(s * s + l * l + u * u + h * h);
                        s *= C, l *= C, u *= C, h *= C
                    }
                }
                e[t] = s, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h
            }
        }), (0, l.default)(_r.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (e) {
                    this._x = e, this._onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (e) {
                    this._y = e, this._onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (e) {
                    this._z = e, this._onChangeCallback()
                }
            },
            w: {
                get: function () {
                    return this._w
                },
                set: function (e) {
                    this._w = e, this._onChangeCallback()
                }
            }
        }), (0, We.default)(_r.prototype, {
            isQuaternion: !0,
            set: function (e, t, n, r) {
                return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function (e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            },
            setFromEuler: function (e, t) {
                if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var n = e._x,
                    r = e._y,
                    i = e._z,
                    a = e.order,
                    o = Math.cos,
                    s = Math.sin,
                    l = o(n / 2),
                    u = o(r / 2),
                    h = o(i / 2),
                    c = s(n / 2),
                    d = s(r / 2),
                    f = s(i / 2);
                return "XYZ" === a ? (this._x = c * u * h + l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h - c * d * f) : "YXZ" === a ? (this._x = c * u * h + l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h + c * d * f) : "ZXY" === a ? (this._x = c * u * h - l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h - c * d * f) : "ZYX" === a ? (this._x = c * u * h - l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h + c * d * f) : "YZX" === a ? (this._x = c * u * h + l * d * f, this._y = l * d * h + c * u * f, this._z = l * u * f - c * d * h, this._w = l * u * h - c * d * f) : "XZY" === a && (this._x = c * u * h - l * d * f, this._y = l * d * h - c * u * f, this._z = l * u * f + c * d * h, this._w = l * u * h + c * d * f), !1 !== t && this._onChangeCallback(), this
            },
            setFromAxisAngle: function (e, t) {
                var n = t / 2,
                    r = Math.sin(n);
                return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
            },
            setFromRotationMatrix: function (e) {
                var t, n = e.elements,
                    r = n[0],
                    i = n[4],
                    a = n[8],
                    o = n[1],
                    s = n[5],
                    l = n[9],
                    u = n[2],
                    h = n[6],
                    c = n[10],
                    d = r + s + c;
                return 0 < d ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (h - l) * t, this._y = (a - u) * t, this._z = (o - i) * t) : s < r && c < r ? (t = 2 * Math.sqrt(1 + r - s - c), this._w = (h - l) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (a + u) / t) : c < s ? (t = 2 * Math.sqrt(1 + s - r - c), this._w = (a - u) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (l + h) / t) : (t = 2 * Math.sqrt(1 + c - r - s), this._w = (o - i) / t, this._x = (a + u) / t, this._y = (l + h) / t, this._z = .25 * t), this._onChangeCallback(), this
            },
            setFromUnitVectors: function (e, t) {
                var n = 1e-6,
                    r = e.dot(t) + 1;
                return r < n ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = r, this.normalize()
            },
            angleTo: function (e) {
                return 2 * Math.acos(Math.abs(hr.clamp(this.dot(e), -1, 1)))
            },
            rotateTowards: function (e, t) {
                var n = this.angleTo(e);
                if (0 === n) return this;
                var r = Math.min(1, t / n);
                return this.slerp(e, r), this
            },
            inverse: function () {
                return this.conjugate()
            },
            conjugate: function () {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            },
            dot: function (e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            },
            lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function () {
                var e = this.length();
                return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
            },
            premultiply: function (e) {
                return this.multiplyQuaternions(e, this)
            },
            multiplyQuaternions: function (e, t) {
                var n = e._x,
                    r = e._y,
                    i = e._z,
                    a = e._w,
                    o = t._x,
                    s = t._y,
                    l = t._z,
                    u = t._w;
                return this._x = n * u + a * o + r * l - i * s, this._y = r * u + a * s + i * o - n * l, this._z = i * u + a * l + n * s - r * o, this._w = a * u - n * o - r * s - i * l, this._onChangeCallback(), this
            },
            slerp: function (e, t) {
                if (0 === t) return this;
                if (1 === t) return this.copy(e);
                var n = this._x,
                    r = this._y,
                    i = this._z,
                    a = this._w,
                    o = a * e._w + n * e._x + r * e._y + i * e._z;
                if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                var s = 1 - o * o;
                if (s <= ie.default) {
                    var l = 1 - t;
                    return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                }
                var u = Math.sqrt(s),
                    h = Math.atan2(u, o),
                    c = Math.sin((1 - t) * h) / u,
                    d = Math.sin(t * h) / u;
                return this._w = a * c + this._w * d, this._x = n * c + this._x * d, this._y = r * c + this._y * d, this._z = i * c + this._z * d, this._onChangeCallback(), this
            },
            equals: function (e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            },
            fromBufferAttribute: function (e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
            },
            _onChange: function (e) {
                return this._onChangeCallback = e, this
            },
            _onChangeCallback: function () {}
        });
        var Ar = new Cr,
            xr = new _r;

        function Cr(e, t, n) {
            this.x = e || 0, this.y = t || 0, this.z = n || 0
        }(0, We.default)(Cr.prototype, {
            isVector3: !0,
            set: function (e, t, n) {
                return this.x = e, this.y = t, this.z = n, this
            },
            setScalar: function (e) {
                return this.x = e, this.y = e, this.z = e, this
            },
            setX: function (e) {
                return this.x = e, this
            },
            setY: function (e) {
                return this.y = e, this
            },
            setZ: function (e) {
                return this.z = e, this
            },
            setComponent: function (e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            },
            getComponent: function (e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function (e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            },
            add: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
            },
            addScalar: function (e) {
                return this.x += e, this.y += e, this.z += e, this
            },
            addVectors: function (e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            },
            addScaledVector: function (e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            },
            sub: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
            },
            subScalar: function (e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            },
            subVectors: function (e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
            },
            multiplyScalar: function (e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            },
            multiplyVectors: function (e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            },
            applyEuler: function (e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(xr.setFromEuler(e))
            },
            applyAxisAngle: function (e, t) {
                return this.applyQuaternion(xr.setFromAxisAngle(e, t))
            },
            applyMatrix3: function (e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
            },
            applyNormalMatrix: function (e) {
                return this.applyMatrix3(e).normalize()
            },
            applyMatrix4: function (e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements,
                    a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this
            },
            applyQuaternion: function (e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.x,
                    a = e.y,
                    o = e.z,
                    s = e.w,
                    l = s * t + a * r - o * n,
                    u = s * n + o * t - i * r,
                    h = s * r + i * n - a * t,
                    c = -i * t - a * n - o * r;
                return this.x = l * s + c * -i + u * -o - h * -a, this.y = u * s + c * -a + h * -i - l * -o, this.z = h * s + c * -o + l * -a - u * -i, this
            },
            project: function (e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            },
            unproject: function (e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            },
            transformDirection: function (e) {
                var t = this.x,
                    n = this.y,
                    r = this.z,
                    i = e.elements;
                return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
            },
            divide: function (e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            },
            divideScalar: function (e) {
                return this.multiplyScalar(1 / e)
            },
            min: function (e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            },
            max: function (e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            },
            clamp: function (e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            },
            clampScalar: function (e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            },
            clampLength: function (e, t) {
                var n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            },
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function () {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function (e) {
                return this.normalize().multiplyScalar(e)
            },
            lerp: function (e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            },
            lerpVectors: function (e, t, n) {
                return this.subVectors(t, e).multiplyScalar(n).add(e)
            },
            cross: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
            },
            crossVectors: function (e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z,
                    a = t.x,
                    o = t.y,
                    s = t.z;
                return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this
            },
            projectOnVector: function (e) {
                var t = e.lengthSq();
                if (0 === t) return this.set(0, 0, 0);
                var n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            },
            projectOnPlane: function (e) {
                return Ar.copy(this).projectOnVector(e), this.sub(Ar)
            },
            reflect: function (e) {
                return this.sub(Ar.copy(e).multiplyScalar(2 * this.dot(e)))
            },
            angleTo: function (e) {
                var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                var n = this.dot(e) / t;
                return Math.acos(hr.clamp(n, -1, 1))
            },
            distanceTo: function (e) {
                return Math.sqrt(this.distanceToSquared(e))
            },
            distanceToSquared: function (e) {
                var t = this.x - e.x,
                    n = this.y - e.y,
                    r = this.z - e.z;
                return t * t + n * n + r * r
            },
            manhattanDistanceTo: function (e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            },
            setFromSpherical: function (e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            },
            setFromSphericalCoords: function (e, t, n) {
                var r = Math.sin(t) * e;
                return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
            },
            setFromCylindrical: function (e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            },
            setFromCylindricalCoords: function (e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            },
            setFromMatrixPosition: function (e) {
                var t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            },
            setFromMatrixScale: function (e) {
                var t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    r = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = r, this
            },
            setFromMatrixColumn: function (e, t) {
                return this.fromArray(e.elements, 4 * t)
            },
            setFromMatrix3Column: function (e, t) {
                return this.fromArray(e.elements, 3 * t)
            },
            equals: function (e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            },
            fromBufferAttribute: function (e, t, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
        });
        var Ir = new Cr,
            wr = new Lr,
            Mr = new Cr(0, 0, 0),
            br = new Cr(1, 1, 1),
            Sr = new Cr,
            Er = new Cr,
            Tr = new Cr;

        function Lr() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }(0, We.default)(Lr.prototype, {
            isMatrix4: !0,
            set: function (e, t, n, r, i, a, o, s, l, u, h, c, d, f, p, g) {
                var m = this.elements;
                return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = a, m[9] = o, m[13] = s, m[2] = l, m[6] = u, m[10] = h, m[14] = c, m[3] = d, m[7] = f, m[11] = p, m[15] = g, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new Lr).fromArray(this.elements)
            },
            copy: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            },
            copyPosition: function (e) {
                var t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            },
            extractBasis: function (e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function (e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function (e) {
                var t = this.elements,
                    n = e.elements,
                    r = 1 / Ir.setFromMatrixColumn(e, 0).length(),
                    i = 1 / Ir.setFromMatrixColumn(e, 1).length(),
                    a = 1 / Ir.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            },
            makeRotationFromEuler: function (e) {
                e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z,
                    a = Math.cos(n),
                    o = Math.sin(n),
                    s = Math.cos(r),
                    l = Math.sin(r),
                    u = Math.cos(i),
                    h = Math.sin(i);
                if ("XYZ" === e.order) {
                    var c = a * u,
                        d = a * h,
                        f = o * u,
                        p = o * h;
                    t[0] = s * u, t[4] = -s * h, t[8] = l, t[1] = d + f * l, t[5] = c - p * l, t[9] = -o * s, t[2] = p - c * l, t[6] = f + d * l, t[10] = a * s
                } else if ("YXZ" === e.order) {
                    var g = s * u,
                        m = s * h,
                        v = l * u,
                        y = l * h;
                    t[0] = g + y * o, t[4] = v * o - m, t[8] = a * l, t[1] = a * h, t[5] = a * u, t[9] = -o, t[2] = m * o - v, t[6] = y + g * o, t[10] = a * s
                } else if ("ZXY" === e.order) g = s * u, m = s * h, v = l * u, y = l * h, t[0] = g - y * o, t[4] = -a * h, t[8] = v + m * o, t[1] = m + v * o, t[5] = a * u, t[9] = y - g * o, t[2] = -a * l, t[6] = o, t[10] = a * s;
                else if ("ZYX" === e.order) c = a * u, d = a * h, f = o * u, p = o * h, t[0] = s * u, t[4] = f * l - d, t[8] = c * l + p, t[1] = s * h, t[5] = p * l + c, t[9] = d * l - f, t[2] = -l, t[6] = o * s, t[10] = a * s;
                else if ("YZX" === e.order) {
                    var _ = a * s,
                        A = a * l,
                        x = o * s,
                        C = o * l;
                    t[0] = s * u, t[4] = C - _ * h, t[8] = x * h + A, t[1] = h, t[5] = a * u, t[9] = -o * u, t[2] = -l * u, t[6] = A * h + x, t[10] = _ - C * h
                } else "XZY" === e.order && (_ = a * s, A = a * l, x = o * s, C = o * l, t[0] = s * u, t[4] = -h, t[8] = l * u, t[1] = _ * h + C, t[5] = a * u, t[9] = A * h - x, t[2] = x * h - A, t[6] = o * u, t[10] = C * h + _);
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            },
            makeRotationFromQuaternion: function (e) {
                return this.compose(Mr, e, br)
            },
            lookAt: function (e, t, n) {
                var r = this.elements;
                return Tr.subVectors(e, t), 0 === Tr.lengthSq() && (Tr.z = 1), Tr.normalize(), Sr.crossVectors(n, Tr), 0 === Sr.lengthSq() && (1 === Math.abs(n.z) ? Tr.x += 1e-4 : Tr.z += 1e-4, Tr.normalize(), Sr.crossVectors(n, Tr)), Sr.normalize(), Er.crossVectors(Tr, Sr), r[0] = Sr.x, r[4] = Er.x, r[8] = Tr.x, r[1] = Sr.y, r[5] = Er.y, r[9] = Tr.y, r[2] = Sr.z, r[6] = Er.z, r[10] = Tr.z, this
            },
            multiply: function (e, t) {
                return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
            },
            premultiply: function (e) {
                return this.multiplyMatrices(e, this)
            },
            multiplyMatrices: function (e, t) {
                var n = e.elements,
                    r = t.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[4],
                    s = n[8],
                    l = n[12],
                    u = n[1],
                    h = n[5],
                    c = n[9],
                    d = n[13],
                    f = n[2],
                    p = n[6],
                    g = n[10],
                    m = n[14],
                    v = n[3],
                    y = n[7],
                    _ = n[11],
                    A = n[15],
                    x = r[0],
                    C = r[4],
                    I = r[8],
                    w = r[12],
                    M = r[1],
                    b = r[5],
                    S = r[9],
                    E = r[13],
                    T = r[2],
                    L = r[6],
                    N = r[10],
                    R = r[14],
                    k = r[3],
                    P = r[7],
                    D = r[11],
                    O = r[15];
                return i[0] = a * x + o * M + s * T + l * k, i[4] = a * C + o * b + s * L + l * P, i[8] = a * I + o * S + s * N + l * D, i[12] = a * w + o * E + s * R + l * O, i[1] = u * x + h * M + c * T + d * k, i[5] = u * C + h * b + c * L + d * P, i[9] = u * I + h * S + c * N + d * D, i[13] = u * w + h * E + c * R + d * O, i[2] = f * x + p * M + g * T + m * k, i[6] = f * C + p * b + g * L + m * P, i[10] = f * I + p * S + g * N + m * D, i[14] = f * w + p * E + g * R + m * O, i[3] = v * x + y * M + _ * T + A * k, i[7] = v * C + y * b + _ * L + A * P, i[11] = v * I + y * S + _ * N + A * D, i[15] = v * w + y * E + _ * R + A * O, this
            },
            multiplyScalar: function (e) {
                var t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            },
            determinant: function () {
                var e = this.elements,
                    t = e[0],
                    n = e[4],
                    r = e[8],
                    i = e[12],
                    a = e[1],
                    o = e[5],
                    s = e[9],
                    l = e[13],
                    u = e[2],
                    h = e[6],
                    c = e[10],
                    d = e[14],
                    f = e[3],
                    p = e[7],
                    g = e[11],
                    m = e[15];
                return f * (i * s * h - r * l * h - i * o * c + n * l * c + r * o * d - n * s * d) + p * (t * s * d - t * l * c + i * a * c - r * a * d + r * l * u - i * s * u) + g * (t * l * h - t * o * d - i * a * h + n * a * d + i * o * u - n * l * u) + m * (-r * o * u - t * s * h + t * o * c + r * a * h - n * a * c + n * s * u)
            },
            transpose: function () {
                var e, t = this.elements;
                return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            },
            setPosition: function (e, t, n) {
                var r = this.elements;
                return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
            },
            getInverse: function (e, t) {
                void 0 !== t && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
                var n = this.elements,
                    r = e.elements,
                    i = r[0],
                    a = r[1],
                    o = r[2],
                    s = r[3],
                    l = r[4],
                    u = r[5],
                    h = r[6],
                    c = r[7],
                    d = r[8],
                    f = r[9],
                    p = r[10],
                    g = r[11],
                    m = r[12],
                    v = r[13],
                    y = r[14],
                    _ = r[15],
                    A = f * y * c - v * p * c + v * h * g - u * y * g - f * h * _ + u * p * _,
                    x = m * p * c - d * y * c - m * h * g + l * y * g + d * h * _ - l * p * _,
                    C = d * v * c - m * f * c + m * u * g - l * v * g - d * u * _ + l * f * _,
                    I = m * f * h - d * v * h - m * u * p + l * v * p + d * u * y - l * f * y,
                    w = i * A + a * x + o * C + s * I;
                if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                var M = 1 / w;
                return n[0] = A * M, n[1] = (v * p * s - f * y * s - v * o * g + a * y * g + f * o * _ - a * p * _) * M, n[2] = (u * y * s - v * h * s + v * o * c - a * y * c - u * o * _ + a * h * _) * M, n[3] = (f * h * s - u * p * s - f * o * c + a * p * c + u * o * g - a * h * g) * M, n[4] = x * M, n[5] = (d * y * s - m * p * s + m * o * g - i * y * g - d * o * _ + i * p * _) * M, n[6] = (m * h * s - l * y * s - m * o * c + i * y * c + l * o * _ - i * h * _) * M, n[7] = (l * p * s - d * h * s + d * o * c - i * p * c - l * o * g + i * h * g) * M, n[8] = C * M, n[9] = (m * f * s - d * v * s - m * a * g + i * v * g + d * a * _ - i * f * _) * M, n[10] = (l * v * s - m * u * s + m * a * c - i * v * c - l * a * _ + i * u * _) * M, n[11] = (d * u * s - l * f * s - d * a * c + i * f * c + l * a * g - i * u * g) * M, n[12] = I * M, n[13] = (d * v * o - m * f * o + m * a * p - i * v * p - d * a * y + i * f * y) * M, n[14] = (m * u * o - l * v * o - m * a * h + i * v * h + l * a * y - i * u * y) * M, n[15] = (l * f * o - d * u * o + d * a * h - i * f * h - l * a * p + i * u * p) * M, this
            },
            scale: function (e) {
                var t = this.elements,
                    n = e.x,
                    r = e.y,
                    i = e.z;
                return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
            },
            getMaxScaleOnAxis: function () {
                var e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, r))
            },
            makeTranslation: function (e, t, n) {
                return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            },
            makeRotationX: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function (e) {
                var t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function (e, t) {
                var n = Math.cos(t),
                    r = Math.sin(t),
                    i = 1 - n,
                    a = e.x,
                    o = e.y,
                    s = e.z,
                    l = i * a,
                    u = i * o;
                return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, u * o + n, u * s - r * a, 0, l * s - r * o, u * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
            },
            makeScale: function (e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            },
            makeShear: function (e, t, n) {
                return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
            },
            compose: function (e, t, n) {
                var r = this.elements,
                    i = t._x,
                    a = t._y,
                    o = t._z,
                    s = t._w,
                    l = i + i,
                    u = a + a,
                    h = o + o,
                    c = i * l,
                    d = i * u,
                    f = i * h,
                    p = a * u,
                    g = a * h,
                    m = o * h,
                    v = s * l,
                    y = s * u,
                    _ = s * h,
                    A = n.x,
                    x = n.y,
                    C = n.z;
                return r[0] = (1 - (p + m)) * A, r[1] = (d + _) * A, r[2] = (f - y) * A, r[3] = 0, r[4] = (d - _) * x, r[5] = (1 - (c + m)) * x, r[6] = (g + v) * x, r[7] = 0, r[8] = (f + y) * C, r[9] = (g - v) * C, r[10] = (1 - (c + p)) * C, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
            },
            decompose: function (e, t, n) {
                var r = this.elements,
                    i = Ir.set(r[0], r[1], r[2]).length(),
                    a = Ir.set(r[4], r[5], r[6]).length(),
                    o = Ir.set(r[8], r[9], r[10]).length(),
                    s = this.determinant();
                s < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], wr.copy(this);
                var l = 1 / i,
                    u = 1 / a,
                    h = 1 / o;
                return wr.elements[0] *= l, wr.elements[1] *= l, wr.elements[2] *= l, wr.elements[4] *= u, wr.elements[5] *= u, wr.elements[6] *= u, wr.elements[8] *= h, wr.elements[9] *= h, wr.elements[10] *= h, t.setFromRotationMatrix(wr), n.x = i, n.y = a, n.z = o, this
            },
            makePerspective: function (e, t, n, r, i, a) {
                void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var o = this.elements,
                    s = 2 * i / (t - e),
                    l = 2 * i / (n - r),
                    u = (t + e) / (t - e),
                    h = (n + r) / (n - r),
                    c = -(a + i) / (a - i),
                    d = -2 * a * i / (a - i);
                return o[0] = s, o[4] = 0, o[8] = u, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = c, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            },
            makeOrthographic: function (e, t, n, r, i, a) {
                var o = this.elements,
                    s = 1 / (t - e),
                    l = 1 / (n - r),
                    u = 1 / (a - i),
                    h = (t + e) * s,
                    c = (n + r) * l,
                    d = (a + i) * u;
                return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -c, o[2] = 0, o[6] = 0, o[10] = -2 * u, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            },
            equals: function (e) {
                for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                    if (t[r] !== n[r]) return !1;
                return !0
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                var n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        });
        var Nr = new Lr,
            Rr = new _r;

        function kr(e, t, n, r) {
            this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = r || kr.DefaultOrder
        }

        function Pr() {
            this.mask = 1
        }
        kr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], kr.DefaultOrder = "XYZ", (0, l.default)(kr.prototype, {
            x: {
                get: function () {
                    return this._x
                },
                set: function (e) {
                    this._x = e, this._onChangeCallback()
                }
            },
            y: {
                get: function () {
                    return this._y
                },
                set: function (e) {
                    this._y = e, this._onChangeCallback()
                }
            },
            z: {
                get: function () {
                    return this._z
                },
                set: function (e) {
                    this._z = e, this._onChangeCallback()
                }
            },
            order: {
                get: function () {
                    return this._order
                },
                set: function (e) {
                    this._order = e, this._onChangeCallback()
                }
            }
        }), (0, We.default)(kr.prototype, {
            isEuler: !0,
            set: function (e, t, n, r) {
                return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function (e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            },
            setFromRotationMatrix: function (e, t, n) {
                var r = hr.clamp,
                    i = e.elements,
                    a = i[0],
                    o = i[4],
                    s = i[8],
                    l = i[1],
                    u = i[5],
                    h = i[9],
                    c = i[2],
                    d = i[6],
                    f = i[10];
                return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, u), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, f), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-c, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-c, f), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-r(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, u))) : "YZX" === t ? (this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, u), this._y = Math.atan2(-c, a)) : (this._x = 0, this._y = Math.atan2(s, f))) : "XZY" === t ? (this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-h, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== n && this._onChangeCallback(), this
            },
            setFromQuaternion: function (e, t, n) {
                return Nr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Nr, t, n)
            },
            setFromVector3: function (e, t) {
                return this.set(e.x, e.y, e.z, t || this._order)
            },
            reorder: function (e) {
                return Rr.setFromEuler(this), this.setFromQuaternion(Rr, e)
            },
            equals: function (e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            },
            fromArray: function (e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            },
            toVector3: function (e) {
                return e ? e.set(this._x, this._y, this._z) : new Cr(this._x, this._y, this._z)
            },
            _onChange: function (e) {
                return this._onChangeCallback = e, this
            },
            _onChangeCallback: function () {}
        }), (0, We.default)(Pr.prototype, {
            set: function (e) {
                this.mask = 1 << e | 0
            },
            enable: function (e) {
                this.mask |= 1 << e | 0
            },
            enableAll: function () {
                this.mask = -1
            },
            toggle: function (e) {
                this.mask ^= 1 << e | 0
            },
            disable: function (e) {
                this.mask &= ~(1 << e | 0)
            },
            disableAll: function () {
                this.mask = 0
            },
            test: function (e) {
                return 0 != (this.mask & e.mask)
            }
        });
        var Dr = 0,
            Or = new Cr,
            Fr = new _r,
            Br = new Lr,
            Gr = new Cr,
            Ur = new Cr,
            zr = new Cr,
            Vr = new _r,
            Hr = new Cr(1, 0, 0),
            Wr = new Cr(0, 1, 0),
            jr = new Cr(0, 0, 1),
            Yr = {
                type: "added"
            },
            qr = {
                type: "removed"
            };

        function Xr() {
            (0, y.default)(this, "id", {
                value: Dr++
            }), this.uuid = hr.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Xr.DefaultUp.clone();
            var e = new Cr,
                t = new kr,
                n = new _r,
                r = new Cr(1, 1, 1);

            function i() {
                n.setFromEuler(t, !1)
            }

            function a() {
                t.setFromQuaternion(n, void 0, !1)
            }
            t._onChange(i), n._onChange(a), (0, l.default)(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: r
                },
                modelViewMatrix: {
                    value: new Lr
                },
                normalMatrix: {
                    value: new dr
                }
            }), this.matrix = new Lr, this.matrixWorld = new Lr, this.matrixAutoUpdate = Xr.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Pr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function Zr() {
            Xr.call(this), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        Xr.DefaultUp = new Cr(0, 1, 0), Xr.DefaultMatrixAutoUpdate = !0, Xr.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: Xr,
            isObject3D: !0,
            onBeforeRender: function () {},
            onAfterRender: function () {},
            applyMatrix4: function (e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function (e) {
                return this.quaternion.premultiply(e), this
            },
            setRotationFromAxisAngle: function (e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            },
            setRotationFromEuler: function (e) {
                this.quaternion.setFromEuler(e, !0)
            },
            setRotationFromMatrix: function (e) {
                this.quaternion.setFromRotationMatrix(e)
            },
            setRotationFromQuaternion: function (e) {
                this.quaternion.copy(e)
            },
            rotateOnAxis: function (e, t) {
                return Fr.setFromAxisAngle(e, t), this.quaternion.multiply(Fr), this
            },
            rotateOnWorldAxis: function (e, t) {
                return Fr.setFromAxisAngle(e, t), this.quaternion.premultiply(Fr), this
            },
            rotateX: function (e) {
                return this.rotateOnAxis(Hr, e)
            },
            rotateY: function (e) {
                return this.rotateOnAxis(Wr, e)
            },
            rotateZ: function (e) {
                return this.rotateOnAxis(jr, e)
            },
            translateOnAxis: function (e, t) {
                return Or.copy(e).applyQuaternion(this.quaternion), this.position.add(Or.multiplyScalar(t)), this
            },
            translateX: function (e) {
                return this.translateOnAxis(Hr, e)
            },
            translateY: function (e) {
                return this.translateOnAxis(Wr, e)
            },
            translateZ: function (e) {
                return this.translateOnAxis(jr, e)
            },
            localToWorld: function (e) {
                return e.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function (e) {
                return e.applyMatrix4(Br.getInverse(this.matrixWorld))
            },
            lookAt: function (e, t, n) {
                e.isVector3 ? Gr.copy(e) : Gr.set(e, t, n);
                var r = this.parent;
                this.updateWorldMatrix(!0, !1), Ur.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Br.lookAt(Ur, Gr, this.up) : Br.lookAt(Gr, Ur, this.up), this.quaternion.setFromRotationMatrix(Br), r && (Br.extractRotation(r.matrixWorld), Fr.setFromRotationMatrix(Br), this.quaternion.premultiply(Fr.inverse()))
            },
            add: function (e) {
                if (1 < arguments.length) {
                    for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                    return this
                }
                return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Yr)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
            },
            remove: function (e) {
                if (1 < arguments.length) {
                    for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    return this
                }
                var n = this.children.indexOf(e);
                return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(qr)), this
            },
            attach: function (e) {
                return this.updateWorldMatrix(!0, !1), Br.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Br.multiply(e.parent.matrixWorld)), e.applyMatrix4(Br), e.updateWorldMatrix(!1, !1), this.add(e), this
            },
            getObjectById: function (e) {
                return this.getObjectByProperty("id", e)
            },
            getObjectByName: function (e) {
                return this.getObjectByProperty("name", e)
            },
            getObjectByProperty: function (e, t) {
                if (this[e] === t) return this;
                for (var n = 0, r = this.children.length; n < r; n++) {
                    var i = this.children[n],
                        a = i.getObjectByProperty(e, t);
                    if (void 0 !== a) return a
                }
            },
            getWorldPosition: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Cr), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new _r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ur, e, zr), e
            },
            getWorldScale: function (e) {
                return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Cr), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ur, Vr, e), e
            },
            getWorldDirection: function (e) {
                void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Cr), this.updateMatrixWorld(!0);
                var t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            },
            raycast: function () {},
            traverse: function (e) {
                e(this);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
            },
            traverseVisible: function (e) {
                if (!1 !== this.visible) {
                    e(this);
                    for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                }
            },
            traverseAncestors: function (e) {
                var t = this.parent;
                null !== t && (e(t), t.traverseAncestors(e))
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function (e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
            },
            updateWorldMatrix: function (e, t) {
                var n = this.parent;
                if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                    for (var r = this.children, i = 0, a = r.length; i < a; i++) r[i].updateWorldMatrix(!1, !0)
            },
            toJSON: function (n) {
                var e = void 0 === n || "string" == typeof n,
                    t = {};
                e && (n = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, t.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var r = {};

                function i(e, t) {
                    return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(n)), t.uuid
                }
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== (0, v.default)(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                    r.geometry = i(n.geometries, this.geometry);
                    var a = this.geometry.parameters;
                    if (void 0 !== a && void 0 !== a.shapes) {
                        var o = a.shapes;
                        if ((0, He.default)(o))
                            for (var s = 0, l = o.length; s < l; s++) {
                                var u = o[s];
                                i(n.shapes, u)
                            } else i(n.shapes, o)
                    }
                }
                if (void 0 !== this.material)
                    if ((0, He.default)(this.material)) {
                        var h = [];
                        for (s = 0, l = this.material.length; s < l; s++) h.push(i(n.materials, this.material[s]));
                        r.material = h
                    } else r.material = i(n.materials, this.material);
                if (0 < this.children.length)
                    for (r.children = [], s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(n).object);
                if (e) {
                    var c = g(n.geometries),
                        d = g(n.materials),
                        f = g(n.textures),
                        p = g(n.images);
                    o = g(n.shapes), 0 < c.length && (t.geometries = c), 0 < d.length && (t.materials = d), 0 < f.length && (t.textures = f), 0 < p.length && (t.images = p), 0 < o.length && (t.shapes = o)
                }
                return t.object = r, t;

                function g(e) {
                    var t = [];
                    for (var n in e) {
                        var r = e[n];
                        delete r.metadata, t.push(r)
                    }
                    return t
                }
            },
            clone: function (e) {
                return (new this.constructor).copy(this, e)
            },
            copy: function (e, t) {
                if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse((0, v.default)(e.userData)), !0 === t)
                    for (var n = 0; n < e.children.length; n++) {
                        var r = e.children[n];
                        this.add(r.clone())
                    }
                return this
            }
        }), Zr.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: Zr,
            isScene: !0,
            copy: function (e, t) {
                return Xr.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            },
            toJSON: function (e) {
                var t = Xr.prototype.toJSON.call(this, e);
                return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Jr = [new Cr, new Cr, new Cr, new Cr, new Cr, new Cr, new Cr, new Cr],
            Kr = new Cr,
            Qr = new ui,
            $r = new Cr,
            ei = new Cr,
            ti = new Cr,
            ni = new Cr,
            ri = new Cr,
            ii = new Cr,
            ai = new Cr,
            oi = new Cr,
            si = new Cr,
            li = new Cr;

        function ui(e, t) {
            this.min = void 0 !== e ? e : new Cr(Infinity, Infinity, Infinity), this.max = void 0 !== t ? t : new Cr(-Infinity, -Infinity, -Infinity)
        }

        function hi(e, t, n, r, i) {
            var a, o;
            for (a = 0, o = e.length - 3; a <= o; a += 3) {
                li.fromArray(e, a);
                var s = i.x * Math.abs(li.x) + i.y * Math.abs(li.y) + i.z * Math.abs(li.z),
                    l = t.dot(li),
                    u = n.dot(li),
                    h = r.dot(li);
                if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > s) return !1
            }
            return !0
        }(0, We.default)(ui.prototype, {
            isBox3: !0,
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this
            },
            setFromArray: function (e) {
                for (var t = Infinity, n = Infinity, r = Infinity, i = -Infinity, a = -Infinity, o = -Infinity, s = 0, l = e.length; s < l; s += 3) {
                    var u = e[s],
                        h = e[s + 1],
                        c = e[s + 2];
                    u < t && (t = u), h < n && (n = h), c < r && (r = c), i < u && (i = u), a < h && (a = h), o < c && (o = c)
                }
                return this.min.set(t, n, r), this.max.set(i, a, o), this
            },
            setFromBufferAttribute: function (e) {
                for (var t = Infinity, n = Infinity, r = Infinity, i = -Infinity, a = -Infinity, o = -Infinity, s = 0, l = e.count; s < l; s++) {
                    var u = e.getX(s),
                        h = e.getY(s),
                        c = e.getZ(s);
                    u < t && (t = u), h < n && (n = h), c < r && (r = c), i < u && (i = u), a < h && (a = h), o < c && (o = c)
                }
                return this.min.set(t, n, r), this.max.set(i, a, o), this
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            },
            setFromCenterAndSize: function (e, t) {
                var n = Kr.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            },
            setFromObject: function (e) {
                return this.makeEmpty(), this.expandByObject(e)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Cr), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Cr), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            },
            expandByObject: function (e) {
                e.updateWorldMatrix(!1, !1);
                var t = e.geometry;
                void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Qr.copy(t.boundingBox), Qr.applyMatrix4(e.matrixWorld), this.union(Qr));
                for (var n = e.children, r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
                return this
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            },
            getParameter: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Cr), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            },
            intersectsSphere: function (e) {
                return this.clampPoint(e.center, Kr), Kr.distanceToSquared(e.center) <= e.radius * e.radius
            },
            intersectsPlane: function (e) {
                var t, n;
                return n = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            },
            intersectsTriangle: function (e) {
                if (this.isEmpty()) return !1;
                this.getCenter(ai), oi.subVectors(this.max, ai), $r.subVectors(e.a, ai), ei.subVectors(e.b, ai), ti.subVectors(e.c, ai), ni.subVectors(ei, $r), ri.subVectors(ti, ei), ii.subVectors($r, ti);
                var t = [0, -ni.z, ni.y, 0, -ri.z, ri.y, 0, -ii.z, ii.y, ni.z, 0, -ni.x, ri.z, 0, -ri.x, ii.z, 0, -ii.x, -ni.y, ni.x, 0, -ri.y, ri.x, 0, -ii.y, ii.x, 0];
                return !!hi(t, $r, ei, ti, oi) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!hi(t, $r, ei, ti, oi) && (si.crossVectors(ni, ri), t = [si.x, si.y, si.z], hi(t, $r, ei, ti, oi)))
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Cr), t.copy(e).clamp(this.min, this.max)
            },
            distanceToPoint: function (e) {
                var t = Kr.copy(e).clamp(this.min, this.max);
                return t.sub(e).length()
            },
            getBoundingSphere: function (e) {
                return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(Kr).length(), e
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this
            },
            applyMatrix4: function (e) {
                return this.isEmpty() || (Jr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Jr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Jr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Jr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Jr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Jr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Jr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Jr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Jr)), this
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        });
        var ci = new ui;

        function di(e, t) {
            this.center = void 0 !== e ? e : new Cr, this.radius = void 0 !== t ? t : 0
        }(0, We.default)(di.prototype, {
            set: function (e, t) {
                return this.center.copy(e), this.radius = t, this
            },
            setFromPoints: function (e, t) {
                var n = this.center;
                void 0 !== t ? n.copy(t) : ci.setFromPoints(e).getCenter(n);
                for (var r = 0, i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                return this.radius = Math.sqrt(r), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            },
            empty: function () {
                return this.radius <= 0
            },
            containsPoint: function (e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function (e) {
                return e.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function (e) {
                var t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            },
            intersectsBox: function (e) {
                return e.intersectsSphere(this)
            },
            intersectsPlane: function (e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function (e, t) {
                var n = this.center.distanceToSquared(e);
                return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Cr), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            },
            getBoundingBox: function (e) {
                return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new ui), e.set(this.center, this.center), e.expandByScalar(this.radius), e
            },
            applyMatrix4: function (e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            },
            translate: function (e) {
                return this.center.add(e), this
            },
            equals: function (e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
        });
        var fi = new Cr,
            pi = new Cr,
            gi = new Cr,
            mi = new Cr,
            vi = new Cr,
            yi = new Cr,
            _i = new Cr;

        function Ai(e, t) {
            this.origin = void 0 !== e ? e : new Cr, this.direction = void 0 !== t ? t : new Cr(0, 0, -1)
        }(0, We.default)(Ai.prototype, {
            set: function (e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Cr), t.copy(this.direction).multiplyScalar(e).add(this.origin)
            },
            lookAt: function (e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            },
            recast: function (e) {
                return this.origin.copy(this.at(e, fi)), this
            },
            closestPointToPoint: function (e, t) {
                void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Cr), t.subVectors(e, this.origin);
                var n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function (e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            },
            distanceSqToPoint: function (e) {
                var t = fi.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (fi.copy(this.direction).multiplyScalar(t).add(this.origin), fi.distanceToSquared(e))
            },
            distanceSqToSegment: function (e, t, n, r) {
                pi.copy(e).add(t).multiplyScalar(.5), gi.copy(t).sub(e).normalize(), mi.copy(this.origin).sub(pi);
                var i, a, o, s, l = .5 * e.distanceTo(t),
                    u = -this.direction.dot(gi),
                    h = mi.dot(this.direction),
                    c = -mi.dot(gi),
                    d = mi.lengthSq(),
                    f = Math.abs(1 - u * u);
                if (0 < f)
                    if (i = u * c - h, a = u * h - c, s = l * f, 0 <= i)
                        if (-s <= a)
                            if (a <= s) {
                                var p = 1 / f;
                                i *= p, a *= p, o = i * (i + u * a + 2 * h) + a * (u * i + a + 2 * c) + d
                            } else a = l, i = Math.max(0, -(u * a + h)), o = -i * i + a * (a + 2 * c) + d;
                else a = -l, i = Math.max(0, -(u * a + h)), o = -i * i + a * (a + 2 * c) + d;
                else o = a <= -s ? (i = Math.max(0, -(-u * l + h)), a = 0 < i ? -l : Math.min(Math.max(-l, -c), l), -i * i + a * (a + 2 * c) + d) : a <= s ? (i = 0, a = Math.min(Math.max(-l, -c), l), a * (a + 2 * c) + d) : (i = Math.max(0, -(u * l + h)), a = 0 < i ? l : Math.min(Math.max(-l, -c), l), -i * i + a * (a + 2 * c) + d);
                else a = 0 < u ? -l : l, i = Math.max(0, -(u * a + h)), o = -i * i + a * (a + 2 * c) + d;
                return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(gi).multiplyScalar(a).add(pi), o
            },
            intersectSphere: function (e, t) {
                fi.subVectors(e.center, this.origin);
                var n = fi.dot(this.direction),
                    r = fi.dot(fi) - n * n,
                    i = e.radius * e.radius;
                if (i < r) return null;
                var a = Math.sqrt(i - r),
                    o = n - a,
                    s = n + a;
                return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
            },
            intersectsSphere: function (e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            },
            distanceToPlane: function (e) {
                var t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(e.normal) + e.constant) / t;
                return 0 <= n ? n : null
            },
            intersectPlane: function (e, t) {
                var n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            },
            intersectsPlane: function (e) {
                var t = e.distanceToPoint(this.origin);
                if (0 === t) return !0;
                var n = e.normal.dot(this.direction);
                return n * t < 0
            },
            intersectBox: function (e, t) {
                var n, r, i, a, o, s, l = 1 / this.direction.x,
                    u = 1 / this.direction.y,
                    h = 1 / this.direction.z,
                    c = this.origin;
                return r = 0 <= l ? (n = (e.min.x - c.x) * l, (e.max.x - c.x) * l) : (n = (e.max.x - c.x) * l, (e.min.x - c.x) * l), a = 0 <= u ? (i = (e.min.y - c.y) * u, (e.max.y - c.y) * u) : (i = (e.max.y - c.y) * u, (e.min.y - c.y) * u), a < n || r < i ? null : ((n < i || n != n) && (n = i), (a < r || r != r) && (r = a), s = 0 <= h ? (o = (e.min.z - c.z) * h, (e.max.z - c.z) * h) : (o = (e.max.z - c.z) * h, (e.min.z - c.z) * h), s < n || r < o ? null : ((n < o || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(0 <= n ? n : r, t)))
            },
            intersectsBox: function (e) {
                return null !== this.intersectBox(e, fi)
            },
            intersectTriangle: function (e, t, n, r, i) {
                vi.subVectors(t, e), yi.subVectors(n, e), _i.crossVectors(vi, yi);
                var a, o = this.direction.dot(_i);
                if (0 < o) {
                    if (r) return null;
                    a = 1
                } else {
                    if (!(o < 0)) return null;
                    a = -1, o = -o
                }
                mi.subVectors(this.origin, e);
                var s = a * this.direction.dot(yi.crossVectors(mi, yi));
                if (s < 0) return null;
                var l = a * this.direction.dot(vi.cross(mi));
                if (l < 0) return null;
                if (o < s + l) return null;
                var u = -a * mi.dot(_i);
                return u < 0 ? null : this.at(u / o, i)
            },
            applyMatrix4: function (e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            },
            equals: function (e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
        });
        var xi = new Cr,
            Ci = new Cr,
            Ii = new dr;

        function wi(e, t) {
            this.normal = void 0 !== e ? e : new Cr(1, 0, 0), this.constant = void 0 !== t ? t : 0
        }(0, We.default)(wi.prototype, {
            isPlane: !0,
            set: function (e, t) {
                return this.normal.copy(e), this.constant = t, this
            },
            setComponents: function (e, t, n, r) {
                return this.normal.set(e, t, n), this.constant = r, this
            },
            setFromNormalAndCoplanarPoint: function (e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            },
            setFromCoplanarPoints: function (e, t, n) {
                var r = xi.subVectors(n, t).cross(Ci.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(r, e), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            },
            normalize: function () {
                var e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            },
            negate: function () {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function (e) {
                return this.normal.dot(e) + this.constant
            },
            distanceToSphere: function (e) {
                return this.distanceToPoint(e.center) - e.radius
            },
            projectPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Cr), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
            },
            intersectLine: function (e, t) {
                void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Cr);
                var n = e.delta(xi),
                    r = this.normal.dot(n);
                if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
                var i = -(e.start.dot(this.normal) + this.constant) / r;
                return i < 0 || 1 < i ? void 0 : t.copy(n).multiplyScalar(i).add(e.start)
            },
            intersectsLine: function (e) {
                var t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && 0 < n || n < 0 && 0 < t
            },
            intersectsBox: function (e) {
                return e.intersectsPlane(this)
            },
            intersectsSphere: function (e) {
                return e.intersectsPlane(this)
            },
            coplanarPoint: function (e) {
                return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Cr), e.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function (e, t) {
                var n = t || Ii.getNormalMatrix(e),
                    r = this.coplanarPoint(xi).applyMatrix4(e),
                    i = this.normal.applyMatrix3(n).normalize();
                return this.constant = -r.dot(i), this
            },
            translate: function (e) {
                return this.constant -= e.dot(this.normal), this
            },
            equals: function (e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
        });
        var Mi = new Cr,
            bi = new Cr,
            Si = new Cr,
            Ei = new Cr,
            Ti = new Cr,
            Li = new Cr,
            Ni = new Cr,
            Ri = new Cr,
            ki = new Cr,
            Pi = new Cr;

        function Di(e, t, n) {
            this.a = void 0 !== e ? e : new Cr, this.b = void 0 !== t ? t : new Cr, this.c = void 0 !== n ? n : new Cr
        }(0, We.default)(Di, {
            getNormal: function (e, t, n, r) {
                void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Cr), r.subVectors(n, t), Mi.subVectors(e, t), r.cross(Mi);
                var i = r.lengthSq();
                return 0 < i ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
            },
            getBarycoord: function (e, t, n, r, i) {
                Mi.subVectors(r, t), bi.subVectors(n, t), Si.subVectors(e, t);
                var a = Mi.dot(Mi),
                    o = Mi.dot(bi),
                    s = Mi.dot(Si),
                    l = bi.dot(bi),
                    u = bi.dot(Si),
                    h = a * l - o * o;
                if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new Cr), 0 === h) return i.set(-2, -1, -1);
                var c = 1 / h,
                    d = (l * s - o * u) * c,
                    f = (a * u - o * s) * c;
                return i.set(1 - d - f, f, d)
            },
            containsPoint: function (e, t, n, r) {
                return Di.getBarycoord(e, t, n, r, Ei), 0 <= Ei.x && 0 <= Ei.y && Ei.x + Ei.y <= 1
            },
            getUV: function (e, t, n, r, i, a, o, s) {
                return this.getBarycoord(e, t, n, r, Ei), s.set(0, 0), s.addScaledVector(i, Ei.x), s.addScaledVector(a, Ei.y), s.addScaledVector(o, Ei.z), s
            },
            isFrontFacing: function (e, t, n, r) {
                return Mi.subVectors(n, t), bi.subVectors(e, t), Mi.cross(bi).dot(r) < 0
            }
        }), (0, We.default)(Di.prototype, {
            set: function (e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            },
            setFromPointsAndIndices: function (e, t, n, r) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            },
            getArea: function () {
                return Mi.subVectors(this.c, this.b), bi.subVectors(this.a, this.b), .5 * Mi.cross(bi).length()
            },
            getMidpoint: function (e) {
                return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Cr), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function (e) {
                return Di.getNormal(this.a, this.b, this.c, e)
            },
            getPlane: function (e) {
                return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new wi), e.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function (e, t) {
                return Di.getBarycoord(e, this.a, this.b, this.c, t)
            },
            getUV: function (e, t, n, r, i) {
                return Di.getUV(e, this.a, this.b, this.c, t, n, r, i)
            },
            containsPoint: function (e) {
                return Di.containsPoint(e, this.a, this.b, this.c)
            },
            isFrontFacing: function (e) {
                return Di.isFrontFacing(this.a, this.b, this.c, e)
            },
            intersectsBox: function (e) {
                return e.intersectsTriangle(this)
            },
            closestPointToPoint: function (e, t) {
                void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Cr);
                var n, r, i = this.a,
                    a = this.b,
                    o = this.c;
                Ti.subVectors(a, i), Li.subVectors(o, i), Ri.subVectors(e, i);
                var s = Ti.dot(Ri),
                    l = Li.dot(Ri);
                if (s <= 0 && l <= 0) return t.copy(i);
                ki.subVectors(e, a);
                var u = Ti.dot(ki),
                    h = Li.dot(ki);
                if (0 <= u && h <= u) return t.copy(a);
                var c = s * h - u * l;
                if (c <= 0 && 0 <= s && u <= 0) return n = s / (s - u), t.copy(i).addScaledVector(Ti, n);
                Pi.subVectors(e, o);
                var d = Ti.dot(Pi),
                    f = Li.dot(Pi);
                if (0 <= f && d <= f) return t.copy(o);
                var p = d * l - s * f;
                if (p <= 0 && 0 <= l && f <= 0) return r = l / (l - f), t.copy(i).addScaledVector(Li, r);
                var g = u * f - d * h;
                if (g <= 0 && 0 <= h - u && 0 <= d - f) return Ni.subVectors(o, a), r = (h - u) / (h - u + (d - f)), t.copy(a).addScaledVector(Ni, r);
                var m = 1 / (g + p + c);
                return n = p * m, r = c * m, t.copy(i).addScaledVector(Ti, n).addScaledVector(Li, r)
            },
            equals: function (e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        });
        var Oi = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Fi = {
                h: 0,
                s: 0,
                l: 0
            },
            Bi = {
                h: 0,
                s: 0,
                l: 0
            };

        function Gi(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }

        function Ui(e, t, n) {
            return n < 0 && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }

        function zi(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }

        function Vi(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }

        function Hi(e, t, n, r, i, a) {
            this.a = e, this.b = t, this.c = n, this.normal = r && r.isVector3 ? r : new Cr, this.vertexNormals = (0, He.default)(r) ? r : [], this.color = i && i.isColor ? i : new Gi, this.vertexColors = (0, He.default)(i) ? i : [], this.materialIndex = void 0 !== a ? a : 0
        }(0, We.default)(Gi.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function (e) {
                return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
            },
            setScalar: function (e) {
                return this.r = e, this.g = e, this.b = e, this
            },
            setHex: function (e) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
            },
            setRGB: function (e, t, n) {
                return this.r = e, this.g = t, this.b = n, this
            },
            setHSL: function (e, t, n) {
                if (e = hr.euclideanModulo(e, 1), t = hr.clamp(t, 0, 1), n = hr.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                else {
                    var r = n <= .5 ? n * (1 + t) : n + t - n * t,
                        i = 2 * n - r;
                    this.r = Ui(i, r, e + 1 / 3), this.g = Ui(i, r, e), this.b = Ui(i, r, e - 1 / 3)
                }
                return this
            },
            setStyle: function (t) {
                function e(e) {
                    void 0 !== e && (0, ge.default)(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var n;
                if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var r, i = n[1],
                        a = n[2];
                    switch (i) {
                        case "rgb":
                        case "rgba":
                            if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, (0, m.default)(r[1], 10)) / 255, this.g = Math.min(255, (0, m.default)(r[2], 10)) / 255, this.b = Math.min(255, (0, m.default)(r[3], 10)) / 255, e(r[5]), this;
                            if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, (0, m.default)(r[1], 10)) / 100, this.g = Math.min(100, (0, m.default)(r[2], 10)) / 100, this.b = Math.min(100, (0, m.default)(r[3], 10)) / 100, e(r[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                var o = (0, ge.default)(r[1]) / 360,
                                    s = (0, m.default)(r[2], 10) / 100,
                                    l = (0, m.default)(r[3], 10) / 100;
                                return e(r[5]), this.setHSL(o, s, l)
                            }
                    }
                } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var u = n[1],
                        h = u.length;
                    if (3 === h) return this.r = (0, m.default)(u.charAt(0) + u.charAt(0), 16) / 255, this.g = (0, m.default)(u.charAt(1) + u.charAt(1), 16) / 255, this.b = (0, m.default)(u.charAt(2) + u.charAt(2), 16) / 255, this;
                    if (6 === h) return this.r = (0, m.default)(u.charAt(0) + u.charAt(1), 16) / 255, this.g = (0, m.default)(u.charAt(2) + u.charAt(3), 16) / 255, this.b = (0, m.default)(u.charAt(4) + u.charAt(5), 16) / 255, this
                }
                return t && 0 < t.length ? this.setColorName(t) : this
            },
            setColorName: function (e) {
                var t = Oi[e];
                return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
            },
            clone: function () {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function (e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            },
            copyGammaToLinear: function (e, t) {
                return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
            },
            copyLinearToGamma: function (e, t) {
                void 0 === t && (t = 2);
                var n = 0 < t ? 1 / t : 1;
                return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
            },
            convertGammaToLinear: function (e) {
                return this.copyGammaToLinear(this, e), this
            },
            convertLinearToGamma: function (e) {
                return this.copyLinearToGamma(this, e), this
            },
            copySRGBToLinear: function (e) {
                return this.r = zi(e.r), this.g = zi(e.g), this.b = zi(e.b), this
            },
            copyLinearToSRGB: function (e) {
                return this.r = Vi(e.r), this.g = Vi(e.g), this.b = Vi(e.b), this
            },
            convertSRGBToLinear: function () {
                return this.copySRGBToLinear(this), this
            },
            convertLinearToSRGB: function () {
                return this.copyLinearToSRGB(this), this
            },
            getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function (e) {
                void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var t, n, r = this.r,
                    i = this.g,
                    a = this.b,
                    o = Math.max(r, i, a),
                    s = Math.min(r, i, a),
                    l = (s + o) / 2;
                if (s === o) t = 0, n = 0;
                else {
                    var u = o - s;
                    switch (n = l <= .5 ? u / (o + s) : u / (2 - o - s), o) {
                        case r:
                            t = (i - a) / u + (i < a ? 6 : 0);
                            break;
                        case i:
                            t = (a - r) / u + 2;
                            break;
                        case a:
                            t = (r - i) / u + 4
                    }
                    t /= 6
                }
                return e.h = t, e.s = n, e.l = l, e
            },
            getStyle: function () {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function (e, t, n) {
                return this.getHSL(Fi), Fi.h += e, Fi.s += t, Fi.l += n, this.setHSL(Fi.h, Fi.s, Fi.l), this
            },
            add: function (e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            },
            addColors: function (e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            },
            addScalar: function (e) {
                return this.r += e, this.g += e, this.b += e, this
            },
            sub: function (e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            },
            multiply: function (e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            },
            multiplyScalar: function (e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            },
            lerp: function (e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            },
            lerpHSL: function (e, t) {
                this.getHSL(Fi), e.getHSL(Bi);
                var n = hr.lerp(Fi.h, Bi.h, t),
                    r = hr.lerp(Fi.s, Bi.s, t),
                    i = hr.lerp(Fi.l, Bi.l, t);
                return this.setHSL(n, r, i), this
            },
            equals: function (e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            },
            fromArray: function (e, t) {
                return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            },
            toArray: function (e, t) {
                return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            },
            toJSON: function () {
                return this.getHex()
            }
        }), Gi.NAMES = Oi, (0, We.default)(Hi.prototype, {
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                return this
            }
        });
        var Wi = 0;

        function ji() {
            (0, y.default)(this, "id", {
                value: Wi++
            }), this.uuid = hr.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = xe, this.side = k, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = De, this.blendDst = Oe, this.blendEquation = be, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Xe, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Jn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = On, this.stencilZFail = On, this.stencilZPass = On, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
        }

        function Yi(e) {
            ji.call(this), this.type = "MeshBasicMaterial", this.color = new Gi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = D, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e)
        }
        ji.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: ji,
            isMaterial: !0,
            onBeforeCompile: function () {},
            setValues: function (e) {
                if (void 0 !== e)
                    for (var t in e) {
                        var n = e[t];
                        if (void 0 !== n)
                            if ("shading" !== t) {
                                var r = this[t];
                                void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                            } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === L
                    }
            },
            toJSON: function (e) {
                var t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function r(e) {
                    var t = [];
                    for (var n in e) {
                        var r = e[n];
                        delete r.metadata, t.push(r)
                    }
                    return t
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== xe && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== k && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== (0, v.default)(this.userData) && (n.userData = this.userData), t) {
                    var i = r(e.textures),
                        a = r(e.images);
                    0 < i.length && (n.textures = i), 0 < a.length && (n.images = a)
                }
                return n
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                var t = e.clippingPlanes,
                    n = null;
                if (null !== t) {
                    var r = t.length;
                    n = new Array(r);
                    for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse((0, v.default)(e.userData)), this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), (0, y.default)(ji.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), Yi.prototype = (0, s.default)(ji.prototype), Yi.prototype.constructor = Yi, Yi.prototype.isMeshBasicMaterial = !0, Yi.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
        };
        var qi = new Cr;

        function Xi(e, t, n) {
            if ((0, He.default)(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = Kn, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Zi(e, t, n) {
            Xi.call(this, new Int8Array(e), t, n)
        }

        function Ji(e, t, n) {
            Xi.call(this, new Uint8Array(e), t, n)
        }

        function Ki(e, t, n) {
            Xi.call(this, new Uint8ClampedArray(e), t, n)
        }

        function Qi(e, t, n) {
            Xi.call(this, new Int16Array(e), t, n)
        }

        function $i(e, t, n) {
            Xi.call(this, new Uint16Array(e), t, n)
        }

        function ea(e, t, n) {
            Xi.call(this, new Int32Array(e), t, n)
        }

        function ta(e, t, n) {
            Xi.call(this, new Uint32Array(e), t, n)
        }

        function na(e, t, n) {
            Xi.call(this, new Float32Array(e), t, n)
        }

        function ra(e, t, n) {
            Xi.call(this, new Float64Array(e), t, n)
        }

        function ia() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function aa(e) {
            if (0 === e.length) return -Infinity;
            for (var t = e[0], n = 1, r = e.length; n < r; ++n) e[n] > t && (t = e[n]);
            return t
        }(0, y.default)(Xi.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), (0, We.default)(Xi.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function () {},
            setUsage: function (e) {
                return this.usage = e, this
            },
            copy: function (e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
            },
            copyAt: function (e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                return this
            },
            copyArray: function (e) {
                return this.array.set(e), this
            },
            copyColorsArray: function (e) {
                for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                    var a = e[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), a = new Gi), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
                }
                return this
            },
            copyVector2sArray: function (e) {
                for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                    var a = e[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new cr), t[n++] = a.x, t[n++] = a.y
                }
                return this
            },
            copyVector3sArray: function (e) {
                for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                    var a = e[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new Cr), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z
                }
                return this
            },
            copyVector4sArray: function (e) {
                for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) {
                    var a = e[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new mr), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
                }
                return this
            },
            applyMatrix3: function (e) {
                for (var t = 0, n = this.count; t < n; t++) qi.x = this.getX(t), qi.y = this.getY(t), qi.z = this.getZ(t), qi.applyMatrix3(e), this.setXYZ(t, qi.x, qi.y, qi.z);
                return this
            },
            applyMatrix4: function (e) {
                for (var t = 0, n = this.count; t < n; t++) qi.x = this.getX(t), qi.y = this.getY(t), qi.z = this.getZ(t), qi.applyMatrix4(e), this.setXYZ(t, qi.x, qi.y, qi.z);
                return this
            },
            applyNormalMatrix: function (e) {
                for (var t = 0, n = this.count; t < n; t++) qi.x = this.getX(t), qi.y = this.getY(t), qi.z = this.getZ(t), qi.applyNormalMatrix(e), this.setXYZ(t, qi.x, qi.y, qi.z);
                return this
            },
            transformDirection: function (e) {
                for (var t = 0, n = this.count; t < n; t++) qi.x = this.getX(t), qi.y = this.getY(t), qi.z = this.getZ(t), qi.transformDirection(e), this.setXYZ(t, qi.x, qi.y, qi.z);
                return this
            },
            set: function (e, t) {
                return void 0 === t && (t = 0), this.array.set(e, t), this
            },
            getX: function (e) {
                return this.array[e * this.itemSize]
            },
            setX: function (e, t) {
                return this.array[e * this.itemSize] = t, this
            },
            getY: function (e) {
                return this.array[e * this.itemSize + 1]
            },
            setY: function (e, t) {
                return this.array[e * this.itemSize + 1] = t, this
            },
            getZ: function (e) {
                return this.array[e * this.itemSize + 2]
            },
            setZ: function (e, t) {
                return this.array[e * this.itemSize + 2] = t, this
            },
            getW: function (e) {
                return this.array[e * this.itemSize + 3]
            },
            setW: function (e, t) {
                return this.array[e * this.itemSize + 3] = t, this
            },
            setXY: function (e, t, n) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
            },
            setXYZ: function (e, t, n, r) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
            },
            setXYZW: function (e, t, n, r, i) {
                return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
            },
            onUpload: function (e) {
                return this.onUploadCallback = e, this
            },
            clone: function () {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function () {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), Zi.prototype = (0, s.default)(Xi.prototype), Zi.prototype.constructor = Zi, Ji.prototype = (0, s.default)(Xi.prototype), Ji.prototype.constructor = Ji, Ki.prototype = (0, s.default)(Xi.prototype), Ki.prototype.constructor = Ki, Qi.prototype = (0, s.default)(Xi.prototype), Qi.prototype.constructor = Qi, $i.prototype = (0, s.default)(Xi.prototype), $i.prototype.constructor = $i, ea.prototype = (0, s.default)(Xi.prototype), ea.prototype.constructor = ea, ta.prototype = (0, s.default)(Xi.prototype), ta.prototype.constructor = ta, na.prototype = (0, s.default)(Xi.prototype), na.prototype.constructor = na, ra.prototype = (0, s.default)(Xi.prototype), ra.prototype.constructor = ra, (0, We.default)(ia.prototype, {
            computeGroups: function (e) {
                for (var t, n = [], r = void 0, i = e.faces, a = 0; a < i.length; a++) {
                    var o = i[a];
                    o.materialIndex !== r && (r = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), t = {
                        start: 3 * a,
                        materialIndex: r
                    })
                }
                void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), this.groups = n
            },
            fromGeometry: function (e) {
                var t, n = e.faces,
                    r = e.vertices,
                    i = e.faceVertexUvs,
                    a = i[0] && 0 < i[0].length,
                    o = i[1] && 0 < i[1].length,
                    s = e.morphTargets,
                    l = s.length;
                if (0 < l) {
                    t = [];
                    for (var u = 0; u < l; u++) t[u] = {
                        name: s[u].name,
                        data: []
                    };
                    this.morphTargets.position = t
                }
                var h, c = e.morphNormals,
                    d = c.length;
                if (0 < d) {
                    for (h = [], u = 0; u < d; u++) h[u] = {
                        name: c[u].name,
                        data: []
                    };
                    this.morphTargets.normal = h
                }
                var f = e.skinIndices,
                    p = e.skinWeights,
                    g = f.length === r.length,
                    m = p.length === r.length;
                for (0 < r.length && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), u = 0; u < n.length; u++) {
                    var v = n[u];
                    this.vertices.push(r[v.a], r[v.b], r[v.c]);
                    var y = v.vertexNormals;
                    if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                    else {
                        var _ = v.normal;
                        this.normals.push(_, _, _)
                    }
                    var A = v.vertexColors;
                    if (3 === A.length) this.colors.push(A[0], A[1], A[2]);
                    else {
                        var x = v.color;
                        this.colors.push(x, x, x)
                    }
                    if (!0 === a) {
                        var C = i[0][u];
                        void 0 !== C ? this.uvs.push(C[0], C[1], C[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new cr, new cr, new cr))
                    }!0 === o && (C = i[1][u], void 0 !== C ? this.uvs2.push(C[0], C[1], C[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new cr, new cr, new cr)));
                    for (var I = 0; I < l; I++) {
                        var w = s[I].vertices;
                        t[I].data.push(w[v.a], w[v.b], w[v.c])
                    }
                    for (I = 0; I < d; I++) {
                        var M = c[I].vertexNormals[u];
                        h[I].data.push(M.a, M.b, M.c)
                    }
                    g && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), m && this.skinWeights.push(p[v.a], p[v.b], p[v.c])
                }
                return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
            }
        });
        var oa = 1,
            sa = new Lr,
            la = new Xr,
            ua = new Cr,
            ha = new ui,
            ca = new ui,
            da = new Cr;

        function fa() {
            (0, y.default)(this, "id", {
                value: oa += 2
            }), this.uuid = hr.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: Infinity
            }, this.userData = {}
        }
        fa.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: fa,
            isBufferGeometry: !0,
            getIndex: function () {
                return this.index
            },
            setIndex: function (e) {
                (0, He.default)(e) ? this.index = new(65535 < aa(e) ? ta : $i)(e, 1): this.index = e
            },
            getAttribute: function (e) {
                return this.attributes[e]
            },
            setAttribute: function (e, t) {
                return this.attributes[e] = t, this
            },
            deleteAttribute: function (e) {
                return delete this.attributes[e], this
            },
            addGroup: function (e, t, n) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: void 0 !== n ? n : 0
                })
            },
            clearGroups: function () {
                this.groups = []
            },
            setDrawRange: function (e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            },
            applyMatrix4: function (e) {
                var t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                var n = this.attributes.normal;
                if (void 0 !== n) {
                    var r = (new dr).getNormalMatrix(e);
                    n.applyNormalMatrix(r), n.needsUpdate = !0
                }
                var i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function (e) {
                return sa.makeRotationX(e), this.applyMatrix4(sa), this
            },
            rotateY: function (e) {
                return sa.makeRotationY(e), this.applyMatrix4(sa), this
            },
            rotateZ: function (e) {
                return sa.makeRotationZ(e), this.applyMatrix4(sa), this
            },
            translate: function (e, t, n) {
                return sa.makeTranslation(e, t, n), this.applyMatrix4(sa), this
            },
            scale: function (e, t, n) {
                return sa.makeScale(e, t, n), this.applyMatrix4(sa), this
            },
            lookAt: function (e) {
                return la.lookAt(e), la.updateMatrix(), this.applyMatrix4(la.matrix), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(ua).negate(), this.translate(ua.x, ua.y, ua.z), this
            },
            setFromObject: function (e) {
                var t = e.geometry;
                if (e.isPoints || e.isLine) {
                    var n = new na(3 * t.vertices.length, 3),
                        r = new na(3 * t.colors.length, 3);
                    if (this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                        var i = new na(t.lineDistances.length, 1);
                        this.setAttribute("lineDistance", i.copyArray(t.lineDistances))
                    }
                    null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                return this
            },
            setFromPoints: function (e) {
                for (var t = [], n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    t.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new na(t, 3)), this
            },
            updateFromObject: function (e) {
                var t, n = e.geometry;
                if (e.isMesh) {
                    var r = n.__directGeometry;
                    if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                    r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
                }
                return !0 === n.verticesNeedUpdate && (t = this.attributes.position, void 0 !== t && (t.copyVector3sArray(n.vertices), t.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (t = this.attributes.normal, void 0 !== t && (t.copyVector3sArray(n.normals), t.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (t = this.attributes.color, void 0 !== t && (t.copyColorsArray(n.colors), t.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (t = this.attributes.uv, void 0 !== t && (t.copyVector2sArray(n.uvs), t.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (t = this.attributes.lineDistance, void 0 !== t && (t.copyArray(n.lineDistances), t.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(e.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
            },
            fromGeometry: function (e) {
                return e.__directGeometry = (new ia).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
            },
            fromDirectGeometry: function (e) {
                var t = new Float32Array(3 * e.vertices.length);
                if (this.setAttribute("position", new Xi(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) {
                    var n = new Float32Array(3 * e.normals.length);
                    this.setAttribute("normal", new Xi(n, 3).copyVector3sArray(e.normals))
                }
                if (0 < e.colors.length) {
                    var r = new Float32Array(3 * e.colors.length);
                    this.setAttribute("color", new Xi(r, 3).copyColorsArray(e.colors))
                }
                if (0 < e.uvs.length) {
                    var i = new Float32Array(2 * e.uvs.length);
                    this.setAttribute("uv", new Xi(i, 2).copyVector2sArray(e.uvs))
                }
                if (0 < e.uvs2.length) {
                    var a = new Float32Array(2 * e.uvs2.length);
                    this.setAttribute("uv2", new Xi(a, 2).copyVector2sArray(e.uvs2))
                }
                for (var o in this.groups = e.groups, e.morphTargets) {
                    for (var s = [], l = e.morphTargets[o], u = 0, h = l.length; u < h; u++) {
                        var c = l[u],
                            d = new na(3 * c.data.length, 3);
                        d.name = c.name, s.push(d.copyVector3sArray(c.data))
                    }
                    this.morphAttributes[o] = s
                }
                if (0 < e.skinIndices.length) {
                    var f = new na(4 * e.skinIndices.length, 4);
                    this.setAttribute("skinIndex", f.copyVector4sArray(e.skinIndices))
                }
                if (0 < e.skinWeights.length) {
                    var p = new na(4 * e.skinWeights.length, 4);
                    this.setAttribute("skinWeight", p.copyVector4sArray(e.skinWeights))
                }
                return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new ui);
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (var n = 0, r = t.length; n < r; n++) {
                            var i = t[n];
                            ha.setFromBufferAttribute(i), this.morphTargetsRelative ? (da.addVectors(this.boundingBox.min, ha.min), this.boundingBox.expandByPoint(da), da.addVectors(this.boundingBox.max, ha.max), this.boundingBox.expandByPoint(da)) : (this.boundingBox.expandByPoint(ha.min), this.boundingBox.expandByPoint(ha.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new di);
                var e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e) {
                    var n = this.boundingSphere.center;
                    if (ha.setFromBufferAttribute(e), t)
                        for (var r = 0, i = t.length; r < i; r++) {
                            var a = t[r];
                            ca.setFromBufferAttribute(a), this.morphTargetsRelative ? (da.addVectors(ha.min, ca.min), ha.expandByPoint(da), da.addVectors(ha.max, ca.max), ha.expandByPoint(da)) : (ha.expandByPoint(ca.min), ha.expandByPoint(ca.max))
                        }
                    ha.getCenter(n);
                    var o = 0;
                    for (r = 0, i = e.count; r < i; r++) da.fromBufferAttribute(e, r), o = Math.max(o, n.distanceToSquared(da));
                    if (t)
                        for (r = 0, i = t.length; r < i; r++) {
                            a = t[r];
                            for (var s = this.morphTargetsRelative, l = 0, u = a.count; l < u; l++) da.fromBufferAttribute(a, l), s && (ua.fromBufferAttribute(e, l), da.add(ua)), o = Math.max(o, n.distanceToSquared(da))
                        }
                    this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function () {},
            computeVertexNormals: function () {
                var e = this.index,
                    t = this.attributes;
                if (t.position) {
                    var n = t.position.array;
                    if (void 0 === t.normal) this.setAttribute("normal", new Xi(new Float32Array(n.length), 3));
                    else
                        for (var r = t.normal.array, i = 0, a = r.length; i < a; i++) r[i] = 0;
                    var o, s, l, u = t.normal.array,
                        h = new Cr,
                        c = new Cr,
                        d = new Cr,
                        f = new Cr,
                        p = new Cr;
                    if (e) {
                        var g = e.array;
                        for (i = 0, a = e.count; i < a; i += 3) o = 3 * g[i + 0], s = 3 * g[i + 1], l = 3 * g[i + 2], h.fromArray(n, o), c.fromArray(n, s), d.fromArray(n, l), f.subVectors(d, c), p.subVectors(h, c), f.cross(p), u[o] += f.x, u[o + 1] += f.y, u[o + 2] += f.z, u[s] += f.x, u[s + 1] += f.y, u[s + 2] += f.z, u[l] += f.x, u[l + 1] += f.y, u[l + 2] += f.z
                    } else
                        for (i = 0, a = n.length; i < a; i += 9) h.fromArray(n, i), c.fromArray(n, i + 3), d.fromArray(n, i + 6), f.subVectors(d, c), p.subVectors(h, c), f.cross(p), u[i] = f.x, u[i + 1] = f.y, u[i + 2] = f.z, u[i + 3] = f.x, u[i + 4] = f.y, u[i + 5] = f.z, u[i + 6] = f.x, u[i + 7] = f.y, u[i + 8] = f.z;
                    this.normalizeNormals(), t.normal.needsUpdate = !0
                }
            },
            merge: function (e, t) {
                if (e && e.isBufferGeometry) {
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var r in n)
                        if (void 0 !== e.attributes[r])
                            for (var i = n[r], a = i.array, o = e.attributes[r], s = o.array, l = o.itemSize * t, u = Math.min(s.length, a.length - l), h = 0, c = l; h < u; h++, c++) a[c] = s[h];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
            },
            normalizeNormals: function () {
                for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) da.x = e.getX(t), da.y = e.getY(t), da.z = e.getZ(t), da.normalize(), e.setXYZ(t, da.x, da.y, da.z)
            },
            toNonIndexed: function () {
                function e(e, t) {
                    for (var n = e.array, r = e.itemSize, i = new n.constructor(t.length * r), a = 0, o = 0, s = 0, l = t.length; s < l; s++) {
                        a = t[s] * r;
                        for (var u = 0; u < r; u++) i[o++] = n[a++]
                    }
                    return new Xi(i, r)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t = new fa,
                    n = this.index.array,
                    r = this.attributes;
                for (var i in r) {
                    var a = r[i],
                        o = e(a, n);
                    t.setAttribute(i, o)
                }
                var s = this.morphAttributes;
                for (i in s) {
                    for (var l = [], u = s[i], h = 0, c = u.length; h < c; h++) a = u[h], o = e(a, n), l.push(o);
                    t.morphAttributes[i] = l
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                for (var d = this.groups, f = (h = 0, d.length); h < f; h++) {
                    var p = d[h];
                    t.addGroup(p.start, p.count, p.materialIndex)
                }
                return t
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < (0, g.default)(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                var r = this.index;
                null !== r && (e.data.index = {
                    type: r.array.constructor.name,
                    array: Array.prototype.slice.call(r.array)
                });
                var i = this.attributes;
                for (var n in i) {
                    var a = i[n],
                        o = a.toJSON();
                    "" !== a.name && (o.name = a.name), e.data.attributes[n] = o
                }
                var s = {},
                    l = !1;
                for (var n in this.morphAttributes) {
                    for (var u = this.morphAttributes[n], h = [], c = 0, d = u.length; c < d; c++) a = u[c], o = a.toJSON(), "" !== a.name && (o.name = a.name), h.push(o);
                    0 < h.length && (s[n] = h, l = !0)
                }
                l && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
                var f = this.groups;
                0 < f.length && (e.data.groups = JSON.parse((0, v.default)(f)));
                var p = this.boundingSphere;
                return null !== p && (e.data.boundingSphere = {
                    center: p.center.toArray(),
                    radius: p.radius
                }), e
            },
            clone: function () {
                return (new fa).copy(this)
            },
            copy: function (e) {
                var t, n, r;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                var i = e.index;
                null !== i && this.setIndex(i.clone());
                var a = e.attributes;
                for (t in a) {
                    var o = a[t];
                    this.setAttribute(t, o.clone())
                }
                var s = e.morphAttributes;
                for (t in s) {
                    var l = [],
                        u = s[t];
                    for (n = 0, r = u.length; n < r; n++) l.push(u[n].clone());
                    this.morphAttributes[t] = l
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                var h = e.groups;
                for (n = 0, r = h.length; n < r; n++) {
                    var c = h[n];
                    this.addGroup(c.start, c.count, c.materialIndex)
                }
                var d = e.boundingBox;
                null !== d && (this.boundingBox = d.clone());
                var f = e.boundingSphere;
                return null !== f && (this.boundingSphere = f.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var pa = new Lr,
            ga = new Ai,
            ma = new di,
            va = new Cr,
            ya = new Cr,
            _a = new Cr,
            Aa = new Cr,
            xa = new Cr,
            Ca = new Cr,
            Ia = new Cr,
            wa = new Cr,
            Ma = new Cr,
            ba = new cr,
            Sa = new cr,
            Ea = new cr,
            Ta = new Cr,
            La = new Cr;

        function Na(e, t) {
            Xr.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new fa, this.material = void 0 !== t ? t : new Yi, this.updateMorphTargets()
        }

        function Ra(e, t, n, r, i, a, o, s) {
            var l;
            if (l = t.side === je ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== _e, s), null === l) return null;
            La.copy(s), La.applyMatrix4(e.matrixWorld);
            var u = n.ray.origin.distanceTo(La);
            return u < n.near || u > n.far ? null : {
                distance: u,
                point: La.clone(),
                object: e
            }
        }

        function ka(e, t, n, r, i, a, o, s, l, u, h, c) {
            va.fromBufferAttribute(i, u), ya.fromBufferAttribute(i, h), _a.fromBufferAttribute(i, c);
            var d = e.morphTargetInfluences;
            if (t.morphTargets && a && d) {
                Ia.set(0, 0, 0), wa.set(0, 0, 0), Ma.set(0, 0, 0);
                for (var f = 0, p = a.length; f < p; f++) {
                    var g = d[f],
                        m = a[f];
                    0 !== g && (Aa.fromBufferAttribute(m, u), xa.fromBufferAttribute(m, h), Ca.fromBufferAttribute(m, c), o ? (Ia.addScaledVector(Aa, g), wa.addScaledVector(xa, g), Ma.addScaledVector(Ca, g)) : (Ia.addScaledVector(Aa.sub(va), g), wa.addScaledVector(xa.sub(ya), g), Ma.addScaledVector(Ca.sub(_a), g)))
                }
                va.add(Ia), ya.add(wa), _a.add(Ma)
            }
            var v = Ra(e, t, n, r, va, ya, _a, Ta);
            if (v) {
                s && (ba.fromBufferAttribute(s, u), Sa.fromBufferAttribute(s, h), Ea.fromBufferAttribute(s, c), v.uv = Di.getUV(Ta, va, ya, _a, ba, Sa, Ea, new cr)), l && (ba.fromBufferAttribute(l, u), Sa.fromBufferAttribute(l, h), Ea.fromBufferAttribute(l, c), v.uv2 = Di.getUV(Ta, va, ya, _a, ba, Sa, Ea, new cr));
                var y = new Hi(u, h, c);
                Di.getNormal(va, ya, _a, y.normal), v.face = y
            }
            return v
        }
        Na.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: Na,
            isMesh: !0,
            copy: function (e) {
                return Xr.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = (0, We.default)({}, e.morphTargetDictionary)), this
            },
            updateMorphTargets: function () {
                var e, t, n, r = this.geometry;
                if (r.isBufferGeometry) {
                    var i = r.morphAttributes,
                        a = (0, g.default)(i);
                    if (0 < a.length) {
                        var o = i[a[0]];
                        if (void 0 !== o)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                } else {
                    var s = r.morphTargets;
                    void 0 !== s && 0 < s.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            raycast: function (e, t) {
                var n, r = this.geometry,
                    i = this.material,
                    a = this.matrixWorld;
                if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), ma.copy(r.boundingSphere), ma.applyMatrix4(a), !1 !== e.ray.intersectsSphere(ma) && (pa.getInverse(a), ga.copy(e.ray).applyMatrix4(pa), null === r.boundingBox || !1 !== ga.intersectsBox(r.boundingBox))))
                    if (r.isBufferGeometry) {
                        var o, s, l, u, h, c, d, f, p, g, m, v = r.index,
                            y = r.attributes.position,
                            _ = r.morphAttributes.position,
                            A = r.morphTargetsRelative,
                            x = r.attributes.uv,
                            C = r.attributes.uv2,
                            I = r.groups,
                            w = r.drawRange;
                        if (null !== v)
                            if ((0, He.default)(i))
                                for (u = 0, c = I.length; u < c; u++)
                                    for (f = I[u], p = i[f.materialIndex], g = Math.max(f.start, w.start), m = Math.min(f.start + f.count, w.start + w.count), h = g, d = m; h < d; h += 3) o = v.getX(h), s = v.getX(h + 1), l = v.getX(h + 2), n = ka(this, p, e, ga, y, _, A, x, C, o, s, l), n && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = f.materialIndex, t.push(n));
                            else
                                for (g = Math.max(0, w.start), m = Math.min(v.count, w.start + w.count), u = g, c = m; u < c; u += 3) o = v.getX(u), s = v.getX(u + 1), l = v.getX(u + 2), n = ka(this, i, e, ga, y, _, A, x, C, o, s, l), n && (n.faceIndex = Math.floor(u / 3), t.push(n));
                        else if (void 0 !== y)
                            if ((0, He.default)(i))
                                for (u = 0, c = I.length; u < c; u++)
                                    for (f = I[u], p = i[f.materialIndex], g = Math.max(f.start, w.start), m = Math.min(f.start + f.count, w.start + w.count), h = g, d = m; h < d; h += 3) o = h, s = h + 1, l = h + 2, n = ka(this, p, e, ga, y, _, A, x, C, o, s, l), n && (n.faceIndex = Math.floor(h / 3), n.face.materialIndex = f.materialIndex, t.push(n));
                            else
                                for (g = Math.max(0, w.start), m = Math.min(y.count, w.start + w.count), u = g, c = m; u < c; u += 3) o = u, s = u + 1, l = u + 2, n = ka(this, i, e, ga, y, _, A, x, C, o, s, l), n && (n.faceIndex = Math.floor(u / 3), t.push(n))
                    } else if (r.isGeometry) {
                    var M, b, S, E, T = (0, He.default)(i),
                        L = r.vertices,
                        N = r.faces,
                        R = r.faceVertexUvs[0];
                    0 < R.length && (E = R);
                    for (var k = 0, P = N.length; k < P; k++) {
                        var D = N[k],
                            O = T ? i[D.materialIndex] : i;
                        if (void 0 !== O && (M = L[D.a], b = L[D.b], S = L[D.c], n = Ra(this, O, e, ga, M, b, S, Ta), n)) {
                            if (E && E[k]) {
                                var F = E[k];
                                ba.copy(F[0]), Sa.copy(F[1]), Ea.copy(F[2]), n.uv = Di.getUV(Ta, M, b, S, ba, Sa, Ea, new cr)
                            }
                            n.face = D, n.faceIndex = k, t.push(n)
                        }
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var Pa = 0,
            Da = new Lr,
            Oa = new Xr,
            Fa = new Cr;

        function Ba() {
            (0, y.default)(this, "id", {
                value: Pa += 2
            }), this.uuid = hr.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }
        Ba.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: Ba,
            isGeometry: !0,
            applyMatrix4: function (e) {
                for (var t = (new dr).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) {
                    var i = this.vertices[n];
                    i.applyMatrix4(e)
                }
                for (n = 0, r = this.faces.length; n < r; n++) {
                    var a = this.faces[n];
                    a.normal.applyMatrix3(t).normalize();
                    for (var o = 0, s = a.vertexNormals.length; o < s; o++) a.vertexNormals[o].applyMatrix3(t).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            },
            rotateX: function (e) {
                return Da.makeRotationX(e), this.applyMatrix4(Da), this
            },
            rotateY: function (e) {
                return Da.makeRotationY(e), this.applyMatrix4(Da), this
            },
            rotateZ: function (e) {
                return Da.makeRotationZ(e), this.applyMatrix4(Da), this
            },
            translate: function (e, t, n) {
                return Da.makeTranslation(e, t, n), this.applyMatrix4(Da), this
            },
            scale: function (e, t, n) {
                return Da.makeScale(e, t, n), this.applyMatrix4(Da), this
            },
            lookAt: function (e) {
                return Oa.lookAt(e), Oa.updateMatrix(), this.applyMatrix4(Oa.matrix), this
            },
            fromBufferGeometry: function (e) {
                var s = this,
                    t = null !== e.index ? e.index.array : void 0,
                    n = e.attributes;
                if (void 0 === n.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                var r = n.position.array,
                    l = void 0 !== n.normal ? n.normal.array : void 0,
                    u = void 0 !== n.color ? n.color.array : void 0,
                    h = void 0 !== n.uv ? n.uv.array : void 0,
                    c = void 0 !== n.uv2 ? n.uv2.array : void 0;
                void 0 !== c && (this.faceVertexUvs[1] = []);
                for (var i = 0; i < r.length; i += 3) s.vertices.push((new Cr).fromArray(r, i)), void 0 !== u && s.colors.push((new Gi).fromArray(u, i));

                function a(e, t, n, r) {
                    var i = void 0 === u ? [] : [s.colors[e].clone(), s.colors[t].clone(), s.colors[n].clone()],
                        a = void 0 === l ? [] : [(new Cr).fromArray(l, 3 * e), (new Cr).fromArray(l, 3 * t), (new Cr).fromArray(l, 3 * n)],
                        o = new Hi(e, t, n, a, i, r);
                    s.faces.push(o), void 0 !== h && s.faceVertexUvs[0].push([(new cr).fromArray(h, 2 * e), (new cr).fromArray(h, 2 * t), (new cr).fromArray(h, 2 * n)]), void 0 !== c && s.faceVertexUvs[1].push([(new cr).fromArray(c, 2 * e), (new cr).fromArray(c, 2 * t), (new cr).fromArray(c, 2 * n)])
                }
                var o = e.groups;
                if (0 < o.length)
                    for (i = 0; i < o.length; i++)
                        for (var d = o[i], f = d.start, p = d.count, g = f, m = f + p; g < m; g += 3) void 0 !== t ? a(t[g], t[g + 1], t[g + 2], d.materialIndex) : a(g, g + 1, g + 2, d.materialIndex);
                else if (void 0 !== t)
                    for (i = 0; i < t.length; i += 3) a(t[i], t[i + 1], t[i + 2]);
                else
                    for (i = 0; i < r.length / 3; i += 3) a(i, i + 1, i + 2);
                return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            },
            center: function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Fa).negate(), this.translate(Fa.x, Fa.y, Fa.z), this
            },
            normalize: function () {
                this.computeBoundingSphere();
                var e = this.boundingSphere.center,
                    t = this.boundingSphere.radius,
                    n = 0 === t ? 1 : 1 / t,
                    r = new Lr;
                return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(r), this
            },
            computeFaceNormals: function () {
                for (var e = new Cr, t = new Cr, n = 0, r = this.faces.length; n < r; n++) {
                    var i = this.faces[n],
                        a = this.vertices[i.a],
                        o = this.vertices[i.b],
                        s = this.vertices[i.c];
                    e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), i.normal.copy(e)
                }
            },
            computeVertexNormals: function (e) {
                var t, n, r, i, a, o;
                for (void 0 === e && (e = !0), o = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) o[t] = new Cr;
                if (e) {
                    var s, l, u, h = new Cr,
                        c = new Cr;
                    for (r = 0, i = this.faces.length; r < i; r++) a = this.faces[r], s = this.vertices[a.a], l = this.vertices[a.b], u = this.vertices[a.c], h.subVectors(u, l), c.subVectors(s, l), h.cross(c), o[a.a].add(h), o[a.b].add(h), o[a.c].add(h)
                } else
                    for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a = this.faces[r], o[a.a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
                for (t = 0, n = this.vertices.length; t < n; t++) o[t].normalize();
                for (r = 0, i = this.faces.length; r < i; r++) {
                    a = this.faces[r];
                    var d = a.vertexNormals;
                    3 === d.length ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c])) : (d[0] = o[a.a].clone(), d[1] = o[a.b].clone(), d[2] = o[a.c].clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function () {
                var e, t, n;
                for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                    n = this.faces[e];
                    var r = n.vertexNormals;
                    3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function () {
                var e, t, n, r, i;
                for (n = 0, r = this.faces.length; n < r; n++)
                    for (i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
                var a = new Ba;
                for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                    if (!this.morphNormals[e]) {
                        this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                        var o = this.morphNormals[e].faceNormals,
                            s = this.morphNormals[e].vertexNormals;
                        for (n = 0, r = this.faces.length; n < r; n++) l = new Cr, u = {
                            a: new Cr,
                            b: new Cr,
                            c: new Cr
                        }, o.push(l), s.push(u)
                    }
                    var l, u, h = this.morphNormals[e];
                    for (a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], l = h.faceNormals[n], u = h.vertexNormals[n], l.copy(i.normal), u.a.copy(i.vertexNormals[0]), u.b.copy(i.vertexNormals[1]), u.c.copy(i.vertexNormals[2])
                }
                for (n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], i.normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
            },
            computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new ui), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new di), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function (e, t, n) {
                if (e && e.isGeometry) {
                    var r, i = this.vertices.length,
                        a = this.vertices,
                        o = e.vertices,
                        s = this.faces,
                        l = e.faces,
                        u = this.colors,
                        h = e.colors;
                    void 0 === n && (n = 0), void 0 !== t && (r = (new dr).getNormalMatrix(t));
                    for (var c = 0, d = o.length; c < d; c++) {
                        var f = o[c],
                            p = f.clone();
                        void 0 !== t && p.applyMatrix4(t), a.push(p)
                    }
                    for (c = 0, d = h.length; c < d; c++) u.push(h[c].clone());
                    for (c = 0, d = l.length; c < d; c++) {
                        var g, m, v, y = l[c],
                            _ = y.vertexNormals,
                            A = y.vertexColors;
                        g = new Hi(y.a + i, y.b + i, y.c + i), g.normal.copy(y.normal), void 0 !== r && g.normal.applyMatrix3(r).normalize();
                        for (var x = 0, C = _.length; x < C; x++) m = _[x].clone(), void 0 !== r && m.applyMatrix3(r).normalize(), g.vertexNormals.push(m);
                        for (g.color.copy(y.color), x = 0, C = A.length; x < C; x++) v = A[x], g.vertexColors.push(v.clone());
                        g.materialIndex = y.materialIndex + n, s.push(g)
                    }
                    for (c = 0, d = e.faceVertexUvs.length; c < d; c++) {
                        var I = e.faceVertexUvs[c];
                        for (void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []), x = 0, C = I.length; x < C; x++) {
                            for (var w = I[x], M = [], b = 0, S = w.length; b < S; b++) M.push(w[b].clone());
                            this.faceVertexUvs[c].push(M)
                        }
                    }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
            },
            mergeMesh: function (e) {
                e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
            },
            mergeVertices: function () {
                var e, t, n, r, i, a, o, s, l = {},
                    u = [],
                    h = [],
                    c = 4,
                    d = Math.pow(10, c);
                for (n = 0, r = this.vertices.length; n < r; n++) e = this.vertices[n], t = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d), void 0 === l[t] ? (l[t] = n, u.push(this.vertices[n]), h[n] = u.length - 1) : h[n] = h[l[t]];
                var f = [];
                for (n = 0, r = this.faces.length; n < r; n++) {
                    i = this.faces[n], i.a = h[i.a], i.b = h[i.b], i.c = h[i.c], a = [i.a, i.b, i.c];
                    for (var p = 0; p < 3; p++)
                        if (a[p] === a[(p + 1) % 3]) {
                            f.push(n);
                            break
                        }
                }
                for (n = f.length - 1; 0 <= n; n--) {
                    var g = f[n];
                    for (this.faces.splice(g, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(g, 1)
                }
                var m = this.vertices.length - u.length;
                return this.vertices = u, m
            },
            setFromPoints: function (e) {
                this.vertices = [];
                for (var t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    this.vertices.push(new Cr(r.x, r.y, r.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function () {
                for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;

                function r(e, t) {
                    return e.materialIndex - t.materialIndex
                }
                e.sort(r);
                var i, a, o = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1];
                for (o && o.length === t && (i = []), s && s.length === t && (a = []), n = 0; n < t; n++) {
                    var l = e[n]._id;
                    i && i.push(o[l]), a && a.push(s[l])
                }
                i && (this.faceVertexUvs[0] = i), a && (this.faceVertexUvs[1] = a)
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                    var t = this.parameters;
                    for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                for (var r = [], i = 0; i < this.vertices.length; i++) {
                    var a = this.vertices[i];
                    r.push(a.x, a.y, a.z)
                }
                var o = [],
                    s = [],
                    l = {},
                    u = [],
                    h = {},
                    c = [],
                    d = {};
                for (i = 0; i < this.faces.length; i++) {
                    var f = this.faces[i],
                        p = !0,
                        g = !1,
                        m = void 0 !== this.faceVertexUvs[0][i],
                        v = 0 < f.normal.length(),
                        y = 0 < f.vertexNormals.length,
                        _ = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                        A = 0 < f.vertexColors.length,
                        x = 0;
                    if (x = M(x, 0, 0), x = M(x, 1, p), x = M(x, 2, g), x = M(x, 3, m), x = M(x, 4, v), x = M(x, 5, y), x = M(x, 6, _), x = M(x, 7, A), o.push(x), o.push(f.a, f.b, f.c), o.push(f.materialIndex), m) {
                        var C = this.faceVertexUvs[0][i];
                        o.push(E(C[0]), E(C[1]), E(C[2]))
                    }
                    if (v && o.push(b(f.normal)), y) {
                        var I = f.vertexNormals;
                        o.push(b(I[0]), b(I[1]), b(I[2]))
                    }
                    if (_ && o.push(S(f.color)), A) {
                        var w = f.vertexColors;
                        o.push(S(w[0]), S(w[1]), S(w[2]))
                    }
                }

                function M(e, t, n) {
                    return n ? e | 1 << t : e & ~(1 << t)
                }

                function b(e) {
                    var t = e.x.toString() + e.y.toString() + e.z.toString();
                    return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
                }

                function S(e) {
                    var t = e.r.toString() + e.g.toString() + e.b.toString();
                    return void 0 !== h[t] || (h[t] = u.length, u.push(e.getHex())), h[t]
                }

                function E(e) {
                    var t = e.x.toString() + e.y.toString();
                    return void 0 !== d[t] || (d[t] = c.length / 2, c.push(e.x, e.y)), d[t]
                }
                return e.data = {}, e.data.vertices = r, e.data.normals = s, 0 < u.length && (e.data.colors = u), 0 < c.length && (e.data.uvs = [c]), e.data.faces = o, e
            },
            clone: function () {
                return (new Ba).copy(this)
            },
            copy: function (e) {
                var t, n, r, i, a, o;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                var s = e.vertices;
                for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                var l = e.colors;
                for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
                var u = e.faces;
                for (t = 0, n = u.length; t < n; t++) this.faces.push(u[t].clone());
                for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                    var h = e.faceVertexUvs[t];
                    for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), r = 0, i = h.length; r < i; r++) {
                        var c = h[r],
                            d = [];
                        for (a = 0, o = c.length; a < o; a++) {
                            var f = c[a];
                            d.push(f.clone())
                        }
                        this.faceVertexUvs[t].push(d)
                    }
                }
                var p = e.morphTargets;
                for (t = 0, n = p.length; t < n; t++) {
                    var g = {};
                    if (g.name = p[t].name, void 0 !== p[t].vertices)
                        for (g.vertices = [], r = 0, i = p[t].vertices.length; r < i; r++) g.vertices.push(p[t].vertices[r].clone());
                    if (void 0 !== p[t].normals)
                        for (g.normals = [], r = 0, i = p[t].normals.length; r < i; r++) g.normals.push(p[t].normals[r].clone());
                    this.morphTargets.push(g)
                }
                var m = e.morphNormals;
                for (t = 0, n = m.length; t < n; t++) {
                    var v = {};
                    if (void 0 !== m[t].vertexNormals)
                        for (v.vertexNormals = [], r = 0, i = m[t].vertexNormals.length; r < i; r++) {
                            var y = m[t].vertexNormals[r],
                                _ = {};
                            _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                        }
                    if (void 0 !== m[t].faceNormals)
                        for (v.faceNormals = [], r = 0, i = m[t].faceNormals.length; r < i; r++) v.faceNormals.push(m[t].faceNormals[r].clone());
                    this.morphNormals.push(v)
                }
                var A = e.skinWeights;
                for (t = 0, n = A.length; t < n; t++) this.skinWeights.push(A[t].clone());
                var x = e.skinIndices;
                for (t = 0, n = x.length; t < n; t++) this.skinIndices.push(x[t].clone());
                var C = e.lineDistances;
                for (t = 0, n = C.length; t < n; t++) this.lineDistances.push(C[t]);
                var I = e.boundingBox;
                null !== I && (this.boundingBox = I.clone());
                var w = e.boundingSphere;
                return null !== w && (this.boundingSphere = w.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
            },
            dispose: function () {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Ga = function (e) {
            function s(e, t, n, r, i, a) {
                var o;
                return (0, h.default)(this, s), o = (0, c.default)(this, (0, f.default)(s).call(this)), o.type = "BoxGeometry", o.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: a
                }, o.fromBufferGeometry(new Ua(e, t, n, r, i, a)), o.mergeVertices(), o
            }
            return (0, p.default)(s, e), s
        }(Ba);
        t.CubeGeometry = t.BoxGeometry = Ga;
        var Ua = function (e) {
            function l(e, t, n, r, i, a) {
                var o;
                (0, h.default)(this, l), o = (0, c.default)(this, (0, f.default)(l).call(this)), o.type = "BoxBufferGeometry", o.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: a
                };
                var T = (0, u.default)(o);
                e = e || 1, t = t || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, a = Math.floor(a) || 1;
                var L = [],
                    N = [],
                    R = [],
                    k = [],
                    P = 0,
                    D = 0;

                function s(e, t, n, r, i, a, o, s, l, u, h) {
                    var c, d, f = a / l,
                        p = o / u,
                        g = a / 2,
                        m = o / 2,
                        v = s / 2,
                        y = l + 1,
                        _ = u + 1,
                        A = 0,
                        x = 0,
                        C = new Cr;
                    for (d = 0; d < _; d++) {
                        var I = d * p - m;
                        for (c = 0; c < y; c++) {
                            var w = c * f - g;
                            C[e] = w * r, C[t] = I * i, C[n] = v, N.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = 0 < s ? 1 : -1, R.push(C.x, C.y, C.z), k.push(c / l), k.push(1 - d / u), A += 1
                        }
                    }
                    for (d = 0; d < u; d++)
                        for (c = 0; c < l; c++) {
                            var M = P + c + y * d,
                                b = P + c + y * (d + 1),
                                S = P + (c + 1) + y * (d + 1),
                                E = P + (c + 1) + y * d;
                            L.push(M, b, E), L.push(b, S, E), x += 6
                        }
                    T.addGroup(D, x, h), D += x, P += A
                }
                return s("z", "y", "x", -1, -1, n, t, e, a, i, 0), s("z", "y", "x", 1, -1, n, t, -e, a, i, 1), s("x", "z", "y", 1, 1, e, n, t, r, a, 2), s("x", "z", "y", 1, -1, e, n, -t, r, a, 3), s("x", "y", "z", 1, -1, e, t, n, r, i, 4), s("x", "y", "z", -1, -1, e, t, -n, r, i, 5), o.setIndex(L), o.setAttribute("position", new na(N, 3)), o.setAttribute("normal", new na(R, 3)), o.setAttribute("uv", new na(k, 2)), o
            }
            return (0, p.default)(l, e), l
        }(fa);

        function za(e) {
            var t = {};
            for (var n in e)
                for (var r in t[n] = {}, e[n]) {
                    var i = e[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : (0, He.default)(i) ? t[n][r] = i.slice() : t[n][r] = i
                }
            return t
        }

        function Va(e) {
            for (var t = {}, n = 0; n < e.length; n++) {
                var r = za(e[n]);
                for (var i in r) t[i] = r[i]
            }
            return t
        }
        t.BoxBufferGeometry = Ua;
        var Ha = {
            clone: za,
            merge: Va
        };
        t.UniformsUtils = Ha;
        var Wa = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
            ja = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

        function Ya(e) {
            ji.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Wa, this.fragmentShader = ja, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
        }

        function qa() {
            Xr.call(this), this.type = "Camera", this.matrixWorldInverse = new Lr, this.projectionMatrix = new Lr, this.projectionMatrixInverse = new Lr
        }

        function Xa(e, t, n, r) {
            qa.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        Ya.prototype = (0, s.default)(ji.prototype), Ya.prototype.constructor = Ya, Ya.prototype.isShaderMaterial = !0, Ya.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = za(e.uniforms), this.defines = (0, We.default)({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
        }, Ya.prototype.toJSON = function (e) {
            var t = ji.prototype.toJSON.call(this, e);
            for (var n in t.uniforms = {}, this.uniforms) {
                var r = this.uniforms[n],
                    i = r.value;
                i && i.isTexture ? t.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(e).uuid
                } : i && i.isColor ? t.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? t.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? t.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? t.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? t.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? t.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : t.uniforms[n] = {
                    value: i
                }
            }
            0 < (0, g.default)(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
            var a = {};
            for (var o in this.extensions) !0 === this.extensions[o] && (a[o] = !0);
            return 0 < (0, g.default)(a).length && (t.extensions = a), t
        }, qa.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: qa,
            isCamera: !0,
            copy: function (e, t) {
                return Xr.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
            },
            getWorldDirection: function (e) {
                void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Cr), this.updateMatrixWorld(!0);
                var t = this.matrixWorld.elements;
                return e.set(-t[8], -t[9], -t[10]).normalize()
            },
            updateMatrixWorld: function (e) {
                Xr.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            updateWorldMatrix: function (e, t) {
                Xr.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), Xa.prototype = (0, We.default)((0, s.default)(qa.prototype), {
            constructor: Xa,
            isPerspectiveCamera: !0,
            copy: function (e, t) {
                return qa.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : (0, We.default)({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            },
            setFocalLength: function (e) {
                var t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * hr.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
                var e = Math.tan(.5 * hr.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / e
            },
            getEffectiveFOV: function () {
                return 2 * hr.RAD2DEG * Math.atan(Math.tan(.5 * hr.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (e, t, n, r, i, a) {
                this.aspect = e / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var e = this.near,
                    t = e * Math.tan(.5 * hr.DEG2RAD * this.fov) / this.zoom,
                    n = 2 * t,
                    r = this.aspect * n,
                    i = -.5 * r,
                    a = this.view;
                if (null !== this.view && this.view.enabled) {
                    var o = a.fullWidth,
                        s = a.fullHeight;
                    i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s
                }
                var l = this.filmOffset;
                0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function (e) {
                var t = Xr.prototype.toJSON.call(this, e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = (0, We.default)({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        });
        var Za = 90,
            Ja = 1;

        function Ka(e, t, n, r) {
            Xr.call(this), this.type = "CubeCamera";
            var a = new Xa(Za, Ja, e, t);
            a.up.set(0, -1, 0), a.lookAt(new Cr(1, 0, 0)), this.add(a);
            var o = new Xa(Za, Ja, e, t);
            o.up.set(0, -1, 0), o.lookAt(new Cr(-1, 0, 0)), this.add(o);
            var s = new Xa(Za, Ja, e, t);
            s.up.set(0, 0, 1), s.lookAt(new Cr(0, 1, 0)), this.add(s);
            var l = new Xa(Za, Ja, e, t);
            l.up.set(0, 0, -1), l.lookAt(new Cr(0, -1, 0)), this.add(l);
            var u = new Xa(Za, Ja, e, t);
            u.up.set(0, -1, 0), u.lookAt(new Cr(0, 0, 1)), this.add(u);
            var h = new Xa(Za, Ja, e, t);
            h.up.set(0, -1, 0), h.lookAt(new Cr(0, 0, -1)), this.add(h), r = r || {
                format: ct,
                magFilter: ue,
                minFilter: ue
            }, this.renderTarget = new Qa(n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
                null === this.parent && this.updateMatrixWorld();
                var n = e.getRenderTarget(),
                    r = this.renderTarget,
                    i = r.texture.generateMipmaps;
                r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, a), e.setRenderTarget(r, 1), e.render(t, o), e.setRenderTarget(r, 2), e.render(t, s), e.setRenderTarget(r, 3), e.render(t, l), e.setRenderTarget(r, 4), e.render(t, u), r.texture.generateMipmaps = i, e.setRenderTarget(r, 5), e.render(t, h), e.setRenderTarget(n)
            }, this.clear = function (e, t, n, r) {
                for (var i = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) e.setRenderTarget(a, o), e.clear(t, n, r);
                e.setRenderTarget(i)
            }
        }

        function Qa(e, t, n) {
            (0, _.default)(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), vr.call(this, e, e, t)
        }

        function $a(e, t, n, r, i, a, o, s, l, u, h, c) {
            gr.call(this, null, a, o, s, l, u, r, i, h, c), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1
            }, this.magFilter = void 0 !== l ? l : oe, this.minFilter = void 0 !== u ? u : oe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }
        Ka.prototype = (0, s.default)(Xr.prototype), Ka.prototype.constructor = Ka, Qa.prototype = (0, s.default)(vr.prototype), Qa.prototype.constructor = Qa, Qa.prototype.isWebGLCubeRenderTarget = !0, Qa.prototype.fromEquirectangularTexture = function (e, t) {
            this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding;
            var n = new Zr,
                r = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
                },
                i = new Ya({
                    type: "CubemapFromEquirect",
                    uniforms: za(r.uniforms),
                    vertexShader: r.vertexShader,
                    fragmentShader: r.fragmentShader,
                    side: je,
                    blending: Ae
                });
            i.uniforms.tEquirect.value = t;
            var a = new Na(new Ua(5, 5, 5), i);
            n.add(a);
            var o = new Ka(1, 10, 1);
            return o.renderTarget = this, o.renderTarget.texture.name = "CubeCameraTexture", o.update(e, n), a.geometry.dispose(), a.material.dispose(), this
        }, $a.prototype = (0, s.default)(gr.prototype), $a.prototype.constructor = $a, $a.prototype.isDataTexture = !0;
        var eo = new di,
            to = new Cr;

        function no(e, t, n, r, i, a) {
            this.planes = [void 0 !== e ? e : new wi, void 0 !== t ? t : new wi, void 0 !== n ? n : new wi, void 0 !== r ? r : new wi, void 0 !== i ? i : new wi, void 0 !== a ? a : new wi]
        }(0, We.default)(no.prototype, {
            set: function (e, t, n, r, i, a) {
                var o = this.planes;
                return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            },
            setFromProjectionMatrix: function (e) {
                var t = this.planes,
                    n = e.elements,
                    r = n[0],
                    i = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    u = n[6],
                    h = n[7],
                    c = n[8],
                    d = n[9],
                    f = n[10],
                    p = n[11],
                    g = n[12],
                    m = n[13],
                    v = n[14],
                    y = n[15];
                return t[0].setComponents(o - r, h - s, p - c, y - g).normalize(), t[1].setComponents(o + r, h + s, p + c, y + g).normalize(), t[2].setComponents(o + i, h + l, p + d, y + m).normalize(), t[3].setComponents(o - i, h - l, p - d, y - m).normalize(), t[4].setComponents(o - a, h - u, p - f, y - v).normalize(), t[5].setComponents(o + a, h + u, p + f, y + v).normalize(), this
            },
            intersectsObject: function (e) {
                var t = e.geometry;
                return null === t.boundingSphere && t.computeBoundingSphere(), eo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(eo)
            },
            intersectsSprite: function (e) {
                return eo.center.set(0, 0, 0), eo.radius = .7071067811865476, eo.applyMatrix4(e.matrixWorld), this.intersectsSphere(eo)
            },
            intersectsSphere: function (e) {
                for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                    var a = t[i].distanceToPoint(n);
                    if (a < r) return !1
                }
                return !0
            },
            intersectsBox: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++) {
                    var r = t[n];
                    if (to.x = 0 < r.normal.x ? e.max.x : e.min.x, to.y = 0 < r.normal.y ? e.max.y : e.min.y, to.z = 0 < r.normal.z ? e.max.z : e.min.z, r.distanceToPoint(to) < 0) return !1
                }
                return !0
            },
            containsPoint: function (e) {
                for (var t = this.planes, n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
        });
        var ro = {
            common: {
                diffuse: {
                    value: new Gi(15658734)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                uvTransform: {
                    value: new dr
                },
                uv2Transform: {
                    value: new dr
                },
                alphaMap: {
                    value: null
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                refractionRatio: {
                    value: .98
                },
                maxMipLevel: {
                    value: 0
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalScale: {
                    value: new cr(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Gi(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {
                    value: []
                },
                spotShadowMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                }
            },
            points: {
                diffuse: {
                    value: new Gi(15658734)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new dr
                }
            },
            sprite: {
                diffuse: {
                    value: new Gi(15658734)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new cr(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                uvTransform: {
                    value: new dr
                }
            }
        };

        function io() {
            var n = null,
                r = !1,
                i = null;

            function a(e, t) {
                !1 !== r && (i(e, t), n.requestAnimationFrame(a))
            }
            return {
                start: function () {
                    !0 !== r && null !== i && (n.requestAnimationFrame(a), r = !0)
                },
                stop: function () {
                    r = !1
                },
                setAnimationLoop: function (e) {
                    i = e
                },
                setContext: function (e) {
                    n = e
                }
            }
        }

        function ao(o, e) {
            var a = e.isWebGL2,
                r = new te.default;

            function i(e, t) {
                var n = e.array,
                    r = e.usage,
                    i = o.createBuffer();
                o.bindBuffer(t, i), o.bufferData(t, n, r), e.onUploadCallback();
                var a = 5126;
                return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), {
                    buffer: i,
                    type: a,
                    bytesPerElement: n.BYTES_PER_ELEMENT,
                    version: e.version
                }
            }

            function s(e, t, n) {
                var r = t.array,
                    i = t.updateRange;
                o.bindBuffer(n, e), -1 === i.count ? o.bufferSubData(n, 0, r) : (a ? o.bufferSubData(n, i.offset * r.BYTES_PER_ELEMENT, r, i.offset, i.count) : o.bufferSubData(n, i.offset * r.BYTES_PER_ELEMENT, r.subarray(i.offset, i.offset + i.count)), i.count = -1)
            }

            function t(e) {
                return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
            }

            function n(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var t = r.get(e);
                t && (o.deleteBuffer(t.buffer), r.delete(e))
            }

            function l(e, t) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n = r.get(e);
                void 0 === n ? r.set(e, i(e, t)) : n.version < e.version && (s(n.buffer, e, t), n.version = e.version)
            }
            return {
                get: t,
                remove: n,
                update: l
            }
        }

        function oo(e, t, n, r) {
            Ba.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: r
            }, this.fromBufferGeometry(new so(e, t, n, r)), this.mergeVertices()
        }

        function so(e, t, n, r) {
            fa.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: r
            }, e = e || 1, t = t || 1;
            var i, a, o = e / 2,
                s = t / 2,
                l = Math.floor(n) || 1,
                u = Math.floor(r) || 1,
                h = l + 1,
                c = u + 1,
                d = e / l,
                f = t / u,
                p = [],
                g = [],
                m = [],
                v = [];
            for (a = 0; a < c; a++) {
                var y = a * f - s;
                for (i = 0; i < h; i++) {
                    var _ = i * d - o;
                    g.push(_, -y, 0), m.push(0, 0, 1), v.push(i / l), v.push(1 - a / u)
                }
            }
            for (a = 0; a < u; a++)
                for (i = 0; i < l; i++) {
                    var A = i + h * a,
                        x = i + h * (a + 1),
                        C = i + 1 + h * (a + 1),
                        I = i + 1 + h * a;
                    p.push(A, x, I), p.push(x, C, I)
                }
            this.setIndex(p), this.setAttribute("position", new na(g, 3)), this.setAttribute("normal", new na(m, 3)), this.setAttribute("uv", new na(v, 2))
        }
        t.UniformsLib = ro, oo.prototype = (0, s.default)(Ba.prototype), oo.prototype.constructor = oo, so.prototype = (0, s.default)(fa.prototype), so.prototype.constructor = so;
        var lo = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            uo = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            ho = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            co = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            fo = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            po = "vec3 transformed = vec3( position );",
            go = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            mo = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            vo = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            yo = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            _o = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            Ao = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            xo = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            Co = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            Io = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            wo = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            Mo = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            bo = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
            So = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
            Eo = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            To = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            Lo = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            No = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            Ro = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            ko = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            Po = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            Do = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            Oo = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            Fo = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            Bo = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            Go = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            Uo = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
            zo = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            Vo = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            Ho = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            Wo = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            jo = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            Yo = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            qo = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            Xo = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            Zo = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            Jo = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            Ko = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            Qo = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            $o = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            es = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            ts = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            ns = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            rs = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            is = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            as = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            os = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            ss = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            ls = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            us = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\t#ifdef USE_MAP_MIXCOLOR\n diffuseColor = texelColor*texelColor.a + diffuseColor*(1.0-texelColor.a);\n #else\n diffuseColor *= texelColor;\n #endif\n #endif\n",
            hs = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            cs = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            ds = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            fs = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            ps = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            gs = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            ms = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            vs = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            ys = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            _s = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
            As = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
            xs = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            Cs = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
            Is = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            ws = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            Ms = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            bs = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            Ss = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            Es = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            Ts = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            Ls = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            Ns = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            Rs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            ks = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            Ps = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            Ds = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            Os = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            Fs = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            Bs = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            Gs = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            Us = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            zs = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            Vs = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
            Hs = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            Ws = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            js = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            Ys = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            qs = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            Xs = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            Zs = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            Js = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            Ks = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            Qs = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            $s = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            el = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            tl = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            nl = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            rl = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            il = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            al = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            ol = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            sl = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            ll = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            ul = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            hl = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            cl = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            dl = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            fl = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            pl = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            gl = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            ml = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\tgl_FragColor =vec4(1.0,0.2,0.3,1.0);\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            vl = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            yl = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform float test;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\tif(test == 1.0){\n\tgl_FragColor = vec4( 1.0,1.0,0.2,1.0 );\n\t}\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            _l = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            Al = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            xl = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            Cl = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            Il = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            wl = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            Ml = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            bl = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            Sl = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            El = {
                alphamap_fragment: lo,
                alphamap_pars_fragment: uo,
                alphatest_fragment: ho,
                aomap_fragment: co,
                aomap_pars_fragment: fo,
                begin_vertex: po,
                beginnormal_vertex: go,
                bsdfs: mo,
                bumpmap_pars_fragment: vo,
                clipping_planes_fragment: yo,
                clipping_planes_pars_fragment: _o,
                clipping_planes_pars_vertex: Ao,
                clipping_planes_vertex: xo,
                color_fragment: Co,
                color_pars_fragment: Io,
                color_pars_vertex: wo,
                color_vertex: Mo,
                common: bo,
                cube_uv_reflection_fragment: So,
                defaultnormal_vertex: Eo,
                displacementmap_pars_vertex: To,
                displacementmap_vertex: Lo,
                emissivemap_fragment: No,
                emissivemap_pars_fragment: Ro,
                encodings_fragment: ko,
                encodings_pars_fragment: Po,
                envmap_fragment: Do,
                envmap_common_pars_fragment: Oo,
                envmap_pars_fragment: Fo,
                envmap_pars_vertex: Bo,
                envmap_physical_pars_fragment: Zo,
                envmap_vertex: Go,
                fog_vertex: Uo,
                fog_pars_vertex: zo,
                fog_fragment: Vo,
                fog_pars_fragment: Ho,
                gradientmap_pars_fragment: Wo,
                lightmap_fragment: jo,
                lightmap_pars_fragment: Yo,
                lights_lambert_vertex: qo,
                lights_pars_begin: Xo,
                lights_toon_fragment: Jo,
                lights_toon_pars_fragment: Ko,
                lights_phong_fragment: Qo,
                lights_phong_pars_fragment: $o,
                lights_physical_fragment: es,
                lights_physical_pars_fragment: ts,
                lights_fragment_begin: ns,
                lights_fragment_maps: rs,
                lights_fragment_end: is,
                logdepthbuf_fragment: as,
                logdepthbuf_pars_fragment: os,
                logdepthbuf_pars_vertex: ss,
                logdepthbuf_vertex: ls,
                map_fragment: us,
                map_pars_fragment: hs,
                map_particle_fragment: cs,
                map_particle_pars_fragment: ds,
                metalnessmap_fragment: fs,
                metalnessmap_pars_fragment: ps,
                morphnormal_vertex: gs,
                morphtarget_pars_vertex: ms,
                morphtarget_vertex: vs,
                normal_fragment_begin: ys,
                normal_fragment_maps: _s,
                normalmap_pars_fragment: As,
                clearcoat_normal_fragment_begin: xs,
                clearcoat_normal_fragment_maps: Cs,
                clearcoat_pars_fragment: Is,
                packing: ws,
                premultiplied_alpha_fragment: Ms,
                project_vertex: bs,
                dithering_fragment: Ss,
                dithering_pars_fragment: Es,
                roughnessmap_fragment: Ts,
                roughnessmap_pars_fragment: Ls,
                shadowmap_pars_fragment: Ns,
                shadowmap_pars_vertex: Rs,
                shadowmap_vertex: ks,
                shadowmask_pars_fragment: Ps,
                skinbase_vertex: Ds,
                skinning_pars_vertex: Os,
                skinning_vertex: Fs,
                skinnormal_vertex: Bs,
                specularmap_fragment: Gs,
                specularmap_pars_fragment: Us,
                tonemapping_fragment: zs,
                tonemapping_pars_fragment: Vs,
                uv_pars_fragment: Hs,
                uv_pars_vertex: Ws,
                uv_vertex: js,
                uv2_pars_fragment: Ys,
                uv2_pars_vertex: qs,
                uv2_vertex: Xs,
                worldpos_vertex: Zs,
                background_frag: Js,
                background_vert: Ks,
                cube_frag: Qs,
                cube_vert: $s,
                depth_frag: el,
                depth_vert: tl,
                distanceRGBA_frag: nl,
                distanceRGBA_vert: rl,
                equirect_frag: il,
                equirect_vert: al,
                linedashed_frag: ol,
                linedashed_vert: sl,
                meshbasic_frag: ll,
                meshbasic_vert: ul,
                meshlambert_frag: hl,
                meshlambert_vert: cl,
                meshmatcap_frag: dl,
                meshmatcap_vert: fl,
                meshtoon_frag: pl,
                meshtoon_vert: gl,
                meshphong_frag: ml,
                meshphong_vert: vl,
                meshphysical_frag: yl,
                meshphysical_vert: _l,
                normal_frag: Al,
                normal_vert: xl,
                points_frag: Cl,
                points_vert: Il,
                shadow_frag: wl,
                shadow_vert: Ml,
                sprite_frag: bl,
                sprite_vert: Sl
            };
        t.ShaderChunk = El;
        var Tl = {
            basic: {
                uniforms: Va([ro.common, ro.specularmap, ro.envmap, ro.aomap, ro.lightmap, ro.fog]),
                vertexShader: El.meshbasic_vert,
                fragmentShader: El.meshbasic_frag
            },
            lambert: {
                uniforms: Va([ro.common, ro.specularmap, ro.envmap, ro.aomap, ro.lightmap, ro.emissivemap, ro.fog, ro.lights, {
                    emissive: {
                        value: new Gi(0)
                    }
                }]),
                vertexShader: El.meshlambert_vert,
                fragmentShader: El.meshlambert_frag
            },
            phong: {
                uniforms: Va([ro.common, ro.specularmap, ro.envmap, ro.aomap, ro.lightmap, ro.emissivemap, ro.bumpmap, ro.normalmap, ro.displacementmap, ro.fog, ro.lights, {
                    emissive: {
                        value: new Gi(0)
                    },
                    specular: {
                        value: new Gi(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: El.meshphong_vert,
                fragmentShader: El.meshphong_frag
            },
            standard: {
                uniforms: Va([ro.common, ro.envmap, ro.aomap, ro.lightmap, ro.emissivemap, ro.bumpmap, ro.normalmap, ro.displacementmap, ro.roughnessmap, ro.metalnessmap, ro.fog, ro.lights, {
                    emissive: {
                        value: new Gi(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: El.meshphysical_vert,
                fragmentShader: El.meshphysical_frag
            },
            toon: {
                uniforms: Va([ro.common, ro.specularmap, ro.aomap, ro.lightmap, ro.emissivemap, ro.bumpmap, ro.normalmap, ro.displacementmap, ro.gradientmap, ro.fog, ro.lights, {
                    emissive: {
                        value: new Gi(0)
                    },
                    specular: {
                        value: new Gi(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: El.meshtoon_vert,
                fragmentShader: El.meshtoon_frag
            },
            matcap: {
                uniforms: Va([ro.common, ro.bumpmap, ro.normalmap, ro.displacementmap, ro.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: El.meshmatcap_vert,
                fragmentShader: El.meshmatcap_frag
            },
            points: {
                uniforms: Va([ro.points, ro.fog]),
                vertexShader: El.points_vert,
                fragmentShader: El.points_frag
            },
            dashed: {
                uniforms: Va([ro.common, ro.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: El.linedashed_vert,
                fragmentShader: El.linedashed_frag
            },
            depth: {
                uniforms: Va([ro.common, ro.displacementmap]),
                vertexShader: El.depth_vert,
                fragmentShader: El.depth_frag
            },
            normal: {
                uniforms: Va([ro.common, ro.bumpmap, ro.normalmap, ro.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: El.normal_vert,
                fragmentShader: El.normal_frag
            },
            sprite: {
                uniforms: Va([ro.sprite, ro.fog]),
                vertexShader: El.sprite_vert,
                fragmentShader: El.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new dr
                    },
                    t2D: {
                        value: null
                    }
                },
                vertexShader: El.background_vert,
                fragmentShader: El.background_frag
            },
            cube: {
                uniforms: Va([ro.envmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: El.cube_vert,
                fragmentShader: El.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: El.equirect_vert,
                fragmentShader: El.equirect_frag
            },
            distanceRGBA: {
                uniforms: Va([ro.common, ro.displacementmap, {
                    referencePosition: {
                        value: new Cr
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: El.distanceRGBA_vert,
                fragmentShader: El.distanceRGBA_frag
            },
            shadow: {
                uniforms: Va([ro.lights, ro.fog, {
                    color: {
                        value: new Gi(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: El.shadow_vert,
                fragmentShader: El.shadow_frag
            }
        };

        function Ll(l, n, u, r) {
            var h, c, d = new Gi(0),
                f = 0,
                p = null,
                g = 0,
                m = null;

            function e(e, t, n, r) {
                var i = t.background,
                    a = l.xr,
                    o = a.getSession && a.getSession();
                if (o && "additive" === o.environmentBlendMode && (i = null), null === i ? v(d, f) : i && i.isColor && (v(i, 1), r = !0), (l.autoClear || r) && l.clear(l.autoClearColor, l.autoClearDepth, l.autoClearStencil), i && (i.isCubeTexture || i.isWebGLCubeRenderTarget || i.mapping === Z)) {
                    void 0 === c && (c = new Na(new Ua(1, 1, 1), new Ya({
                        type: "BackgroundCubeMaterial",
                        uniforms: za(Tl.cube.uniforms),
                        vertexShader: Tl.cube.vertexShader,
                        fragmentShader: Tl.cube.fragmentShader,
                        side: je,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, (0, y.default)(c.material, "envMap", {
                        get: function () {
                            return this.uniforms.envMap.value
                        }
                    }), u.update(c));
                    var s = i.isWebGLCubeRenderTarget ? i.texture : i;
                    c.material.uniforms.envMap.value = s, c.material.uniforms.flipEnvMap.value = s.isCubeTexture ? -1 : 1, p === i && g === s.version && m === l.toneMapping || (c.material.needsUpdate = !0, p = i, g = s.version, m = l.toneMapping), e.unshift(c, c.geometry, c.material, 0, 0, null)
                } else i && i.isTexture && (void 0 === h && (h = new Na(new so(2, 2), new Ya({
                    type: "BackgroundMaterial",
                    uniforms: za(Tl.background.uniforms),
                    vertexShader: Tl.background.vertexShader,
                    fragmentShader: Tl.background.fragmentShader,
                    side: k,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), h.geometry.deleteAttribute("normal"), (0, y.default)(h.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), u.update(h)), h.material.uniforms.t2D.value = i, !0 === i.matrixAutoUpdate && i.updateMatrix(), h.material.uniforms.uvTransform.value.copy(i.matrix), p === i && g === i.version && m === l.toneMapping || (h.material.needsUpdate = !0, p = i, g = i.version, m = l.toneMapping), e.unshift(h, h.geometry, h.material, 0, 0, null))
            }

            function v(e, t) {
                n.buffers.color.setClear(e.r, e.g, e.b, t, r)
            }
            return {
                getClearColor: function () {
                    return d
                },
                setClearColor: function (e, t) {
                    d.set(e), f = void 0 !== t ? t : 1, v(d, f)
                },
                getClearAlpha: function () {
                    return f
                },
                setClearAlpha: function (e) {
                    f = e, v(d, f)
                },
                render: e
            }
        }

        function Nl(o, s, l, e) {
            var u, h = e.isWebGL2;

            function t(e) {
                u = e
            }

            function n(e, t) {
                o.drawArrays(u, e, t), l.update(t, u)
            }

            function r(e, t, n, r) {
                if (0 !== r) {
                    var i, a;
                    if (h) i = o, a = "drawArraysInstanced";
                    else if (i = s.get("ANGLE_instanced_arrays"), a = "drawArraysInstancedANGLE", null === i) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    i[a](u, t, n, r), l.update(n, u, r)
                }
            }
            this.setMode = t, this.render = n, this.renderInstances = r
        }

        function Rl(t, n, e) {
            var r;

            function i() {
                if (void 0 !== r) return r;
                var e = n.get("EXT_texture_filter_anisotropic");
                return r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, r
            }

            function a(e) {
                if ("highp" === e) {
                    if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
            }
            var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext,
                s = void 0 !== e.precision ? e.precision : "highp",
                l = a(s);
            l !== s && (s = l);
            var u = !0 === e.logarithmicDepthBuffer,
                h = t.getParameter(34930),
                c = t.getParameter(35660),
                d = t.getParameter(3379),
                f = t.getParameter(34076),
                p = t.getParameter(34921),
                g = t.getParameter(36347),
                m = t.getParameter(36348),
                v = t.getParameter(36349),
                y = 0 < c,
                _ = o || !!n.get("OES_texture_float"),
                A = y && _,
                x = o ? t.getParameter(36183) : 0;
            return {
                isWebGL2: o,
                getMaxAnisotropy: i,
                getMaxPrecision: a,
                precision: s,
                logarithmicDepthBuffer: u,
                maxTextures: h,
                maxVertexTextures: c,
                maxTextureSize: d,
                maxCubemapSize: f,
                maxAttributes: p,
                maxVertexUniforms: g,
                maxVaryings: m,
                maxFragmentUniforms: v,
                vertexTextures: y,
                floatFragmentTextures: _,
                floatVertexTextures: A,
                maxSamples: x
            }
        }

        function kl() {
            var h = this,
                c = null,
                d = 0,
                f = !1,
                p = !1,
                g = new wi,
                m = new dr,
                v = {
                    value: null,
                    needsUpdate: !1
                };

            function y() {
                v.value !== c && (v.value = c, v.needsUpdate = 0 < d), h.numPlanes = d, h.numIntersection = 0
            }

            function _(e, t, n, r) {
                var i = null !== e ? e.length : 0,
                    a = null;
                if (0 !== i) {
                    if (a = v.value, !0 !== r || null === a) {
                        var o = n + 4 * i,
                            s = t.matrixWorldInverse;
                        m.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
                        for (var l = 0, u = n; l !== i; ++l, u += 4) g.copy(e[l]).applyMatrix4(s, m), g.normal.toArray(a, u), a[u + 3] = g.constant
                    }
                    v.value = a, v.needsUpdate = !0
                }
                return h.numPlanes = i, h.numIntersection = 0, a
            }
            this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, n) {
                var r = 0 !== e.length || t || 0 !== d || f;
                return f = t, c = _(e, n, 0), d = e.length, r
            }, this.beginShadows = function () {
                p = !0, _(null)
            }, this.endShadows = function () {
                p = !1, y()
            }, this.setState = function (e, t, n, r, i, a) {
                if (!f || null === e || 0 === e.length || p && !n) p ? _(null) : y();
                else {
                    var o = p ? 0 : d,
                        s = 4 * o,
                        l = i.clippingState || null;
                    v.value = l, l = _(e, r, s, a);
                    for (var u = 0; u !== s; ++u) l[u] = c[u];
                    i.clippingState = l, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += o
                }
            }
        }

        function Pl(n) {
            var r = {};
            return {
                get: function (e) {
                    if (void 0 !== r[e]) return r[e];
                    var t;
                    switch (e) {
                        case "WEBGL_depth_texture":
                            t = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            t = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            t = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            t = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            t = n.getExtension(e)
                    }
                    return r[e] = t, t
                }
            }
        }

        function Dl(e, f, a) {
            var o = new te.default,
                p = new te.default;

            function s(e) {
                var t = e.target,
                    n = o.get(t);
                for (var r in null !== n.index && f.remove(n.index), n.attributes) f.remove(n.attributes[r]);
                t.removeEventListener("dispose", s), o.delete(t);
                var i = p.get(n);
                i && (f.remove(i), p.delete(n)), a.memory.geometries--
            }

            function t(e, t) {
                var n = o.get(t);
                return n || (t.addEventListener("dispose", s), t.isBufferGeometry ? n = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new fa).setFromObject(e)), n = t._bufferGeometry), o.set(t, n), a.memory.geometries++, n)
            }

            function n(e) {
                var t = e.index,
                    n = e.attributes;
                for (var r in null !== t && f.update(t, 34963), n) f.update(n[r], 34962);
                var i = e.morphAttributes;
                for (var r in i)
                    for (var a = i[r], o = 0, s = a.length; o < s; o++) f.update(a[o], 34962)
            }

            function r(e) {
                var t = [],
                    n = e.index,
                    r = e.attributes.position,
                    i = 0;
                if (null !== n) {
                    var a = n.array;
                    i = n.version;
                    for (var o = 0, s = a.length; o < s; o += 3) {
                        var l = a[o + 0],
                            u = a[o + 1],
                            h = a[o + 2];
                        t.push(l, u, u, h, h, l)
                    }
                } else
                    for (a = r.array, i = r.version, o = 0, s = a.length / 3 - 1; o < s; o += 3) l = o + 0, u = o + 1, h = o + 2, t.push(l, u, u, h, h, l);
                var c = new(65535 < aa(t) ? ta : $i)(t, 1);
                c.version = i, f.update(c, 34963);
                var d = p.get(e);
                d && f.remove(d), p.set(e, c)
            }

            function i(e) {
                var t = p.get(e);
                if (t) {
                    var n = e.index;
                    null !== n && t.version < n.version && r(e)
                } else r(e);
                return p.get(e)
            }
            return {
                get: t,
                update: n,
                getWireframeAttribute: i
            }
        }

        function Ol(o, s, l, e) {
            var u, h, c, d = e.isWebGL2;

            function t(e) {
                u = e
            }

            function n(e) {
                h = e.type, c = e.bytesPerElement
            }

            function r(e, t) {
                o.drawElements(u, t, h, e * c), l.update(t, u)
            }

            function i(e, t, n, r) {
                if (0 !== r) {
                    var i, a;
                    if (d) i = o, a = "drawElementsInstanced";
                    else if (i = s.get("ANGLE_instanced_arrays"), a = "drawElementsInstancedANGLE", null === i) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    i[a](u, n, h, t * c, r), l.update(n, u, r)
                }
            }
            this.setMode = t, this.setIndex = n, this.render = r, this.renderInstances = i
        }

        function Fl() {
            var e = {
                    geometries: 0,
                    textures: 0
                },
                r = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };

            function t(e, t, n) {
                switch (n = n || 1, r.calls++, t) {
                    case 4:
                        r.triangles += n * (e / 3);
                        break;
                    case 1:
                        r.lines += n * (e / 2);
                        break;
                    case 3:
                        r.lines += n * (e - 1);
                        break;
                    case 2:
                        r.lines += n * e;
                        break;
                    case 0:
                        r.points += n * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                }
            }

            function n() {
                r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
            }
            return {
                memory: e,
                render: r,
                programs: null,
                autoReset: !0,
                reset: n,
                update: t
            }
        }

        function Bl(e, t) {
            return Math.abs(t[1]) - Math.abs(e[1])
        }

        function Gl(g) {
            var m = {},
                v = new Float32Array(8);

            function e(e, t, n, r) {
                var i = e.morphTargetInfluences,
                    a = void 0 === i ? 0 : i.length,
                    o = m[t.id];
                if (void 0 === o) {
                    o = [];
                    for (var s = 0; s < a; s++) o[s] = [s, 0];
                    m[t.id] = o
                }
                var l = n.morphTargets && t.morphAttributes.position,
                    u = n.morphNormals && t.morphAttributes.normal;
                for (s = 0; s < a; s++) {
                    var h = o[s];
                    0 !== h[1] && (l && t.deleteAttribute("morphTarget" + s), u && t.deleteAttribute("morphNormal" + s))
                }
                for (s = 0; s < a; s++) h = o[s], h[0] = s, h[1] = i[s];
                o.sort(Bl);
                var c = 0;
                for (s = 0; s < 8; s++) {
                    if (h = o[s], h) {
                        var d = h[0],
                            f = h[1];
                        if (f) {
                            l && t.setAttribute("morphTarget" + s, l[d]), u && t.setAttribute("morphNormal" + s, u[d]), v[s] = f, c += f;
                            continue
                        }
                    }
                    v[s] = 0
                }
                var p = t.morphTargetsRelative ? 1 : 1 - c;
                r.getUniforms().setValue(g, "morphTargetBaseInfluence", p), r.getUniforms().setValue(g, "morphTargetInfluences", v)
            }
            return {
                update: e
            }
        }

        function Ul(e, i, a, o) {
            var s = new te.default;

            function t(e) {
                var t = o.render.frame,
                    n = e.geometry,
                    r = i.get(e, n);
                return s.get(r) !== t && (n.isGeometry && r.updateFromObject(e), i.update(r), s.set(r, t)), e.isInstancedMesh && a.update(e.instanceMatrix, 34962), r
            }

            function n() {
                s = new te.default
            }
            return {
                update: t,
                dispose: n
            }
        }

        function zl(e, t, n, r, i, a, o, s, l, u) {
            e = void 0 !== e ? e : [], t = void 0 !== t ? t : W, o = void 0 !== o ? o : ct, gr.call(this, e, t, n, r, i, a, o, s, l, u), this.flipY = !1
        }

        function Vl(e, t, n, r) {
            gr.call(this, null), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1,
                depth: r || 1
            }, this.magFilter = oe, this.minFilter = oe, this.wrapR = re, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }

        function Hl(e, t, n, r) {
            gr.call(this, null), this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1,
                depth: r || 1
            }, this.magFilter = oe, this.minFilter = oe, this.wrapR = re, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
        }
        t.ShaderLib = Tl, Tl.physical = {
            uniforms: Va([Tl.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new cr(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Gi(0)
                },
                transparency: {
                    value: 0
                }
            }]),
            vertexShader: El.meshphysical_vert,
            fragmentShader: El.meshphysical_frag
        }, zl.prototype = (0, s.default)(gr.prototype), zl.prototype.constructor = zl, zl.prototype.isCubeTexture = !0, (0, y.default)(zl.prototype, "images", {
            get: function () {
                return this.image
            },
            set: function (e) {
                this.image = e
            }
        }), Vl.prototype = (0, s.default)(gr.prototype), Vl.prototype.constructor = Vl, Vl.prototype.isDataTexture2DArray = !0, Hl.prototype = (0, s.default)(gr.prototype), Hl.prototype.constructor = Hl, Hl.prototype.isDataTexture3D = !0;
        var Wl = new gr,
            jl = new Vl,
            Yl = new Hl,
            ql = new zl,
            Xl = [],
            Zl = [],
            Jl = new Float32Array(16),
            Kl = new Float32Array(9),
            Ql = new Float32Array(4);

        function $l(e, t, n) {
            var r = e[0];
            if (r <= 0 || 0 < r) return e;
            var i = t * n,
                a = Xl[i];
            if (void 0 === a && (a = new Float32Array(i), Xl[i] = a), 0 !== t) {
                r.toArray(a, 0);
                for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
            }
            return a
        }

        function eu(e, t) {
            if (e.length !== t.length) return !1;
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function tu(e, t) {
            for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
        }

        function nu(e, t) {
            var n = Zl[t];
            void 0 === n && (n = new Int32Array(t), Zl[t] = n);
            for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
            return n
        }

        function ru(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
        }

        function iu(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (eu(n, t)) return;
                e.uniform2fv(this.addr, t), tu(n, t)
            }
        }

        function au(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (eu(n, t)) return;
                e.uniform3fv(this.addr, t), tu(n, t)
            }
        }

        function ou(e, t) {
            var n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (eu(n, t)) return;
                e.uniform4fv(this.addr, t), tu(n, t)
            }
        }

        function su(e, t) {
            var n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (eu(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), tu(n, t)
            } else {
                if (eu(n, r)) return;
                Ql.set(r), e.uniformMatrix2fv(this.addr, !1, Ql), tu(n, r)
            }
        }

        function lu(e, t) {
            var n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (eu(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), tu(n, t)
            } else {
                if (eu(n, r)) return;
                Kl.set(r), e.uniformMatrix3fv(this.addr, !1, Kl), tu(n, r)
            }
        }

        function uu(e, t) {
            var n = this.cache,
                r = t.elements;
            if (void 0 === r) {
                if (eu(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), tu(n, t)
            } else {
                if (eu(n, r)) return;
                Jl.set(r), e.uniformMatrix4fv(this.addr, !1, Jl), tu(n, r)
            }
        }

        function hu(e, t, n) {
            var r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || Wl, i)
        }

        function cu(e, t, n) {
            var r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || jl, i)
        }

        function du(e, t, n) {
            var r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Yl, i)
        }

        function fu(e, t, n) {
            var r = this.cache,
                i = n.allocateTextureUnit();
            r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || ql, i)
        }

        function pu(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
        }

        function gu(e, t) {
            var n = this.cache;
            eu(n, t) || (e.uniform2iv(this.addr, t), tu(n, t))
        }

        function mu(e, t) {
            var n = this.cache;
            eu(n, t) || (e.uniform3iv(this.addr, t), tu(n, t))
        }

        function vu(e, t) {
            var n = this.cache;
            eu(n, t) || (e.uniform4iv(this.addr, t), tu(n, t))
        }

        function yu(e, t) {
            var n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
        }

        function _u(e) {
            switch (e) {
                case 5126:
                    return ru;
                case 35664:
                    return iu;
                case 35665:
                    return au;
                case 35666:
                    return ou;
                case 35674:
                    return su;
                case 35675:
                    return lu;
                case 35676:
                    return uu;
                case 5124:
                case 35670:
                    return pu;
                case 35667:
                case 35671:
                    return gu;
                case 35668:
                case 35672:
                    return mu;
                case 35669:
                case 35673:
                    return vu;
                case 5125:
                    return yu;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return hu;
                case 35679:
                case 36299:
                case 36307:
                    return du;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return fu;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                    return cu
            }
        }

        function Au(e, t) {
            e.uniform1fv(this.addr, t)
        }

        function xu(e, t) {
            e.uniform1iv(this.addr, t)
        }

        function Cu(e, t) {
            e.uniform2iv(this.addr, t)
        }

        function Iu(e, t) {
            e.uniform3iv(this.addr, t)
        }

        function wu(e, t) {
            e.uniform4iv(this.addr, t)
        }

        function Mu(e, t) {
            var n = $l(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }

        function bu(e, t) {
            var n = $l(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }

        function Su(e, t) {
            var n = $l(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }

        function Eu(e, t) {
            var n = $l(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }

        function Tu(e, t) {
            var n = $l(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }

        function Lu(e, t) {
            var n = $l(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }

        function Nu(e, t, n) {
            var r = t.length,
                i = nu(n, r);
            e.uniform1iv(this.addr, i);
            for (var a = 0; a !== r; ++a) n.safeSetTexture2D(t[a] || Wl, i[a])
        }

        function Ru(e, t, n) {
            var r = t.length,
                i = nu(n, r);
            e.uniform1iv(this.addr, i);
            for (var a = 0; a !== r; ++a) n.safeSetTextureCube(t[a] || ql, i[a])
        }

        function ku(e) {
            switch (e) {
                case 5126:
                    return Au;
                case 35664:
                    return Mu;
                case 35665:
                    return bu;
                case 35666:
                    return Su;
                case 35674:
                    return Eu;
                case 35675:
                    return Tu;
                case 35676:
                    return Lu;
                case 5124:
                case 35670:
                    return xu;
                case 35667:
                case 35671:
                    return Cu;
                case 35668:
                case 35672:
                    return Iu;
                case 35669:
                case 35673:
                    return wu;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                    return Nu;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                    return Ru
            }
        }

        function Pu(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.setValue = _u(t.type)
        }

        function Du(e, t, n) {
            this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = ku(t.type)
        }

        function Ou(e) {
            this.id = e, this.seq = [], this.map = {}
        }
        Du.prototype.updateCache = function (e) {
            var t = this.cache;
            e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), tu(t, e)
        }, Ou.prototype.setValue = function (e, t, n) {
            for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                var o = r[i];
                o.setValue(e, t[o.id], n)
            }
        };
        var Fu = /([\w\d_]+)(\])?(\[|\.)?/g;

        function Bu(e, t) {
            e.seq.push(t), e.map[t.id] = t
        }

        function Gu(e, t, n) {
            var r = e.name,
                i = r.length;
            for (Fu.lastIndex = 0;;) {
                var a = Fu.exec(r),
                    o = Fu.lastIndex,
                    s = a[1],
                    l = "]" === a[2],
                    u = a[3];
                if (l && (s |= 0), void 0 === u || "[" === u && o + 2 === i) {
                    Bu(n, new(void 0 === u ? Pu : Du)(s, e, t));
                    break
                }
                var h = n.map,
                    c = h[s];
                void 0 === c && (c = new Ou(s), Bu(n, c)), n = c
            }
        }

        function Uu(e, t) {
            this.seq = [], this.map = {};
            for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) {
                var i = e.getActiveUniform(t, r),
                    a = e.getUniformLocation(t, i.name);
                Gu(i, a, this)
            }
        }

        function zu(e, t, n) {
            var r = e.createShader(t);
            return e.shaderSource(r, n), e.compileShader(r), r
        }
        Uu.prototype.setValue = function (e, t, n, r) {
            var i = this.map[t];
            void 0 !== i && i.setValue(e, n, r)
        }, Uu.prototype.setOptional = function (e, t, n) {
            var r = t[n];
            void 0 !== r && this.setValue(e, n, r)
        }, Uu.upload = function (e, t, n, r) {
            for (var i = 0, a = t.length; i !== a; ++i) {
                var o = t[i],
                    s = n[o.id];
                !1 !== s.needsUpdate && o.setValue(e, s.value, r)
            }
        }, Uu.seqWithValue = function (e, t) {
            for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                var a = e[r];
                a.id in t && n.push(a)
            }
            return n
        };
        var Vu = 0;

        function Hu(e) {
            for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
            return t.join("\n")
        }

        function Wu(e) {
            switch (e) {
                case In:
                    return ["Linear", "( value )"];
                case wn:
                    return ["sRGB", "( value )"];
                case bn:
                    return ["RGBE", "( value )"];
                case En:
                    return ["RGBM", "( value, 7.0 )"];
                case Tn:
                    return ["RGBM", "( value, 16.0 )"];
                case Ln:
                    return ["RGBD", "( value, 256.0 )"];
                case Mn:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case Sn:
                    return ["LogLuv", "( value )"];
                default:
                    throw new Error("unsupported encoding: " + e)
            }
        }

        function ju(e, t, n) {
            var r = e.getShaderParameter(t, 35713),
                i = e.getShaderInfoLog(t).trim();
            if (r && "" === i) return "";
            var a = e.getShaderSource(t);
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + Hu(a)
        }

        function Yu(e, t) {
            var n = Wu(t);
            return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function qu(e, t) {
            var n = Wu(t);
            return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function Xu(e, t) {
            var n;
            switch (t) {
                case $e:
                    n = "Linear";
                    break;
                case G:
                    n = "Reinhard";
                    break;
                case U:
                    n = "Uncharted2";
                    break;
                case z:
                    n = "OptimizedCineon";
                    break;
                case V:
                    n = "ACESFilmic";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + t)
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Zu(e) {
            var t = [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
            return t.filter(Qu).join("\n")
        }

        function Ju(e) {
            var t = [];
            for (var n in e) {
                var r = e[n];
                !1 !== r && t.push("#define " + n + " " + r)
            }
            return t.join("\n")
        }

        function Ku(e, t) {
            for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) {
                var a = e.getActiveAttrib(t, i),
                    o = a.name;
                n[o] = e.getAttribLocation(t, o)
            }
            return n
        }

        function Qu(e) {
            return "" !== e
        }

        function $u(e, t) {
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }

        function eh(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        var th = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function nh(e) {
            return e.replace(th, rh)
        }

        function rh(e, t) {
            var n = El[t];
            if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
            return nh(n)
        }
        var ih = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            ah = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

        function oh(e) {
            return e.replace(ah, lh).replace(ih, sh)
        }

        function sh(e, t, n, r) {
            return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), lh(e, t, n, r)
        }

        function lh(e, t, n, r) {
            for (var i = "", a = (0, m.default)(t); a < (0, m.default)(n); a++) i += r.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
            return i
        }

        function uh(e) {
            var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
        }

        function hh(e) {
            var t = "SHADOWMAP_TYPE_BASIC";
            return e.shadowMapType === N ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === T ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === R && (t = "SHADOWMAP_TYPE_VSM"), t
        }

        function ch(e) {
            var t = "ENVMAP_TYPE_CUBE";
            if (e.envMap) switch (e.envMapMode) {
                case W:
                case j:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case Z:
                case J:
                    t = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case Y:
                case q:
                    t = "ENVMAP_TYPE_EQUIREC";
                    break;
                case X:
                    t = "ENVMAP_TYPE_SPHERE"
            }
            return t
        }

        function dh(e) {
            var t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap) switch (e.envMapMode) {
                case j:
                case q:
                    t = "ENVMAP_MODE_REFRACTION"
            }
            return t
        }

        function fh(e) {
            var t = "ENVMAP_BLENDING_NONE";
            if (e.envMap) switch (e.combine) {
                case D:
                    t = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case O:
                    t = "ENVMAP_BLENDING_MIX";
                    break;
                case F:
                    t = "ENVMAP_BLENDING_ADD"
            }
            return t
        }

        function ph(e, t, n) {
            var r, i, a = e.getContext(),
                o = n.defines,
                s = n.vertexShader,
                l = n.fragmentShader,
                u = hh(n),
                h = ch(n),
                c = dh(n),
                d = fh(n),
                f = 0 < e.gammaFactor ? e.gammaFactor : 1,
                p = n.isWebGL2 ? "" : Zu(n),
                g = Ju(o),
                m = a.createProgram();
            if (n.isRawShaderMaterial ? (r = [g].filter(Qu).join("\n"), 0 < r.length && (r += "\n"), i = [p, g].filter(Qu).join("\n"), 0 < i.length && (i += "\n")) : (r = [uh(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + f, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.mapMixColor ? "#define USE_MAP_MIXCOLOR" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qu).join("\n"), i = [p, uh(n), "#define SHADER_NAME " + n.shaderName, g, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.mapMixColor ? "#define USE_MAP_MIXCOLOR" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== B ? "#define TONE_MAPPING" : "", n.toneMapping !== B ? El.tonemapping_pars_fragment : "", n.toneMapping !== B ? Xu("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? El.encodings_pars_fragment : "", n.mapEncoding ? Yu("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? Yu("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? Yu("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Yu("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? Yu("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? qu("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qu).join("\n")), s = nh(s), s = $u(s, n), s = eh(s, n), l = nh(l), l = $u(l, n), l = eh(l, n), s = oh(s), l = oh(l), n.isWebGL2 && !n.isRawShaderMaterial) {
                var v = !1,
                    y = /^\s*#version\s+300\s+es\s*\n/;
                n.isShaderMaterial && null !== s.match(y) && null !== l.match(y) && (v = !0, s = s.replace(y, ""), l = l.replace(y, "")), r = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + r, i = ["#version 300 es\n", "#define varying in", v ? "" : "out highp vec4 pc_fragColor;", v ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + i
            }
            var _, A, x = r + s,
                C = i + l,
                I = zu(a, 35633, x),
                w = zu(a, 35632, C);
            if (a.attachShader(m, I), a.attachShader(m, w), void 0 !== n.index0AttributeName ? a.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(m, 0, "position"), a.linkProgram(m), e.debug.checkShaderErrors) {
                var M = a.getProgramInfoLog(m).trim(),
                    b = a.getShaderInfoLog(I).trim(),
                    S = a.getShaderInfoLog(w).trim(),
                    E = !0,
                    T = !0;
                if (!1 === a.getProgramParameter(m, 35714)) {
                    E = !1;
                    var L = ju(a, I, "vertex"),
                        N = ju(a, w, "fragment");
                    console.error("THREE.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(m, 35715), "gl.getProgramInfoLog", M, L, N)
                } else "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== b && "" !== S || (T = !1);
                T && (this.diagnostics = {
                    runnable: E,
                    programLog: M,
                    vertexShader: {
                        log: b,
                        prefix: r
                    },
                    fragmentShader: {
                        log: S,
                        prefix: i
                    }
                })
            }
            return a.detachShader(m, I), a.detachShader(m, w), a.deleteShader(I), a.deleteShader(w), this.getUniforms = function () {
                return void 0 === _ && (_ = new Uu(a, m)), _
            }, this.getAttributes = function () {
                return void 0 === A && (A = Ku(a, m)), A
            }, this.destroy = function () {
                a.deleteProgram(m), this.program = void 0
            }, this.name = n.shaderName, this.id = Vu++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = I, this.fragmentShader = w, this
        }

        function gh(g, m, v) {
            var o = [],
                y = v.isWebGL2,
                _ = v.logarithmicDepthBuffer,
                A = v.floatVertexTextures,
                x = v.precision,
                s = v.maxVertexUniforms,
                C = v.vertexTextures,
                I = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                i = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapMixColor", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

            function w(e, t) {
                var n;
                if (t) {
                    var r = Tl[t];
                    n = {
                        name: e.type,
                        uniforms: Ha.clone(r.uniforms),
                        vertexShader: r.vertexShader,
                        fragmentShader: r.fragmentShader
                    }
                } else n = {
                    name: e.type,
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                };
                return n
            }

            function M(e) {
                var t = e.skeleton,
                    n = t.bones;
                if (A) return 1024;
                var r = s,
                    i = Math.floor((r - 20) / 4),
                    a = Math.min(i, n.length);
                return a < n.length ? 0 : a
            }

            function b(e) {
                var t;
                return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = In, t
            }
            this.getParameters = function (e, t, n, r, i, a, o) {
                var s = r.fog,
                    l = e.isMeshStandardMaterial ? r.environment : null,
                    u = e.envMap || l,
                    h = I[e.type],
                    c = o.isSkinnedMesh ? M(o) : 0;
                null !== e.precision && (x = v.getMaxPrecision(e.precision), x !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", x, "instead."));
                var d = w(e, h);
                e.onBeforeCompile(d, g);
                var f = g.getRenderTarget(),
                    p = {
                        isWebGL2: y,
                        shaderID: h,
                        shaderName: d.name,
                        uniforms: d.uniforms,
                        vertexShader: d.vertexShader,
                        fragmentShader: d.fragmentShader,
                        defines: e.defines,
                        isRawShaderMaterial: e.isRawShaderMaterial,
                        isShaderMaterial: e.isShaderMaterial,
                        precision: x,
                        instancing: !0 === o.isInstancedMesh,
                        supportsVertexTextures: C,
                        outputEncoding: null !== f ? b(f.texture) : g.outputEncoding,
                        map: !!e.map,
                        mapMixColor: !!e.mapMixColor,
                        mapEncoding: b(e.map),
                        matcap: !!e.matcap,
                        matcapEncoding: b(e.matcap),
                        envMap: !!u,
                        envMapMode: u && u.mapping,
                        envMapEncoding: b(u),
                        envMapCubeUV: !!u && (u.mapping === Z || u.mapping === J),
                        lightMap: !!e.lightMap,
                        lightMapEncoding: b(e.lightMap),
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: b(e.emissiveMap),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === Pn,
                        tangentSpaceNormalMap: e.normalMapType === kn,
                        clearcoatMap: !!e.clearcoatMap,
                        clearcoatRoughnessMap: !!e.clearcoatRoughnessMap,
                        clearcoatNormalMap: !!e.clearcoatNormalMap,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        sheen: !!e.sheen,
                        combine: e.combine,
                        vertexTangents: e.normalMap && e.vertexTangents,
                        vertexColors: e.vertexColors,
                        vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatMap || e.clearcoatRoughnessMap || e.clearcoatNormalMap || e.displacementMap),
                        uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || !e.displacementMap),
                        fog: !!s,
                        useFog: e.fog,
                        fogExp2: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: _,
                        skinning: e.skinning && 0 < c,
                        maxBones: c,
                        useVertexTexture: A,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: g.maxMorphTargets,
                        maxMorphNormals: g.maxMorphNormals,
                        numDirLights: t.directional.length,
                        numPointLights: t.point.length,
                        numSpotLights: t.spot.length,
                        numRectAreaLights: t.rectArea.length,
                        numHemiLights: t.hemi.length,
                        numDirLightShadows: t.directionalShadowMap.length,
                        numPointLightShadows: t.pointShadowMap.length,
                        numSpotLightShadows: t.spotShadowMap.length,
                        numClippingPlanes: i,
                        numClipIntersection: a,
                        dithering: e.dithering,
                        shadowMapEnabled: g.shadowMap.enabled && 0 < n.length,
                        shadowMapType: g.shadowMap.type,
                        toneMapping: e.toneMapped ? g.toneMapping : B,
                        physicallyCorrectLights: g.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === _e,
                        flipSided: e.side === je,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking,
                        index0AttributeName: e.index0AttributeName,
                        extensionDerivatives: e.extensions && e.extensions.derivatives,
                        extensionFragDepth: e.extensions && e.extensions.fragDepth,
                        extensionDrawBuffers: e.extensions && e.extensions.drawBuffers,
                        extensionShaderTextureLOD: e.extensions && e.extensions.shaderTextureLOD,
                        rendererExtensionFragDepth: y || null !== m.get("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: y || null !== m.get("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: y || null !== m.get("EXT_shader_texture_lod"),
                        onBeforeCompile: e.onBeforeCompile
                    };
                return p
            }, this.getProgramCacheKey = function (e) {
                var t = [];
                if (e.shaderID ? t.push(e.shaderID) : (t.push(e.fragmentShader), t.push(e.vertexShader)), void 0 !== e.defines)
                    for (var n in e.defines) t.push(n), t.push(e.defines[n]);
                if (void 0 === e.isRawShaderMaterial) {
                    for (var r = 0; r < i.length; r++) t.push(e[i[r]]);
                    t.push(g.outputEncoding), t.push(g.gammaFactor)
                }
                return t.push(e.onBeforeCompile.toString()), t.join()
            }, this.acquireProgram = function (e, t) {
                for (var n, r = 0, i = o.length; r < i; r++) {
                    var a = o[r];
                    if (a.cacheKey === t) {
                        n = a, ++n.usedTimes;
                        break
                    }
                }
                return void 0 === n && (n = new ph(g, t, e), o.push(n)), n
            }, this.releaseProgram = function (e) {
                if (0 == --e.usedTimes) {
                    var t = o.indexOf(e);
                    o[t] = o[o.length - 1], o.pop(), e.destroy()
                }
            }, this.programs = o
        }

        function mh() {
            var r = new te.default;

            function e(e) {
                var t = r.get(e);
                return void 0 === t && (t = {}, r.set(e, t)), t
            }

            function t(e) {
                r.delete(e)
            }

            function n(e, t, n) {
                r.get(e)[t] = n
            }

            function i() {
                r = new te.default
            }
            return {
                get: e,
                remove: t,
                update: n,
                dispose: i
            }
        }

        function vh(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function yh(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function _h() {
            var s = [],
                l = 0,
                u = [],
                h = [],
                c = {
                    id: -1
                };

            function e() {
                l = 0, u.length = 0, h.length = 0
            }

            function d(e, t, n, r, i, a) {
                var o = s[l];
                return void 0 === o ? (o = {
                    id: e.id,
                    object: e,
                    geometry: t,
                    material: n,
                    program: n.program || c,
                    groupOrder: r,
                    renderOrder: e.renderOrder,
                    z: i,
                    group: a
                }, s[l] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = n, o.program = n.program || c, o.groupOrder = r, o.renderOrder = e.renderOrder, o.z = i, o.group = a), l++, o
            }

            function t(e, t, n, r, i, a) {
                var o = d(e, t, n, r, i, a);
                (!0 === n.transparent ? h : u).push(o)
            }

            function n(e, t, n, r, i, a) {
                var o = d(e, t, n, r, i, a);
                (!0 === n.transparent ? h : u).unshift(o)
            }

            function r(e, t) {
                1 < u.length && u.sort(e || vh), 1 < h.length && h.sort(t || yh)
            }

            function i() {
                for (var e = l, t = s.length; e < t; e++) {
                    var n = s[e];
                    if (null === n.id) break;
                    n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                }
            }
            return {
                opaque: u,
                transparent: h,
                init: e,
                push: t,
                unshift: n,
                finish: i,
                sort: r
            }
        }

        function Ah() {
            var i = new te.default;

            function a(e) {
                var t = e.target;
                t.removeEventListener("dispose", a), i.delete(t)
            }

            function e(e, t) {
                var n, r = i.get(e);
                return void 0 === r ? (n = new _h, i.set(e, new te.default), i.get(e).set(t, n), e.addEventListener("dispose", a)) : (n = r.get(t), void 0 === n && (n = new _h, r.set(t, n))), n
            }

            function t() {
                i = new te.default
            }
            return {
                get: e,
                dispose: t
            }
        }

        function xh() {
            var n = {};
            return {
                get: function (e) {
                    if (void 0 !== n[e.id]) return n[e.id];
                    var t;
                    switch (e.type) {
                        case "DirectionalLight":
                            t = {
                                direction: new Cr,
                                color: new Gi
                            };
                            break;
                        case "SpotLight":
                            t = {
                                position: new Cr,
                                direction: new Cr,
                                color: new Gi,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            t = {
                                position: new Cr,
                                color: new Gi,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            t = {
                                direction: new Cr,
                                skyColor: new Gi,
                                groundColor: new Gi
                            };
                            break;
                        case "RectAreaLight":
                            t = {
                                color: new Gi,
                                position: new Cr,
                                halfWidth: new Cr,
                                halfHeight: new Cr
                            }
                    }
                    return n[e.id] = t, t
                }
            }
        }

        function Ch() {
            var n = {};
            return {
                get: function (e) {
                    if (void 0 !== n[e.id]) return n[e.id];
                    var t;
                    switch (e.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            t = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new cr
                            };
                            break;
                        case "PointLight":
                            t = {
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new cr,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                    }
                    return n[e.id] = t, t
                }
            }
        }
        var Ih = 0;

        function wh(e, t) {
            return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
        }

        function Mh() {
            for (var S = new xh, E = Ch(), T = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: []
                }, e = 0; e < 9; e++) T.probe.push(new Cr);
            var L = new Cr,
                N = new Lr,
                R = new Lr;

            function t(e, t, n) {
                for (var r = 0, i = 0, a = 0, o = 0; o < 9; o++) T.probe[o].set(0, 0, 0);
                var s = 0,
                    l = 0,
                    u = 0,
                    h = 0,
                    c = 0,
                    d = 0,
                    f = 0,
                    p = 0,
                    g = n.matrixWorldInverse;
                e.sort(wh), o = 0;
                for (var m = e.length; o < m; o++) {
                    var v = e[o],
                        y = v.color,
                        _ = v.intensity,
                        A = v.distance,
                        x = v.shadow && v.shadow.map ? v.shadow.map.texture : null;
                    if (v.isAmbientLight) r += y.r * _, i += y.g * _, a += y.b * _;
                    else if (v.isLightProbe)
                        for (var C = 0; C < 9; C++) T.probe[C].addScaledVector(v.sh.coefficients[C], _);
                    else if (v.isDirectionalLight) {
                        var I = S.get(v);
                        if (I.color.copy(v.color).multiplyScalar(v.intensity), I.direction.setFromMatrixPosition(v.matrixWorld), L.setFromMatrixPosition(v.target.matrixWorld), I.direction.sub(L), I.direction.transformDirection(g), v.castShadow) {
                            var w = v.shadow,
                                M = E.get(v);
                            M.shadowBias = w.bias, M.shadowRadius = w.radius, M.shadowMapSize = w.mapSize, T.directionalShadow[s] = M, T.directionalShadowMap[s] = x, T.directionalShadowMatrix[s] = v.shadow.matrix, d++
                        }
                        T.directional[s] = I, s++
                    } else v.isSpotLight ? (I = S.get(v), I.position.setFromMatrixPosition(v.matrixWorld), I.position.applyMatrix4(g), I.color.copy(y).multiplyScalar(_), I.distance = A, I.direction.setFromMatrixPosition(v.matrixWorld), L.setFromMatrixPosition(v.target.matrixWorld), I.direction.sub(L), I.direction.transformDirection(g), I.coneCos = Math.cos(v.angle), I.penumbraCos = Math.cos(v.angle * (1 - v.penumbra)), I.decay = v.decay, v.castShadow && (w = v.shadow, M = E.get(v), M.shadowBias = w.bias, M.shadowRadius = w.radius, M.shadowMapSize = w.mapSize, T.spotShadow[u] = M, T.spotShadowMap[u] = x, T.spotShadowMatrix[u] = v.shadow.matrix, p++), T.spot[u] = I, u++) : v.isRectAreaLight ? (I = S.get(v), I.color.copy(y).multiplyScalar(_), I.position.setFromMatrixPosition(v.matrixWorld), I.position.applyMatrix4(g), R.identity(), N.copy(v.matrixWorld), N.premultiply(g), R.extractRotation(N), I.halfWidth.set(.5 * v.width, 0, 0), I.halfHeight.set(0, .5 * v.height, 0), I.halfWidth.applyMatrix4(R), I.halfHeight.applyMatrix4(R), T.rectArea[h] = I, h++) : v.isPointLight ? (I = S.get(v), I.position.setFromMatrixPosition(v.matrixWorld), I.position.applyMatrix4(g), I.color.copy(v.color).multiplyScalar(v.intensity), I.distance = v.distance, I.decay = v.decay, v.castShadow && (w = v.shadow, M = E.get(v), M.shadowBias = w.bias, M.shadowRadius = w.radius, M.shadowMapSize = w.mapSize, M.shadowCameraNear = w.camera.near, M.shadowCameraFar = w.camera.far, T.pointShadow[l] = M, T.pointShadowMap[l] = x, T.pointShadowMatrix[l] = v.shadow.matrix, f++), T.point[l] = I, l++) : v.isHemisphereLight && (I = S.get(v), I.direction.setFromMatrixPosition(v.matrixWorld), I.direction.transformDirection(g), I.direction.normalize(), I.skyColor.copy(v.color).multiplyScalar(_), I.groundColor.copy(v.groundColor).multiplyScalar(_), T.hemi[c] = I, c++)
                }
                T.ambient[0] = r, T.ambient[1] = i, T.ambient[2] = a;
                var b = T.hash;
                b.directionalLength === s && b.pointLength === l && b.spotLength === u && b.rectAreaLength === h && b.hemiLength === c && b.numDirectionalShadows === d && b.numPointShadows === f && b.numSpotShadows === p || (T.directional.length = s, T.spot.length = u, T.rectArea.length = h, T.point.length = l, T.hemi.length = c, T.directionalShadow.length = d, T.directionalShadowMap.length = d, T.pointShadow.length = f, T.pointShadowMap.length = f, T.spotShadow.length = p, T.spotShadowMap.length = p, T.directionalShadowMatrix.length = d, T.pointShadowMatrix.length = f, T.spotShadowMatrix.length = p, b.directionalLength = s, b.pointLength = l, b.spotLength = u, b.rectAreaLength = h, b.hemiLength = c, b.numDirectionalShadows = d, b.numPointShadows = f, b.numSpotShadows = p, T.version = Ih++)
            }
            return {
                setup: t,
                state: T
            }
        }

        function bh() {
            var t = new Mh,
                n = [],
                r = [];

            function e() {
                n.length = 0, r.length = 0
            }

            function i(e) {
                n.push(e)
            }

            function a(e) {
                r.push(e)
            }

            function o(e) {
                t.setup(n, r, e)
            }
            var s = {
                lightsArray: n,
                shadowsArray: r,
                lights: t
            };
            return {
                init: e,
                state: s,
                setupLights: o,
                pushLight: i,
                pushShadow: a
            }
        }

        function Sh() {
            var r = new te.default;

            function i(e) {
                var t = e.target;
                t.removeEventListener("dispose", i), r.delete(t)
            }

            function e(e, t) {
                var n;
                return !1 === r.has(e) ? (n = new bh, r.set(e, new te.default), r.get(e).set(t, n), e.addEventListener("dispose", i)) : !1 === r.get(e).has(t) ? (n = new bh, r.get(e).set(t, n)) : n = r.get(e).get(t), n
            }

            function t() {
                r = new te.default
            }
            return {
                get: e,
                dispose: t
            }
        }

        function Eh(e) {
            ji.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Nn, this.skinning = !1, this.morphTargets = !1, this.map = null, this.mapMixColor = !1, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
        }

        function Th(e) {
            ji.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Cr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
        }
        Eh.prototype = (0, s.default)(ji.prototype), Eh.prototype.constructor = Eh, Eh.prototype.isMeshDepthMaterial = !0, Eh.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
        }, Th.prototype = (0, s.default)(ji.prototype), Th.prototype.constructor = Th, Th.prototype.isMeshDistanceMaterial = !0, Th.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
        };
        var Lh = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            Nh = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

        function Rh(v, y, m) {
            var _ = new no,
                A = new cr,
                x = new cr,
                C = new mr,
                a = [],
                o = [],
                I = {},
                w = {
                    0: je,
                    1: k,
                    2: _e
                },
                r = new Ya({
                    defines: {
                        SAMPLE_RATE: .25,
                        HALF_SAMPLE_RATE: 1 / 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new cr
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: Nh,
                    fragmentShader: Lh
                }),
                i = r.clone();
            i.defines.HORIZONAL_PASS = 1;
            var e = new fa;
            e.setAttribute("position", new Xi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            var s = new Na(e, r),
                M = this;

            function b(e, t) {
                var n = y.update(s);
                r.uniforms.shadow_pass.value = e.map.texture, r.uniforms.resolution.value = e.mapSize, r.uniforms.radius.value = e.radius, v.setRenderTarget(e.mapPass), v.clear(), v.renderBufferDirect(t, null, n, r, s, null), i.uniforms.shadow_pass.value = e.mapPass.texture, i.uniforms.resolution.value = e.mapSize, i.uniforms.radius.value = e.radius, v.setRenderTarget(e.map), v.clear(), v.renderBufferDirect(t, null, n, i, s, null)
            }

            function S(e, t, n) {
                var r = e << 0 | t << 1 | n << 2,
                    i = a[r];
                return void 0 === i && (i = new Eh({
                    depthPacking: Rn,
                    morphTargets: e,
                    skinning: t
                }), a[r] = i), i
            }

            function E(e, t, n) {
                var r = e << 0 | t << 1 | n << 2,
                    i = o[r];
                return void 0 === i && (i = new Th({
                    morphTargets: e,
                    skinning: t
                }), o[r] = i), i
            }

            function T(e, t, n, r, i, a) {
                var o = e.geometry,
                    s = null,
                    l = S,
                    u = e.customDepthMaterial;
                if (!0 === n.isPointLight && (l = E, u = e.customDistanceMaterial), void 0 === u) {
                    var h = !1;
                    !0 === t.morphTargets && (!0 === o.isBufferGeometry ? h = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : !0 === o.isGeometry && (h = o.morphTargets && 0 < o.morphTargets.length));
                    var c = !1;
                    !0 === e.isSkinnedMesh && (!0 === t.skinning ? c = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                    var d = !0 === e.isInstancedMesh;
                    s = l(h, c, d)
                } else s = u;
                if (v.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) {
                    var f = s.uuid,
                        p = t.uuid,
                        g = I[f];
                    void 0 === g && (g = {}, I[f] = g);
                    var m = g[p];
                    void 0 === m && (m = s.clone(), g[p] = m), s = m
                }
                return s.visible = t.visible, s.wireframe = t.wireframe, s.side = a === R ? null !== t.shadowSide ? t.shadowSide : t.side : null !== t.shadowSide ? t.shadowSide : w[t.side], s.clipShadows = t.clipShadows, s.clippingPlanes = t.clippingPlanes, s.clipIntersection = t.clipIntersection, s.wireframeLinewidth = t.wireframeLinewidth, s.linewidth = t.linewidth, !0 === n.isPointLight && !0 === s.isMeshDistanceMaterial && (s.referencePosition.setFromMatrixPosition(n.matrixWorld), s.nearDistance = r, s.farDistance = i), s
            }

            function L(e, t, n, r, i) {
                if (!1 !== e.visible) {
                    var a = e.layers.test(t.layers);
                    if (a && (e.isMesh || e.isLine || e.isPoints) && (e.castShadow || e.receiveShadow && i === R) && (!e.frustumCulled || _.intersectsObject(e))) {
                        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld);
                        var o = y.update(e),
                            s = e.material;
                        if ((0, He.default)(s))
                            for (var l = o.groups, u = 0, h = l.length; u < h; u++) {
                                var c = l[u],
                                    d = s[c.materialIndex];
                                if (d && d.visible) {
                                    var f = T(e, d, r, n.near, n.far, i);
                                    v.renderBufferDirect(n, null, o, f, e, c)
                                }
                            } else s.visible && (f = T(e, s, r, n.near, n.far, i), v.renderBufferDirect(n, null, o, f, e, null))
                    }
                    for (var p = e.children, g = 0, m = p.length; g < m; g++) L(p[g], t, n, r, i)
                }
            }
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = N, this.render = function (e, t, n) {
                if (!1 !== M.enabled && (!1 !== M.autoUpdate || !1 !== M.needsUpdate) && 0 !== e.length) {
                    var r = v.getRenderTarget(),
                        i = v.getActiveCubeFace(),
                        a = v.getActiveMipmapLevel(),
                        o = v.state;
                    o.setBlending(Ae), o.buffers.color.setClear(1, 1, 1, 1), o.buffers.depth.setTest(!0), o.setScissorTest(!1);
                    for (var s = 0, l = e.length; s < l; s++) {
                        var u = e[s],
                            h = u.shadow;
                        if (void 0 !== h) {
                            A.copy(h.mapSize);
                            var c = h.getFrameExtents();
                            if (A.multiply(c), x.copy(h.mapSize), (A.x > m || A.y > m) && (console.warn("THREE.WebGLShadowMap:", u, "has shadow exceeding max texture size, reducing"), A.x > m && (x.x = Math.floor(m / c.x), A.x = x.x * c.x, h.mapSize.x = x.x), A.y > m && (x.y = Math.floor(m / c.y), A.y = x.y * c.y, h.mapSize.y = x.y)), null === h.map && !h.isPointLightShadow && this.type === R) {
                                var d = {
                                    minFilter: ue,
                                    magFilter: ue,
                                    format: dt
                                };
                                h.map = new vr(A.x, A.y, d), h.map.texture.name = u.name + ".shadowMap", h.mapPass = new vr(A.x, A.y, d), h.camera.updateProjectionMatrix()
                            }
                            null === h.map && (d = {
                                minFilter: oe,
                                magFilter: oe,
                                format: dt
                            }, h.map = new vr(A.x, A.y, d), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix()), v.setRenderTarget(h.map), v.clear();
                            for (var f = h.getViewportCount(), p = 0; p < f; p++) {
                                var g = h.getViewport(p);
                                C.set(x.x * g.x, x.y * g.y, x.x * g.z, x.y * g.w), o.viewport(C), h.updateMatrices(u, p), _ = h.getFrustum(), L(t, n, h.camera, u, this.type)
                            }
                            h.isPointLightShadow || this.type !== R || b(h, n)
                        } else console.warn("THREE.WebGLShadowMap:", u, "has no shadow.")
                    }
                    M.needsUpdate = !1, v.setRenderTarget(r, i, a)
                }
            }
        }

        function kh(h, r, e) {
            var t, n, i = e.isWebGL2;

            function a() {
                var t = !1,
                    a = new mr,
                    n = null,
                    o = new mr(0, 0, 0, 0);
                return {
                    setMask: function (e) {
                        n === e || t || (h.colorMask(e, e, e, e), n = e)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e, t, n, r, i) {
                        !0 === i && (e *= r, t *= r, n *= r), a.set(e, t, n, r), !1 === o.equals(a) && (h.clearColor(e, t, n, r), o.copy(a))
                    },
                    reset: function () {
                        t = !1, n = null, o.set(-1, 0, 0, 0)
                    }
                }
            }

            function o() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null;
                return {
                    setTest: function (e) {
                        (e ? Y : q)(2929)
                    },
                    setMask: function (e) {
                        n === e || t || (h.depthMask(e), n = e)
                    },
                    setFunc: function (e) {
                        if (r !== e) {
                            if (e) switch (e) {
                                case Ve:
                                    h.depthFunc(512);
                                    break;
                                case Ye:
                                    h.depthFunc(519);
                                    break;
                                case qe:
                                    h.depthFunc(513);
                                    break;
                                case Xe:
                                    h.depthFunc(515);
                                    break;
                                case Ze:
                                    h.depthFunc(514);
                                    break;
                                case Je:
                                    h.depthFunc(518);
                                    break;
                                case Ke:
                                    h.depthFunc(516);
                                    break;
                                case Qe:
                                    h.depthFunc(517);
                                    break;
                                default:
                                    h.depthFunc(515)
                            } else h.depthFunc(515);
                            r = e
                        }
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e) {
                        i !== e && (h.clearDepth(e), i = e)
                    },
                    reset: function () {
                        t = !1, n = null, r = null, i = null
                    }
                }
            }

            function s() {
                var t = !1,
                    n = null,
                    r = null,
                    i = null,
                    a = null,
                    o = null,
                    s = null,
                    l = null,
                    u = null;
                return {
                    setTest: function (e) {
                        t || (e ? Y : q)(2960)
                    },
                    setMask: function (e) {
                        n === e || t || (h.stencilMask(e), n = e)
                    },
                    setFunc: function (e, t, n) {
                        r === e && i === t && a === n || (h.stencilFunc(e, t, n), r = e, i = t, a = n)
                    },
                    setOp: function (e, t, n) {
                        o === e && s === t && l === n || (h.stencilOp(e, t, n), o = e, s = t, l = n)
                    },
                    setLocked: function (e) {
                        t = e
                    },
                    setClear: function (e) {
                        u !== e && (h.clearStencil(e), u = e)
                    },
                    reset: function () {
                        t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, u = null
                    }
                }
            }
            var l = new a,
                u = new o,
                c = new s,
                d = h.getParameter(34921),
                f = new Uint8Array(d),
                p = new Uint8Array(d),
                g = new Uint8Array(d),
                m = {},
                v = null,
                y = null,
                _ = null,
                A = null,
                x = null,
                C = null,
                I = null,
                w = null,
                M = null,
                b = !1,
                S = null,
                E = null,
                T = null,
                L = null,
                N = null,
                R = h.getParameter(35661),
                k = !1,
                P = 0,
                D = h.getParameter(7938); - 1 !== D.indexOf("WebGL") ? (P = (0, ge.default)(/^WebGL\ ([0-9])/.exec(D)[1]), k = 1 <= P) : -1 !== D.indexOf("OpenGL ES") && (P = (0, ge.default)(/^OpenGL\ ES\ ([0-9])/.exec(D)[1]), k = 2 <= P);
            var O = null,
                F = {},
                B = new mr,
                G = new mr;

            function U(e, t, n) {
                var r = new Uint8Array(4),
                    i = h.createTexture();
                h.bindTexture(e, i), h.texParameteri(e, 10241, 9728), h.texParameteri(e, 10240, 9728);
                for (var a = 0; a < n; a++) h.texImage2D(t + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return i
            }
            var z = {};

            function V() {
                for (var e = 0, t = f.length; e < t; e++) f[e] = 0
            }

            function H(e) {
                W(e, 0)
            }

            function W(e, t) {
                if (f[e] = 1, 0 === p[e] && (h.enableVertexAttribArray(e), p[e] = 1), g[e] !== t) {
                    var n = i ? h : r.get("ANGLE_instanced_arrays");
                    n[i ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), g[e] = t
                }
            }

            function j() {
                for (var e = 0, t = p.length; e !== t; ++e) p[e] !== f[e] && (h.disableVertexAttribArray(e), p[e] = 0)
            }

            function Y(e) {
                !0 !== m[e] && (h.enable(e), m[e] = !0)
            }

            function q(e) {
                !1 !== m[e] && (h.disable(e), m[e] = !1)
            }

            function X(e) {
                return v !== e && (h.useProgram(e), v = e, !0)
            }
            z[3553] = U(3553, 3553, 1), z[34067] = U(34067, 34069, 6), l.setClear(0, 0, 0, 1), u.setClear(1), c.setClear(0), Y(2929), u.setFunc(Xe), ee(!1), te(ve), Y(2884), Q(Ae);
            var Z = (t = {}, (0, pe.default)(t, be, 32774), (0, pe.default)(t, Se, 32778), (0, pe.default)(t, Ee, 32779), t);
            if (i) Z[Te] = 32775, Z[Le] = 32776;
            else {
                var J = r.get("EXT_blend_minmax");
                null !== J && (Z[Te] = J.MIN_EXT, Z[Le] = J.MAX_EXT)
            }
            var K = (n = {}, (0, pe.default)(n, Ne, 0), (0, pe.default)(n, Re, 1), (0, pe.default)(n, ke, 768), (0, pe.default)(n, De, 770), (0, pe.default)(n, ze, 776), (0, pe.default)(n, Ge, 774), (0, pe.default)(n, Fe, 772), (0, pe.default)(n, Pe, 769), (0, pe.default)(n, Oe, 771), (0, pe.default)(n, Ue, 775), (0, pe.default)(n, Be, 773), n);

            function Q(e, t, n, r, i, a, o, s) {
                if (e !== Ae) {
                    if (y || (Y(3042), y = !0), e === Me) i = i || t, a = a || n, o = o || r, t === A && i === I || (h.blendEquationSeparate(Z[t], Z[i]), A = t, I = i), n === x && r === C && a === w && o === M || (h.blendFuncSeparate(K[n], K[r], K[a], K[o]), x = n, C = r, w = a, M = o), _ = e, b = null;
                    else if (e !== _ || s !== b) {
                        if (A === be && I === be || (h.blendEquation(32774), A = be, I = be), s) switch (e) {
                            case xe:
                                h.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Ce:
                                h.blendFunc(1, 1);
                                break;
                            case Ie:
                                h.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case we:
                                h.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case xe:
                                h.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Ce:
                                h.blendFunc(770, 1);
                                break;
                            case Ie:
                                h.blendFunc(0, 769);
                                break;
                            case we:
                                h.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        x = null, C = null, w = null, M = null, _ = e, b = s
                    }
                } else y && (q(3042), y = !1)
            }

            function $(e, t) {
                (e.side === _e ? q : Y)(2884);
                var n = e.side === je;
                t && (n = !n), ee(n), e.blending === xe && !1 === e.transparent ? Q(Ae) : Q(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), u.setFunc(e.depthFunc), u.setTest(e.depthTest), u.setMask(e.depthWrite), l.setMask(e.colorWrite);
                var r = e.stencilWrite;
                c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), re(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            }

            function ee(e) {
                S !== e && (e ? h.frontFace(2304) : h.frontFace(2305), S = e)
            }

            function te(e) {
                e !== me ? (Y(2884), e !== E && (e === ve ? h.cullFace(1029) : e === ye ? h.cullFace(1028) : h.cullFace(1032))) : q(2884), E = e
            }

            function ne(e) {
                e !== T && (k && h.lineWidth(e), T = e)
            }

            function re(e, t, n) {
                e ? (Y(32823), L === t && N === n || (h.polygonOffset(t, n), L = t, N = n)) : q(32823)
            }

            function ie(e) {
                (e ? Y : q)(3089)
            }

            function ae(e) {
                void 0 === e && (e = 33984 + R - 1), O !== e && (h.activeTexture(e), O = e)
            }

            function oe(e, t) {
                null === O && ae();
                var n = F[O];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, F[O] = n), n.type === e && n.texture === t || (h.bindTexture(e, t || z[e]), n.type = e, n.texture = t)
            }

            function se() {
                var e = F[O];
                void 0 !== e && void 0 !== e.type && (h.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            }

            function le() {
                try {
                    h.compressedTexImage2D.apply(h, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }

            function ue() {
                try {
                    h.texImage2D.apply(h, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }

            function he() {
                try {
                    h.texImage3D.apply(h, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }

            function ce(e) {
                !1 === B.equals(e) && (h.scissor(e.x, e.y, e.z, e.w), B.copy(e))
            }

            function de(e) {
                !1 === G.equals(e) && (h.viewport(e.x, e.y, e.z, e.w), G.copy(e))
            }

            function fe() {
                for (var e = 0; e < p.length; e++) 1 === p[e] && (h.disableVertexAttribArray(e), p[e] = 0);
                m = {}, O = null, F = {}, v = null, _ = null, S = null, E = null, l.reset(), u.reset(), c.reset()
            }
            return {
                buffers: {
                    color: l,
                    depth: u,
                    stencil: c
                },
                initAttributes: V,
                enableAttribute: H,
                enableAttributeAndDivisor: W,
                disableUnusedAttributes: j,
                enable: Y,
                disable: q,
                useProgram: X,
                setBlending: Q,
                setMaterial: $,
                setFlipSided: ee,
                setCullFace: te,
                setLineWidth: ne,
                setPolygonOffset: re,
                setScissorTest: ie,
                activeTexture: ae,
                bindTexture: oe,
                unbindTexture: se,
                compressedTexImage2D: le,
                texImage2D: ue,
                texImage3D: he,
                scissor: ce,
                viewport: de,
                reset: fe
            }
        }

        function Ph(m, i, v, y, a, _, c) {
            var e, t, h, A = a.isWebGL2,
                n = a.maxTextures,
                x = a.maxCubemapSize,
                p = a.maxTextureSize,
                r = a.maxSamples,
                o = new te.default,
                s = !1;
            try {
                s = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (e) {}

            function d(e, t) {
                return s ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function C(e, t, n, r) {
                var i = 1;
                if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        var a = t ? hr.floorPowerOfTwo : Math.floor,
                            o = a(i * e.width),
                            s = a(i * e.height);
                        void 0 === h && (h = d(o, s));
                        var l = n ? d(o, s) : h;
                        l.width = o, l.height = s;
                        var u = l.getContext("2d");
                        return u.drawImage(e, 0, 0, o, s), l
                    }
                    return e
                }
                return e
            }

            function I(e) {
                return hr.isPowerOfTwo(e.width) && hr.isPowerOfTwo(e.height)
            }

            function g(e) {
                return !A && (e.wrapS !== re || e.wrapT !== re || e.minFilter !== oe && e.minFilter !== ue)
            }

            function w(e, t) {
                return e.generateMipmaps && t && e.minFilter !== oe && e.minFilter !== ue
            }

            function M(e, t, n, r) {
                m.generateMipmap(e);
                var i = y.get(t);
                i.__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
            }

            function b(e, t, n) {
                if (!1 === A) return t;
                if (null !== e && void 0 !== m[e]) return m[e];
                var r = t;
                return 6403 === t && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === t && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === t && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r || i.get("EXT_color_buffer_float"), r
            }

            function l(e) {
                return e === oe || e === se || e === le ? 9728 : 9729
            }

            function u(e) {
                var t = e.target;
                t.removeEventListener("dispose", u), S(t), t.isVideoTexture && o.delete(t), c.memory.textures--
            }

            function f(e) {
                var t = e.target;
                t.removeEventListener("dispose", f), E(t), c.memory.textures--
            }

            function S(e) {
                var t = y.get(e);
                void 0 !== t.__webglInit && (m.deleteTexture(t.__webglTexture), y.remove(e))
            }

            function E(e) {
                var t = y.get(e),
                    n = y.get(e.texture);
                if (e) {
                    if (void 0 !== n.__webglTexture && m.deleteTexture(n.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                        for (var r = 0; r < 6; r++) m.deleteFramebuffer(t.__webglFramebuffer[r]), t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer[r]);
                    else m.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer), t.__webglMultisampledFramebuffer && m.deleteFramebuffer(t.__webglMultisampledFramebuffer), t.__webglColorRenderbuffer && m.deleteRenderbuffer(t.__webglColorRenderbuffer), t.__webglDepthRenderbuffer && m.deleteRenderbuffer(t.__webglDepthRenderbuffer);
                    y.remove(e.texture), y.remove(e)
                }
            }
            var T = 0;

            function L() {
                T = 0
            }

            function N() {
                var e = T;
                return n <= e && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + n), T += 1, e
            }

            function R(e, t) {
                var n = y.get(e);
                if (e.isVideoTexture && J(e), 0 < e.version && n.__version !== e.version) {
                    var r = e.image;
                    if (void 0 !== r && !1 !== r.complete) return void z(n, e, t)
                }
                v.activeTexture(33984 + t), v.bindTexture(3553, n.__webglTexture)
            }

            function k(e, t) {
                var n = y.get(e);
                0 < e.version && n.__version !== e.version ? z(n, e, t) : (v.activeTexture(33984 + t), v.bindTexture(35866, n.__webglTexture))
            }

            function P(e, t) {
                var n = y.get(e);
                0 < e.version && n.__version !== e.version ? z(n, e, t) : (v.activeTexture(33984 + t), v.bindTexture(32879, n.__webglTexture))
            }

            function D(e, t) {
                if (6 === e.image.length) {
                    var n = y.get(e);
                    if (0 < e.version && n.__version !== e.version) {
                        U(n, e), v.activeTexture(33984 + t), v.bindTexture(34067, n.__webglTexture), m.pixelStorei(37440, e.flipY);
                        for (var r = e && (e.isCompressedTexture || e.image[0].isCompressedTexture), i = e.image[0] && e.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = r || i ? i ? e.image[o].image : e.image[o] : C(e.image[o], !1, !0, x);
                        var s, l = a[0],
                            u = I(l) || A,
                            h = _.convert(e.format),
                            c = _.convert(e.type),
                            d = b(e.internalFormat, h, c);
                        if (G(34067, e, u), r) {
                            for (o = 0; o < 6; o++) {
                                s = a[o].mipmaps;
                                for (var f = 0; f < s.length; f++) {
                                    var p = s[f];
                                    e.format !== dt && e.format !== ct ? null !== h && v.compressedTexImage2D(34069 + o, f, d, p.width, p.height, 0, p.data) : v.texImage2D(34069 + o, f, d, p.width, p.height, 0, h, c, p.data)
                                }
                            }
                            n.__maxMipLevel = s.length - 1
                        } else {
                            for (s = e.mipmaps, o = 0; o < 6; o++)
                                if (i)
                                    for (v.texImage2D(34069 + o, 0, d, a[o].width, a[o].height, 0, h, c, a[o].data), f = 0; f < s.length; f++) {
                                        p = s[f];
                                        var g = p.image[o].image;
                                        v.texImage2D(34069 + o, f + 1, d, g.width, g.height, 0, h, c, g.data)
                                    } else
                                        for (v.texImage2D(34069 + o, 0, d, h, c, a[o]), f = 0; f < s.length; f++) p = s[f], v.texImage2D(34069 + o, f + 1, d, h, c, p.image[o]);
                            n.__maxMipLevel = s.length
                        }
                        w(e, u) && M(34067, e, l.width, l.height), n.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else v.activeTexture(33984 + t), v.bindTexture(34067, n.__webglTexture)
                }
            }

            function O(e, t) {
                v.activeTexture(33984 + t), v.bindTexture(34067, y.get(e).__webglTexture)
            }
            var F = (e = {}, (0, pe.default)(e, ne, 10497), (0, pe.default)(e, re, 33071), (0, pe.default)(e, ae, 33648), e),
                B = (t = {}, (0, pe.default)(t, oe, 9728), (0, pe.default)(t, se, 9984), (0, pe.default)(t, le, 9986), (0, pe.default)(t, ue, 9729), (0, pe.default)(t, he, 9985), (0, pe.default)(t, ce, 9987), t);

            function G(e, t, n) {
                n ? (m.texParameteri(e, 10242, F[t.wrapS]), m.texParameteri(e, 10243, F[t.wrapT]), 32879 !== e && 35866 !== e || m.texParameteri(e, 32882, F[t.wrapR]), m.texParameteri(e, 10240, B[t.magFilter]), m.texParameteri(e, 10241, B[t.minFilter])) : (m.texParameteri(e, 10242, 33071), m.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || m.texParameteri(e, 32882, 33071), t.wrapS !== re || t.wrapT, m.texParameteri(e, 10240, l(t.magFilter)), m.texParameteri(e, 10241, l(t.minFilter)), t.minFilter !== oe && t.minFilter);
                var r = i.get("EXT_texture_filter_anisotropic");
                if (r) {
                    if (t.type === it && null === i.get("OES_texture_float_linear")) return;
                    if (t.type === at && null === (A || i.get("OES_texture_half_float_linear"))) return;
                    (1 < t.anisotropy || y.get(t).__currentAnisotropy) && (m.texParameterf(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, a.getMaxAnisotropy())), y.get(t).__currentAnisotropy = t.anisotropy)
                }
            }

            function U(e, t) {
                void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", u), e.__webglTexture = m.createTexture(), c.memory.textures++)
            }

            function z(e, t, n) {
                var r = 3553;
                t.isDataTexture2DArray && (r = 35866), t.isDataTexture3D && (r = 32879), U(e, t), v.activeTexture(33984 + n), v.bindTexture(r, e.__webglTexture), m.pixelStorei(37440, t.flipY), m.pixelStorei(37441, t.premultiplyAlpha), m.pixelStorei(3317, t.unpackAlignment);
                var i = g(t) && !1 === I(t.image),
                    a = C(t.image, i, !1, p),
                    o = I(a) || A,
                    s = _.convert(t.format),
                    l = _.convert(t.type),
                    u = b(t.internalFormat, s, l);
                G(r, t, o);
                var h, c = t.mipmaps;
                if (t.isDepthTexture) u = 6402, A ? u = t.type === it ? 36012 : t.type === rt ? 33190 : t.type === ut ? 35056 : 33189 : t.type === it && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), t.format === mt && 6402 === u && t.type !== tt && t.type !== rt && (t.type = tt, l = _.convert(t.type)), t.format === vt && 6402 === u && (u = 34041, t.type !== ut && (t.type = ut, l = _.convert(t.type))), v.texImage2D(3553, 0, u, a.width, a.height, 0, s, l, null);
                else if (t.isDataTexture)
                    if (0 < c.length && o) {
                        for (var d = 0, f = c.length; d < f; d++) h = c[d], v.texImage2D(3553, d, u, h.width, h.height, 0, s, l, h.data);
                        t.generateMipmaps = !1, e.__maxMipLevel = c.length - 1
                    } else v.texImage2D(3553, 0, u, a.width, a.height, 0, s, l, a.data), e.__maxMipLevel = 0;
                else if (t.isCompressedTexture) {
                    for (d = 0, f = c.length; d < f; d++) h = c[d], t.format !== dt && t.format !== ct ? null !== s && v.compressedTexImage2D(3553, d, u, h.width, h.height, 0, h.data) : v.texImage2D(3553, d, u, h.width, h.height, 0, s, l, h.data);
                    e.__maxMipLevel = c.length - 1
                } else if (t.isDataTexture2DArray) v.texImage3D(35866, 0, u, a.width, a.height, a.depth, 0, s, l, a.data), e.__maxMipLevel = 0;
                else if (t.isDataTexture3D) v.texImage3D(32879, 0, u, a.width, a.height, a.depth, 0, s, l, a.data), e.__maxMipLevel = 0;
                else if (0 < c.length && o) {
                    for (d = 0, f = c.length; d < f; d++) h = c[d], v.texImage2D(3553, d, u, s, l, h);
                    t.generateMipmaps = !1, e.__maxMipLevel = c.length - 1
                } else v.texImage2D(3553, 0, u, s, l, a), e.__maxMipLevel = 0;
                w(t, o) && M(r, t, a.width, a.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
            }

            function V(e, t, n, r) {
                var i = _.convert(t.texture.format),
                    a = _.convert(t.texture.type),
                    o = b(t.texture.internalFormat, i, a);
                v.texImage2D(r, 0, o, t.width, t.height, 0, i, a, null), m.bindFramebuffer(36160, e), m.framebufferTexture2D(36160, n, r, y.get(t.texture).__webglTexture, 0), m.bindFramebuffer(36160, null)
            }

            function H(e, t, n) {
                if (m.bindRenderbuffer(36161, e), t.depthBuffer && !t.stencilBuffer) {
                    var r = 33189;
                    if (n) {
                        var i = t.depthTexture;
                        i && i.isDepthTexture && (i.type === it ? r = 36012 : i.type === rt && (r = 33190));
                        var a = Z(t);
                        m.renderbufferStorageMultisample(36161, a, r, t.width, t.height)
                    } else m.renderbufferStorage(36161, r, t.width, t.height);
                    m.framebufferRenderbuffer(36160, 36096, 36161, e)
                } else if (t.depthBuffer && t.stencilBuffer) n ? (a = Z(t), m.renderbufferStorageMultisample(36161, a, 35056, t.width, t.height)) : m.renderbufferStorage(36161, 34041, t.width, t.height), m.framebufferRenderbuffer(36160, 33306, 36161, e);
                else {
                    var o = _.convert(t.texture.format),
                        s = _.convert(t.texture.type);
                    r = b(t.texture.internalFormat, o, s), n ? (a = Z(t), m.renderbufferStorageMultisample(36161, a, r, t.width, t.height)) : m.renderbufferStorage(36161, r, t.width, t.height)
                }
                m.bindRenderbuffer(36161, null)
            }

            function W(e, t) {
                var n = t && t.isWebGLCubeRenderTarget;
                if (n) throw new Error("Depth Texture with cube render targets is not supported");
                if (m.bindFramebuffer(36160, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                y.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), R(t.depthTexture, 0);
                var r = y.get(t.depthTexture).__webglTexture;
                if (t.depthTexture.format === mt) m.framebufferTexture2D(36160, 36096, 3553, r, 0);
                else {
                    if (t.depthTexture.format !== vt) throw new Error("Unknown depthTexture format");
                    m.framebufferTexture2D(36160, 33306, 3553, r, 0)
                }
            }

            function j(e) {
                var t = y.get(e),
                    n = !0 === e.isWebGLCubeRenderTarget;
                if (e.depthTexture) {
                    if (n) throw new Error("target.depthTexture not supported in Cube render targets");
                    W(t.__webglFramebuffer, e)
                } else if (n) {
                    t.__webglDepthbuffer = [];
                    for (var r = 0; r < 6; r++) m.bindFramebuffer(36160, t.__webglFramebuffer[r]), t.__webglDepthbuffer[r] = m.createRenderbuffer(), H(t.__webglDepthbuffer[r], e, !1)
                } else m.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = m.createRenderbuffer(), H(t.__webglDepthbuffer, e, !1);
                m.bindFramebuffer(36160, null)
            }

            function Y(e) {
                var t = y.get(e),
                    n = y.get(e.texture);
                e.addEventListener("dispose", f), n.__webglTexture = m.createTexture(), c.memory.textures++;
                var r = !0 === e.isWebGLCubeRenderTarget,
                    i = !0 === e.isWebGLMultisampleRenderTarget,
                    a = I(e) || A;
                if (!A || e.texture.format !== ct || e.texture.type !== it && e.texture.type !== at || (e.texture.format = dt), r) {
                    t.__webglFramebuffer = [];
                    for (var o = 0; o < 6; o++) t.__webglFramebuffer[o] = m.createFramebuffer()
                } else if (t.__webglFramebuffer = m.createFramebuffer(), i && A) {
                    t.__webglMultisampledFramebuffer = m.createFramebuffer(), t.__webglColorRenderbuffer = m.createRenderbuffer(), m.bindRenderbuffer(36161, t.__webglColorRenderbuffer);
                    var s = _.convert(e.texture.format),
                        l = _.convert(e.texture.type),
                        u = b(e.texture.internalFormat, s, l),
                        h = Z(e);
                    m.renderbufferStorageMultisample(36161, h, u, e.width, e.height), m.bindFramebuffer(36160, t.__webglMultisampledFramebuffer), m.framebufferRenderbuffer(36160, 36064, 36161, t.__webglColorRenderbuffer), m.bindRenderbuffer(36161, null), e.depthBuffer && (t.__webglDepthRenderbuffer = m.createRenderbuffer(), H(t.__webglDepthRenderbuffer, e, !0)), m.bindFramebuffer(36160, null)
                }
                if (r) {
                    for (v.bindTexture(34067, n.__webglTexture), G(34067, e.texture, a), o = 0; o < 6; o++) V(t.__webglFramebuffer[o], e, 36064, 34069 + o);
                    w(e.texture, a) && M(34067, e.texture, e.width, e.height), v.bindTexture(34067, null)
                } else v.bindTexture(3553, n.__webglTexture), G(3553, e.texture, a), V(t.__webglFramebuffer, e, 36064, 3553), w(e.texture, a) && M(3553, e.texture, e.width, e.height), v.bindTexture(3553, null);
                e.depthBuffer && j(e)
            }

            function q(e) {
                var t = e.texture,
                    n = I(e) || A;
                if (w(t, n)) {
                    var r = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                        i = y.get(t).__webglTexture;
                    v.bindTexture(r, i), M(r, t, e.width, e.height), v.bindTexture(r, null)
                }
            }

            function X(e) {
                if (e.isWebGLMultisampleRenderTarget && A) {
                    var t = y.get(e);
                    m.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), m.bindFramebuffer(36009, t.__webglFramebuffer);
                    var n = e.width,
                        r = e.height,
                        i = 16384;
                    e.depthBuffer && (i |= 256), e.stencilBuffer && (i |= 1024), m.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728), m.bindFramebuffer(36160, t.__webglMultisampledFramebuffer)
                }
            }

            function Z(e) {
                return A && e.isWebGLMultisampleRenderTarget ? Math.min(r, e.samples) : 0
            }

            function J(e) {
                var t = c.render.frame;
                o.get(e) !== t && (o.set(e, t), e.update())
            }
            var K = !1,
                Q = !1;

            function $(e, t) {
                e && e.isWebGLRenderTarget && (!1 === K && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), K = !0), e = e.texture), R(e, t)
            }

            function ee(e, t) {
                e && e.isWebGLCubeRenderTarget && (!1 === Q && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), Q = !0), e = e.texture), (e && e.isCubeTexture || (0, He.default)(e.image) && 6 === e.image.length ? D : O)(e, t)
            }
            this.allocateTextureUnit = N, this.resetTextureUnits = L, this.setTexture2D = R, this.setTexture2DArray = k, this.setTexture3D = P, this.setTextureCube = D, this.setTextureCubeDynamic = O, this.setupRenderTarget = Y, this.updateRenderTargetMipmap = q, this.updateMultisampleRenderTarget = X, this.safeSetTexture2D = $, this.safeSetTextureCube = ee
        }

        function Dh(e, n, t) {
            var r = t.isWebGL2;

            function i(e) {
                var t;
                if (e === et) return 5121;
                if (e === ot) return 32819;
                if (e === st) return 32820;
                if (e === lt) return 33635;
                if (e === de) return 5120;
                if (e === fe) return 5122;
                if (e === tt) return 5123;
                if (e === nt) return 5124;
                if (e === rt) return 5125;
                if (e === it) return 5126;
                if (e === at) return r ? 5131 : (t = n.get("OES_texture_half_float"), null !== t ? t.HALF_FLOAT_OES : null);
                if (e === ht) return 6406;
                if (e === ct) return 6407;
                if (e === dt) return 6408;
                if (e === ft) return 6409;
                if (e === pt) return 6410;
                if (e === mt) return 6402;
                if (e === vt) return 34041;
                if (e === yt) return 6403;
                if (e === _t) return 36244;
                if (e === At) return 33319;
                if (e === xt) return 33320;
                if (e === Ct) return 36248;
                if (e === It) return 36249;
                if (e === wt || e === Mt || e === bt || e === St) {
                    if (t = n.get("WEBGL_compressed_texture_s3tc"), null === t) return null;
                    if (e === wt) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === Mt) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === bt) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === St) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (e === Et || e === Tt || e === Lt || e === Nt) {
                    if (t = n.get("WEBGL_compressed_texture_pvrtc"), null === t) return null;
                    if (e === Et) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === Tt) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === Lt) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === Nt) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === Rt) return t = n.get("WEBGL_compressed_texture_etc1"), null !== t ? t.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((e === kt || e === Pt) && (t = n.get("WEBGL_compressed_texture_etc"), null !== t)) {
                    if (e === kt) return t.COMPRESSED_RGB8_ETC2;
                    if (e === Pt) return t.COMPRESSED_RGBA8_ETC2_EAC
                }
                return e === Dt || e === Ot || e === Ft || e === Bt || e === Gt || e === Ut || e === zt || e === Vt || e === Ht || e === Wt || e === jt || e === Yt || e === qt || e === Xt || e === Jt || e === Kt || e === Qt || e === $t || e === en || e === tn || e === nn || e === rn || e === an || e === on || e === sn || e === ln || e === un || e === hn ? (t = n.get("WEBGL_compressed_texture_astc"), null !== t ? e : null) : e === Zt ? (t = n.get("EXT_texture_compression_bptc"), null !== t ? e : null) : e === ut ? r ? 34042 : (t = n.get("WEBGL_depth_texture"), null !== t ? t.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
            return {
                convert: i
            }
        }

        function Oh(e) {
            Xa.call(this), this.cameras = e || []
        }

        function Fh() {
            Xr.call(this), this.type = "Group"
        }

        function Bh(f, i) {
            var t = this,
                p = null,
                a = 1,
                g = null,
                o = "local-floor",
                m = null,
                v = [],
                s = new S.default,
                l = new Xa;
            l.layers.enable(1), l.viewport = new mr;
            var u = new Xa;
            u.layers.enable(2), u.viewport = new mr;
            var y = new Oh([l, u]);
            y.layers.enable(1), y.layers.enable(2);
            var h = null,
                c = null;

            function d(e) {
                var t = s.get(e.inputSource);
                t && (t.targetRay && t.targetRay.dispatchEvent({
                    type: e.type
                }), t.grip && t.grip.dispatchEvent({
                    type: e.type
                }))
            }

            function _() {
                s.forEach(function (e, t) {
                    e.targetRay && (e.targetRay.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), e.targetRay.visible = !1), e.grip && (e.grip.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), e.grip.visible = !1)
                }), s.clear(), f.setFramebuffer(null), f.setRenderTarget(f.getRenderTarget()), n.stop(), t.isPresenting = !1, t.dispatchEvent({
                    type: "sessionend"
                })
            }

            function A(e) {
                g = e, n.setContext(p), n.start(), t.isPresenting = !0, t.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function x(e) {
                for (var t = p.inputSources, n = 0; n < v.length; n++) s.set(t[n], v[n]);
                for (n = 0; n < e.removed.length; n++) {
                    var r = e.removed[n],
                        i = s.get(r);
                    i && (i.targetRay && i.targetRay.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), i.grip && i.grip.dispatchEvent({
                        type: "disconnected",
                        data: r
                    }), s.delete(r))
                }
                for (n = 0; n < e.added.length; n++) r = e.added[n], i = s.get(r), i && (i.targetRay && i.targetRay.dispatchEvent({
                    type: "connected",
                    data: r
                }), i.grip && i.grip.dispatchEvent({
                    type: "connected",
                    data: r
                }))
            }
            this.enabled = !1, this.isPresenting = !1, this.getController = function (e) {
                var t = v[e];
                return void 0 === t && (t = {}, v[e] = t), void 0 === t.targetRay && (t.targetRay = new Fh, t.targetRay.matrixAutoUpdate = !1, t.targetRay.visible = !1), t.targetRay
            }, this.getControllerGrip = function (e) {
                var t = v[e];
                return void 0 === t && (t = {}, v[e] = t), void 0 === t.grip && (t.grip = new Fh, t.grip.matrixAutoUpdate = !1, t.grip.visible = !1), t.grip
            }, this.setFramebufferScaleFactor = function (e) {
                a = e, 1 == t.isPresenting && console.warn("WebXRManager: Cannot change framebuffer scale while presenting VR content")
            }, this.setReferenceSpaceType = function (e) {
                o = e
            }, this.getReferenceSpace = function () {
                return g
            }, this.getSession = function () {
                return p
            }, this.setSession = function (e) {
                if (p = e, null !== p) {
                    p.addEventListener("select", d), p.addEventListener("selectstart", d), p.addEventListener("selectend", d), p.addEventListener("squeeze", d), p.addEventListener("squeezestart", d), p.addEventListener("squeezeend", d), p.addEventListener("end", _);
                    var t = i.getContextAttributes(),
                        n = {
                            antialias: t.antialias,
                            alpha: t.alpha,
                            depth: t.depth,
                            stencil: t.stencil,
                            framebufferScaleFactor: a
                        },
                        r = new XRWebGLLayer(p, i, n);
                    p.updateRenderState({
                        baseLayer: r
                    }), p.requestReferenceSpace(o).then(A), p.addEventListener("inputsourceschange", x)
                }
            };
            var C = new Cr,
                I = new Cr;

            function w(e, t, n) {
                C.setFromMatrixPosition(t.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                var r = C.distanceTo(I),
                    i = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    l = (i[9] + 1) / i[5],
                    u = (i[9] - 1) / i[5],
                    h = (i[8] - 1) / i[0],
                    c = (a[8] + 1) / a[0],
                    d = o * h,
                    f = o * c,
                    p = r / (-h + c),
                    g = p * -h;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(g), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                var m = o + p,
                    v = s + p,
                    y = d - g,
                    _ = f + (r - g),
                    A = l * s / v * m,
                    x = u * s / v * m;
                e.projectionMatrix.makePerspective(y, _, A, x, m, v)
            }

            function M(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
            }
            this.getCamera = function (e) {
                y.near = u.near = l.near = e.near, y.far = u.far = l.far = e.far, h === y.near && c === y.far || (p.updateRenderState({
                    depthNear: y.near,
                    depthFar: y.far
                }), h = y.near, c = y.far);
                var t = e.parent,
                    n = y.cameras;
                M(y, t);
                for (var r = 0; r < n.length; r++) M(n[r], t);
                e.matrixWorld.copy(y.matrixWorld);
                for (var i = e.children, a = (r = 0, i.length); r < a; r++) i[r].updateMatrixWorld(!0);
                return w(y, l, u), y
            };
            var b = null;

            function e(e, t) {
                if (m = t.getViewerPose(g), null !== m) {
                    var n = m.views,
                        r = p.renderState.baseLayer;
                    f.setFramebuffer(r.framebuffer);
                    for (var i = 0; i < n.length; i++) {
                        var a = n[i],
                            o = r.getViewport(a),
                            s = y.cameras[i];
                        s.matrix.fromArray(a.transform.matrix), s.projectionMatrix.fromArray(a.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === i && y.matrix.copy(s.matrix)
                    }
                }
                var l = p.inputSources;
                for (i = 0; i < v.length; i++) {
                    var u = v[i],
                        h = l[i],
                        c = null,
                        d = null;
                    h && (u.targetRay && (c = t.getPose(h.targetRaySpace, g), null !== c && (u.targetRay.matrix.fromArray(c.transform.matrix), u.targetRay.matrix.decompose(u.targetRay.position, u.targetRay.rotation, u.targetRay.scale))), u.grip && h.gripSpace && (d = t.getPose(h.gripSpace, g), null !== d && (u.grip.matrix.fromArray(d.transform.matrix), u.grip.matrix.decompose(u.grip.position, u.grip.rotation, u.grip.scale)))), u.targetRay && (u.targetRay.visible = null !== c), u.grip && (u.grip.visible = null !== d)
                }
                b && b(e, t)
            }
            var n = new io;
            n.setAnimationLoop(e), this.setAnimationLoop = function (e) {
                b = e
            }, this.dispose = function () {}
        }

        function Gh(e) {
            e = e || {};
            var r = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                t = void 0 !== e.context ? e.context : null,
                n = void 0 !== e.alpha && e.alpha,
                i = void 0 === e.depth || e.depth,
                a = void 0 === e.stencil || e.stencil,
                o = void 0 !== e.antialias && e.antialias,
                s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                u = void 0 !== e.powerPreference ? e.powerPreference : "default",
                h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                f = null,
                x = null;
            this.domElement = r, this.debug = {
                checkShaderErrors: !0
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = In, this.physicallyCorrectLights = !1, this.toneMapping = $e, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var I, A, C, w, p, M, b, S, E, g, m, c, d, v, T, L, N, y, R = this,
                _ = !1,
                k = null,
                P = 0,
                D = 0,
                O = null,
                F = null,
                B = -1,
                G = {
                    geometry: null,
                    program: null,
                    wireframe: !1
                },
                U = null,
                z = null,
                V = new mr,
                H = new mr,
                W = null,
                j = r.width,
                Y = r.height,
                q = 1,
                X = null,
                Z = null,
                J = new mr(0, 0, j, Y),
                K = new mr(0, 0, j, Y),
                Q = !1,
                $ = new no,
                ee = new kl,
                te = !1,
                ne = !1,
                re = new Lr,
                ie = new Cr;

            function ae() {
                return null === O ? q : 1
            }
            try {
                var oe = {
                    alpha: n,
                    depth: i,
                    stencil: a,
                    antialias: o,
                    premultipliedAlpha: s,
                    preserveDrawingBuffer: l,
                    powerPreference: u,
                    failIfMajorPerformanceCaveat: h,
                    xrCompatible: !0
                };
                if (r.addEventListener("webglcontextlost", he, !1), r.addEventListener("webglcontextrestored", ce, !1), I = t || r.getContext("webgl", oe) || r.getContext("experimental-webgl", oe), null === I) throw null !== r.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                void 0 === I.getShaderPrecisionFormat && (I.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (e) {
                throw console.error("THREE.WebGLRenderer: " + e.message), e
            }

            function se() {
                A = new Pl(I), C = new Rl(I, A, e), !1 === C.isWebGL2 && (A.get("WEBGL_depth_texture"), A.get("OES_texture_float"), A.get("OES_texture_half_float"), A.get("OES_texture_half_float_linear"), A.get("OES_standard_derivatives"), A.get("OES_element_index_uint"), A.get("ANGLE_instanced_arrays")), A.get("OES_texture_float_linear"), y = new Dh(I, A, C), w = new kh(I, A, C), w.scissor(H.copy(K).multiplyScalar(q).floor()), w.viewport(V.copy(J).multiplyScalar(q).floor()), p = new Fl(I), M = new mh, b = new Ph(I, A, w, M, C, y, p), S = new ao(I, C), E = new Dl(I, S, p), g = new Ul(I, E, S, p), T = new Gl(I), m = new gh(R, A, C), c = new Ah, d = new Sh, v = new Ll(R, w, g, s), L = new Nl(I, A, p, C), N = new Ol(I, A, p, C), p.programs = m.programs, R.capabilities = C, R.extensions = A, R.properties = M, R.renderLists = c, R.state = w, R.info = p
            }
            se();
            var le = new Bh(R, I);
            this.xr = le;
            var ue = new Rh(R, g, C.maxTextureSize);

            function he(e) {
                e.preventDefault(), _ = !0
            }

            function ce() {
                _ = !1, se()
            }

            function de(e) {
                var t = e.target;
                t.removeEventListener("dispose", de), fe(t)
            }

            function fe(e) {
                pe(e), M.remove(e)
            }

            function pe(e) {
                var t = M.get(e).program;
                e.program = void 0, void 0 !== t && m.releaseProgram(t)
            }

            function ge(e, t) {
                e.render(function (e) {
                    R.renderBufferImmediate(e, t)
                })
            }
            this.shadowMap = ue, this.getContext = function () {
                return I
            }, this.getContextAttributes = function () {
                return I.getContextAttributes()
            }, this.forceContextLoss = function () {
                var e = A.get("WEBGL_lose_context");
                e && e.loseContext()
            }, this.forceContextRestore = function () {
                var e = A.get("WEBGL_lose_context");
                e && e.restoreContext()
            }, this.getPixelRatio = function () {
                return q
            }, this.setPixelRatio = function (e) {
                void 0 !== e && (q = e, this.setSize(j, Y, !1))
            }, this.getSize = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new cr), e.set(j, Y)
            }, this.setSize = function (e, t, n) {
                le.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (j = e, Y = t, r.width = Math.floor(e * q), r.height = Math.floor(t * q), !1 !== n && (r.style.width = e + "px", r.style.height = t + "px"), this.setViewport(0, 0, e, t))
            }, this.getDrawingBufferSize = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new cr), e.set(j * q, Y * q).floor()
            }, this.setDrawingBufferSize = function (e, t, n) {
                j = e, Y = t, q = n, r.width = Math.floor(e * n), r.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
            }, this.getCurrentViewport = function (e) {
                return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new mr), e.copy(V)
            }, this.getViewport = function (e) {
                return e.copy(J)
            }, this.setViewport = function (e, t, n, r) {
                e.isVector4 ? J.set(e.x, e.y, e.z, e.w) : J.set(e, t, n, r), w.viewport(V.copy(J).multiplyScalar(q).floor())
            }, this.getScissor = function (e) {
                return e.copy(K)
            }, this.setScissor = function (e, t, n, r) {
                e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, n, r), w.scissor(H.copy(K).multiplyScalar(q).floor())
            }, this.getScissorTest = function () {
                return Q
            }, this.setScissorTest = function (e) {
                w.setScissorTest(Q = e)
            }, this.setOpaqueSort = function (e) {
                X = e
            }, this.setTransparentSort = function (e) {
                Z = e
            }, this.getClearColor = function () {
                return v.getClearColor()
            }, this.setClearColor = function () {
                v.setClearColor.apply(v, arguments)
            }, this.getClearAlpha = function () {
                return v.getClearAlpha()
            }, this.setClearAlpha = function () {
                v.setClearAlpha.apply(v, arguments)
            }, this.clear = function (e, t, n) {
                var r = 0;
                void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== n && !n || (r |= 1024), I.clear(r)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                r.removeEventListener("webglcontextlost", he, !1), r.removeEventListener("webglcontextrestored", ce, !1), c.dispose(), d.dispose(), M.dispose(), g.dispose(), le.dispose(), Ae.stop(), this.forceContextLoss()
            }, this.renderBufferImmediate = function (e, t) {
                w.initAttributes();
                var n = M.get(e);
                e.hasPositions && !n.position && (n.position = I.createBuffer()), e.hasNormals && !n.normal && (n.normal = I.createBuffer()), e.hasUvs && !n.uv && (n.uv = I.createBuffer()), e.hasColors && !n.color && (n.color = I.createBuffer());
                var r = t.getAttributes();
                e.hasPositions && (I.bindBuffer(34962, n.position), I.bufferData(34962, e.positionArray, 35048), w.enableAttribute(r.position), I.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (I.bindBuffer(34962, n.normal), I.bufferData(34962, e.normalArray, 35048), w.enableAttribute(r.normal), I.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (I.bindBuffer(34962, n.uv), I.bufferData(34962, e.uvArray, 35048), w.enableAttribute(r.uv), I.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (I.bindBuffer(34962, n.color), I.bufferData(34962, e.colorArray, 35048), w.enableAttribute(r.color), I.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), w.disableUnusedAttributes(), I.drawArrays(4, 0, e.count), e.count = 0
            };
            var me = new Zr;

            function ve(e, t, n, r) {
                if (!1 !== C.isWebGL2 || !e.isInstancedMesh && !t.isInstancedBufferGeometry || null !== A.get("ANGLE_instanced_arrays")) {
                    w.initAttributes();
                    var i = t.attributes,
                        a = r.getAttributes(),
                        o = n.defaultAttributeValues;
                    for (var s in a) {
                        var l = a[s];
                        if (0 <= l) {
                            var u = i[s];
                            if (void 0 !== u) {
                                var h = u.normalized,
                                    c = u.itemSize,
                                    d = S.get(u);
                                if (void 0 === d) continue;
                                var f = d.buffer,
                                    p = d.type,
                                    g = d.bytesPerElement;
                                if (u.isInterleavedBufferAttribute) {
                                    var m = u.data,
                                        v = m.stride,
                                        y = u.offset;
                                    m && m.isInstancedInterleavedBuffer ? (w.enableAttributeAndDivisor(l, m.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = m.meshPerAttribute * m.count)) : w.enableAttribute(l), I.bindBuffer(34962, f), I.vertexAttribPointer(l, c, p, h, v * g, y * g)
                                } else u.isInstancedBufferAttribute ? (w.enableAttributeAndDivisor(l, u.meshPerAttribute), void 0 === t.maxInstancedCount && (t.maxInstancedCount = u.meshPerAttribute * u.count)) : w.enableAttribute(l), I.bindBuffer(34962, f), I.vertexAttribPointer(l, c, p, h, 0, 0)
                            } else if ("instanceMatrix" === s) {
                                if (d = S.get(e.instanceMatrix), void 0 === d) continue;
                                f = d.buffer, p = d.type, w.enableAttributeAndDivisor(l + 0, 1), w.enableAttributeAndDivisor(l + 1, 1), w.enableAttributeAndDivisor(l + 2, 1), w.enableAttributeAndDivisor(l + 3, 1), I.bindBuffer(34962, f), I.vertexAttribPointer(l + 0, 4, p, !1, 64, 0), I.vertexAttribPointer(l + 1, 4, p, !1, 64, 16), I.vertexAttribPointer(l + 2, 4, p, !1, 64, 32), I.vertexAttribPointer(l + 3, 4, p, !1, 64, 48)
                            } else if (void 0 !== o) {
                                var _ = o[s];
                                if (void 0 !== _) switch (_.length) {
                                    case 2:
                                        I.vertexAttrib2fv(l, _);
                                        break;
                                    case 3:
                                        I.vertexAttrib3fv(l, _);
                                        break;
                                    case 4:
                                        I.vertexAttrib4fv(l, _);
                                        break;
                                    default:
                                        I.vertexAttrib1fv(l, _)
                                }
                            }
                        }
                    }
                    w.disableUnusedAttributes()
                }
            }
            this.renderBufferDirect = function (e, t, n, r, i, a) {
                null === t && (t = me);
                var o = i.isMesh && i.matrixWorld.determinant() < 0,
                    s = Me(e, t, r, i);
                w.setMaterial(r, o);
                var l = !1;
                G.geometry === n.id && G.program === s.id && G.wireframe === (!0 === r.wireframe) || (G.geometry = n.id, G.program = s.id, G.wireframe = !0 === r.wireframe, l = !0), (r.morphTargets || r.morphNormals) && (T.update(i, n, r, s), l = !0);
                var u = n.index,
                    h = n.attributes.position;
                if (null === u) {
                    if (void 0 === h || 0 === h.count) return
                } else if (0 === u.count) return;
                var c, d = 1;
                !0 === r.wireframe && (u = E.getWireframeAttribute(n), d = 2);
                var f = L;
                null !== u && (c = S.get(u), f = N, f.setIndex(c)), l && (ve(i, n, r, s), null !== u && I.bindBuffer(34963, c.buffer));
                var p = null !== u ? u.count : h.count,
                    g = n.drawRange.start * d,
                    m = n.drawRange.count * d,
                    v = null !== a ? a.start * d : 0,
                    y = null !== a ? a.count * d : Infinity,
                    _ = Math.max(g, v),
                    A = Math.min(p, g + m, v + y) - 1,
                    x = Math.max(0, A - _ + 1);
                if (0 !== x) {
                    if (i.isMesh) !0 === r.wireframe ? (w.setLineWidth(r.wireframeLinewidth * ae()), f.setMode(1)) : f.setMode(4);
                    else if (i.isLine) {
                        var C = r.linewidth;
                        void 0 === C && (C = 1), w.setLineWidth(C * ae()), i.isLineSegments ? f.setMode(1) : i.isLineLoop ? f.setMode(2) : f.setMode(3)
                    } else i.isPoints ? f.setMode(0) : i.isSprite && f.setMode(4);
                    i.isInstancedMesh ? f.renderInstances(n, _, x, i.count) : n.isInstancedBufferGeometry ? f.renderInstances(n, _, x, n.maxInstancedCount) : f.render(_, x)
                }
            }, this.compile = function (n, e) {
                x = d.get(n, e), x.init(), n.traverse(function (e) {
                    e.isLight && (x.pushLight(e), e.castShadow && x.pushShadow(e))
                }), x.setupLights(e);
                var r = {};
                n.traverse(function (e) {
                    if (e.material)
                        if ((0, He.default)(e.material))
                            for (var t = 0; t < e.material.length; t++) e.material[t].uuid in r == 0 && (we(e.material[t], n, e), r[e.material[t].uuid] = !0);
                        else e.material.uuid in r == 0 && (we(e.material, n, e), r[e.material.uuid] = !0)
                })
            };
            var ye = null;

            function _e(e) {
                le.isPresenting || ye && ye(e)
            }
            var Ae = new io;

            function xe(e, t, n, r) {
                if (!1 !== e.visible) {
                    var i = e.layers.test(t.layers);
                    if (i)
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) x.pushLight(e), e.castShadow && x.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || $.intersectsSprite(e)) {
                            r && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(re);
                            var a = g.update(e),
                                o = e.material;
                            o.visible && f.push(e, a, o, n, ie.z, null)
                        }
                    } else if (e.isImmediateRenderObject) r && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(re), f.push(e, null, e.material, n, ie.z, null);
                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== p.render.frame && (e.skeleton.update(), e.skeleton.frame = p.render.frame), !e.frustumCulled || $.intersectsObject(e)))
                        if (r && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(re), a = g.update(e), o = e.material, (0, He.default)(o))
                            for (var s = a.groups, l = 0, u = s.length; l < u; l++) {
                                var h = s[l],
                                    c = o[h.materialIndex];
                                c && c.visible && f.push(e, a, c, n, ie.z, h)
                            } else o.visible && f.push(e, a, o, n, ie.z, null);
                    var d = e.children;
                    for (l = 0, u = d.length; l < u; l++) xe(d[l], t, n, r)
                }
            }

            function Ce(e, t, n, r) {
                for (var i = 0, a = e.length; i < a; i++) {
                    var o = e[i],
                        s = o.object,
                        l = o.geometry,
                        u = void 0 === r ? o.material : r,
                        h = o.group;
                    if (n.isArrayCamera) {
                        z = n;
                        for (var c = n.cameras, d = 0, f = c.length; d < f; d++) {
                            var p = c[d];
                            s.layers.test(p.layers) && (w.viewport(V.copy(p.viewport)), x.setupLights(p), Ie(s, t, p, l, u, h))
                        }
                    } else z = null, Ie(s, t, n, l, u, h)
                }
            }

            function Ie(e, t, n, r, i, a) {
                if (e.onBeforeRender(R, t, n, r, i, a), x = d.get(t, z || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                    var o = Me(n, t, i, e);
                    w.setMaterial(i), G.geometry = null, G.program = null, G.wireframe = !1, ge(e, o)
                } else R.renderBufferDirect(n, t, r, i, e, a);
                e.onAfterRender(R, t, n, r, i, a), x = d.get(t, z || n)
            }

            function we(e, t, n) {
                var r = M.get(e),
                    i = x.state.lights,
                    a = x.state.shadowsArray,
                    o = i.state.version,
                    s = m.getParameters(e, i.state, a, t, ee.numPlanes, ee.numIntersection, n),
                    l = m.getProgramCacheKey(s),
                    u = r.program,
                    h = !0;
                if (void 0 === u) e.addEventListener("dispose", de);
                else if (u.cacheKey !== l) pe(e);
                else if (r.lightsStateVersion !== o) r.lightsStateVersion = o, h = !1;
                else {
                    if (void 0 !== s.shaderID) return;
                    h = !1
                }
                h && (u = m.acquireProgram(s, l), r.program = u, r.uniforms = s.uniforms, r.environment = e.isMeshStandardMaterial ? t.environment : null, r.outputEncoding = R.outputEncoding, e.program = u);
                var c = u.getAttributes();
                if (e.morphTargets) {
                    e.numSupportedMorphTargets = 0;
                    for (var d = 0; d < R.maxMorphTargets; d++) 0 <= c["morphTarget" + d] && e.numSupportedMorphTargets++
                }
                if (e.morphNormals)
                    for (e.numSupportedMorphNormals = 0, d = 0; d < R.maxMorphNormals; d++) 0 <= c["morphNormal" + d] && e.numSupportedMorphNormals++;
                var f = r.uniforms;
                (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = ee.numPlanes, r.numIntersection = ee.numIntersection, f.clippingPlanes = ee.uniform), r.fog = t.fog, r.needsLights = Ve(e), r.lightsStateVersion = o, r.needsLights && (f.ambientLightColor.value = i.state.ambient, f.lightProbe.value = i.state.probe, f.directionalLights.value = i.state.directional, f.directionalLightShadows.value = i.state.directionalShadow, f.spotLights.value = i.state.spot, f.spotLightShadows.value = i.state.spotShadow, f.rectAreaLights.value = i.state.rectArea, f.pointLights.value = i.state.point, f.pointLightShadows.value = i.state.pointShadow, f.hemisphereLights.value = i.state.hemi, f.directionalShadowMap.value = i.state.directionalShadowMap, f.directionalShadowMatrix.value = i.state.directionalShadowMatrix, f.spotShadowMap.value = i.state.spotShadowMap, f.spotShadowMatrix.value = i.state.spotShadowMatrix, f.pointShadowMap.value = i.state.pointShadowMap, f.pointShadowMatrix.value = i.state.pointShadowMatrix);
                var p = r.program.getUniforms(),
                    g = Uu.seqWithValue(p.seq, f);
                r.uniformsList = g
            }

            function Me(e, t, n, r) {
                b.resetTextureUnits();
                var i = t.fog,
                    a = n.isMeshStandardMaterial ? t.environment : null,
                    o = M.get(n),
                    s = x.state.lights;
                if (te && (ne || e !== U)) {
                    var l = e === U && n.id === B;
                    ee.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, o, l)
                }
                n.version === o.__version ? void 0 === o.program || n.fog && o.fog !== i || o.environment !== a || o.needsLights && o.lightsStateVersion !== s.state.version ? we(n, t, r) : void 0 === o.numClippingPlanes || o.numClippingPlanes === ee.numPlanes && o.numIntersection === ee.numIntersection ? o.outputEncoding !== R.outputEncoding && we(n, t, r) : we(n, t, r) : (we(n, t, r), o.__version = n.version);
                var u = !1,
                    h = !1,
                    c = !1,
                    d = o.program,
                    f = d.getUniforms(),
                    p = o.uniforms;
                if (w.useProgram(d.program) && (u = !0, h = !0, c = !0), n.id !== B && (B = n.id, h = !0), u || U !== e) {
                    if (f.setValue(I, "projectionMatrix", e.projectionMatrix), C.logarithmicDepthBuffer && f.setValue(I, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), U !== e && (U = e, h = !0, c = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                        var g = f.map.cameraPosition;
                        void 0 !== g && g.setValue(I, ie.setFromMatrixPosition(e.matrixWorld))
                    }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && f.setValue(I, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && f.setValue(I, "viewMatrix", e.matrixWorldInverse)
                }
                if (n.skinning) {
                    f.setOptional(I, r, "bindMatrix"), f.setOptional(I, r, "bindMatrixInverse");
                    var m = r.skeleton;
                    if (m) {
                        var v = m.bones;
                        if (C.floatVertexTextures) {
                            if (void 0 === m.boneTexture) {
                                var y = Math.sqrt(4 * v.length);
                                y = hr.ceilPowerOfTwo(y), y = Math.max(y, 4);
                                var _ = new Float32Array(y * y * 4);
                                _.set(m.boneMatrices);
                                var A = new $a(_, y, y, dt, it);
                                m.boneMatrices = _, m.boneTexture = A, m.boneTextureSize = y
                            }
                            f.setValue(I, "boneTexture", m.boneTexture, b), f.setValue(I, "boneTextureSize", m.boneTextureSize)
                        } else f.setOptional(I, m, "boneMatrices")
                    }
                }
                return !h && o.receiveShadow === r.receiveShadow || (o.receiveShadow = r.receiveShadow, f.setValue(I, "receiveShadow", r.receiveShadow)), h && (f.setValue(I, "toneMappingExposure", R.toneMappingExposure), f.setValue(I, "toneMappingWhitePoint", R.toneMappingWhitePoint), o.needsLights && ze(p, c), i && n.fog && Ne(p, i), n.isMeshBasicMaterial ? be(p, n) : n.isMeshLambertMaterial ? (be(p, n), Re(p, n)) : n.isMeshToonMaterial ? (be(p, n), Pe(p, n)) : n.isMeshPhongMaterial ? (be(p, n), ke(p, n)) : n.isMeshStandardMaterial ? (be(p, n, a), (n.isMeshPhysicalMaterial ? Oe : De)(p, n, a)) : n.isMeshMatcapMaterial ? (be(p, n), Fe(p, n)) : n.isMeshDepthMaterial ? (be(p, n), Be(p, n)) : n.isMeshDistanceMaterial ? (be(p, n), Ge(p, n)) : n.isMeshNormalMaterial ? (be(p, n), Ue(p, n)) : n.isLineBasicMaterial ? (Se(p, n), n.isLineDashedMaterial && Ee(p, n)) : n.isPointsMaterial ? Te(p, n) : n.isSpriteMaterial ? Le(p, n) : n.isShadowMaterial && (p.color.value.copy(n.color), p.opacity.value = n.opacity), void 0 !== p.ltc_1 && (p.ltc_1.value = ro.LTC_1), void 0 !== p.ltc_2 && (p.ltc_2.value = ro.LTC_2), Uu.upload(I, o.uniformsList, p, b), n.isShaderMaterial && (n.uniformsNeedUpdate = !1)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Uu.upload(I, o.uniformsList, p, b), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && f.setValue(I, "center", r.center), f.setValue(I, "modelViewMatrix", r.modelViewMatrix), f.setValue(I, "normalMatrix", r.normalMatrix), f.setValue(I, "modelMatrix", r.matrixWorld), d
            }

            function be(e, t, n) {
                e.opacity.value = t.opacity, (0, We.default)(e, t.uniforms), t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap);
                var r, i, a = t.envMap || n;
                a && (e.envMap.value = a, e.flipEnvMap.value = a.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = M.get(a).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap && (r = t.emissiveMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), t.aoMap ? i = t.aoMap : t.lightMap && (i = t.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uv2Transform.value.copy(i.matrix))
            }

            function Se(e, t) {
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
            }

            function Ee(e, t) {
                e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
            }

            function Te(e, t) {
                var n;
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * q, e.scale.value = .5 * Y, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
            }

            function Le(e, t) {
                var n;
                e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
            }

            function Ne(e, t) {
                e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }

            function Re(e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
            }

            function ke(e, t) {
                e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === je && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === je && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }

            function Pe(e, t) {
                e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === je && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === je && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }

            function De(e, t, n) {
                e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === je && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === je && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity)
            }

            function Oe(e, t, n) {
                De(e, t, n), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen), t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === je && e.clearcoatNormalScale.value.negate()), e.transparency.value = t.transparency
            }

            function Fe(e, t) {
                t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === je && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === je && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }

            function Be(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }

            function Ge(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
            }

            function Ue(e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === je && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === je && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }

            function ze(e, t) {
                e.ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.directionalLightShadows.needsUpdate = t, e.pointLights.needsUpdate = t, e.pointLightShadows.needsUpdate = t, e.spotLights.needsUpdate = t, e.spotLightShadows.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
            }

            function Ve(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }
            Ae.setAnimationLoop(_e), "undefined" != typeof window && Ae.setContext(window), this.setAnimationLoop = function (e) {
                ye = e, le.setAnimationLoop(e), Ae.start()
            }, this.render = function (e, t, n, r) {
                var i, a;
                if (void 0 !== n && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== r && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), a = arguments[3]), t && t.isCamera) {
                    if (!_) {
                        G.geometry = null, G.program = null, G.wireframe = !1, B = -1, U = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), le.enabled && le.isPresenting && (t = le.getCamera(t)), x = d.get(e, t), x.init(), e.onBeforeRender(R, e, t, i || O), re.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), $.setFromProjectionMatrix(re), ne = this.localClippingEnabled, te = ee.init(this.clippingPlanes, ne, t), f = c.get(e, t), f.init(), xe(e, t, 0, R.sortObjects), f.finish(), !0 === R.sortObjects && f.sort(X, Z), te && ee.beginShadows();
                        var o = x.state.shadowsArray;
                        ue.render(o, e, t), x.setupLights(t), te && ee.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), v.render(f, e, t, a);
                        var s = f.opaque,
                            l = f.transparent;
                        if (e.overrideMaterial) {
                            var u = e.overrideMaterial;
                            s.length && Ce(s, e, t, u), l.length && Ce(l, e, t, u)
                        } else s.length && Ce(s, e, t), l.length && Ce(l, e, t);
                        e.onAfterRender(R, e, t), null !== O && (b.updateRenderTargetMipmap(O), b.updateMultisampleRenderTarget(O)), w.buffers.depth.setTest(!0), w.buffers.depth.setMask(!0), w.buffers.color.setMask(!0), w.setPolygonOffset(!1), f = null, x = null
                    }
                } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFramebuffer = function (e) {
                k !== e && null === O && I.bindFramebuffer(36160, e), k = e
            }, this.getActiveCubeFace = function () {
                return P
            }, this.getActiveMipmapLevel = function () {
                return D
            }, this.getRenderTarget = function () {
                return O
            }, this.setRenderTarget = function (e, t, n) {
                O = e, P = t, D = n, e && void 0 === M.get(e).__webglFramebuffer && b.setupRenderTarget(e);
                var r = k,
                    i = !1;
                if (e) {
                    var a = M.get(e).__webglFramebuffer;
                    e.isWebGLCubeRenderTarget ? (r = a[t || 0], i = !0) : r = e.isWebGLMultisampleRenderTarget ? M.get(e).__webglMultisampledFramebuffer : a, V.copy(e.viewport), H.copy(e.scissor), W = e.scissorTest
                } else V.copy(J).multiplyScalar(q).floor(), H.copy(K).multiplyScalar(q).floor(), W = Q;
                if (F !== r && (I.bindFramebuffer(36160, r), F = r), w.viewport(V), w.scissor(H), w.setScissorTest(W), i) {
                    var o = M.get(e.texture);
                    I.framebufferTexture2D(36160, 36064, 34069 + (t || 0), o.__webglTexture, n || 0)
                }
            }, this.readRenderTargetPixels = function (e, t, n, r, i, a, o) {
                if (e && e.isWebGLRenderTarget) {
                    var s = M.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                        var l = !1;
                        s !== F && (I.bindFramebuffer(36160, s), l = !0);
                        try {
                            var u = e.texture,
                                h = u.format,
                                c = u.type;
                            if (h !== dt && y.convert(h) !== I.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(c === et || y.convert(c) === I.getParameter(35738) || c === it && (C.isWebGL2 || A.get("OES_texture_float") || A.get("WEBGL_color_buffer_float")) || c === at && (C.isWebGL2 ? A.get("EXT_color_buffer_float") : A.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === I.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - r && 0 <= n && n <= e.height - i && I.readPixels(t, n, r, i, y.convert(h), y.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            l && I.bindFramebuffer(36160, F)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function (e, t, n) {
                void 0 === n && (n = 0);
                var r = Math.pow(2, -n),
                    i = Math.floor(t.image.width * r),
                    a = Math.floor(t.image.height * r),
                    o = y.convert(t.format);
                b.setTexture2D(t, 0), I.copyTexImage2D(3553, n, o, e.x, e.y, i, a, 0), w.unbindTexture()
            }, this.copyTextureToTexture = function (e, t, n, r) {
                var i = t.image.width,
                    a = t.image.height,
                    o = y.convert(n.format),
                    s = y.convert(n.type);
                b.setTexture2D(n, 0), t.isDataTexture ? I.texSubImage2D(3553, r || 0, e.x, e.y, i, a, o, s, t.image.data) : I.texSubImage2D(3553, r || 0, e.x, e.y, o, s, t.image), w.unbindTexture()
            }, this.initTexture = function (e) {
                b.setTexture2D(e, 0), w.unbindTexture()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function Uh(e, t) {
            this.name = "", this.color = new Gi(e), this.density = void 0 !== t ? t : 25e-5
        }

        function zh(e, t, n) {
            this.name = "", this.color = new Gi(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
        }

        function Vh(e, t) {
            this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Kn, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }
        Oh.prototype = (0, We.default)((0, s.default)(Xa.prototype), {
            constructor: Oh,
            isArrayCamera: !0
        }), Fh.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: Fh,
            isGroup: !0
        }), (0, We.default)(Bh.prototype, or.prototype), (0, We.default)(Uh.prototype, {
            isFogExp2: !0,
            clone: function () {
                return new Uh(this.color, this.density)
            },
            toJSON: function () {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }), (0, We.default)(zh.prototype, {
            isFog: !0,
            clone: function () {
                return new zh(this.color, this.near, this.far)
            },
            toJSON: function () {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }), (0, y.default)(Vh.prototype, "needsUpdate", {
            set: function (e) {
                !0 === e && this.version++
            }
        }), (0, We.default)(Vh.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function () {},
            setUsage: function (e) {
                return this.usage = e, this
            },
            copy: function (e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            },
            copyAt: function (e, t, n) {
                e *= this.stride, n *= t.stride;
                for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                return this
            },
            set: function (e, t) {
                return void 0 === t && (t = 0), this.array.set(e, t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            onUpload: function (e) {
                return this.onUploadCallback = e, this
            }
        });
        var Hh, Wh = new Cr;

        function jh(e, t, n, r) {
            this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
        }

        function Yh(e) {
            ji.call(this), this.type = "SpriteMaterial", this.color = new Gi(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e)
        }(0, l.default)(jh.prototype, {
            count: {
                get: function () {
                    return this.data.count
                }
            },
            array: {
                get: function () {
                    return this.data.array
                }
            }
        }), (0, We.default)(jh.prototype, {
            isInterleavedBufferAttribute: !0,
            applyMatrix4: function (e) {
                for (var t = 0, n = this.data.count; t < n; t++) Wh.x = this.getX(t), Wh.y = this.getY(t), Wh.z = this.getZ(t), Wh.applyMatrix4(e), this.setXYZ(t, Wh.x, Wh.y, Wh.z);
                return this
            },
            setX: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset] = t, this
            },
            setY: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 1] = t, this
            },
            setZ: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 2] = t, this
            },
            setW: function (e, t) {
                return this.data.array[e * this.data.stride + this.offset + 3] = t, this
            },
            getX: function (e) {
                return this.data.array[e * this.data.stride + this.offset]
            },
            getY: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 1]
            },
            getZ: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 2]
            },
            getW: function (e) {
                return this.data.array[e * this.data.stride + this.offset + 3]
            },
            setXY: function (e, t, n) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            },
            setXYZ: function (e, t, n, r) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
            },
            setXYZW: function (e, t, n, r, i) {
                return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
            }
        }), Yh.prototype = (0, s.default)(ji.prototype), Yh.prototype.constructor = Yh, Yh.prototype.isSpriteMaterial = !0, Yh.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
        };
        var qh = new Cr,
            Xh = new Cr,
            Zh = new Cr,
            Jh = new cr,
            Kh = new cr,
            Qh = new Lr,
            $h = new Cr,
            ec = new Cr,
            tc = new Cr,
            nc = new cr,
            rc = new cr,
            ic = new cr;

        function ac(e) {
            if (Xr.call(this), this.type = "Sprite", void 0 === Hh) {
                Hh = new fa;
                var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                    n = new Vh(t, 5);
                Hh.setIndex([0, 1, 2, 0, 2, 3]), Hh.setAttribute("position", new jh(n, 3, 0, !1)), Hh.setAttribute("uv", new jh(n, 2, 3, !1))
            }
            this.geometry = Hh, this.material = void 0 !== e ? e : new Yh, this.center = new cr(.5, .5)
        }

        function oc(e, t, n, r, i, a) {
            Jh.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Kh.x = a * Jh.x - i * Jh.y, Kh.y = i * Jh.x + a * Jh.y) : Kh.copy(Jh), e.copy(t), e.x += Kh.x, e.y += Kh.y, e.applyMatrix4(Qh)
        }
        ac.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: ac,
            isSprite: !0,
            raycast: function (e, t) {
                null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Xh.setFromMatrixScale(this.matrixWorld), Qh.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Zh.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Xh.multiplyScalar(-Zh.z);
                var n, r, i = this.material.rotation;
                0 !== i && (r = Math.cos(i), n = Math.sin(i));
                var a = this.center;
                oc($h.set(-.5, -.5, 0), Zh, a, Xh, n, r), oc(ec.set(.5, -.5, 0), Zh, a, Xh, n, r), oc(tc.set(.5, .5, 0), Zh, a, Xh, n, r), nc.set(0, 0), rc.set(1, 0), ic.set(1, 1);
                var o = e.ray.intersectTriangle($h, ec, tc, !1, qh);
                if (null !== o || (oc(ec.set(-.5, .5, 0), Zh, a, Xh, n, r), rc.set(0, 1), o = e.ray.intersectTriangle($h, tc, ec, !1, qh), null !== o)) {
                    var s = e.ray.origin.distanceTo(qh);
                    s < e.near || s > e.far || t.push({
                        distance: s,
                        point: qh.clone(),
                        uv: Di.getUV(qh, $h, ec, tc, nc, rc, ic, new cr),
                        face: null,
                        object: this
                    })
                }
            },
            clone: function () {
                return new this.constructor(this.material).copy(this)
            },
            copy: function (e) {
                return Xr.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
            }
        });
        var sc = new Cr,
            lc = new Cr;

        function uc() {
            Xr.call(this), this._currentLevel = 0, this.type = "LOD", (0, l.default)(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0
        }

        function hc(e, t) {
            e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Na.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Lr, this.bindMatrixInverse = new Lr
        }
        uc.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: uc,
            isLOD: !0,
            copy: function (e) {
                Xr.prototype.copy.call(this, e, !1);
                for (var t = e.levels, n = 0, r = t.length; n < r; n++) {
                    var i = t[n];
                    this.addLevel(i.object.clone(), i.distance)
                }
                return this.autoUpdate = e.autoUpdate, this
            },
            addLevel: function (e, t) {
                void 0 === t && (t = 0), t = Math.abs(t);
                for (var n = this.levels, r = 0; r < n.length && !(t < n[r].distance); r++);
                return n.splice(r, 0, {
                    distance: t,
                    object: e
                }), this.add(e), this
            },
            getCurrentLevel: function () {
                return this._currentLevel
            },
            getObjectForDistance: function (e) {
                var t = this.levels;
                if (0 < t.length) {
                    for (var n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                    return t[n - 1].object
                }
                return null
            },
            raycast: function (e, t) {
                var n = this.levels;
                if (0 < n.length) {
                    sc.setFromMatrixPosition(this.matrixWorld);
                    var r = e.ray.origin.distanceTo(sc);
                    this.getObjectForDistance(r).raycast(e, t)
                }
            },
            update: function (e) {
                var t = this.levels;
                if (1 < t.length) {
                    sc.setFromMatrixPosition(e.matrixWorld), lc.setFromMatrixPosition(this.matrixWorld);
                    var n = sc.distanceTo(lc) / e.zoom;
                    t[0].object.visible = !0;
                    for (var r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                    for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1
                }
            },
            toJSON: function (e) {
                var t = Xr.prototype.toJSON.call(this, e);
                !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.object.levels.push({
                        object: a.object.uuid,
                        distance: a.distance
                    })
                }
                return t
            }
        }), hc.prototype = (0, We.default)((0, s.default)(Na.prototype), {
            constructor: hc,
            isSkinnedMesh: !0,
            bind: function (e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                for (var e = new mr, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                    e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                    var i = 1 / e.manhattanLength();
                    Infinity !== i ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            },
            updateMatrixWorld: function (e) {
                Na.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var cc = new Lr,
            dc = new Lr;

        function fc(e, t) {
            if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
            else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
            else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Lr)
            }
        }

        function pc() {
            Xr.call(this), this.type = "Bone"
        }(0, We.default)(fc.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var e = 0, t = this.bones.length; e < t; e++) {
                    var n = new Lr;
                    this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                }
            },
            pose: function () {
                var e, t, n;
                for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
                for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
            },
            update: function () {
                for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) {
                    var o = e[i] ? e[i].matrixWorld : dc;
                    cc.multiplyMatrices(o, t[i]), cc.toArray(n, 16 * i)
                }
                void 0 !== r && (r.needsUpdate = !0)
            },
            clone: function () {
                return new fc(this.bones, this.boneInverses)
            },
            getBoneByName: function (e) {
                for (var t = 0, n = this.bones.length; t < n; t++) {
                    var r = this.bones[t];
                    if (r.name === e) return r
                }
            },
            dispose: function () {
                this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
            }
        }), pc.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: pc,
            isBone: !0
        });
        var gc = new Lr,
            mc = new Lr,
            vc = [],
            yc = new Na;

        function _c(e, t, n) {
            Na.call(this, e, t), this.instanceMatrix = new Xi(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1
        }

        function Ac(e) {
            ji.call(this), this.type = "LineBasicMaterial", this.color = new Gi(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
        }
        _c.prototype = (0, We.default)((0, s.default)(Na.prototype), {
            constructor: _c,
            isInstancedMesh: !0,
            getMatrixAt: function (e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            },
            raycast: function (e, t) {
                var n = this.matrixWorld,
                    r = this.count;
                if (yc.geometry = this.geometry, yc.material = this.material, void 0 !== yc.material)
                    for (var i = 0; i < r; i++) this.getMatrixAt(i, gc), mc.multiplyMatrices(n, gc), yc.matrixWorld = mc, yc.raycast(e, vc), 0 < vc.length && (vc[0].instanceId = i, vc[0].object = this, t.push(vc[0]), vc.length = 0)
            },
            setMatrixAt: function (e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            },
            updateMorphTargets: function () {}
        }), Ac.prototype = (0, s.default)(ji.prototype), Ac.prototype.constructor = Ac, Ac.prototype.isLineBasicMaterial = !0, Ac.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
        };
        var xc = new Cr,
            Cc = new Cr,
            Ic = new Lr,
            wc = new Ai,
            Mc = new di;

        function bc(e, t, n) {
            1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Xr.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new fa, this.material = void 0 !== t ? t : new Ac
        }
        bc.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: bc,
            isLine: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) xc.fromBufferAttribute(t, r - 1), Cc.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += xc.distanceTo(Cc);
                        e.setAttribute("lineDistance", new na(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var a = e.vertices;
                    for (n = e.lineDistances, n[0] = 0, r = 1, i = a.length; r < i; r++) n[r] = n[r - 1], n[r] += a[r - 1].distanceTo(a[r])
                }
                return this
            },
            raycast: function (e, t) {
                var n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Line.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Mc.copy(n.boundingSphere), Mc.applyMatrix4(r), Mc.radius += i, !1 !== e.ray.intersectsSphere(Mc)) {
                    Ic.getInverse(r), wc.copy(e.ray).applyMatrix4(Ic);
                    var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        s = new Cr,
                        l = new Cr,
                        u = new Cr,
                        h = new Cr,
                        c = this && this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        var d = n.index,
                            f = n.attributes,
                            p = f.position.array;
                        if (null !== d)
                            for (var g = d.array, m = 0, v = g.length - 1; m < v; m += c) {
                                var y = g[m],
                                    _ = g[m + 1];
                                s.fromArray(p, 3 * y), l.fromArray(p, 3 * _);
                                var A = wc.distanceSqToSegment(s, l, h, u);
                                if (!(o < A)) {
                                    h.applyMatrix4(this.matrixWorld);
                                    var x = e.ray.origin.distanceTo(h);
                                    x < e.near || x > e.far || t.push({
                                        distance: x,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: m,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else
                                for (m = 0, v = p.length / 3 - 1; m < v; m += c) s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), A = wc.distanceSqToSegment(s, l, h, u), o < A || (h.applyMatrix4(this.matrixWorld), x = e.ray.origin.distanceTo(h), x < e.near || x > e.far || t.push({
                                    distance: x,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: m,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                    } else if (n.isGeometry) {
                        var C = n.vertices,
                            I = C.length;
                        for (m = 0; m < I - 1; m += c) A = wc.distanceSqToSegment(C[m], C[m + 1], h, u), o < A || (h.applyMatrix4(this.matrixWorld), x = e.ray.origin.distanceTo(h), x < e.near || x > e.far || t.push({
                            distance: x,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: m,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    }
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var Sc = new Cr,
            Ec = new Cr;

        function Tc(e, t) {
            bc.call(this, e, t), this.type = "LineSegments"
        }

        function Lc(e, t) {
            bc.call(this, e, t), this.type = "LineLoop"
        }

        function Nc(e) {
            ji.call(this), this.type = "PointsMaterial", this.color = new Gi(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e)
        }
        Tc.prototype = (0, We.default)((0, s.default)(bc.prototype), {
            constructor: Tc,
            isLineSegments: !0,
            computeLineDistances: function () {
                var e = this.geometry;
                if (e.isBufferGeometry)
                    if (null === e.index) {
                        for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) Sc.fromBufferAttribute(t, r), Ec.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Sc.distanceTo(Ec);
                        e.setAttribute("lineDistance", new na(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (e.isGeometry) {
                    var a = e.vertices;
                    for (n = e.lineDistances, r = 0, i = a.length; r < i; r += 2) Sc.copy(a[r]), Ec.copy(a[r + 1]), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Sc.distanceTo(Ec)
                }
                return this
            }
        }), Lc.prototype = (0, We.default)((0, s.default)(bc.prototype), {
            constructor: Lc,
            isLineLoop: !0
        }), Nc.prototype = (0, s.default)(ji.prototype), Nc.prototype.constructor = Nc, Nc.prototype.isPointsMaterial = !0, Nc.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
        };
        var Rc = new Lr,
            kc = new Ai,
            Pc = new di,
            Dc = new Cr;

        function Oc(e, t) {
            Xr.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new fa, this.material = void 0 !== t ? t : new Nc, this.updateMorphTargets()
        }

        function Fc(e, t, n, r, i, a, o) {
            var s = kc.distanceSqToPoint(e);
            if (s < n) {
                var l = new Cr;
                kc.closestPointToPoint(e, l), l.applyMatrix4(r);
                var u = i.ray.origin.distanceTo(l);
                if (u < i.near || u > i.far) return;
                a.push({
                    distance: u,
                    distanceToRay: Math.sqrt(s),
                    point: l,
                    index: t,
                    face: null,
                    object: o
                })
            }
        }

        function Bc(e, t, n, r, i, a, o, s, l) {
            gr.call(this, e, t, n, r, i, a, o, s, l), this.format = void 0 !== o ? o : ct, this.minFilter = void 0 !== a ? a : ue, this.magFilter = void 0 !== i ? i : ue, this.generateMipmaps = !1
        }

        function Gc(e, t, n, r, i, a, o, s, l, u, h, c) {
            gr.call(this, null, a, o, s, l, u, r, i, h, c), this.image = {
                width: t,
                height: n
            }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
        }

        function Uc(e, t, n, r, i, a, o, s, l) {
            gr.call(this, e, t, n, r, i, a, o, s, l), this.needsUpdate = !0
        }

        function zc(e, t, n, r, i, a, o, s, l, u) {
            if (u = void 0 !== u ? u : mt, u !== mt && u !== vt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && u === mt && (n = tt), void 0 === n && u === vt && (n = ut), gr.call(this, null, r, i, a, o, s, u, n, l), this.image = {
                width: e,
                height: t
            }, this.magFilter = void 0 !== o ? o : oe, this.minFilter = void 0 !== s ? s : oe, this.flipY = !1, this.generateMipmaps = !1
        }

        function Vc(e) {
            fa.call(this), this.type = "WireframeGeometry";
            var t, n, r, i, a, o, s, l, u, h, c = [],
                d = [0, 0],
                f = {},
                p = ["a", "b", "c"];
            if (e && e.isGeometry) {
                var g = e.faces;
                for (t = 0, r = g.length; t < r; t++) {
                    var m = g[t];
                    for (n = 0; n < 3; n++) s = m[p[n]], l = m[p[(n + 1) % 3]], d[0] = Math.min(s, l), d[1] = Math.max(s, l), u = d[0] + "," + d[1], void 0 === f[u] && (f[u] = {
                        index1: d[0],
                        index2: d[1]
                    })
                }
                for (u in f) o = f[u], h = e.vertices[o.index1], c.push(h.x, h.y, h.z), h = e.vertices[o.index2], c.push(h.x, h.y, h.z)
            } else if (e && e.isBufferGeometry) {
                var v, y, _, A, x, C, I, w;
                if (h = new Cr, null !== e.index) {
                    for (v = e.attributes.position, y = e.index, _ = e.groups, 0 === _.length && (_ = [{
                            start: 0,
                            count: y.count,
                            materialIndex: 0
                        }]), i = 0, a = _.length; i < a; ++i)
                        for (A = _[i], x = A.start, C = A.count, t = x, r = x + C; t < r; t += 3)
                            for (n = 0; n < 3; n++) s = y.getX(t + n), l = y.getX(t + (n + 1) % 3), d[0] = Math.min(s, l), d[1] = Math.max(s, l), u = d[0] + "," + d[1], void 0 === f[u] && (f[u] = {
                                index1: d[0],
                                index2: d[1]
                            });
                    for (u in f) o = f[u], h.fromBufferAttribute(v, o.index1), c.push(h.x, h.y, h.z), h.fromBufferAttribute(v, o.index2), c.push(h.x, h.y, h.z)
                } else
                    for (v = e.attributes.position, t = 0, r = v.count / 3; t < r; t++)
                        for (n = 0; n < 3; n++) I = 3 * t + n, h.fromBufferAttribute(v, I), c.push(h.x, h.y, h.z), w = 3 * t + (n + 1) % 3, h.fromBufferAttribute(v, w), c.push(h.x, h.y, h.z)
            }
            this.setAttribute("position", new na(c, 3))
        }

        function Hc(e, t, n) {
            Ba.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: e,
                slices: t,
                stacks: n
            }, this.fromBufferGeometry(new Wc(e, t, n)), this.mergeVertices()
        }

        function Wc(e, t, n) {
            fa.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: e,
                slices: t,
                stacks: n
            };
            var r, i, a = [],
                o = [],
                s = [],
                l = [],
                u = 1e-5,
                h = new Cr,
                c = new Cr,
                d = new Cr,
                f = new Cr,
                p = new Cr;
            e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            var g = t + 1;
            for (r = 0; r <= n; r++) {
                var m = r / n;
                for (i = 0; i <= t; i++) {
                    var v = i / t;
                    e(v, m, c), o.push(c.x, c.y, c.z), 0 <= v - u ? (e(v - u, m, d), f.subVectors(c, d)) : (e(v + u, m, d), f.subVectors(d, c)), 0 <= m - u ? (e(v, m - u, d), p.subVectors(c, d)) : (e(v, m + u, d), p.subVectors(d, c)), h.crossVectors(f, p).normalize(), s.push(h.x, h.y, h.z), l.push(v, m)
                }
            }
            for (r = 0; r < n; r++)
                for (i = 0; i < t; i++) {
                    var y = r * g + i,
                        _ = r * g + i + 1,
                        A = (r + 1) * g + i + 1,
                        x = (r + 1) * g + i;
                    a.push(y, _, x), a.push(_, A, x)
                }
            this.setIndex(a), this.setAttribute("position", new na(o, 3)), this.setAttribute("normal", new na(s, 3)), this.setAttribute("uv", new na(l, 2))
        }

        function jc(e, t, n, r) {
            Ba.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: e,
                indices: t,
                radius: n,
                detail: r
            }, this.fromBufferGeometry(new Yc(e, t, n, r)), this.mergeVertices()
        }

        function Yc(r, a, e, t) {
            fa.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: r,
                indices: a,
                radius: e,
                detail: t
            }, e = e || 1, t = t || 0;
            var h = [],
                c = [];

            function n(e) {
                for (var t = new Cr, n = new Cr, r = new Cr, i = 0; i < a.length; i += 3) u(a[i + 0], t), u(a[i + 1], n), u(a[i + 2], r), o(t, n, r, e)
            }

            function o(e, t, n, r) {
                var i, a, o = Math.pow(2, r),
                    s = [];
                for (i = 0; i <= o; i++) {
                    s[i] = [];
                    var l = e.clone().lerp(n, i / o),
                        u = t.clone().lerp(n, i / o),
                        h = o - i;
                    for (a = 0; a <= h; a++) s[i][a] = 0 === a && i === o ? l : l.clone().lerp(u, a / h)
                }
                for (i = 0; i < o; i++)
                    for (a = 0; a < 2 * (o - i) - 1; a++) {
                        var c = Math.floor(a / 2);
                        a % 2 == 0 ? (d(s[i][c + 1]), d(s[i + 1][c]), d(s[i][c])) : (d(s[i][c + 1]), d(s[i + 1][c + 1]), d(s[i + 1][c]))
                    }
            }

            function i(e) {
                for (var t = new Cr, n = 0; n < h.length; n += 3) t.x = h[n + 0], t.y = h[n + 1], t.z = h[n + 2], t.normalize().multiplyScalar(e), h[n + 0] = t.x, h[n + 1] = t.y, h[n + 2] = t.z
            }

            function s() {
                for (var e = new Cr, t = 0; t < h.length; t += 3) {
                    e.x = h[t + 0], e.y = h[t + 1], e.z = h[t + 2];
                    var n = g(e) / 2 / Math.PI + .5,
                        r = m(e) / Math.PI + .5;
                    c.push(n, 1 - r)
                }
                f(), l()
            }

            function l() {
                for (var e = 0; e < c.length; e += 6) {
                    var t = c[e + 0],
                        n = c[e + 2],
                        r = c[e + 4],
                        i = Math.max(t, n, r),
                        a = Math.min(t, n, r);
                    .9 < i && a < .1 && (t < .2 && (c[e + 0] += 1), n < .2 && (c[e + 2] += 1), r < .2 && (c[e + 4] += 1))
                }
            }

            function d(e) {
                h.push(e.x, e.y, e.z)
            }

            function u(e, t) {
                var n = 3 * e;
                t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2]
            }

            function f() {
                for (var e = new Cr, t = new Cr, n = new Cr, r = new Cr, i = new cr, a = new cr, o = new cr, s = 0, l = 0; s < h.length; s += 9, l += 6) {
                    e.set(h[s + 0], h[s + 1], h[s + 2]), t.set(h[s + 3], h[s + 4], h[s + 5]), n.set(h[s + 6], h[s + 7], h[s + 8]), i.set(c[l + 0], c[l + 1]), a.set(c[l + 2], c[l + 3]), o.set(c[l + 4], c[l + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                    var u = g(r);
                    p(i, l + 0, e, u), p(a, l + 2, t, u), p(o, l + 4, n, u)
                }
            }

            function p(e, t, n, r) {
                r < 0 && 1 === e.x && (c[t] = e.x - 1), 0 === n.x && 0 === n.z && (c[t] = r / 2 / Math.PI + .5)
            }

            function g(e) {
                return Math.atan2(e.z, -e.x)
            }

            function m(e) {
                return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
            }
            n(t), i(e), s(), this.setAttribute("position", new na(h, 3)), this.setAttribute("normal", new na(h.slice(), 3)), this.setAttribute("uv", new na(c, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function qc(e, t) {
            Ba.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new Xc(e, t)), this.mergeVertices()
        }

        function Xc(e, t) {
            var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            Yc.call(this, n, r, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function Zc(e, t) {
            Ba.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new Jc(e, t)), this.mergeVertices()
        }

        function Jc(e, t) {
            var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            Yc.call(this, n, r, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function Kc(e, t) {
            Ba.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new Qc(e, t)), this.mergeVertices()
        }

        function Qc(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
                i = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            Yc.call(this, r, i, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function $c(e, t) {
            Ba.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: e,
                detail: t
            }, this.fromBufferGeometry(new ed(e, t)), this.mergeVertices()
        }

        function ed(e, t) {
            var n = (1 + Math.sqrt(5)) / 2,
                r = 1 / n,
                i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r],
                a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            Yc.call(this, i, a, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: e,
                detail: t
            }
        }

        function td(e, t, n, r, i, a) {
            Ba.call(this), this.type = "TubeGeometry", this.parameters = {
                path: e,
                tubularSegments: t,
                radius: n,
                radialSegments: r,
                closed: i
            }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
            var o = new nd(e, t, n, r, i);
            this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
        }

        function nd(o, s, l, u, e) {
            fa.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: o,
                tubularSegments: s,
                radius: l,
                radialSegments: u,
                closed: e
            }, s = s || 64, l = l || 1, u = u || 8, e = e || !1;
            var h = o.computeFrenetFrames(s, e);
            this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
            var i, c, d = new Cr,
                f = new Cr,
                t = new cr,
                p = new Cr,
                g = [],
                m = [],
                n = [],
                a = [];

            function r() {
                for (i = 0; i < s; i++) v(i);
                v(!1 === e ? s : 0), _(), y()
            }

            function v(e) {
                p = o.getPointAt(e / s, p);
                var t = h.normals[e],
                    n = h.binormals[e];
                for (c = 0; c <= u; c++) {
                    var r = c / u * Math.PI * 2,
                        i = Math.sin(r),
                        a = -Math.cos(r);
                    f.x = a * t.x + i * n.x, f.y = a * t.y + i * n.y, f.z = a * t.z + i * n.z, f.normalize(), m.push(f.x, f.y, f.z), d.x = p.x + l * f.x, d.y = p.y + l * f.y, d.z = p.z + l * f.z, g.push(d.x, d.y, d.z)
                }
            }

            function y() {
                for (c = 1; c <= s; c++)
                    for (i = 1; i <= u; i++) {
                        var e = (u + 1) * (c - 1) + (i - 1),
                            t = (u + 1) * c + (i - 1),
                            n = (u + 1) * c + i,
                            r = (u + 1) * (c - 1) + i;
                        a.push(e, t, r), a.push(t, n, r)
                    }
            }

            function _() {
                for (i = 0; i <= s; i++)
                    for (c = 0; c <= u; c++) t.x = i / s, t.y = c / u, n.push(t.x, t.y)
            }
            r(), this.setIndex(a), this.setAttribute("position", new na(g, 3)), this.setAttribute("normal", new na(m, 3)), this.setAttribute("uv", new na(n, 2))
        }

        function rd(e, t, n, r, i, a, o) {
            Ba.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: r,
                p: i,
                q: a
            }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new id(e, t, n, r, i, a)), this.mergeVertices()
        }

        function id(e, t, n, r, i, a) {
            fa.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: e,
                tube: t,
                tubularSegments: n,
                radialSegments: r,
                p: i,
                q: a
            }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, a = a || 3;
            var o, s, l = [],
                u = [],
                h = [],
                c = [],
                d = new Cr,
                f = new Cr,
                p = new Cr,
                g = new Cr,
                m = new Cr,
                v = new Cr,
                y = new Cr;
            for (o = 0; o <= n; ++o) {
                var _ = o / n * i * Math.PI * 2;
                for (S(_, i, a, e, p), S(_ + .01, i, a, e, g), v.subVectors(g, p), y.addVectors(g, p), m.crossVectors(v, y), y.crossVectors(m, v), m.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                    var A = s / r * Math.PI * 2,
                        x = -t * Math.cos(A),
                        C = t * Math.sin(A);
                    d.x = p.x + (x * y.x + C * m.x), d.y = p.y + (x * y.y + C * m.y), d.z = p.z + (x * y.z + C * m.z), u.push(d.x, d.y, d.z), f.subVectors(d, p).normalize(), h.push(f.x, f.y, f.z), c.push(o / n), c.push(s / r)
                }
            }
            for (s = 1; s <= n; s++)
                for (o = 1; o <= r; o++) {
                    var I = (r + 1) * (s - 1) + (o - 1),
                        w = (r + 1) * s + (o - 1),
                        M = (r + 1) * s + o,
                        b = (r + 1) * (s - 1) + o;
                    l.push(I, w, b), l.push(w, M, b)
                }

            function S(e, t, n, r, i) {
                var a = Math.cos(e),
                    o = Math.sin(e),
                    s = n / t * e,
                    l = Math.cos(s);
                i.x = r * (2 + l) * .5 * a, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(s) * .5
            }
            this.setIndex(l), this.setAttribute("position", new na(u, 3)), this.setAttribute("normal", new na(h, 3)), this.setAttribute("uv", new na(c, 2))
        }

        function ad(e, t, n, r, i) {
            Ba.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: r,
                arc: i
            }, this.fromBufferGeometry(new od(e, t, n, r, i)), this.mergeVertices()
        }

        function od(e, t, n, r, i) {
            fa.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: e,
                tube: t,
                radialSegments: n,
                tubularSegments: r,
                arc: i
            }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
            var a, o, s = [],
                l = [],
                u = [],
                h = [],
                c = new Cr,
                d = new Cr,
                f = new Cr;
            for (a = 0; a <= n; a++)
                for (o = 0; o <= r; o++) {
                    var p = o / r * i,
                        g = a / n * Math.PI * 2;
                    d.x = (e + t * Math.cos(g)) * Math.cos(p), d.y = (e + t * Math.cos(g)) * Math.sin(p), d.z = t * Math.sin(g), l.push(d.x, d.y, d.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), f.subVectors(d, c).normalize(), u.push(f.x, f.y, f.z), h.push(o / r), h.push(a / n)
                }
            for (a = 1; a <= n; a++)
                for (o = 1; o <= r; o++) {
                    var m = (r + 1) * a + o - 1,
                        v = (r + 1) * (a - 1) + o - 1,
                        y = (r + 1) * (a - 1) + o,
                        _ = (r + 1) * a + o;
                    s.push(m, v, _), s.push(v, y, _)
                }
            this.setIndex(s), this.setAttribute("position", new na(l, 3)), this.setAttribute("normal", new na(u, 3)), this.setAttribute("uv", new na(h, 2))
        }
        Oc.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: Oc,
            isPoints: !0,
            raycast: function (e, t) {
                var n = this.geometry,
                    r = this.matrixWorld,
                    i = e.params.Points.threshold;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Pc.copy(n.boundingSphere), Pc.applyMatrix4(r), Pc.radius += i, !1 !== e.ray.intersectsSphere(Pc)) {
                    Rc.getInverse(r), kc.copy(e.ray).applyMatrix4(Rc);
                    var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (n.isBufferGeometry) {
                        var s = n.index,
                            l = n.attributes,
                            u = l.position.array;
                        if (null !== s)
                            for (var h = s.array, c = 0, d = h.length; c < d; c++) {
                                var f = h[c];
                                Dc.fromArray(u, 3 * f), Fc(Dc, f, o, r, e, t, this)
                            } else {
                                c = 0;
                                for (var p = u.length / 3; c < p; c++) Dc.fromArray(u, 3 * c), Fc(Dc, c, o, r, e, t, this)
                            }
                    } else {
                        var g = n.vertices;
                        for (c = 0, p = g.length; c < p; c++) Fc(g[c], c, o, r, e, t, this)
                    }
                }
            },
            updateMorphTargets: function () {
                var e, t, n, r = this.geometry;
                if (r.isBufferGeometry) {
                    var i = r.morphAttributes,
                        a = (0, g.default)(i);
                    if (0 < a.length) {
                        var o = i[a[0]];
                        if (void 0 !== o)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                } else {
                    var s = r.morphTargets;
                    void 0 !== s && 0 < s.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Bc.prototype = (0, We.default)((0, s.default)(gr.prototype), {
            constructor: Bc,
            isVideoTexture: !0,
            update: function () {
                var e = this.image;
                e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), Gc.prototype = (0, s.default)(gr.prototype), Gc.prototype.constructor = Gc, Gc.prototype.isCompressedTexture = !0, Uc.prototype = (0, s.default)(gr.prototype), Uc.prototype.constructor = Uc, Uc.prototype.isCanvasTexture = !0, zc.prototype = (0, s.default)(gr.prototype), zc.prototype.constructor = zc, zc.prototype.isDepthTexture = !0, Vc.prototype = (0, s.default)(fa.prototype), Vc.prototype.constructor = Vc, Hc.prototype = (0, s.default)(Ba.prototype), Hc.prototype.constructor = Hc, Wc.prototype = (0, s.default)(fa.prototype), Wc.prototype.constructor = Wc, jc.prototype = (0, s.default)(Ba.prototype), jc.prototype.constructor = jc, Yc.prototype = (0, s.default)(fa.prototype), Yc.prototype.constructor = Yc, qc.prototype = (0, s.default)(Ba.prototype), qc.prototype.constructor = qc, Xc.prototype = (0, s.default)(Yc.prototype), Xc.prototype.constructor = Xc, Zc.prototype = (0, s.default)(Ba.prototype), Zc.prototype.constructor = Zc, Jc.prototype = (0, s.default)(Yc.prototype), Jc.prototype.constructor = Jc, Kc.prototype = (0, s.default)(Ba.prototype), Kc.prototype.constructor = Kc, Qc.prototype = (0, s.default)(Yc.prototype), Qc.prototype.constructor = Qc, $c.prototype = (0, s.default)(Ba.prototype), $c.prototype.constructor = $c, ed.prototype = (0, s.default)(Yc.prototype), ed.prototype.constructor = ed, td.prototype = (0, s.default)(Ba.prototype), td.prototype.constructor = td, nd.prototype = (0, s.default)(fa.prototype), nd.prototype.constructor = nd, nd.prototype.toJSON = function () {
            var e = fa.prototype.toJSON.call(this);
            return e.path = this.parameters.path.toJSON(), e
        }, rd.prototype = (0, s.default)(Ba.prototype), rd.prototype.constructor = rd, id.prototype = (0, s.default)(fa.prototype), id.prototype.constructor = id, ad.prototype = (0, s.default)(Ba.prototype), ad.prototype.constructor = ad, od.prototype = (0, s.default)(fa.prototype), od.prototype.constructor = od;
        var sd = {
            triangulate: function (e, t, n) {
                n = n || 2;
                var r, i, a, o, s, l, u, h = t && t.length,
                    c = h ? t[0] * n : e.length,
                    d = ld(e, 0, c, n, !0),
                    f = [];
                if (!d || d.next === d.prev) return f;
                if (h && (d = gd(e, t, d, n)), e.length > 80 * n) {
                    r = a = e[0], i = o = e[1];
                    for (var p = n; p < c; p += n) s = e[p], l = e[p + 1], s < r && (r = s), l < i && (i = l), a < s && (a = s), o < l && (o = l);
                    u = Math.max(a - r, o - i), u = 0 !== u ? 1 / u : 0
                }
                return hd(d, f, n, r, i, u), f
            }
        };

        function ld(e, t, n, r, i) {
            var a, o;
            if (i === 0 < Dd(e, t, n, r))
                for (a = t; a < n; a += r) o = Rd(a, e[a], e[a + 1], o);
            else
                for (a = n - r; t <= a; a -= r) o = Rd(a, e[a], e[a + 1], o);
            return o && bd(o, o.next) && (kd(o), o = o.next), o
        }

        function ud(e, t) {
            if (!e) return e;
            t = t || e;
            var n, r = e;
            do {
                if (n = !1, r.steiner || !bd(r, r.next) && 0 !== Md(r.prev, r, r.next)) r = r.next;
                else {
                    if (kd(r), r = t = r.prev, r === r.next) break;
                    n = !0
                }
            } while (n || r !== t);
            return t
        }

        function hd(e, t, n, r, i, a, o) {
            if (e) {
                !o && a && _d(e, r, i, a);
                for (var s, l, u = e; e.prev !== e.next;)
                    if (s = e.prev, l = e.next, a ? dd(e, r, i, a) : cd(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), kd(e), e = l.next, u = l.next;
                    else if (e = l, e === u) {
                    o ? 1 === o ? (e = fd(e, t, n), hd(e, t, n, r, i, a, 2)) : 2 === o && pd(e, t, n, r, i, a) : hd(ud(e), t, n, r, i, a, 1);
                    break
                }
            }
        }

        function cd(e) {
            var t = e.prev,
                n = e,
                r = e.next;
            if (0 <= Md(t, n, r)) return !1;
            for (var i = e.next.next; i !== e.prev;) {
                if (Id(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && 0 <= Md(i.prev, i, i.next)) return !1;
                i = i.next
            }
            return !0
        }

        function dd(e, t, n, r) {
            var i = e.prev,
                a = e,
                o = e.next;
            if (0 <= Md(i, a, o)) return !1;
            for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, l = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, u = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, h = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, c = xd(s, l, t, n, r), d = xd(u, h, t, n, r), f = e.prevZ, p = e.nextZ; f && f.z >= c && p && p.z <= d;) {
                if (f !== e.prev && f !== e.next && Id(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= Md(f.prev, f, f.next)) return !1;
                if (f = f.prevZ, p !== e.prev && p !== e.next && Id(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Md(p.prev, p, p.next)) return !1;
                p = p.nextZ
            }
            for (; f && f.z >= c;) {
                if (f !== e.prev && f !== e.next && Id(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && 0 <= Md(f.prev, f, f.next)) return !1;
                f = f.prevZ
            }
            for (; p && p.z <= d;) {
                if (p !== e.prev && p !== e.next && Id(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Md(p.prev, p, p.next)) return !1;
                p = p.nextZ
            }
            return !0
        }

        function fd(e, t, n) {
            var r = e;
            do {
                var i = r.prev,
                    a = r.next.next;
                !bd(i, a) && Sd(i, r, r.next, a) && Td(i, a) && Td(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), kd(r), kd(r.next), r = e = a), r = r.next
            } while (r !== e);
            return r
        }

        function pd(e, t, n, r, i, a) {
            var o = e;
            do {
                for (var s = o.next.next; s !== o.prev;) {
                    if (o.i !== s.i && wd(o, s)) {
                        var l = Nd(o, s);
                        return o = ud(o, o.next), l = ud(l, l.next), hd(o, t, n, r, i, a), void hd(l, t, n, r, i, a)
                    }
                    s = s.next
                }
                o = o.next
            } while (o !== e)
        }

        function gd(e, t, n, r) {
            var i, a, o, s, l, u = [];
            for (i = 0, a = t.length; i < a; i++) o = t[i] * r, s = i < a - 1 ? t[i + 1] * r : e.length, l = ld(e, o, s, r, !1), l === l.next && (l.steiner = !0), u.push(Cd(l));
            for (u.sort(md), i = 0; i < u.length; i++) vd(u[i], n), n = ud(n, n.next);
            return n
        }

        function md(e, t) {
            return e.x - t.x
        }

        function vd(e, t) {
            if (t = yd(e, t), t) {
                var n = Nd(t, e);
                ud(n, n.next)
            }
        }

        function yd(e, t) {
            var n, r = t,
                i = e.x,
                a = e.y,
                o = -Infinity;
            do {
                if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
                    var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                    if (s <= i && o < s) {
                        if (o = s, s === i) {
                            if (a === r.y) return r;
                            if (a === r.next.y) return r.next
                        }
                        n = r.x < r.next.x ? r : r.next
                    }
                }
                r = r.next
            } while (r !== t);
            if (!n) return null;
            if (i === o) return n.prev;
            var l, u = n,
                h = n.x,
                c = n.y,
                d = Infinity;
            for (r = n.next; r !== u;) i >= r.x && r.x >= h && i !== r.x && Id(a < c ? i : o, a, h, c, a < c ? o : i, a, r.x, r.y) && (l = Math.abs(a - r.y) / (i - r.x), (l < d || l === d && r.x > n.x) && Td(r, e) && (n = r, d = l)), r = r.next;
            return n
        }

        function _d(e, t, n, r) {
            for (var i = e; null === i.z && (i.z = xd(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next, i !== e;);
            i.prevZ.nextZ = null, i.prevZ = null, Ad(i)
        }

        function Ad(e) {
            var t, n, r, i, a, o, s, l, u = 1;
            do {
                for (n = e, e = null, a = null, o = 0; n;) {
                    for (o++, r = n, s = 0, t = 0; t < u && (s++, r = r.nextZ, r); t++);
                    for (l = u; 0 < s || 0 < l && r;) 0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i;
                    n = r
                }
                a.nextZ = null, u *= 2
            } while (1 < o);
            return e
        }

        function xd(e, t, n, r, i) {
            return e = 32767 * (e - n) * i, t = 32767 * (t - r) * i, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e | t << 1
        }

        function Cd(e) {
            for (var t = e, n = e;
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next, t !== e;);
            return n
        }

        function Id(e, t, n, r, i, a, o, s) {
            return 0 <= (i - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (r - s) - (n - o) * (t - s) && 0 <= (n - o) * (a - s) - (i - o) * (r - s)
        }

        function wd(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && !Ed(e, t) && Td(e, t) && Td(t, e) && Ld(e, t)
        }

        function Md(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }

        function bd(e, t) {
            return e.x === t.x && e.y === t.y
        }

        function Sd(e, t, n, r) {
            return !!(bd(e, n) && bd(t, r) || bd(e, r) && bd(n, t)) || 0 < Md(e, t, n) != 0 < Md(e, t, r) && 0 < Md(n, r, e) != 0 < Md(n, r, t)
        }

        function Ed(e, t) {
            var n = e;
            do {
                if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Sd(n, n.next, e, t)) return !0;
                n = n.next
            } while (n !== e);
            return !1
        }

        function Td(e, t) {
            return Md(e.prev, e, e.next) < 0 ? 0 <= Md(e, t, e.next) && 0 <= Md(e, e.prev, t) : Md(e, t, e.prev) < 0 || Md(e, e.next, t) < 0
        }

        function Ld(e, t) {
            for (var n = e, r = !1, i = (e.x + t.x) / 2, a = (e.y + t.y) / 2; n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next, n !== e;);
            return r
        }

        function Nd(e, t) {
            var n = new Pd(e.i, e.x, e.y),
                r = new Pd(t.i, t.x, t.y),
                i = e.next,
                a = t.prev;
            return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r
        }

        function Rd(e, t, n, r) {
            var i = new Pd(e, t, n);
            return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
        }

        function kd(e) {
            e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }

        function Pd(e, t, n) {
            this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }

        function Dd(e, t, n, r) {
            for (var i = 0, a = t, o = n - r; a < n; a += r) i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
            return i
        }
        var Od = {
            area: function (e) {
                for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                return .5 * n
            },
            isClockWise: function (e) {
                return Od.area(e) < 0
            },
            triangulateShape: function (e, t) {
                var n = [],
                    r = [],
                    i = [];
                Fd(e), Bd(n, e);
                var a = e.length;
                t.forEach(Fd);
                for (var o = 0; o < t.length; o++) r.push(a), a += t[o].length, Bd(n, t[o]);
                var s = sd.triangulate(n, r);
                for (o = 0; o < s.length; o += 3) i.push(s.slice(o, o + 3));
                return i
            }
        };

        function Fd(e) {
            var t = e.length;
            2 < t && e[t - 1].equals(e[0]) && e.pop()
        }

        function Bd(e, t) {
            for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
        }

        function Gd(e, t) {
            Ba.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: e,
                options: t
            }, this.fromBufferGeometry(new Ud(e, t)), this.mergeVertices()
        }

        function Ud(e, ee) {
            fa.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                shapes: e,
                options: ee
            }, e = (0, He.default)(e) ? e : [e];
            for (var te = this, ne = [], re = [], t = 0, n = e.length; t < n; t++) {
                var r = e[t];
                i(r)
            }

            function i(e) {
                var r = [],
                    t = void 0 !== ee.curveSegments ? ee.curveSegments : 12,
                    d = void 0 !== ee.steps ? ee.steps : 1,
                    n = void 0 !== ee.depth ? ee.depth : 100,
                    i = void 0 === ee.bevelEnabled || ee.bevelEnabled,
                    a = void 0 !== ee.bevelThickness ? ee.bevelThickness : 6,
                    o = void 0 !== ee.bevelSize ? ee.bevelSize : a - 2,
                    s = void 0 !== ee.bevelOffset ? ee.bevelOffset : 0,
                    f = void 0 !== ee.bevelSegments ? ee.bevelSegments : 3,
                    l = ee.extrudePath,
                    u = void 0 !== ee.UVGenerator ? ee.UVGenerator : zd;
                void 0 !== ee.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), n = ee.amount);
                var h, c, p, g, m, v, y, _, A = !1;
                l && (h = l.getSpacedPoints(d), A = !0, i = !1, c = l.computeFrenetFrames(d, !1), p = new Cr, g = new Cr, m = new Cr), i || (f = 0, a = 0, o = 0, s = 0);
                var x = e.extractPoints(t),
                    C = x.shape,
                    I = x.holes,
                    w = !Od.isClockWise(C);
                if (w)
                    for (C = C.reverse(), y = 0, _ = I.length; y < _; y++) v = I[y], Od.isClockWise(v) && (I[y] = v.reverse());
                var M = Od.triangulateShape(C, I),
                    b = C;
                for (y = 0, _ = I.length; y < _; y++) v = I[y], C = C.concat(v);

                function S(e, t, n) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                }
                var E, T, L, N, R, k, P = C.length,
                    D = M.length;

                function O(e, t, n) {
                    var r, i, a, o = e.x - t.x,
                        s = e.y - t.y,
                        l = n.x - e.x,
                        u = n.y - e.y,
                        h = o * o + s * s,
                        c = o * u - s * l;
                    if (Math.abs(c) > ie.default) {
                        var d = Math.sqrt(h),
                            f = Math.sqrt(l * l + u * u),
                            p = t.x - s / d,
                            g = t.y + o / d,
                            m = n.x - u / f,
                            v = n.y + l / f,
                            y = ((m - p) * u - (v - g) * l) / (o * u - s * l);
                        r = p + o * y - e.x, i = g + s * y - e.y;
                        var _ = r * r + i * i;
                        if (_ <= 2) return new cr(r, i);
                        a = Math.sqrt(_ / 2)
                    } else {
                        var A = !1;
                        o > ie.default ? l > ie.default && (A = !0) : o < -ie.default ? l < -ie.default && (A = !0) : Math.sign(s) === Math.sign(u) && (A = !0), a = A ? (r = -s, i = o, Math.sqrt(h)) : (r = o, i = s, Math.sqrt(h / 2))
                    }
                    return new cr(r / a, i / a)
                }
                for (var F = [], B = 0, G = b.length, U = G - 1, z = B + 1; B < G; B++, U++, z++) U === G && (U = 0), z === G && (z = 0), F[B] = O(b[B], b[U], b[z]);
                var V, H, W = [],
                    j = F.concat();
                for (y = 0, _ = I.length; y < _; y++) {
                    for (v = I[y], V = [], B = 0, G = v.length, U = G - 1, z = B + 1; B < G; B++, U++, z++) U === G && (U = 0), z === G && (z = 0), V[B] = O(v[B], v[U], v[z]);
                    W.push(V), j = j.concat(V)
                }
                for (E = 0; E < f; E++) {
                    for (L = E / f, N = a * Math.cos(L * Math.PI / 2), T = o * Math.sin(L * Math.PI / 2) + s, B = 0, G = b.length; B < G; B++) R = S(b[B], F[B], T), Z(R.x, R.y, -N);
                    for (y = 0, _ = I.length; y < _; y++)
                        for (v = I[y], V = W[y], B = 0, G = v.length; B < G; B++) R = S(v[B], V[B], T), Z(R.x, R.y, -N)
                }
                for (T = o + s, B = 0; B < P; B++) R = i ? S(C[B], j[B], T) : C[B], A ? (g.copy(c.normals[0]).multiplyScalar(R.x), p.copy(c.binormals[0]).multiplyScalar(R.y), m.copy(h[0]).add(g).add(p), Z(m.x, m.y, m.z)) : Z(R.x, R.y, 0);
                for (H = 1; H <= d; H++)
                    for (B = 0; B < P; B++) R = i ? S(C[B], j[B], T) : C[B], A ? (g.copy(c.normals[H]).multiplyScalar(R.x), p.copy(c.binormals[H]).multiplyScalar(R.y), m.copy(h[H]).add(g).add(p), Z(m.x, m.y, m.z)) : Z(R.x, R.y, n / d * H);
                for (E = f - 1; 0 <= E; E--) {
                    for (L = E / f, N = a * Math.cos(L * Math.PI / 2), T = o * Math.sin(L * Math.PI / 2) + s, B = 0, G = b.length; B < G; B++) R = S(b[B], F[B], T), Z(R.x, R.y, n + N);
                    for (y = 0, _ = I.length; y < _; y++)
                        for (v = I[y], V = W[y], B = 0, G = v.length; B < G; B++) R = S(v[B], V[B], T), A ? Z(R.x, R.y + h[d - 1].y, h[d - 1].x + N) : Z(R.x, R.y, n + N)
                }

                function Y() {
                    var e = ne.length / 3;
                    if (i) {
                        var t = 0,
                            n = P * t;
                        for (B = 0; B < D; B++) k = M[B], J(k[2] + n, k[1] + n, k[0] + n);
                        for (t = d + 2 * f, n = P * t, B = 0; B < D; B++) k = M[B], J(k[0] + n, k[1] + n, k[2] + n)
                    } else {
                        for (B = 0; B < D; B++) k = M[B], J(k[2], k[1], k[0]);
                        for (B = 0; B < D; B++) k = M[B], J(k[0] + P * d, k[1] + P * d, k[2] + P * d)
                    }
                    te.addGroup(e, ne.length / 3 - e, 0)
                }

                function q() {
                    var e = ne.length / 3,
                        t = 0;
                    for (X(b, t), t += b.length, y = 0, _ = I.length; y < _; y++) v = I[y], X(v, t), t += v.length;
                    te.addGroup(e, ne.length / 3 - e, 1)
                }

                function X(e, t) {
                    var n, r;
                    for (B = e.length; 0 <= --B;) {
                        n = B, r = B - 1, r < 0 && (r = e.length - 1);
                        var i = 0,
                            a = d + 2 * f;
                        for (i = 0; i < a; i++) {
                            var o = P * i,
                                s = P * (i + 1),
                                l = t + n + o,
                                u = t + r + o,
                                h = t + r + s,
                                c = t + n + s;
                            K(l, u, h, c)
                        }
                    }
                }

                function Z(e, t, n) {
                    r.push(e), r.push(t), r.push(n)
                }

                function J(e, t, n) {
                    Q(e), Q(t), Q(n);
                    var r = ne.length / 3,
                        i = u.generateTopUV(te, ne, r - 3, r - 2, r - 1);
                    $(i[0]), $(i[1]), $(i[2])
                }

                function K(e, t, n, r) {
                    Q(e), Q(t), Q(r), Q(t), Q(n), Q(r);
                    var i = ne.length / 3,
                        a = u.generateSideWallUV(te, ne, i - 6, i - 3, i - 2, i - 1);
                    $(a[0]), $(a[1]), $(a[3]), $(a[1]), $(a[2]), $(a[3])
                }

                function Q(e) {
                    ne.push(r[3 * e + 0]), ne.push(r[3 * e + 1]), ne.push(r[3 * e + 2])
                }

                function $(e) {
                    re.push(e.x), re.push(e.y)
                }
                Y(), q()
            }
            this.setAttribute("position", new na(ne, 3)), this.setAttribute("uv", new na(re, 2)), this.computeVertexNormals()
        }
        t.ShapeUtils = Od, Gd.prototype = (0, s.default)(Ba.prototype), Gd.prototype.constructor = Gd, Gd.prototype.toJSON = function () {
            var e = Ba.prototype.toJSON.call(this),
                t = this.parameters.shapes,
                n = this.parameters.options;
            return Vd(t, n, e)
        }, Ud.prototype = (0, s.default)(fa.prototype), Ud.prototype.constructor = Ud, Ud.prototype.toJSON = function () {
            var e = fa.prototype.toJSON.call(this),
                t = this.parameters.shapes,
                n = this.parameters.options;
            return Vd(t, n, e)
        };
        var zd = {
            generateTopUV: function (e, t, n, r, i) {
                var a = t[3 * n],
                    o = t[3 * n + 1],
                    s = t[3 * r],
                    l = t[3 * r + 1],
                    u = t[3 * i],
                    h = t[3 * i + 1];
                return [new cr(a, o), new cr(s, l), new cr(u, h)]
            },
            generateSideWallUV: function (e, t, n, r, i, a) {
                var o = t[3 * n],
                    s = t[3 * n + 1],
                    l = t[3 * n + 2],
                    u = t[3 * r],
                    h = t[3 * r + 1],
                    c = t[3 * r + 2],
                    d = t[3 * i],
                    f = t[3 * i + 1],
                    p = t[3 * i + 2],
                    g = t[3 * a],
                    m = t[3 * a + 1],
                    v = t[3 * a + 2];
                return Math.abs(s - h) < .01 ? [new cr(o, 1 - l), new cr(u, 1 - c), new cr(d, 1 - p), new cr(g, 1 - v)] : [new cr(s, 1 - l), new cr(h, 1 - c), new cr(f, 1 - p), new cr(m, 1 - v)]
            }
        };

        function Vd(e, t, n) {
            if (n.shapes = [], (0, He.default)(e))
                for (var r = 0, i = e.length; r < i; r++) {
                    var a = e[r];
                    n.shapes.push(a.uuid)
                } else n.shapes.push(e.uuid);
            return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
        }

        function Hd(e, t) {
            Ba.call(this), this.type = "TextGeometry", this.parameters = {
                text: e,
                parameters: t
            }, this.fromBufferGeometry(new Wd(e, t)), this.mergeVertices()
        }

        function Wd(e, t) {
            t = t || {};
            var n = t.font;
            if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Ba;
            var r = n.generateShapes(e, t.size);
            t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ud.call(this, r, t), this.type = "TextBufferGeometry"
        }

        function jd(e, t, n, r, i, a, o) {
            Ba.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: r,
                phiLength: i,
                thetaStart: a,
                thetaLength: o
            }, this.fromBufferGeometry(new Yd(e, t, n, r, i, a, o)), this.mergeVertices()
        }

        function Yd(e, t, n, r, i, a, o) {
            fa.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: r,
                phiLength: i,
                thetaStart: a,
                thetaLength: o
            }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI;
            var s, l, u = Math.min(a + o, Math.PI),
                h = 0,
                c = [],
                d = new Cr,
                f = new Cr,
                p = [],
                g = [],
                m = [],
                v = [];
            for (l = 0; l <= n; l++) {
                var y = [],
                    _ = l / n,
                    A = 0;
                for (0 == l && 0 == a ? A = .5 / t : l == n && u == Math.PI && (A = -.5 / t), s = 0; s <= t; s++) {
                    var x = s / t;
                    d.x = -e * Math.cos(r + x * i) * Math.sin(a + _ * o), d.y = e * Math.cos(a + _ * o), d.z = e * Math.sin(r + x * i) * Math.sin(a + _ * o), g.push(d.x, d.y, d.z), f.copy(d).normalize(), m.push(f.x, f.y, f.z), v.push(x + A, 1 - _), y.push(h++)
                }
                c.push(y)
            }
            for (l = 0; l < n; l++)
                for (s = 0; s < t; s++) {
                    var C = c[l][s + 1],
                        I = c[l][s],
                        w = c[l + 1][s],
                        M = c[l + 1][s + 1];
                    (0 !== l || 0 < a) && p.push(C, I, M), (l !== n - 1 || u < Math.PI) && p.push(I, w, M)
                }
            this.setIndex(p), this.setAttribute("position", new na(g, 3)), this.setAttribute("normal", new na(m, 3)), this.setAttribute("uv", new na(v, 2))
        }

        function qd(e, t, n, r, i, a) {
            Ba.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: i,
                thetaLength: a
            }, this.fromBufferGeometry(new Xd(e, t, n, r, i, a)), this.mergeVertices()
        }

        function Xd(e, t, n, r, i, a) {
            fa.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: e,
                outerRadius: t,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: i,
                thetaLength: a
            }, e = e || .5, t = t || 1, i = void 0 !== i ? i : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
            var o, s, l, u = [],
                h = [],
                c = [],
                d = [],
                f = e,
                p = (t - e) / r,
                g = new Cr,
                m = new cr;
            for (s = 0; s <= r; s++) {
                for (l = 0; l <= n; l++) o = i + l / n * a, g.x = f * Math.cos(o), g.y = f * Math.sin(o), h.push(g.x, g.y, g.z), c.push(0, 0, 1), m.x = (g.x / t + 1) / 2, m.y = (g.y / t + 1) / 2, d.push(m.x, m.y);
                f += p
            }
            for (s = 0; s < r; s++) {
                var v = s * (n + 1);
                for (l = 0; l < n; l++) {
                    o = l + v;
                    var y = o,
                        _ = o + n + 1,
                        A = o + n + 2,
                        x = o + 1;
                    u.push(y, _, x), u.push(_, A, x)
                }
            }
            this.setIndex(u), this.setAttribute("position", new na(h, 3)), this.setAttribute("normal", new na(c, 3)), this.setAttribute("uv", new na(d, 2))
        }

        function Zd(e, t, n, r) {
            Ba.call(this), this.type = "LatheGeometry", this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: r
            }, this.fromBufferGeometry(new Jd(e, t, n, r)), this.mergeVertices()
        }

        function Jd(e, t, n, r) {
            fa.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: e,
                segments: t,
                phiStart: n,
                phiLength: r
            }, t = Math.floor(t) || 12, n = n || 0, r = r || 2 * Math.PI, r = hr.clamp(r, 0, 2 * Math.PI);
            var i, a, o, s = [],
                l = [],
                u = [],
                h = 1 / t,
                c = new Cr,
                d = new cr;
            for (a = 0; a <= t; a++) {
                var f = n + a * h * r,
                    p = Math.sin(f),
                    g = Math.cos(f);
                for (o = 0; o <= e.length - 1; o++) c.x = e[o].x * p, c.y = e[o].y, c.z = e[o].x * g, l.push(c.x, c.y, c.z), d.x = a / t, d.y = o / (e.length - 1), u.push(d.x, d.y)
            }
            for (a = 0; a < t; a++)
                for (o = 0; o < e.length - 1; o++) {
                    i = o + a * e.length;
                    var m = i,
                        v = i + e.length,
                        y = i + e.length + 1,
                        _ = i + 1;
                    s.push(m, v, _), s.push(v, y, _)
                }
            if (this.setIndex(s), this.setAttribute("position", new na(l, 3)), this.setAttribute("uv", new na(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                var A = this.attributes.normal.array,
                    x = new Cr,
                    C = new Cr,
                    I = new Cr;
                for (i = t * e.length * 3, a = 0, o = 0; a < e.length; a++, o += 3) x.x = A[o + 0], x.y = A[o + 1], x.z = A[o + 2], C.x = A[i + o + 0], C.y = A[i + o + 1], C.z = A[i + o + 2], I.addVectors(x, C).normalize(), A[o + 0] = A[i + o + 0] = I.x, A[o + 1] = A[i + o + 1] = I.y, A[o + 2] = A[i + o + 2] = I.z
            }
        }

        function Kd(e, t) {
            Ba.call(this), this.type = "ShapeGeometry", "object" === (0, o.default)(t) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                shapes: e,
                curveSegments: t
            }, this.fromBufferGeometry(new Qd(e, t)), this.mergeVertices()
        }

        function Qd(e, p) {
            fa.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: e,
                curveSegments: p
            }, p = p || 12;
            var g = [],
                m = [],
                v = [],
                y = [],
                t = 0,
                _ = 0;
            if (!1 === (0, He.default)(e)) r(e);
            else
                for (var n = 0; n < e.length; n++) r(e[n]), this.addGroup(t, _, n), t += _, _ = 0;

            function r(e) {
                var t, n, r, i = m.length / 3,
                    a = e.extractPoints(p),
                    o = a.shape,
                    s = a.holes;
                for (!1 === Od.isClockWise(o) && (o = o.reverse()), t = 0, n = s.length; t < n; t++) r = s[t], !0 === Od.isClockWise(r) && (s[t] = r.reverse());
                var l = Od.triangulateShape(o, s);
                for (t = 0, n = s.length; t < n; t++) r = s[t], o = o.concat(r);
                for (t = 0, n = o.length; t < n; t++) {
                    var u = o[t];
                    m.push(u.x, u.y, 0), v.push(0, 0, 1), y.push(u.x, u.y)
                }
                for (t = 0, n = l.length; t < n; t++) {
                    var h = l[t],
                        c = h[0] + i,
                        d = h[1] + i,
                        f = h[2] + i;
                    g.push(c, d, f), _ += 3
                }
            }
            this.setIndex(g), this.setAttribute("position", new na(m, 3)), this.setAttribute("normal", new na(v, 3)), this.setAttribute("uv", new na(y, 2))
        }

        function $d(e, t) {
            if (t.shapes = [], (0, He.default)(e))
                for (var n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    t.shapes.push(i.uuid)
                } else t.shapes.push(e.uuid);
            return t
        }

        function ef(e, t) {
            fa.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: t
            }, t = void 0 !== t ? t : 1;
            var n, r, i, a, o = [],
                s = Math.cos(hr.DEG2RAD * t),
                l = [0, 0],
                u = {},
                h = ["a", "b", "c"];
            e.isBufferGeometry ? (a = new Ba, a.fromBufferGeometry(e)) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals();
            for (var c = a.vertices, d = a.faces, f = 0, p = d.length; f < p; f++)
                for (var g = d[f], m = 0; m < 3; m++) n = g[h[m]], r = g[h[(m + 1) % 3]], l[0] = Math.min(n, r), l[1] = Math.max(n, r), i = l[0] + "," + l[1], void 0 === u[i] ? u[i] = {
                    index1: l[0],
                    index2: l[1],
                    face1: f,
                    face2: void 0
                } : u[i].face2 = f;
            for (i in u) {
                var v = u[i];
                if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                    var y = c[v.index1];
                    o.push(y.x, y.y, y.z), y = c[v.index2], o.push(y.x, y.y, y.z)
                }
            }
            this.setAttribute("position", new na(o, 3))
        }

        function tf(e, t, n, r, i, a, o, s) {
            Ba.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: r,
                heightSegments: i,
                openEnded: a,
                thetaStart: o,
                thetaLength: s
            }, this.fromBufferGeometry(new nf(e, t, n, r, i, a, o, s)), this.mergeVertices()
        }

        function nf(v, y, _, A, x, e, C, I) {
            fa.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: v,
                radiusBottom: y,
                height: _,
                radialSegments: A,
                heightSegments: x,
                openEnded: e,
                thetaStart: C,
                thetaLength: I
            };
            var w = this;
            v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, _ = _ || 1, A = Math.floor(A) || 8, x = Math.floor(x) || 1, e = void 0 !== e && e, C = void 0 !== C ? C : 0, I = void 0 !== I ? I : 2 * Math.PI;
            var M = [],
                b = [],
                S = [],
                E = [],
                T = 0,
                L = [],
                N = _ / 2,
                R = 0;

            function t() {
                var e, t, n = new Cr,
                    r = new Cr,
                    i = 0,
                    a = (y - v) / _;
                for (t = 0; t <= x; t++) {
                    var o = [],
                        s = t / x,
                        l = s * (y - v) + v;
                    for (e = 0; e <= A; e++) {
                        var u = e / A,
                            h = u * I + C,
                            c = Math.sin(h),
                            d = Math.cos(h);
                        r.x = l * c, r.y = -s * _ + N, r.z = l * d, b.push(r.x, r.y, r.z), n.set(c, a, d).normalize(), S.push(n.x, n.y, n.z), E.push(u, 1 - s), o.push(T++)
                    }
                    L.push(o)
                }
                for (e = 0; e < A; e++)
                    for (t = 0; t < x; t++) {
                        var f = L[t][e],
                            p = L[t + 1][e],
                            g = L[t + 1][e + 1],
                            m = L[t][e + 1];
                        M.push(f, p, m), M.push(p, g, m), i += 6
                    }
                w.addGroup(R, i, 0), R += i
            }

            function n(e) {
                var t, n, r, i = new cr,
                    a = new Cr,
                    o = 0,
                    s = !0 === e ? v : y,
                    l = !0 === e ? 1 : -1;
                for (n = T, t = 1; t <= A; t++) b.push(0, N * l, 0), S.push(0, l, 0), E.push(.5, .5), T++;
                for (r = T, t = 0; t <= A; t++) {
                    var u = t / A,
                        h = u * I + C,
                        c = Math.cos(h),
                        d = Math.sin(h);
                    a.x = s * d, a.y = N * l, a.z = s * c, b.push(a.x, a.y, a.z), S.push(0, l, 0), i.x = .5 * c + .5, i.y = .5 * d * l + .5, E.push(i.x, i.y), T++
                }
                for (t = 0; t < A; t++) {
                    var f = n + t,
                        p = r + t;
                    !0 === e ? M.push(p, p + 1, f) : M.push(p + 1, p, f), o += 3
                }
                w.addGroup(R, o, !0 === e ? 1 : 2), R += o
            }
            t(), !1 === e && (0 < v && n(!0), 0 < y && n(!1)), this.setIndex(M), this.setAttribute("position", new na(b, 3)), this.setAttribute("normal", new na(S, 3)), this.setAttribute("uv", new na(E, 2))
        }

        function rf(e, t, n, r, i, a, o) {
            tf.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: r,
                openEnded: i,
                thetaStart: a,
                thetaLength: o
            }
        }

        function af(e, t, n, r, i, a, o) {
            nf.call(this, 0, e, t, n, r, i, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                radius: e,
                height: t,
                radialSegments: n,
                heightSegments: r,
                openEnded: i,
                thetaStart: a,
                thetaLength: o
            }
        }

        function of (e, t, n, r) {
            Ba.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: r
            }, this.fromBufferGeometry(new sf(e, t, n, r)), this.mergeVertices()
        }

        function sf(e, t, n, r) {
            fa.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: e,
                segments: t,
                thetaStart: n,
                thetaLength: r
            }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
            var i, a, o = [],
                s = [],
                l = [],
                u = [],
                h = new Cr,
                c = new cr;
            for (s.push(0, 0, 0), l.push(0, 0, 1), u.push(.5, .5), a = 0, i = 3; a <= t; a++, i += 3) {
                var d = n + a / t * r;
                h.x = e * Math.cos(d), h.y = e * Math.sin(d), s.push(h.x, h.y, h.z), l.push(0, 0, 1), c.x = (s[i] / e + 1) / 2, c.y = (s[i + 1] / e + 1) / 2, u.push(c.x, c.y)
            }
            for (i = 1; i <= t; i++) o.push(i, i + 1, 0);
            this.setIndex(o), this.setAttribute("position", new na(s, 3)), this.setAttribute("normal", new na(l, 3)), this.setAttribute("uv", new na(u, 2))
        }
        Hd.prototype = (0, s.default)(Ba.prototype), Hd.prototype.constructor = Hd, Wd.prototype = (0, s.default)(Ud.prototype), Wd.prototype.constructor = Wd, jd.prototype = (0, s.default)(Ba.prototype), jd.prototype.constructor = jd, Yd.prototype = (0, s.default)(fa.prototype), Yd.prototype.constructor = Yd, qd.prototype = (0, s.default)(Ba.prototype), qd.prototype.constructor = qd, Xd.prototype = (0, s.default)(fa.prototype), Xd.prototype.constructor = Xd, Zd.prototype = (0, s.default)(Ba.prototype), Zd.prototype.constructor = Zd, Jd.prototype = (0, s.default)(fa.prototype), Jd.prototype.constructor = Jd, Kd.prototype = (0, s.default)(Ba.prototype), Kd.prototype.constructor = Kd, Kd.prototype.toJSON = function () {
            var e = Ba.prototype.toJSON.call(this),
                t = this.parameters.shapes;
            return $d(t, e)
        }, Qd.prototype = (0, s.default)(fa.prototype), Qd.prototype.constructor = Qd, Qd.prototype.toJSON = function () {
            var e = fa.prototype.toJSON.call(this),
                t = this.parameters.shapes;
            return $d(t, e)
        }, ef.prototype = (0, s.default)(fa.prototype), ef.prototype.constructor = ef, tf.prototype = (0, s.default)(Ba.prototype), tf.prototype.constructor = tf, nf.prototype = (0, s.default)(fa.prototype), nf.prototype.constructor = nf, rf.prototype = (0, s.default)(tf.prototype), rf.prototype.constructor = rf, af.prototype = (0, s.default)(nf.prototype), af.prototype.constructor = af, of .prototype = (0, s.default)(Ba.prototype), of .prototype.constructor = of , sf.prototype = (0, s.default)(fa.prototype), sf.prototype.constructor = sf;
        var lf = (0, a.default)({
            __proto__: null,
            WireframeGeometry: Vc,
            ParametricGeometry: Hc,
            ParametricBufferGeometry: Wc,
            TetrahedronGeometry: qc,
            TetrahedronBufferGeometry: Xc,
            OctahedronGeometry: Zc,
            OctahedronBufferGeometry: Jc,
            IcosahedronGeometry: Kc,
            IcosahedronBufferGeometry: Qc,
            DodecahedronGeometry: $c,
            DodecahedronBufferGeometry: ed,
            PolyhedronGeometry: jc,
            PolyhedronBufferGeometry: Yc,
            TubeGeometry: td,
            TubeBufferGeometry: nd,
            TorusKnotGeometry: rd,
            TorusKnotBufferGeometry: id,
            TorusGeometry: ad,
            TorusBufferGeometry: od,
            TextGeometry: Hd,
            TextBufferGeometry: Wd,
            SphereGeometry: jd,
            SphereBufferGeometry: Yd,
            RingGeometry: qd,
            RingBufferGeometry: Xd,
            PlaneGeometry: oo,
            PlaneBufferGeometry: so,
            LatheGeometry: Zd,
            LatheBufferGeometry: Jd,
            ShapeGeometry: Kd,
            ShapeBufferGeometry: Qd,
            ExtrudeGeometry: Gd,
            ExtrudeBufferGeometry: Ud,
            EdgesGeometry: ef,
            ConeGeometry: rf,
            ConeBufferGeometry: af,
            CylinderGeometry: tf,
            CylinderBufferGeometry: nf,
            CircleGeometry: of ,
            CircleBufferGeometry: sf,
            BoxGeometry: Ga,
            BoxBufferGeometry: Ua
        });

        function uf(e) {
            ji.call(this), this.type = "ShadowMaterial", this.color = new Gi(0), this.transparent = !0, this.setValues(e)
        }

        function hf(e) {
            Ya.call(this, e), this.type = "RawShaderMaterial"
        }

        function cf(e) {
            ji.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new Gi(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Gi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new cr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e)
        }

        function df(e) {
            cf.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new cr(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(e)
        }

        function ff(e) {
            ji.call(this), this.type = "MeshPhongMaterial", this.color = new Gi(16777215), this.specular = new Gi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Gi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new cr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = D, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function pf(e) {
            ji.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.color = new Gi(16777215), this.specular = new Gi(1118481), this.shininess = 30, this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Gi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new cr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function gf(e) {
            ji.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new cr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function mf(e) {
            ji.call(this), this.type = "MeshLambertMaterial", this.color = new Gi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Gi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = D, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function vf(e) {
            ji.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new Gi(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kn, this.normalScale = new cr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
        }

        function yf(e) {
            Ac.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
        }
        uf.prototype = (0, s.default)(ji.prototype), uf.prototype.constructor = uf, uf.prototype.isShadowMaterial = !0, uf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this
        }, hf.prototype = (0, s.default)(Ya.prototype), hf.prototype.constructor = hf, hf.prototype.isRawShaderMaterial = !0, cf.prototype = (0, s.default)(ji.prototype), cf.prototype.constructor = cf, cf.prototype.isMeshStandardMaterial = !0, cf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.defines = {
                STANDARD: ""
            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this
        }, df.prototype = (0, s.default)(cf.prototype), df.prototype.constructor = df, df.prototype.isMeshPhysicalMaterial = !0, df.prototype.copy = function (e) {
            return cf.prototype.copy.call(this, e), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Gi).copy(e.sheen) : this.sheen = null, this.transparency = e.transparency, this
        }, ff.prototype = (0, s.default)(ji.prototype), ff.prototype.constructor = ff, ff.prototype.isMeshPhongMaterial = !0, ff.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, pf.prototype = (0, s.default)(ji.prototype), pf.prototype.constructor = pf, pf.prototype.isMeshToonMaterial = !0, pf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, gf.prototype = (0, s.default)(ji.prototype), gf.prototype.constructor = gf, gf.prototype.isMeshNormalMaterial = !0, gf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, mf.prototype = (0, s.default)(ji.prototype), mf.prototype.constructor = mf, mf.prototype.isMeshLambertMaterial = !0, mf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, vf.prototype = (0, s.default)(ji.prototype), vf.prototype.constructor = vf, vf.prototype.isMeshMatcapMaterial = !0, vf.prototype.copy = function (e) {
            return ji.prototype.copy.call(this, e), this.defines = {
                MATCAP: ""
            }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
        }, yf.prototype = (0, s.default)(Ac.prototype), yf.prototype.constructor = yf, yf.prototype.isLineDashedMaterial = !0, yf.prototype.copy = function (e) {
            return Ac.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
        };
        var _f = (0, a.default)({
                __proto__: null,
                ShadowMaterial: uf,
                SpriteMaterial: Yh,
                RawShaderMaterial: hf,
                ShaderMaterial: Ya,
                PointsMaterial: Nc,
                MeshPhysicalMaterial: df,
                MeshStandardMaterial: cf,
                MeshPhongMaterial: ff,
                MeshToonMaterial: pf,
                MeshNormalMaterial: gf,
                MeshLambertMaterial: mf,
                MeshDepthMaterial: Eh,
                MeshDistanceMaterial: Th,
                MeshBasicMaterial: Yi,
                MeshMatcapMaterial: vf,
                LineDashedMaterial: yf,
                LineBasicMaterial: Ac,
                Material: ji
            }),
            Af = {
                arraySlice: function (e, t, n) {
                    return Af.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                },
                convertArray: function (e, t, n) {
                    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function (e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function (n) {
                    function e(e, t) {
                        return n[e] - n[t]
                    }
                    for (var t = n.length, r = new Array(t), i = 0; i !== t; ++i) r[i] = i;
                    return r.sort(e), r
                },
                sortedArray: function (e, t, n) {
                    for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)
                        for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s + l];
                    return i
                },
                flattenJSON: function (e, t, n, r) {
                    for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a = e[i++];
                    if (void 0 !== a) {
                        var o = a[r];
                        if (void 0 !== o)
                            if ((0, He.default)(o))
                                for (; o = a[r], void 0 !== o && (t.push(a.time), n.push.apply(n, o)), a = e[i++], void 0 !== a;);
                            else if (void 0 !== o.toArray)
                            for (; o = a[r], void 0 !== o && (t.push(a.time), o.toArray(n, n.length)), a = e[i++], void 0 !== a;);
                        else
                            for (; o = a[r], void 0 !== o && (t.push(a.time), n.push(o)), a = e[i++], void 0 !== a;);
                    }
                },
                subclip: function (e, t, n, r, i) {
                    i = i || 30;
                    var a = e.clone();
                    a.name = t;
                    for (var o = [], s = 0; s < a.tracks.length; ++s) {
                        for (var l = a.tracks[s], u = l.getValueSize(), h = [], c = [], d = 0; d < l.times.length; ++d) {
                            var f = l.times[d] * i;
                            if (!(f < n || r <= f)) {
                                h.push(l.times[d]);
                                for (var p = 0; p < u; ++p) c.push(l.values[d * u + p])
                            }
                        }
                        0 !== h.length && (l.times = Af.convertArray(h, l.times.constructor), l.values = Af.convertArray(c, l.values.constructor), o.push(l))
                    }
                    a.tracks = o;
                    var g = Infinity;
                    for (s = 0; s < a.tracks.length; ++s) g > a.tracks[s].times[0] && (g = a.tracks[s].times[0]);
                    for (s = 0; s < a.tracks.length; ++s) a.tracks[s].shift(-1 * g);
                    return a.resetDuration(), a
                }
            };

        function xf(e, t, n, r) {
            this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n
        }

        function Cf(e, t, n, r) {
            xf.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function If(e, t, n, r) {
            xf.call(this, e, t, n, r)
        }

        function wf(e, t, n, r) {
            xf.call(this, e, t, n, r)
        }

        function Mf(e, t, n, r) {
            if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
            this.name = e, this.times = Af.convertArray(t, this.TimeBufferType), this.values = Af.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
        }

        function bf(e, t, n) {
            Mf.call(this, e, t, n)
        }

        function Sf(e, t, n, r) {
            Mf.call(this, e, t, n, r)
        }

        function Ef(e, t, n, r) {
            Mf.call(this, e, t, n, r)
        }

        function Tf(e, t, n, r) {
            xf.call(this, e, t, n, r)
        }

        function Lf(e, t, n, r) {
            Mf.call(this, e, t, n, r)
        }

        function Nf(e, t, n, r) {
            Mf.call(this, e, t, n, r)
        }

        function Rf(e, t, n, r) {
            Mf.call(this, e, t, n, r)
        }

        function kf(e, t, n) {
            this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = hr.generateUUID(), this.duration < 0 && this.resetDuration()
        }

        function Pf(e) {
            switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return Ef;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Rf;
                case "color":
                    return Sf;
                case "quaternion":
                    return Lf;
                case "bool":
                case "boolean":
                    return bf;
                case "string":
                    return Nf
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }

        function Df(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var t = Pf(e.type);
            if (void 0 === e.times) {
                var n = [],
                    r = [];
                Af.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        }
        t.AnimationUtils = Af, (0, We.default)(xf.prototype, {
            evaluate: function (e) {
                var t = this.parameterPositions,
                    n = this._cachedIndex,
                    r = t[n],
                    i = t[n - 1];
                e: {
                    t: {
                        var a;n: {
                            r: if (!(e < r)) {
                                for (var o = n + 2;;) {
                                    if (void 0 === r) {
                                        if (e < i) break r;
                                        return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i)
                                    }
                                    if (n === o) break;
                                    if (i = r, r = t[++n], e < r) break t
                                }
                                a = t.length;
                                break n
                            }if (i <= e) break e;
                            var s = t[1];
                            for (e < s && (n = 2, i = s), o = n - 2;;) {
                                if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                if (n === o) break;
                                if (r = i, i = t[--n - 1], i <= e) break t
                            }
                            a = n,
                            n = 0
                        }
                        for (; n < a;) {
                            var l = n + a >>> 1;
                            e < t[l] ? a = l : n = l + 1
                        }
                        if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0,
                        this.beforeStart_(0, e, r);
                        if (void 0 === r) return n = t.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, i, e)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, i, r)
                }
                return this.interpolate_(n, i, e, r)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function () {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function (e) {
                for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a) t[a] = n[i + a];
                return t
            },
            interpolate_: function () {
                throw new Error("call to abstract method")
            },
            intervalChanged_: function () {}
        }), (0, We.default)(xf.prototype, {
            beforeStart_: xf.prototype.copySampleValue_,
            afterEnd_: xf.prototype.copySampleValue_
        }), Cf.prototype = (0, We.default)((0, s.default)(xf.prototype), {
            constructor: Cf,
            DefaultSettings_: {
                endingStart: vn,
                endingEnd: vn
            },
            intervalChanged_: function (e, t, n) {
                var r = this.parameterPositions,
                    i = e - 2,
                    a = e + 1,
                    o = r[i],
                    s = r[a];
                if (void 0 === o) switch (this.getSettings_().endingStart) {
                    case yn:
                        i = e, o = 2 * t - n;
                        break;
                    case _n:
                        i = r.length - 2, o = t + r[i] - r[i + 1];
                        break;
                    default:
                        i = e, o = n
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case yn:
                        a = e, s = 2 * n - t;
                        break;
                    case _n:
                        a = 1, s = n + r[1] - r[0];
                        break;
                    default:
                        a = e - 1, s = t
                }
                var l = .5 * (n - t),
                    u = this.valueSize;
                this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * u, this._offsetNext = a * u
            },
            interpolate_: function (e, t, n, r) {
                for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = this._offsetPrev, h = this._offsetNext, c = this._weightPrev, d = this._weightNext, f = (n - t) / (r - t), p = f * f, g = p * f, m = -c * g + 2 * c * p - c * f, v = (1 + c) * g + (-1.5 - 2 * c) * p + (-.5 + c) * f + 1, y = (-1 - d) * g + (1.5 + d) * p + .5 * f, _ = d * g - d * p, A = 0; A !== o; ++A) i[A] = m * a[u + A] + v * a[l + A] + y * a[s + A] + _ * a[h + A];
                return i
            }
        }), If.prototype = (0, We.default)((0, s.default)(xf.prototype), {
            constructor: If,
            interpolate_: function (e, t, n, r) {
                for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = (n - t) / (r - t), h = 1 - u, c = 0; c !== o; ++c) i[c] = a[l + c] * h + a[s + c] * u;
                return i
            }
        }), wf.prototype = (0, We.default)((0, s.default)(xf.prototype), {
            constructor: wf,
            interpolate_: function (e) {
                return this.copySampleValue_(e - 1)
            }
        }), (0, We.default)(Mf, {
            toJSON: function (e) {
                var t, n = e.constructor;
                if (void 0 !== n.toJSON) t = n.toJSON(e);
                else {
                    t = {
                        name: e.name,
                        times: Af.convertArray(e.times, Array),
                        values: Af.convertArray(e.values, Array)
                    };
                    var r = e.getInterpolation();
                    r !== e.DefaultInterpolation && (t.interpolation = r)
                }
                return t.type = e.ValueTypeName, t
            }
        }), (0, We.default)(Mf.prototype, {
            constructor: Mf,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: gn,
            InterpolantFactoryMethodDiscrete: function (e) {
                return new wf(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodLinear: function (e) {
                return new If(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: function (e) {
                return new Cf(this.times, this.values, this.getValueSize(), e)
            },
            setInterpolation: function (e) {
                var t;
                switch (e) {
                    case pn:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case gn:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case mn:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 !== t) return this.createInterpolant = t, this;
                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation) throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", n), this
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return pn;
                    case this.InterpolantFactoryMethodLinear:
                        return gn;
                    case this.InterpolantFactoryMethodSmooth:
                        return mn
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (e) {
                if (0 !== e)
                    for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                return this
            },
            scale: function (e) {
                if (1 !== e)
                    for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                return this
            },
            trim: function (e, t) {
                for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e;) ++i;
                for (; - 1 !== a && n[a] > t;) --a;
                if (++a, 0 !== i || a !== r) {
                    a <= i && (a = Math.max(a, 1), i = a - 1);
                    var o = this.getValueSize();
                    this.times = Af.arraySlice(n, i, a), this.values = Af.arraySlice(this.values, i * o, a * o)
                }
                return this
            },
            validate: function () {
                var e = !0,
                    t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                var n = this.times,
                    r = this.values,
                    i = n.length;
                0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                for (var a = null, o = 0; o !== i; o++) {
                    var s = n[o];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                        break
                    }
                    if (null !== a && s < a) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                        break
                    }
                    a = s
                }
                if (void 0 !== r && Af.isTypedArray(r)) {
                    o = 0;
                    for (var l = r.length; o !== l; ++o) {
                        var u = r[o];
                        if (isNaN(u)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, u), e = !1;
                            break
                        }
                    }
                }
                return e
            },
            optimize: function () {
                for (var e = Af.arraySlice(this.times), t = Af.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === mn, i = 1, a = e.length - 1, o = 1; o < a; ++o) {
                    var s = !1,
                        l = e[o],
                        u = e[o + 1];
                    if (l !== u && (1 !== o || l !== l[0]))
                        if (r) s = !0;
                        else
                            for (var h = o * n, c = h - n, d = h + n, f = 0; f !== n; ++f) {
                                var p = t[h + f];
                                if (p !== t[c + f] || p !== t[d + f]) {
                                    s = !0;
                                    break
                                }
                            }
                    if (s) {
                        if (o !== i) {
                            e[i] = e[o];
                            var g = o * n,
                                m = i * n;
                            for (f = 0; f !== n; ++f) t[m + f] = t[g + f]
                        }++i
                    }
                }
                if (0 < a) {
                    for (e[i] = e[a], g = a * n, m = i * n, f = 0; f !== n; ++f) t[m + f] = t[g + f];
                    ++i
                }
                return i !== e.length ? (this.times = Af.arraySlice(e, 0, i), this.values = Af.arraySlice(t, 0, i * n)) : (this.times = e, this.values = t), this
            },
            clone: function () {
                var e = Af.arraySlice(this.times, 0),
                    t = Af.arraySlice(this.values, 0),
                    n = this.constructor,
                    r = new n(this.name, e, t);
                return r.createInterpolant = this.createInterpolant, r
            }
        }), bf.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: bf,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: pn,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Sf.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: Sf,
            ValueTypeName: "color"
        }), Ef.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: Ef,
            ValueTypeName: "number"
        }), Tf.prototype = (0, We.default)((0, s.default)(xf.prototype), {
            constructor: Tf,
            interpolate_: function (e, t, n, r) {
                for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = (n - t) / (r - t), u = s + o; s !== u; s += 4) _r.slerpFlat(i, 0, a, s - o, a, s, l);
                return i
            }
        }), Lf.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: Lf,
            ValueTypeName: "quaternion",
            DefaultInterpolation: gn,
            InterpolantFactoryMethodLinear: function (e) {
                return new Tf(this.times, this.values, this.getValueSize(), e)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), Nf.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: Nf,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: pn,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Rf.prototype = (0, We.default)((0, s.default)(Mf.prototype), {
            constructor: Rf,
            ValueTypeName: "vector"
        }), (0, We.default)(kf, {
            parse: function (e) {
                for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push(Df(n[i]).scale(r));
                return new kf(e.name, e.duration, t)
            },
            toJSON: function (e) {
                for (var t = [], n = e.tracks, r = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid
                    }, i = 0, a = n.length; i !== a; ++i) t.push(Mf.toJSON(n[i]));
                return r
            },
            CreateFromMorphTargetSequence: function (e, t, n, r) {
                for (var i = t.length, a = [], o = 0; o < i; o++) {
                    var s = [],
                        l = [];
                    s.push((o + i - 1) % i, o, (o + 1) % i), l.push(0, 1, 0);
                    var u = Af.getKeyframeOrder(s);
                    s = Af.sortedArray(s, 1, u), l = Af.sortedArray(l, 1, u), r || 0 !== s[0] || (s.push(i), l.push(l[0])), a.push(new Ef(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
                }
                return new kf(e, -1, a)
            },
            findByName: function (e, t) {
                var n = e;
                if (!(0, He.default)(e)) {
                    var r = e;
                    n = r.geometry && r.geometry.animations || r.animations
                }
                for (var i = 0; i < n.length; i++)
                    if (n[i].name === t) return n[i];
                return null
            },
            CreateClipsFromMorphTargetSequences: function (e, t, n) {
                for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                    var s = e[a],
                        l = s.name.match(i);
                    if (l && 1 < l.length) {
                        var u = l[1],
                            h = r[u];
                        h || (r[u] = h = []), h.push(s)
                    }
                }
                var c = [];
                for (var u in r) c.push(kf.CreateFromMorphTargetSequence(u, r[u], t, n));
                return c
            },
            parseAnimation: function (e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                for (var n = function (e, t, n, r, i) {
                        if (0 !== n.length) {
                            var a = [],
                                o = [];
                            Af.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o))
                        }
                    }, r = [], i = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                    var u = s[l].keys;
                    if (u && 0 !== u.length)
                        if (u[0].morphTargets) {
                            for (var h = {}, c = 0; c < u.length; c++)
                                if (u[c].morphTargets)
                                    for (var d = 0; d < u[c].morphTargets.length; d++) h[u[c].morphTargets[d]] = -1;
                            for (var f in h) {
                                var p = [],
                                    g = [];
                                for (d = 0; d !== u[c].morphTargets.length; ++d) {
                                    var m = u[c];
                                    p.push(m.time), g.push(m.morphTarget === f ? 1 : 0)
                                }
                                r.push(new Ef(".morphTargetInfluence[" + f + "]", p, g))
                            }
                            a = h.length * (o || 1)
                        } else {
                            var v = ".bones[" + t[l].name + "]";
                            n(Rf, v + ".position", u, "pos", r), n(Lf, v + ".quaternion", u, "rot", r), n(Rf, v + ".scale", u, "scl", r)
                        }
                }
                if (0 === r.length) return null;
                var y = new kf(i, a, r);
                return y
            }
        }), (0, We.default)(kf.prototype, {
            resetDuration: function () {
                for (var e = this.tracks, t = 0, n = 0, r = e.length; n !== r; ++n) {
                    var i = this.tracks[n];
                    t = Math.max(t, i.times[i.times.length - 1])
                }
                return this.duration = t, this
            },
            trim: function () {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            },
            validate: function () {
                for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            },
            optimize: function () {
                for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            },
            clone: function () {
                for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new kf(this.name, this.duration, e)
            }
        });
        var Of = {
            enabled: !1,
            files: {},
            add: function (e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function (e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function (e) {
                delete this.files[e]
            },
            clear: function () {
                this.files = {}
            }
        };

        function Ff(e, t, n) {
            var r = this,
                i = !1,
                a = 0,
                o = 0,
                s = void 0,
                l = [];
            this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                o++, !1 === i && void 0 !== r.onStart && r.onStart(e, a, o), i = !0
            }, this.itemEnd = function (e) {
                a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (i = !1, void 0 !== r.onLoad && r.onLoad())
            }, this.itemError = function (e) {
                void 0 !== r.onError && r.onError(e)
            }, this.resolveURL = function (e) {
                return s ? s(e) : e
            }, this.setURLModifier = function (e) {
                return s = e, this
            }, this.addHandler = function (e, t) {
                return l.push(e, t), this
            }, this.removeHandler = function (e) {
                var t = l.indexOf(e);
                return -1 !== t && l.splice(t, 2), this
            }, this.getHandler = function (e) {
                for (var t = 0, n = l.length; t < n; t += 2) {
                    var r = l[t],
                        i = l[t + 1];
                    if (r.global && (r.lastIndex = 0), r.test(e)) return i
                }
                return null
            }
        }
        t.Cache = Of;
        var Bf = new Ff;

        function Gf(e) {
            this.manager = void 0 !== e ? e : Bf, this.crossOrigin = "anonymous", this.path = "", this.resourcePath = ""
        }
        t.DefaultLoadingManager = Bf, (0, We.default)(Gf.prototype, {
            load: function () {},
            parse: function () {},
            setCrossOrigin: function (e) {
                return this.crossOrigin = e, this
            },
            setPath: function (e) {
                return this.path = e, this
            },
            setResourcePath: function (e) {
                return this.resourcePath = e, this
            }
        });
        var Uf = {};

        function zf(e) {
            Gf.call(this, e)
        }

        function Vf(e) {
            Gf.call(this, e)
        }

        function Hf(e) {
            Gf.call(this, e)
        }

        function Wf(e) {
            Gf.call(this, e)
        }

        function jf(e) {
            Gf.call(this, e)
        }

        function Yf(e) {
            Gf.call(this, e)
        }

        function qf(e) {
            Gf.call(this, e)
        }

        function Xf() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function Zf(e, t, n, r, i, a, o, s) {
            Xf.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
        }

        function Jf(e, t, n, r, i, a) {
            Zf.call(this, e, t, n, n, r, i, a), this.type = "ArcCurve"
        }

        function Kf() {
            var i = 0,
                a = 0,
                o = 0,
                s = 0;

            function u(e, t, n, r) {
                i = e, a = n, o = -3 * e + 3 * t - 2 * n - r, s = 2 * e - 2 * t + n + r
            }
            return {
                initCatmullRom: function (e, t, n, r, i) {
                    u(t, n, i * (n - e), i * (r - t))
                },
                initNonuniformCatmullRom: function (e, t, n, r, i, a, o) {
                    var s = (t - e) / i - (n - e) / (i + a) + (n - t) / a,
                        l = (n - t) / a - (r - t) / (a + o) + (r - n) / o;
                    s *= a, l *= a, u(t, n, s, l)
                },
                calc: function (e) {
                    var t = e * e,
                        n = t * e;
                    return i + a * e + o * t + s * n
                }
            }
        }
        zf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: zf,
            load: function (o, e, t, n) {
                void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o);
                var s = this,
                    r = Of.get(o);
                if (void 0 !== r) return s.manager.itemStart(o), setTimeout(function () {
                    e && e(r), s.manager.itemEnd(o)
                }, 0), r;
                if (void 0 === Uf[o]) {
                    var i = /^data:(.*?)(;base64)?,(.*)$/,
                        a = o.match(i);
                    if (a) {
                        var l = a[1],
                            u = !!a[2],
                            h = a[3];
                        h = decodeURIComponent(h), u && (h = atob(h));
                        try {
                            var c, d = (this.responseType || "").toLowerCase();
                            switch (d) {
                                case "arraybuffer":
                                case "blob":
                                    for (var f = new Uint8Array(h.length), p = 0; p < h.length; p++) f[p] = h.charCodeAt(p);
                                    c = "blob" === d ? new Blob([f.buffer], {
                                        type: l
                                    }) : f.buffer;
                                    break;
                                case "document":
                                    var g = new DOMParser;
                                    c = g.parseFromString(h, l);
                                    break;
                                case "json":
                                    c = JSON.parse(h);
                                    break;
                                default:
                                    c = h
                            }
                            setTimeout(function () {
                                e && e(c), s.manager.itemEnd(o)
                            }, 0)
                        } catch (e) {
                            setTimeout(function () {
                                n && n(e), s.manager.itemError(o), s.manager.itemEnd(o)
                            }, 0)
                        }
                    } else {
                        Uf[o] = [], Uf[o].push({
                            onLoad: e,
                            onProgress: t,
                            onError: n
                        });
                        var m = new XMLHttpRequest;
                        for (var v in m.open("GET", o, !0), m.addEventListener("load", function (e) {
                                var t = this.response,
                                    n = Uf[o];
                                if (delete Uf[o], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Of.add(o, t);
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        var a = n[r];
                                        a.onLoad && a.onLoad(t)
                                    }
                                    s.manager.itemEnd(o)
                                } else {
                                    for (r = 0, i = n.length; r < i; r++) a = n[r], a.onError && a.onError(e);
                                    s.manager.itemError(o), s.manager.itemEnd(o)
                                }
                            }, !1), m.addEventListener("progress", function (e) {
                                for (var t = Uf[o], n = 0, r = t.length; n < r; n++) {
                                    var i = t[n];
                                    i.onProgress && i.onProgress(e)
                                }
                            }, !1), m.addEventListener("error", function (e) {
                                var t = Uf[o];
                                delete Uf[o];
                                for (var n = 0, r = t.length; n < r; n++) {
                                    var i = t[n];
                                    i.onError && i.onError(e)
                                }
                                s.manager.itemError(o), s.manager.itemEnd(o)
                            }, !1), m.addEventListener("abort", function (e) {
                                var t = Uf[o];
                                delete Uf[o];
                                for (var n = 0, r = t.length; n < r; n++) {
                                    var i = t[n];
                                    i.onError && i.onError(e)
                                }
                                s.manager.itemError(o), s.manager.itemEnd(o)
                            }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                        m.send(null)
                    }
                    return s.manager.itemStart(o), m
                }
                Uf[o].push({
                    onLoad: e,
                    onProgress: t,
                    onError: n
                })
            },
            setResponseType: function (e) {
                return this.responseType = e, this
            },
            setWithCredentials: function (e) {
                return this.withCredentials = e, this
            },
            setMimeType: function (e) {
                return this.mimeType = e, this
            },
            setRequestHeader: function (e) {
                return this.requestHeader = e, this
            }
        }), Vf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Vf,
            load: function (e, t, n, r) {
                var i = this,
                    a = new zf(i.manager);
                a.setPath(i.path), a.load(e, function (e) {
                    t(i.parse(JSON.parse(e)))
                }, n, r)
            },
            parse: function (e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var r = kf.parse(e[n]);
                    t.push(r)
                }
                return t
            }
        }), Hf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Hf,
            load: function (e, a, t, r) {
                var o = this,
                    s = [],
                    l = new Gc;
                l.image = s;
                var i = new zf(this.manager);

                function n(n) {
                    i.load(e[n], function (e) {
                        var t = o.parse(e, !0);
                        s[n] = {
                            width: t.width,
                            height: t.height,
                            format: t.format,
                            mipmaps: t.mipmaps
                        }, u += 1, 6 === u && (1 === t.mipmapCount && (l.minFilter = ue), l.format = t.format, l.needsUpdate = !0, a && a(l))
                    }, t, r)
                }
                if (i.setPath(this.path), i.setResponseType("arraybuffer"), (0, He.default)(e))
                    for (var u = 0, h = 0, c = e.length; h < c; ++h) n(h);
                else i.load(e, function (e) {
                    var t = o.parse(e, !0);
                    if (t.isCubemap)
                        for (var n = t.mipmaps.length / t.mipmapCount, r = 0; r < n; r++) {
                            s[r] = {
                                mipmaps: []
                            };
                            for (var i = 0; i < t.mipmapCount; i++) s[r].mipmaps.push(t.mipmaps[r * t.mipmapCount + i]), s[r].format = t.format, s[r].width = t.width, s[r].height = t.height
                        } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (l.minFilter = ue), l.format = t.format, l.needsUpdate = !0, a && a(l)
                }, t, r);
                return l
            }
        }), Wf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Wf,
            load: function (e, n, t, r) {
                var i = this,
                    a = new $a,
                    o = new zf(this.manager);
                return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function (e) {
                    var t = i.parse(e);
                    t && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : re, a.wrapT = void 0 !== t.wrapT ? t.wrapT : re, a.magFilter = void 0 !== t.magFilter ? t.magFilter : ue, a.minFilter = void 0 !== t.minFilter ? t.minFilter : ue, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps, a.minFilter = ce), 1 === t.mipmapCount && (a.minFilter = ue), a.needsUpdate = !0, n && n(a, t))
                }, t, r), a
            }
        }), jf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: jf,
            load: function (t, e, n, r) {
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var i = this,
                    a = Of.get(t);
                if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
                    e && e(a), i.manager.itemEnd(t)
                }, 0), a;
                var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                function s() {
                    o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Of.add(t, this), e && e(this), i.manager.itemEnd(t)
                }

                function l(e) {
                    o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                }
                return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
            }
        }), Yf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Yf,
            load: function (e, n, t, r) {
                var i = new zl,
                    a = new jf(this.manager);
                a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                var o = 0;

                function s(t) {
                    a.load(e[t], function (e) {
                        i.images[t] = e, o++, 6 === o && (i.needsUpdate = !0, n && n(i))
                    }, void 0, r)
                }
                for (var l = 0; l < e.length; ++l) s(l);
                return i
            }
        }), qf.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: qf,
            load: function (n, r, e, t) {
                var i = new gr,
                    a = new jf(this.manager);
                return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(n, function (e) {
                    i.image = e;
                    var t = 0 < n.search(/\.jpe?g($|\?)/i) || 0 === n.search(/^data\:image\/jpeg/);
                    i.format = t ? ct : dt, i.needsUpdate = !0, void 0 !== r && r(i)
                }, e, t), i
            }
        }), (0, We.default)(Xf.prototype, {
            getPoint: function () {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function (e, t) {
                var n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            },
            getPoints: function (e) {
                void 0 === e && (e = 5);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return t
            },
            getSpacedPoints: function (e) {
                void 0 === e && (e = 5);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                return t
            },
            getLength: function () {
                var e = this.getLengths();
                return e[e.length - 1]
            },
            getLengths: function (e) {
                if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var t, n, r = [],
                    i = this.getPoint(0),
                    a = 0;
                for (r.push(0), n = 1; n <= e; n++) t = this.getPoint(n / e), a += t.distanceTo(i), r.push(a), i = t;
                return this.cacheArcLengths = r, r
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function (e, t) {
                var n, r = this.getLengths(),
                    i = 0,
                    a = r.length;
                n = t || e * r[a - 1];
                for (var o, s = 0, l = a - 1; s <= l;)
                    if (i = Math.floor(s + (l - s) / 2), o = r[i] - n, o < 0) s = i + 1;
                    else {
                        if (!(0 < o)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    } if (i = l, r[i] === n) return i / (a - 1);
                var u = r[i],
                    h = r[i + 1],
                    c = h - u,
                    d = (n - u) / c,
                    f = (i + d) / (a - 1);
                return f
            },
            getTangent: function (e) {
                var t = 1e-4,
                    n = e - t,
                    r = e + t;
                n < 0 && (n = 0), 1 < r && (r = 1);
                var i = this.getPoint(n),
                    a = this.getPoint(r),
                    o = a.clone().sub(i);
                return o.normalize()
            },
            getTangentAt: function (e) {
                var t = this.getUtoTmapping(e);
                return this.getTangent(t)
            },
            computeFrenetFrames: function (e, t) {
                var n, r, i, a = new Cr,
                    o = [],
                    s = [],
                    l = [],
                    u = new Cr,
                    h = new Lr;
                for (n = 0; n <= e; n++) r = n / e, o[n] = this.getTangentAt(r), o[n].normalize();
                s[0] = new Cr, l[0] = new Cr;
                var c = Number.MAX_VALUE,
                    d = Math.abs(o[0].x),
                    f = Math.abs(o[0].y),
                    p = Math.abs(o[0].z);
                for (d <= c && (c = d, a.set(1, 0, 0)), f <= c && (c = f, a.set(0, 1, 0)), p <= c && a.set(0, 0, 1), u.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], u), l[0].crossVectors(o[0], s[0]), n = 1; n <= e; n++) s[n] = s[n - 1].clone(), l[n] = l[n - 1].clone(), u.crossVectors(o[n - 1], o[n]), u.length() > ie.default && (u.normalize(), i = Math.acos(hr.clamp(o[n - 1].dot(o[n]), -1, 1)), s[n].applyMatrix4(h.makeRotationAxis(u, i))), l[n].crossVectors(o[n], s[n]);
                if (!0 === t)
                    for (i = Math.acos(hr.clamp(s[0].dot(s[e]), -1, 1)), i /= e, 0 < o[0].dot(u.crossVectors(s[0], s[e])) && (i = -i), n = 1; n <= e; n++) s[n].applyMatrix4(h.makeRotationAxis(o[n], i * n)), l[n].crossVectors(o[n], s[n]);
                return {
                    tangents: o,
                    normals: s,
                    binormals: l
                }
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            },
            toJSON: function () {
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
            },
            fromJSON: function (e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
        }), Zf.prototype = (0, s.default)(Xf.prototype), Zf.prototype.constructor = Zf, Zf.prototype.isEllipseCurve = !0, Zf.prototype.getPoint = function (e, t) {
            for (var n = t || new cr, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < ie.default; i < 0;) i += r;
            for (; r < i;) i -= r;
            i < ie.default && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r);
            var o = this.aStartAngle + e * i,
                s = this.aX + this.xRadius * Math.cos(o),
                l = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
                var u = Math.cos(this.aRotation),
                    h = Math.sin(this.aRotation),
                    c = s - this.aX,
                    d = l - this.aY;
                s = c * u - d * h + this.aX, l = c * h + d * u + this.aY
            }
            return n.set(s, l)
        }, Zf.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }, Zf.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
        }, Zf.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
        }, Jf.prototype = (0, s.default)(Zf.prototype), Jf.prototype.constructor = Jf, Jf.prototype.isArcCurve = !0;
        var Qf = new Cr,
            $f = new Kf,
            ep = new Kf,
            tp = new Kf;

        function np(e, t, n, r) {
            Xf.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = r || .5
        }

        function rp(e, t, n, r, i) {
            var a = .5 * (r - t),
                o = .5 * (i - n),
                s = e * e,
                l = e * s;
            return (2 * n - 2 * r + a + o) * l + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n
        }

        function ip(e, t) {
            var n = 1 - e;
            return n * n * t
        }

        function ap(e, t) {
            return 2 * (1 - e) * e * t
        }

        function op(e, t) {
            return e * e * t
        }

        function sp(e, t, n, r) {
            return ip(e, t) + ap(e, n) + op(e, r)
        }

        function lp(e, t) {
            var n = 1 - e;
            return n * n * n * t
        }

        function up(e, t) {
            var n = 1 - e;
            return 3 * n * n * e * t
        }

        function hp(e, t) {
            return 3 * (1 - e) * e * e * t
        }

        function cp(e, t) {
            return e * e * e * t
        }

        function dp(e, t, n, r, i) {
            return lp(e, t) + up(e, n) + hp(e, r) + cp(e, i)
        }

        function fp(e, t, n, r) {
            Xf.call(this), this.type = "CubicBezierCurve", this.v0 = e || new cr, this.v1 = t || new cr, this.v2 = n || new cr, this.v3 = r || new cr
        }

        function pp(e, t, n, r) {
            Xf.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Cr, this.v1 = t || new Cr, this.v2 = n || new Cr, this.v3 = r || new Cr
        }

        function gp(e, t) {
            Xf.call(this), this.type = "LineCurve", this.v1 = e || new cr, this.v2 = t || new cr
        }

        function mp(e, t) {
            Xf.call(this), this.type = "LineCurve3", this.v1 = e || new Cr, this.v2 = t || new Cr
        }

        function vp(e, t, n) {
            Xf.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new cr, this.v1 = t || new cr, this.v2 = n || new cr
        }

        function yp(e, t, n) {
            Xf.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Cr, this.v1 = t || new Cr, this.v2 = n || new Cr
        }

        function _p(e) {
            Xf.call(this), this.type = "SplineCurve", this.points = e || []
        }
        np.prototype = (0, s.default)(Xf.prototype), np.prototype.constructor = np, np.prototype.isCatmullRomCurve3 = !0, np.prototype.getPoint = function (e, t) {
            var n, r, i, a, o = t || new Cr,
                s = this.points,
                l = s.length,
                u = (l - (this.closed ? 0 : 1)) * e,
                h = Math.floor(u),
                c = u - h;
            if (this.closed ? h += 0 < h ? 0 : (Math.floor(Math.abs(h) / l) + 1) * l : 0 === c && h === l - 1 && (h = l - 2, c = 1), n = this.closed || 0 < h ? s[(h - 1) % l] : (Qf.subVectors(s[0], s[1]).add(s[0]), Qf), r = s[h % l], i = s[(h + 1) % l], a = this.closed || h + 2 < l ? s[(h + 2) % l] : (Qf.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), Qf), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var d = "chordal" === this.curveType ? .5 : .25,
                    f = Math.pow(n.distanceToSquared(r), d),
                    p = Math.pow(r.distanceToSquared(i), d),
                    g = Math.pow(i.distanceToSquared(a), d);
                p < 1e-4 && (p = 1), f < 1e-4 && (f = p), g < 1e-4 && (g = p), $f.initNonuniformCatmullRom(n.x, r.x, i.x, a.x, f, p, g), ep.initNonuniformCatmullRom(n.y, r.y, i.y, a.y, f, p, g), tp.initNonuniformCatmullRom(n.z, r.z, i.z, a.z, f, p, g)
            } else "catmullrom" === this.curveType && ($f.initCatmullRom(n.x, r.x, i.x, a.x, this.tension), ep.initCatmullRom(n.y, r.y, i.y, a.y, this.tension), tp.initCatmullRom(n.z, r.z, i.z, a.z, this.tension));
            return o.set($f.calc(c), ep.calc(c), tp.calc(c)), o
        }, np.prototype.copy = function (e) {
            Xf.prototype.copy.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var r = e.points[t];
                this.points.push(r.clone())
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }, np.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            e.points = [];
            for (var t = 0, n = this.points.length; t < n; t++) {
                var r = this.points[t];
                e.points.push(r.toArray())
            }
            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
        }, np.prototype.fromJSON = function (e) {
            Xf.prototype.fromJSON.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var r = e.points[t];
                this.points.push((new Cr).fromArray(r))
            }
            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
        }, fp.prototype = (0, s.default)(Xf.prototype), fp.prototype.constructor = fp, fp.prototype.isCubicBezierCurve = !0, fp.prototype.getPoint = function (e, t) {
            var n = t || new cr,
                r = this.v0,
                i = this.v1,
                a = this.v2,
                o = this.v3;
            return n.set(dp(e, r.x, i.x, a.x, o.x), dp(e, r.y, i.y, a.y, o.y)), n
        }, fp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }, fp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }, fp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }, pp.prototype = (0, s.default)(Xf.prototype), pp.prototype.constructor = pp, pp.prototype.isCubicBezierCurve3 = !0, pp.prototype.getPoint = function (e, t) {
            var n = t || new Cr,
                r = this.v0,
                i = this.v1,
                a = this.v2,
                o = this.v3;
            return n.set(dp(e, r.x, i.x, a.x, o.x), dp(e, r.y, i.y, a.y, o.y), dp(e, r.z, i.z, a.z, o.z)), n
        }, pp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
        }, pp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
        }, pp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
        }, gp.prototype = (0, s.default)(Xf.prototype), gp.prototype.constructor = gp, gp.prototype.isLineCurve = !0, gp.prototype.getPoint = function (e, t) {
            var n = t || new cr;
            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
        }, gp.prototype.getPointAt = function (e, t) {
            return this.getPoint(e, t)
        }, gp.prototype.getTangent = function () {
            var e = this.v2.clone().sub(this.v1);
            return e.normalize()
        }, gp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, gp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, gp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, mp.prototype = (0, s.default)(Xf.prototype), mp.prototype.constructor = mp, mp.prototype.isLineCurve3 = !0, mp.prototype.getPoint = function (e, t) {
            var n = t || new Cr;
            return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
        }, mp.prototype.getPointAt = function (e, t) {
            return this.getPoint(e, t)
        }, mp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, mp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, mp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, vp.prototype = (0, s.default)(Xf.prototype), vp.prototype.constructor = vp, vp.prototype.isQuadraticBezierCurve = !0, vp.prototype.getPoint = function (e, t) {
            var n = t || new cr,
                r = this.v0,
                i = this.v1,
                a = this.v2;
            return n.set(sp(e, r.x, i.x, a.x), sp(e, r.y, i.y, a.y)), n
        }, vp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, vp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, vp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, yp.prototype = (0, s.default)(Xf.prototype), yp.prototype.constructor = yp, yp.prototype.isQuadraticBezierCurve3 = !0, yp.prototype.getPoint = function (e, t) {
            var n = t || new Cr,
                r = this.v0,
                i = this.v1,
                a = this.v2;
            return n.set(sp(e, r.x, i.x, a.x), sp(e, r.y, i.y, a.y), sp(e, r.z, i.z, a.z)), n
        }, yp.prototype.copy = function (e) {
            return Xf.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
        }, yp.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
        }, yp.prototype.fromJSON = function (e) {
            return Xf.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
        }, _p.prototype = (0, s.default)(Xf.prototype), _p.prototype.constructor = _p, _p.prototype.isSplineCurve = !0, _p.prototype.getPoint = function (e, t) {
            var n = t || new cr,
                r = this.points,
                i = (r.length - 1) * e,
                a = Math.floor(i),
                o = i - a,
                s = r[0 === a ? a : a - 1],
                l = r[a],
                u = r[a > r.length - 2 ? r.length - 1 : a + 1],
                h = r[a > r.length - 3 ? r.length - 1 : a + 2];
            return n.set(rp(o, s.x, l.x, u.x, h.x), rp(o, s.y, l.y, u.y, h.y)), n
        }, _p.prototype.copy = function (e) {
            Xf.prototype.copy.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var r = e.points[t];
                this.points.push(r.clone())
            }
            return this
        }, _p.prototype.toJSON = function () {
            var e = Xf.prototype.toJSON.call(this);
            e.points = [];
            for (var t = 0, n = this.points.length; t < n; t++) {
                var r = this.points[t];
                e.points.push(r.toArray())
            }
            return e
        }, _p.prototype.fromJSON = function (e) {
            Xf.prototype.fromJSON.call(this, e), this.points = [];
            for (var t = 0, n = e.points.length; t < n; t++) {
                var r = e.points[t];
                this.points.push((new cr).fromArray(r))
            }
            return this
        };
        var Ap = (0, a.default)({
            __proto__: null,
            ArcCurve: Jf,
            CatmullRomCurve3: np,
            CubicBezierCurve: fp,
            CubicBezierCurve3: pp,
            EllipseCurve: Zf,
            LineCurve: gp,
            LineCurve3: mp,
            QuadraticBezierCurve: vp,
            QuadraticBezierCurve3: yp,
            SplineCurve: _p
        });

        function xp() {
            Xf.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function Cp(e) {
            xp.call(this), this.type = "Path", this.currentPoint = new cr, e && this.setFromPoints(e)
        }

        function Ip(e) {
            Cp.call(this, e), this.uuid = hr.generateUUID(), this.type = "Shape", this.holes = []
        }

        function wp(e, t) {
            Xr.call(this), this.type = "Light", this.color = new Gi(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
        }

        function Mp(e, t, n) {
            wp.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Xr.DefaultUp), this.updateMatrix(), this.groundColor = new Gi(t)
        }

        function bp(e) {
            this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new cr(512, 512), this.map = null, this.mapPass = null, this.matrix = new Lr, this._frustum = new no, this._frameExtents = new cr(1, 1), this._viewportCount = 1, this._viewports = [new mr(0, 0, 1, 1)]
        }

        function Sp() {
            bp.call(this, new Xa(50, 1, .5, 500))
        }

        function Ep(e, t, n, r, i, a) {
            wp.call(this, e, t), this.type = "SpotLight", this.position.copy(Xr.DefaultUp), this.updateMatrix(), this.target = new Xr, (0, y.default)(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                },
                set: function (e) {
                    this.intensity = e / Math.PI
                }
            }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Sp
        }

        function Tp() {
            bp.call(this, new Xa(90, 1, .5, 500)), this._frameExtents = new cr(4, 2), this._viewportCount = 6, this._viewports = [new mr(2, 1, 1, 1), new mr(0, 1, 1, 1), new mr(3, 1, 1, 1), new mr(1, 1, 1, 1), new mr(3, 0, 1, 1), new mr(1, 0, 1, 1)], this._cubeDirections = [new Cr(1, 0, 0), new Cr(-1, 0, 0), new Cr(0, 0, 1), new Cr(0, 0, -1), new Cr(0, 1, 0), new Cr(0, -1, 0)], this._cubeUps = [new Cr(0, 1, 0), new Cr(0, 1, 0), new Cr(0, 1, 0), new Cr(0, 1, 0), new Cr(0, 0, 1), new Cr(0, 0, -1)]
        }

        function Lp(e, t, n, r) {
            wp.call(this, e, t), this.type = "PointLight", (0, y.default)(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                },
                set: function (e) {
                    this.intensity = e / (4 * Math.PI)
                }
            }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Tp
        }

        function Np(e, t, n, r, i, a) {
            qa.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
        }

        function Rp() {
            bp.call(this, new Np(-5, 5, 5, -5, .5, 500))
        }

        function kp(e, t) {
            wp.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Xr.DefaultUp), this.updateMatrix(), this.target = new Xr, this.shadow = new Rp
        }

        function Pp(e, t) {
            wp.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Dp(e, t, n, r) {
            wp.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
        }

        function Op(e) {
            Gf.call(this, e), this.textures = {}
        }
        xp.prototype = (0, We.default)((0, s.default)(Xf.prototype), {
            constructor: xp,
            add: function (e) {
                this.curves.push(e)
            },
            closePath: function () {
                var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new gp(t, e))
            },
            getPoint: function (e) {
                for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                    if (n[r] >= t) {
                        var i = n[r] - t,
                            a = this.curves[r],
                            o = a.getLength(),
                            s = 0 === o ? 0 : 1 - i / o;
                        return a.getPointAt(s)
                    }
                    r++
                }
                return null
            },
            getLength: function () {
                var e = this.getCurveLengths();
                return e[e.length - 1]
            },
            updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
                return this.cacheLengths = e, e
            },
            getSpacedPoints: function (e) {
                void 0 === e && (e = 40);
                for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return this.autoClose && t.push(t[0]), t
            },
            getPoints: function (e) {
                e = e || 12;
                for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)
                    for (var a = i[r], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) {
                        var u = s[l];
                        t && t.equals(u) || (n.push(u), t = u)
                    }
                return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
            },
            copy: function (e) {
                Xf.prototype.copy.call(this, e), this.curves = [];
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var r = e.curves[t];
                    this.curves.push(r.clone())
                }
                return this.autoClose = e.autoClose, this
            },
            toJSON: function () {
                var e = Xf.prototype.toJSON.call(this);
                e.autoClose = this.autoClose, e.curves = [];
                for (var t = 0, n = this.curves.length; t < n; t++) {
                    var r = this.curves[t];
                    e.curves.push(r.toJSON())
                }
                return e
            },
            fromJSON: function (e) {
                Xf.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                for (var t = 0, n = e.curves.length; t < n; t++) {
                    var r = e.curves[t];
                    this.curves.push((new Ap[r.type]).fromJSON(r))
                }
                return this
            }
        }), Cp.prototype = (0, We.default)((0, s.default)(xp.prototype), {
            constructor: Cp,
            setFromPoints: function (e) {
                this.moveTo(e[0].x, e[0].y);
                for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                return this
            },
            moveTo: function (e, t) {
                return this.currentPoint.set(e, t), this
            },
            lineTo: function (e, t) {
                var n = new gp(this.currentPoint.clone(), new cr(e, t));
                return this.curves.push(n), this.currentPoint.set(e, t), this
            },
            quadraticCurveTo: function (e, t, n, r) {
                var i = new vp(this.currentPoint.clone(), new cr(e, t), new cr(n, r));
                return this.curves.push(i), this.currentPoint.set(n, r), this
            },
            bezierCurveTo: function (e, t, n, r, i, a) {
                var o = new fp(this.currentPoint.clone(), new cr(e, t), new cr(n, r), new cr(i, a));
                return this.curves.push(o), this.currentPoint.set(i, a), this
            },
            splineThru: function (e) {
                var t = [this.currentPoint.clone()].concat(e),
                    n = new _p(t);
                return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
            },
            arc: function (e, t, n, r, i, a) {
                var o = this.currentPoint.x,
                    s = this.currentPoint.y;
                return this.absarc(e + o, t + s, n, r, i, a), this
            },
            absarc: function (e, t, n, r, i, a) {
                return this.absellipse(e, t, n, n, r, i, a), this
            },
            ellipse: function (e, t, n, r, i, a, o, s) {
                var l = this.currentPoint.x,
                    u = this.currentPoint.y;
                return this.absellipse(e + l, t + u, n, r, i, a, o, s), this
            },
            absellipse: function (e, t, n, r, i, a, o, s) {
                var l = new Zf(e, t, n, r, i, a, o, s);
                if (0 < this.curves.length) {
                    var u = l.getPoint(0);
                    u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
                }
                this.curves.push(l);
                var h = l.getPoint(1);
                return this.currentPoint.copy(h), this
            },
            copy: function (e) {
                return xp.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
            },
            toJSON: function () {
                var e = xp.prototype.toJSON.call(this);
                return e.currentPoint = this.currentPoint.toArray(), e
            },
            fromJSON: function (e) {
                return xp.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
            }
        }), Ip.prototype = (0, We.default)((0, s.default)(Cp.prototype), {
            constructor: Ip,
            getPointsHoles: function (e) {
                for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                return t
            },
            extractPoints: function (e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            },
            copy: function (e) {
                Cp.prototype.copy.call(this, e), this.holes = [];
                for (var t = 0, n = e.holes.length; t < n; t++) {
                    var r = e.holes[t];
                    this.holes.push(r.clone())
                }
                return this
            },
            toJSON: function () {
                var e = Cp.prototype.toJSON.call(this);
                e.uuid = this.uuid, e.holes = [];
                for (var t = 0, n = this.holes.length; t < n; t++) {
                    var r = this.holes[t];
                    e.holes.push(r.toJSON())
                }
                return e
            },
            fromJSON: function (e) {
                Cp.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                for (var t = 0, n = e.holes.length; t < n; t++) {
                    var r = e.holes[t];
                    this.holes.push((new Cp).fromJSON(r))
                }
                return this
            }
        }), wp.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: wp,
            isLight: !0,
            copy: function (e) {
                return Xr.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
            },
            toJSON: function (e) {
                var t = Xr.prototype.toJSON.call(this, e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }), Mp.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: Mp,
            isHemisphereLight: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
            }
        }), (0, We.default)(bp.prototype, {
            _projScreenMatrix: new Lr,
            _lightPositionWorld: new Cr,
            _lookTarget: new Cr,
            getViewportCount: function () {
                return this._viewportCount
            },
            getFrustum: function () {
                return this._frustum
            },
            updateMatrices: function (e) {
                var t = this.camera,
                    n = this.matrix,
                    r = this._projScreenMatrix,
                    i = this._lookTarget,
                    a = this._lightPositionWorld;
                a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
            },
            getViewport: function (e) {
                return this._viewports[e]
            },
            getFrameExtents: function () {
                return this._frameExtents
            },
            copy: function (e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var e = {};
                return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }), Sp.prototype = (0, We.default)((0, s.default)(bp.prototype), {
            constructor: Sp,
            isSpotLightShadow: !0,
            updateMatrices: function (e) {
                var t = this.camera,
                    n = 2 * hr.RAD2DEG * e.angle,
                    r = this.mapSize.width / this.mapSize.height,
                    i = e.distance || t.far;
                n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), bp.prototype.updateMatrices.call(this, e)
            }
        }), Ep.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: Ep,
            isSpotLight: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }), Tp.prototype = (0, We.default)((0, s.default)(bp.prototype), {
            constructor: Tp,
            isPointLightShadow: !0,
            updateMatrices: function (e, t) {
                void 0 === t && (t = 0);
                var n = this.camera,
                    r = this.matrix,
                    i = this._lightPositionWorld,
                    a = this._lookTarget,
                    o = this._projScreenMatrix;
                i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
            }
        }), Lp.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: Lp,
            isPointLight: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }), Np.prototype = (0, We.default)((0, s.default)(qa.prototype), {
            constructor: Np,
            isOrthographicCamera: !0,
            copy: function (e, t) {
                return qa.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : (0, We.default)({}, e.view), this
            },
            setViewOffset: function (e, t, n, r, i, a) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2,
                    i = n - e,
                    a = n + e,
                    o = r + t,
                    s = r - t;
                if (null !== this.view && this.view.enabled) {
                    var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    i += l * this.view.offsetX, a = i + l * this.view.width, o -= u * this.view.offsetY, s = o - u * this.view.height
                }
                this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function (e) {
                var t = Xr.prototype.toJSON.call(this, e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = (0, We.default)({}, this.view)), t
            }
        }), Rp.prototype = (0, We.default)((0, s.default)(bp.prototype), {
            constructor: Rp,
            isDirectionalLightShadow: !0,
            updateMatrices: function (e) {
                bp.prototype.updateMatrices.call(this, e)
            }
        }), kp.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: kp,
            isDirectionalLight: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }), Pp.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: Pp,
            isAmbientLight: !0
        }), Dp.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: Dp,
            isRectAreaLight: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
            },
            toJSON: function (e) {
                var t = wp.prototype.toJSON.call(this, e);
                return t.object.width = this.width, t.object.height = this.height, t
            }
        }), Op.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Op,
            load: function (e, t, n, r) {
                var i = this,
                    a = new zf(i.manager);
                a.setPath(i.path), a.load(e, function (e) {
                    t(i.parse(JSON.parse(e)))
                }, n, r)
            },
            parse: function (e) {
                var t = this.textures;

                function n(e) {
                    return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                }
                var r = new _f[e.type];
                if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new Gi).setHex(e.sheen)), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.vertexTangents && (r.vertexTangents = e.vertexTangents), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = 0 < e.vertexColors : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                    for (var i in e.uniforms) {
                        var a = e.uniforms[i];
                        switch (r.uniforms[i] = {}, a.type) {
                            case "t":
                                r.uniforms[i].value = n(a.value);
                                break;
                            case "c":
                                r.uniforms[i].value = (new Gi).setHex(a.value);
                                break;
                            case "v2":
                                r.uniforms[i].value = (new cr).fromArray(a.value);
                                break;
                            case "v3":
                                r.uniforms[i].value = (new Cr).fromArray(a.value);
                                break;
                            case "v4":
                                r.uniforms[i].value = (new mr).fromArray(a.value);
                                break;
                            case "m3":
                                r.uniforms[i].value = (new dr).fromArray(a.value);
                            case "m4":
                                r.uniforms[i].value = (new Lr).fromArray(a.value);
                                break;
                            default:
                                r.uniforms[i].value = a.value
                        }
                    }
                if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                    for (var o in e.extensions) r.extensions[o] = e.extensions[o];
                if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                    var s = e.normalScale;
                    !1 === (0, He.default)(s) && (s = [s, s]), r.normalScale = (new cr).fromArray(s)
                }
                return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new cr).fromArray(e.clearcoatNormalScale)), r
            },
            setTextures: function (e) {
                return this.textures = e, this
            }
        });
        var Fp = {
            decodeText: function (e) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            },
            extractUrlBase: function (e) {
                var t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.substr(0, t + 1)
            }
        };

        function Bp() {
            fa.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function Gp(e, t, n, r) {
            "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Xi.call(this, e, t, n), this.meshPerAttribute = r || 1
        }

        function Up(e) {
            Gf.call(this, e)
        }
        t.LoaderUtils = Fp, Bp.prototype = (0, We.default)((0, s.default)(fa.prototype), {
            constructor: Bp,
            isInstancedBufferGeometry: !0,
            copy: function (e) {
                return fa.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            toJSON: function () {
                var e = fa.prototype.toJSON.call(this);
                return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
            }
        }), Gp.prototype = (0, We.default)((0, s.default)(Xi.prototype), {
            constructor: Gp,
            isInstancedBufferAttribute: !0,
            copy: function (e) {
                return Xi.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            },
            toJSON: function () {
                var e = Xi.prototype.toJSON.call(this);
                return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
            }
        }), Up.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Up,
            load: function (e, t, n, r) {
                var i = this,
                    a = new zf(i.manager);
                a.setPath(i.path), a.load(e, function (e) {
                    t(i.parse(JSON.parse(e)))
                }, n, r)
            },
            parse: function (e) {
                var t = new(e.isInstancedBufferGeometry ? Bp : fa),
                    n = e.data.index;
                if (void 0 !== n) {
                    var r = new zp[n.type](n.array);
                    t.setIndex(new Xi(r, 1))
                }
                var i = e.data.attributes;
                for (var a in i) {
                    var o = i[a],
                        s = (r = new zp[o.type](o.array), o.isInstancedBufferAttribute ? Gp : Xi),
                        l = new s(r, o.itemSize, o.normalized);
                    void 0 !== o.name && (l.name = o.name), t.setAttribute(a, l)
                }
                var u = e.data.morphAttributes;
                if (u)
                    for (var a in u) {
                        for (var h = u[a], c = [], d = 0, f = h.length; d < f; d++) o = h[d], r = new zp[o.type](o.array), l = new Xi(r, o.itemSize, o.normalized), void 0 !== o.name && (l.name = o.name), c.push(l);
                        t.morphAttributes[a] = c
                    }
                var p = e.data.morphTargetsRelative;
                p && (t.morphTargetsRelative = !0);
                var g = e.data.groups || e.data.drawcalls || e.data.offsets;
                if (void 0 !== g) {
                    d = 0;
                    for (var m = g.length; d !== m; ++d) {
                        var v = g[d];
                        t.addGroup(v.start, v.count, v.materialIndex)
                    }
                }
                var y = e.data.boundingSphere;
                if (void 0 !== y) {
                    var _ = new Cr;
                    void 0 !== y.center && _.fromArray(y.center), t.boundingSphere = new di(_, y.radius)
                }
                return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
            }
        });
        var zp = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };

        function Vp(e) {
            Gf.call(this, e)
        }
        Vp.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Vp,
            load: function (r, i, e, a) {
                var o = this,
                    t = "" === this.path ? Fp.extractUrlBase(r) : this.path;
                this.resourcePath = this.resourcePath || t;
                var n = new zf(o.manager);
                n.setPath(this.path), n.load(r, function (e) {
                    var t = null;
                    try {
                        t = JSON.parse(e)
                    } catch (e) {
                        return void 0 !== a && a(e), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", e.message)
                    }
                    var n = t.metadata;
                    void 0 !== n && void 0 !== n.type && "geometry" !== n.type.toLowerCase() ? o.parse(t, i) : console.error("THREE.ObjectLoader: Can't load " + r)
                }, e, a)
            },
            parse: function (e, t) {
                var n = this.parseShape(e.shapes),
                    r = this.parseGeometries(e.geometries, n),
                    i = this.parseImages(e.images, function () {
                        void 0 !== t && t(s)
                    }),
                    a = this.parseTextures(e.textures, i),
                    o = this.parseMaterials(e.materials, a),
                    s = this.parseObject(e.object, r, o);
                return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
            },
            parseShape: function (e) {
                var t = {};
                if (void 0 !== e)
                    for (var n = 0, r = e.length; n < r; n++) {
                        var i = (new Ip).fromJSON(e[n]);
                        t[i.uuid] = i
                    }
                return t
            },
            parseGeometries: function (e, t) {
                var n = {};
                if (void 0 !== e)
                    for (var r = new Up, i = 0, a = e.length; i < a; i++) {
                        var o, s = e[i];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                o = new lf[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                o = new lf[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                o = new lf[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                o = new lf[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                o = new lf[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                o = new lf[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                o = new lf[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                o = new lf[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                o = new lf[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                o = new lf[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                o = new lf[s.type]((new Ap[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                o = new lf[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                o = new lf[s.type](s.vertices, s.indices, s.radius, s.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                for (var l = [], u = 0, h = s.shapes.length; u < h; u++) {
                                    var c = t[s.shapes[u]];
                                    l.push(c)
                                }
                                o = new lf[s.type](l, s.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                for (l = [], u = 0, h = s.shapes.length; u < h; u++) c = t[s.shapes[u]], l.push(c);
                                var d = s.options.extrudePath;
                                void 0 !== d && (s.options.extrudePath = (new Ap[d.type]).fromJSON(d)), o = new lf[s.type](l, s.options);
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                o = r.parse(s);
                                break;
                            case "Geometry":
                                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                        }
                        o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), n[s.uuid] = o
                    }
                return n
            },
            parseMaterials: function (e, t) {
                var n = {},
                    r = {};
                if (void 0 !== e) {
                    var i = new Op;
                    i.setTextures(t);
                    for (var a = 0, o = e.length; a < o; a++) {
                        var s = e[a];
                        if ("MultiMaterial" === s.type) {
                            for (var l = [], u = 0; u < s.materials.length; u++) {
                                var h = s.materials[u];
                                void 0 === n[h.uuid] && (n[h.uuid] = i.parse(h)), l.push(n[h.uuid])
                            }
                            r[s.uuid] = l
                        } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                    }
                }
                return r
            },
            parseAnimations: function (e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var r = e[n],
                        i = kf.parse(r);
                    void 0 !== r.uuid && (i.uuid = r.uuid), t.push(i)
                }
                return t
            },
            parseImages: function (e, t) {
                var n = this,
                    r = {};

                function i(e) {
                    return n.manager.itemStart(e), o.load(e, function () {
                        n.manager.itemEnd(e)
                    }, void 0, function () {
                        n.manager.itemError(e), n.manager.itemEnd(e)
                    })
                }
                if (void 0 !== e && 0 < e.length) {
                    var a = new Ff(t),
                        o = new jf(a);
                    o.setCrossOrigin(this.crossOrigin);
                    for (var s = 0, l = e.length; s < l; s++) {
                        var u = e[s],
                            h = u.url;
                        if ((0, He.default)(h)) {
                            r[u.uuid] = [];
                            for (var c = 0, d = h.length; c < d; c++) {
                                var f = h[c],
                                    p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : n.resourcePath + f;
                                r[u.uuid].push(i(p))
                            }
                        } else p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u.url) ? u.url : n.resourcePath + u.url, r[u.uuid] = i(p)
                    }
                }
                return r
            },
            parseTextures: function (e, t) {
                function n(e, t) {
                    return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                }
                var r = {};
                if (void 0 !== e)
                    for (var i = 0, a = e.length; i < a; i++) {
                        var o, s = e[i];
                        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), o = new((0, He.default)(t[s.image]) ? zl : gr)(t[s.image]), o.needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, Wp)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], jp), o.wrapT = n(s.wrap[1], jp)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, Yp)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, Yp)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), r[s.uuid] = o
                    }
                return r
            },
            parseObject: function (e, t, a) {
                var n;

                function r(e) {
                    return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                }

                function i(e) {
                    if (void 0 !== e) {
                        if ((0, He.default)(e)) {
                            for (var t = [], n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                void 0 === a[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(a[i])
                            }
                            return t
                        }
                        return void 0 === a[e] && console.warn("THREE.ObjectLoader: Undefined material", e), a[e]
                    }
                }
                switch (e.type) {
                    case "Scene":
                        n = new Zr, void 0 !== e.background && (0, _.default)(e.background) && (n.background = new Gi(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new zh(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new Uh(e.fog.color, e.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        n = new Xa(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = (0, We.default)({}, e.view));
                        break;
                    case "OrthographicCamera":
                        n = new Np(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = (0, We.default)({}, e.view));
                        break;
                    case "AmbientLight":
                        n = new Pp(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        n = new kp(e.color, e.intensity);
                        break;
                    case "PointLight":
                        n = new Lp(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        n = new Dp(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        n = new Ep(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        n = new Mp(e.color, e.groundColor, e.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        var o = r(e.geometry),
                            s = i(e.material);
                        n = new Na(o, s);
                        break;
                    case "InstancedMesh":
                        o = r(e.geometry), s = i(e.material);
                        var l = e.count,
                            u = e.instanceMatrix;
                        n = new _c(o, s, l), n.instanceMatrix = new Xi(new Float32Array(u.array), 16);
                        break;
                    case "LOD":
                        n = new uc;
                        break;
                    case "Line":
                        n = new bc(r(e.geometry), i(e.material), e.mode);
                        break;
                    case "LineLoop":
                        n = new Lc(r(e.geometry), i(e.material));
                        break;
                    case "LineSegments":
                        n = new Tc(r(e.geometry), i(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        n = new Oc(r(e.geometry), i(e.material));
                        break;
                    case "Sprite":
                        n = new ac(i(e.material));
                        break;
                    case "Group":
                        n = new Fh;
                        break;
                    default:
                        n = new Xr
                }
                if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children)
                    for (var h = e.children, c = 0; c < h.length; c++) n.add(this.parseObject(h[c], t, a));
                if ("LOD" === e.type) {
                    void 0 !== e.autoUpdate && (n.autoUpdate = e.autoUpdate);
                    for (var d = e.levels, f = 0; f < d.length; f++) {
                        var p = d[f],
                            g = n.getObjectByProperty("uuid", p.object);
                        void 0 !== g && n.addLevel(g, p.distance)
                    }
                }
                return n
            }
        });
        var Hp, Wp = {
                UVMapping: H,
                CubeReflectionMapping: W,
                CubeRefractionMapping: j,
                EquirectangularReflectionMapping: Y,
                EquirectangularRefractionMapping: q,
                SphericalReflectionMapping: X,
                CubeUVReflectionMapping: Z,
                CubeUVRefractionMapping: J
            },
            jp = {
                RepeatWrapping: ne,
                ClampToEdgeWrapping: re,
                MirroredRepeatWrapping: ae
            },
            Yp = {
                NearestFilter: oe,
                NearestMipmapNearestFilter: se,
                NearestMipmapLinearFilter: le,
                LinearFilter: ue,
                LinearMipmapNearestFilter: he,
                LinearMipmapLinearFilter: ce
            };

        function qp(e) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Gf.call(this, e), this.options = void 0
        }

        function Xp() {
            this.type = "ShapePath", this.color = new Gi, this.subPaths = [], this.currentPath = null
        }

        function Zp(e) {
            this.type = "Font", this.data = e
        }

        function Jp(e, t, n) {
            for (var r = d.default ? (0, d.default)(e) : String(e).split(""), i = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, o = [], s = 0, l = 0, u = 0; u < r.length; u++) {
                var h = r[u];
                if ("\n" === h) s = 0, l -= a;
                else {
                    var c = Kp(h, i, s, l, n);
                    s += c.offsetX, o.push(c.path)
                }
            }
            return o
        }

        function Kp(e, t, n, r, i) {
            var a = i.glyphs[e] || i.glyphs["?"];
            if (a) {
                var o, s, l, u, h, c, d, f, p = new Xp;
                if (a.o)
                    for (var g = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), m = 0, v = g.length; m < v;) {
                        var y = g[m++];
                        switch (y) {
                            case "m":
                                o = g[m++] * t + n, s = g[m++] * t + r, p.moveTo(o, s);
                                break;
                            case "l":
                                o = g[m++] * t + n, s = g[m++] * t + r, p.lineTo(o, s);
                                break;
                            case "q":
                                l = g[m++] * t + n, u = g[m++] * t + r, h = g[m++] * t + n, c = g[m++] * t + r, p.quadraticCurveTo(h, c, l, u);
                                break;
                            case "b":
                                l = g[m++] * t + n, u = g[m++] * t + r, h = g[m++] * t + n, c = g[m++] * t + r, d = g[m++] * t + n, f = g[m++] * t + r, p.bezierCurveTo(h, c, d, f, l, u)
                        }
                    }
                return {
                    offsetX: a.ha * t,
                    path: p
                }
            }
            console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".")
        }

        function Qp(e) {
            Gf.call(this, e)
        }
        qp.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: qp,
            setOptions: function (e) {
                return this.options = e, this
            },
            load: function (t, n, e, r) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var i = this,
                    a = Of.get(t);
                if (void 0 !== a) return i.manager.itemStart(t), setTimeout(function () {
                    n && n(a), i.manager.itemEnd(t)
                }, 0), a;
                fetch(t).then(function (e) {
                    return e.blob()
                }).then(function (e) {
                    return void 0 === i.options ? createImageBitmap(e) : createImageBitmap(e, i.options)
                }).then(function (e) {
                    Of.add(t, e), n && n(e), i.manager.itemEnd(t)
                }).catch(function (e) {
                    r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                }), i.manager.itemStart(t)
            }
        }), (0, We.default)(Xp.prototype, {
            moveTo: function (e, t) {
                return this.currentPath = new Cp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
            },
            lineTo: function (e, t) {
                return this.currentPath.lineTo(e, t), this
            },
            quadraticCurveTo: function (e, t, n, r) {
                return this.currentPath.quadraticCurveTo(e, t, n, r), this
            },
            bezierCurveTo: function (e, t, n, r, i, a) {
                return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this
            },
            splineThru: function (e) {
                return this.currentPath.splineThru(e), this
            },
            toShapes: function (e, t) {
                function n(e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                        var i = e[n],
                            a = new Ip;
                        a.curves = i.curves, t.push(a)
                    }
                    return t
                }

                function r(e, t) {
                    for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) {
                        var o = t[i],
                            s = t[a],
                            l = s.x - o.x,
                            u = s.y - o.y;
                        if (Math.abs(u) > ie.default) {
                            if (u < 0 && (o = t[a], l = -l, s = t[i], u = -u), e.y < o.y || e.y > s.y) continue;
                            if (e.y === o.y) {
                                if (e.x === o.x) return !0
                            } else {
                                var h = u * (e.x - o.x) - l * (e.y - o.y);
                                if (0 === h) return !0;
                                if (h < 0) continue;
                                r = !r
                            }
                        } else {
                            if (e.y !== o.y) continue;
                            if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0
                        }
                    }
                    return r
                }
                var i = Od.isClockWise,
                    a = this.subPaths;
                if (0 === a.length) return [];
                if (!0 === t) return n(a);
                var o, s, l, u = [];
                if (1 === a.length) return s = a[0], l = new Ip, l.curves = s.curves, u.push(l), u;
                var h = !i(a[0].getPoints());
                h = e ? !h : h;
                var c, d, f = [],
                    p = [],
                    g = [],
                    m = 0;
                p[m] = void 0, g[m] = [];
                for (var v = 0, y = a.length; v < y; v++) s = a[v], c = s.getPoints(), o = i(c), o = e ? !o : o, o ? (!h && p[m] && m++, p[m] = {
                    s: new Ip,
                    p: c
                }, p[m].s.curves = s.curves, h && m++, g[m] = []) : g[m].push({
                    h: s,
                    p: c[0]
                });
                if (!p[0]) return n(a);
                if (1 < p.length) {
                    for (var _ = !1, A = [], x = 0, C = p.length; x < C; x++) f[x] = [];
                    for (x = 0, C = p.length; x < C; x++)
                        for (var I = g[x], w = 0; w < I.length; w++) {
                            for (var M = I[w], b = !0, S = 0; S < p.length; S++) r(M.p, p[S].p) && (x !== S && A.push({
                                froms: x,
                                tos: S,
                                hole: w
                            }), b ? (b = !1, f[S].push(M)) : _ = !0);
                            b && f[x].push(M)
                        }
                    0 < A.length && (_ || (g = f))
                }
                v = 0;
                for (var E = p.length; v < E; v++) {
                    l = p[v].s, u.push(l), d = g[v];
                    for (var T = 0, L = d.length; T < L; T++) l.holes.push(d[T].h)
                }
                return u
            }
        }), (0, We.default)(Zp.prototype, {
            isFont: !0,
            generateShapes: function (e, t) {
                void 0 === t && (t = 100);
                for (var n = [], r = Jp(e, t, this.data), i = 0, a = r.length; i < a; i++) Array.prototype.push.apply(n, r[i].toShapes());
                return n
            }
        }), Qp.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: Qp,
            load: function (e, r, t, n) {
                var i = this,
                    a = new zf(this.manager);
                a.setPath(this.path), a.load(e, function (t) {
                    var n;
                    try {
                        n = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var e = i.parse(n);
                    r && r(e)
                }, t, n)
            },
            parse: function (e) {
                return new Zp(e)
            }
        });
        var $p = {
            getContext: function () {
                return void 0 === Hp && (Hp = new(window.AudioContext || window.webkitAudioContext)), Hp
            },
            setContext: function (e) {
                Hp = e
            }
        };

        function eg(e) {
            Gf.call(this, e)
        }

        function tg() {
            this.coefficients = [];
            for (var e = 0; e < 9; e++) this.coefficients.push(new Cr)
        }

        function ng(e, t) {
            wp.call(this, void 0, t), this.sh = void 0 !== e ? e : new tg
        }

        function rg(e, t, n) {
            ng.call(this, void 0, n);
            var r = (new Gi).set(e),
                i = (new Gi).set(t),
                a = new Cr(r.r, r.g, r.b),
                o = new Cr(i.r, i.g, i.b),
                s = Math.sqrt(Math.PI),
                l = s * Math.sqrt(.75);
            this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l)
        }

        function ig(e, t) {
            ng.call(this, void 0, t);
            var n = (new Gi).set(e);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
        t.AudioContext = $p, eg.prototype = (0, We.default)((0, s.default)(Gf.prototype), {
            constructor: eg,
            load: function (e, r, t, n) {
                var i = new zf(this.manager);
                i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(e, function (e) {
                    var t = e.slice(0),
                        n = $p.getContext();
                    n.decodeAudioData(t, function (e) {
                        r(e)
                    })
                }, t, n)
            }
        }), (0, We.default)(tg.prototype, {
            isSphericalHarmonics3: !0,
            set: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                return this
            },
            zero: function () {
                for (var e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                return this
            },
            getAt: function (e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z,
                    a = this.coefficients;
                return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * i), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * r * 1.092548), t.addScaledVector(a[5], r * i * 1.092548), t.addScaledVector(a[6], .315392 * (3 * i * i - 1)), t.addScaledVector(a[7], n * i * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - r * r)), t
            },
            getIrradianceAt: function (e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z,
                    a = this.coefficients;
                return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * i), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * r), t.addScaledVector(a[5], .858086 * r * i), t.addScaledVector(a[6], .743125 * i * i - .247708), t.addScaledVector(a[7], .858086 * n * i), t.addScaledVector(a[8], .429043 * (n * n - r * r)), t
            },
            add: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                return this
            },
            addScaledSH: function (e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                return this
            },
            scale: function (e) {
                for (var t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                return this
            },
            lerp: function (e, t) {
                for (var n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                return this
            },
            equals: function (e) {
                for (var t = 0; t < 9; t++)
                    if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                return !0
            },
            copy: function (e) {
                return this.set(e.coefficients)
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            fromArray: function (e, t) {
                void 0 === t && (t = 0);
                for (var n = this.coefficients, r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                return this
            },
            toArray: function (e, t) {
                void 0 === e && (e = []), void 0 === t && (t = 0);
                for (var n = this.coefficients, r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                return e
            }
        }), (0, We.default)(tg, {
            getBasisAt: function (e, t) {
                var n = e.x,
                    r = e.y,
                    i = e.z;
                t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
            }
        }), ng.prototype = (0, We.default)((0, s.default)(wp.prototype), {
            constructor: ng,
            isLightProbe: !0,
            copy: function (e) {
                return wp.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
            },
            toJSON: function (e) {
                var t = wp.prototype.toJSON.call(this, e);
                return t
            }
        }), rg.prototype = (0, We.default)((0, s.default)(ng.prototype), {
            constructor: rg,
            isHemisphereLightProbe: !0,
            copy: function (e) {
                return ng.prototype.copy.call(this, e), this
            },
            toJSON: function (e) {
                var t = ng.prototype.toJSON.call(this, e);
                return t
            }
        }), ig.prototype = (0, We.default)((0, s.default)(ng.prototype), {
            constructor: ig,
            isAmbientLightProbe: !0,
            copy: function (e) {
                return ng.prototype.copy.call(this, e), this
            },
            toJSON: function (e) {
                var t = ng.prototype.toJSON.call(this, e);
                return t
            }
        });
        var ag = new Lr,
            og = new Lr;

        function sg() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Xa, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Xa, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }

        function lg(e) {
            this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }(0, We.default)(sg.prototype, {
            update: function (e) {
                var t = this._cache,
                    n = t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep;
                if (n) {
                    t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep;
                    var r, i, a = e.projectionMatrix.clone(),
                        o = t.eyeSep / 2,
                        s = o * t.near / t.focus,
                        l = t.near * Math.tan(hr.DEG2RAD * t.fov * .5) / t.zoom;
                    og.elements[12] = -o, ag.elements[12] = o, r = -l * t.aspect + s, i = l * t.aspect + s, a.elements[0] = 2 * t.near / (i - r), a.elements[8] = (i + r) / (i - r), this.cameraL.projectionMatrix.copy(a), r = -l * t.aspect - s, i = l * t.aspect - s, a.elements[0] = 2 * t.near / (i - r), a.elements[8] = (i + r) / (i - r), this.cameraR.projectionMatrix.copy(a)
                }
                this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(og), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ag)
            }
        }), (0, We.default)(lg.prototype, {
            start: function () {
                this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            },
            stop: function () {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            },
            getElapsedTime: function () {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function () {
                var e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var t = ("undefined" == typeof performance ? Date : performance).now();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        });
        var ug = new Cr,
            hg = new _r,
            cg = new Cr,
            dg = new Cr;

        function fg() {
            Xr.call(this), this.type = "AudioListener", this.context = $p.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new lg
        }

        function pg(e) {
            Xr.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._startedAt = 0, this._pausedAt = 0, this.filters = []
        }
        fg.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: fg,
            getInput: function () {
                return this.gain
            },
            removeFilter: function () {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            },
            getFilter: function () {
                return this.filter
            },
            setFilter: function (e) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            },
            getMasterVolume: function () {
                return this.gain.gain.value
            },
            setMasterVolume: function (e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            },
            updateMatrixWorld: function (e) {
                Xr.prototype.updateMatrixWorld.call(this, e);
                var t = this.context.listener,
                    n = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ug, hg, cg), dg.set(0, 0, -1).applyQuaternion(hg), t.positionX) {
                    var r = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(ug.x, r), t.positionY.linearRampToValueAtTime(ug.y, r), t.positionZ.linearRampToValueAtTime(ug.z, r), t.forwardX.linearRampToValueAtTime(dg.x, r), t.forwardY.linearRampToValueAtTime(dg.y, r), t.forwardZ.linearRampToValueAtTime(dg.z, r), t.upX.linearRampToValueAtTime(n.x, r), t.upY.linearRampToValueAtTime(n.y, r), t.upZ.linearRampToValueAtTime(n.z, r)
                } else t.setPosition(ug.x, ug.y, ug.z), t.setOrientation(dg.x, dg.y, dg.z, n.x, n.y, n.z)
            }
        }), pg.prototype = (0, We.default)((0, s.default)(Xr.prototype), {
            constructor: pg,
            getOutput: function () {
                return this.gain
            },
            setNodeSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            },
            setMediaElementSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
            },
            setMediaStreamSource: function (e) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
            },
            setBuffer: function (e) {
                return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function (e) {
                if (void 0 === e && (e = 0), !0 !== this.isPlaying) {
                    if (!1 !== this.hasPlaybackControl) {
                        this._startedAt = this.context.currentTime + e;
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                } else console.warn("THREE.Audio: Audio is already playing.")
            },
            pause: function () {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function () {
                if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function () {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function () {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function () {
                return this.filters
            },
            setFilters: function (e) {
                return e = e || [], !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
            },
            setDetune: function (e) {
                if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            },
            getDetune: function () {
                return this.detune
            },
            getFilter: function () {
                return this.getFilters()[0]
            },
            setFilter: function (e) {
                return this.setFilters(e ? [e] : [])
            },
            setPlaybackRate: function (e) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function () {
                return this.playbackRate
            },
            onEnded: function () {
                this.isPlaying = !1
            },
            getLoop: function () {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function (e) {
                if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            setLoopStart: function (e) {
                return this.loopStart = e, this
            },
            setLoopEnd: function (e) {
                return this.loopEnd = e, this
            },
            getVolume: function () {
                return this.gain.gain.value
            },
            setVolume: function (e) {
                return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
            }
        });
        var gg = new Cr,
            mg = new _r,
            vg = new Cr,
            yg = new Cr;

        function _g(e) {
            pg.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
        }

        function Ag(e, t) {
            this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
        }

        function xg(e, t, n) {
            this.binding = e, this.valueSize = n;
            var r, i = Float64Array;
            switch (t) {
                case "quaternion":
                    r = this._slerp;
                    break;
                case "string":
                case "bool":
                    i = Array, r = this._select;
                    break;
                default:
                    r = this._lerp
            }
            this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }
        _g.prototype = (0, We.default)((0, s.default)(pg.prototype), {
            constructor: _g,
            getOutput: function () {
                return this.panner
            },
            getRefDistance: function () {
                return this.panner.refDistance
            },
            setRefDistance: function (e) {
                return this.panner.refDistance = e, this
            },
            getRolloffFactor: function () {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function (e) {
                return this.panner.rolloffFactor = e, this
            },
            getDistanceModel: function () {
                return this.panner.distanceModel
            },
            setDistanceModel: function (e) {
                return this.panner.distanceModel = e, this
            },
            getMaxDistance: function () {
                return this.panner.maxDistance
            },
            setMaxDistance: function (e) {
                return this.panner.maxDistance = e, this
            },
            setDirectionalCone: function (e, t, n) {
                return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
            },
            updateMatrixWorld: function (e) {
                if (Xr.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                    this.matrixWorld.decompose(gg, mg, vg), yg.set(0, 0, 1).applyQuaternion(mg);
                    var t = this.panner;
                    if (t.positionX) {
                        var n = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(gg.x, n), t.positionY.linearRampToValueAtTime(gg.y, n), t.positionZ.linearRampToValueAtTime(gg.z, n), t.orientationX.linearRampToValueAtTime(yg.x, n), t.orientationY.linearRampToValueAtTime(yg.y, n), t.orientationZ.linearRampToValueAtTime(yg.z, n)
                    } else t.setPosition(gg.x, gg.y, gg.z), t.setOrientation(yg.x, yg.y, yg.z)
                }
            }
        }), (0, We.default)(Ag.prototype, {
            getFrequencyData: function () {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function () {
                for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                return e / t.length
            }
        }), (0, We.default)(xg.prototype, {
            accumulate: function (e, t) {
                var n = this.buffer,
                    r = this.valueSize,
                    i = e * r + r,
                    a = this.cumulativeWeight;
                if (0 === a) {
                    for (var o = 0; o !== r; ++o) n[i + o] = n[o];
                    a = t
                } else {
                    a += t;
                    var s = t / a;
                    this._mixBufferRegion(n, i, 0, s, r)
                }
                this.cumulativeWeight = a
            },
            apply: function (e) {
                var t = this.valueSize,
                    n = this.buffer,
                    r = e * t + t,
                    i = this.cumulativeWeight,
                    a = this.binding;
                if (this.cumulativeWeight = 0, i < 1) {
                    var o = 3 * t;
                    this._mixBufferRegion(n, r, o, 1 - i, t)
                }
                for (var s = t, l = t + t; s !== l; ++s)
                    if (n[s] !== n[s + t]) {
                        a.setValue(n, r);
                        break
                    }
            },
            saveOriginalState: function () {
                var e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    r = 3 * n;
                e.getValue(t, r);
                for (var i = n, a = r; i !== a; ++i) t[i] = t[r + i % n];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function () {
                var e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            },
            _select: function (e, t, n, r, i) {
                if (.5 <= r)
                    for (var a = 0; a !== i; ++a) e[t + a] = e[n + a]
            },
            _slerp: function (e, t, n, r) {
                _r.slerpFlat(e, t, e, t, e, n, r)
            },
            _lerp: function (e, t, n, r, i) {
                for (var a = 1 - r, o = 0; o !== i; ++o) {
                    var s = t + o;
                    e[s] = e[s] * a + e[n + o] * r
                }
            }
        });
        var Cg, Ig, wg, Mg, bg = "\\[\\]\\.:\\/",
            Sg = new RegExp("[" + bg + "]", "g"),
            Eg = "[^" + bg + "]",
            Tg = "[^" + bg.replace("\\.", "") + "]",
            Lg = /((?:WC+[\/:])*)/.source.replace("WC", Eg),
            Ng = /(WCOD+)?/.source.replace("WCOD", Tg),
            Rg = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Eg),
            kg = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Eg),
            Pg = new RegExp("^" + Lg + Ng + Rg + kg + "$"),
            Dg = ["material", "materials", "bones"];

        function Og(e, t, n) {
            var r = n || Fg.parseTrackName(t);
            this._targetGroup = e, this._bindings = e.subscribe_(t, r)
        }

        function Fg(e, t, n) {
            this.path = t, this.parsedPath = n || Fg.parseTrackName(t), this.node = Fg.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
        }

        function Bg() {
            this.uuid = hr.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var r = this;
            this.stats = {
                objects: {
                    get total() {
                        return r._objects.length
                    },
                    get inUse() {
                        return this.total - r.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return r._bindings.length
                }
            }
        }

        function Gg(e, t, n) {
            this._mixer = e, this._clip = t, this._localRoot = n || null;
            for (var r = t.tracks, i = r.length, a = new Array(i), o = {
                    endingStart: vn,
                    endingEnd: vn
                }, s = 0; s !== i; ++s) {
                var l = r[s].createInterpolant(null);
                a[s] = l, l.settings = o
            }
            this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = dn, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = Infinity, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function Ug(e) {
            this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function zg(e, t) {
            "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
        }

        function Vg(e, t, n) {
            Vh.call(this, e, t), this.meshPerAttribute = n || 1
        }

        function Hg(e, t, n, r) {
            this.ray = new Ai(e, t), this.near = n || 0, this.far = r || Infinity, this.camera = null, this.layers = new Pr, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, (0, l.default)(this.params, {
                PointCloud: {
                    get: function () {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function Wg(e, t) {
            return e.distance - t.distance
        }

        function jg(e, t, n, r) {
            if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r)
                for (var i = e.children, a = 0, o = i.length; a < o; a++) jg(i[a], t, n, !0)
        }

        function Yg(e, t, n) {
            return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
        }

        function qg(e, t, n) {
            return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
        }(0, We.default)(Og.prototype, {
            getValue: function (e, t) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n];
                void 0 !== r && r.getValue(e, t)
            },
            setValue: function (e, t) {
                for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
            },
            bind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            },
            unbind: function () {
                for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }), (0, We.default)(Fg, {
            Composite: Og,
            create: function (e, t, n) {
                return e && e.isAnimationObjectGroup ? new Fg.Composite(e, t, n) : new Fg(e, t, n)
            },
            sanitizeNodeName: function (e) {
                return e.replace(/\s/g, "_").replace(Sg, "")
            },
            parseTrackName: function (e) {
                var t = Pg.exec(e);
                if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                var n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    var i = n.nodeName.substring(r + 1); - 1 !== Dg.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            },
            findNode: function (e, a) {
                if (!a || "" === a || "." === a || -1 === a || a === e.name || a === e.uuid) return e;
                if (e.skeleton) {
                    var t = e.skeleton.getBoneByName(a);
                    if (void 0 !== t) return t
                }
                if (e.children) {
                    var n = function e(t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n];
                                if (r.name === a || r.uuid === a) return r;
                                var i = e(r.children);
                                if (i) return i
                            }
                            return null
                        },
                        r = n(e.children);
                    if (r) return r
                }
                return null
            }
        }), (0, We.default)(Fg.prototype, {
            _getValue_unavailable: function () {},
            _setValue_unavailable: function () {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function (e, t) {
                e[t] = this.node[this.propertyName]
            }, function (e, t) {
                for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
            }, function (e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }, function (e, t) {
                this.resolvedProperty.toArray(e, t)
            }],
            SetterByBindingTypeAndVersioning: [
                [function (e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }, function (e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }, function (e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }, function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function (e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }, function (e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }, function (e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function (e, t) {
                this.bind(), this.getValue(e, t)
            },
            setValue: function (e, t) {
                this.bind(), this.setValue(e, t)
            },
            bind: function () {
                var e = this.node,
                    t = this.parsedPath,
                    n = t.objectName,
                    r = t.propertyName,
                    i = t.propertyIndex;
                if (e || (e = Fg.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                    if (n) {
                        var a = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (var o = 0; o < e.length; o++)
                                    if (e[o].name === a) {
                                        a = o;
                                        break
                                    } break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[a]
                        }
                    }
                    var s = e[r];
                    if (void 0 !== s) {
                        var l = this.Versioning.None;
                        this.targetObject = e, void 0 !== e.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                        var u = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (e.geometry.isBufferGeometry) {
                                    if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                        if (e.geometry.morphAttributes.position[o].name === i) {
                                            i = o;
                                            break
                                        }
                                } else {
                                    if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                                        if (e.geometry.morphTargets[o].name === i) {
                                            i = o;
                                            break
                                        }
                                }
                            }
                            u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : (0, He.default)(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][l]
                    } else {
                        var h = t.nodeName;
                        console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + r + " but it wasn't found.", e)
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), (0, We.default)(Fg.prototype, {
            _getValue_unbound: Fg.prototype.getValue,
            _setValue_unbound: Fg.prototype.setValue
        }), (0, We.default)(Gf.prototype, {
            crossOrigin: "anonymous",
            onLoadStart: function () {},
            onLoadProgress: function () {},
            onLoadComplete: function () {},
            initMaterials: function (e, t, n) {
                for (var r = [], i = 0; i < e.length; ++i) r[i] = this.createMaterial(e[i], t, n);
                return r
            },
            createMaterial: (Cg = {
                NoBlending: Ae,
                NormalBlending: xe,
                AdditiveBlending: Ce,
                SubtractiveBlending: Ie,
                MultiplyBlending: we,
                CustomBlending: Me
            }, Ig = new Gi, wg = new qf, Mg = new Op, function (e, h, c) {
                var d = {};

                function t(e, t, n, r, i) {
                    var a, o = h + e,
                        s = new Ff,
                        l = s.getHandler(o);
                    a = null !== l ? l.load(o) : (wg.setCrossOrigin(c), wg.load(o)), void 0 !== t && (a.repeat.fromArray(t), 1 !== t[0] && (a.wrapS = ne), 1 !== t[1] && (a.wrapT = ne)), void 0 !== n && a.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (a.wrapS = ne), "mirror" === r[0] && (a.wrapS = ae), "repeat" === r[1] && (a.wrapT = ne), "mirror" === r[1] && (a.wrapT = ae)), void 0 !== i && (a.anisotropy = i);
                    var u = hr.generateUUID();
                    return d[u] = a, u
                }
                var n = {
                    uuid: hr.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var r in e) {
                    var i = e[r];
                    switch (r) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            n.name = i;
                            break;
                        case "blending":
                            n.blending = Cg[i];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            break;
                        case "colorDiffuse":
                            n.color = Ig.fromArray(i).getHex();
                            break;
                        case "colorSpecular":
                            n.specular = Ig.fromArray(i).getHex();
                            break;
                        case "colorEmissive":
                            n.emissive = Ig.fromArray(i).getHex();
                            break;
                        case "specularCoef":
                            n.shininess = i;
                            break;
                        case "shading":
                            "basic" === i.toLowerCase() && (n.type = "MeshBasicMaterial"), "phong" === i.toLowerCase() && (n.type = "MeshPhongMaterial"), "standard" === i.toLowerCase() && (n.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            n.map = t(i, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            n.emissiveMap = t(i, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            n.lightMap = t(i, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            n.aoMap = t(i, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            n.bumpMap = t(i, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            n.bumpScale = i;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            n.normalMap = t(i, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            n.normalScale = i;
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            n.specularMap = t(i, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            n.metalnessMap = t(i, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            n.roughnessMap = t(i, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            n.alphaMap = t(i, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            n.side = je;
                            break;
                        case "doubleSided":
                            n.side = _e;
                            break;
                        case "transparency":
                            n.opacity = i;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            n[r] = i;
                            break;
                        case "vertexColors":
                            !0 === i && (n.vertexColors = Av), "face" === i && (n.vertexColors = _v)
                    }
                }
                return "MeshBasicMaterial" === n.type && delete n.emissive, "MeshPhongMaterial" !== n.type && delete n.specular, n.opacity < 1 && (n.transparent = !0), Mg.setTextures(d), Mg.parse(n)
            })
        }), (0, We.default)(Bg.prototype, {
            isAnimationObjectGroup: !0,
            add: function () {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, u = 0, h = arguments.length; u !== h; ++u) {
                    var c = arguments[u],
                        d = c.uuid,
                        f = r[d];
                    if (void 0 === f) {
                        f = t++, r[d] = f, e.push(c);
                        for (var p = 0, g = s; p !== g; ++p) o[p].push(new Fg(c, i[p], a[p]))
                    } else if (f < n) {
                        l = e[f];
                        var m = --n,
                            v = e[m];
                        for (r[v.uuid] = f, e[f] = v, r[d] = m, e[m] = c, p = 0, g = s; p !== g; ++p) {
                            var y = o[p],
                                _ = y[m],
                                A = y[f];
                            y[f] = _, void 0 === A && (A = new Fg(c, i[p], a[p])), y[m] = A
                        }
                    } else e[f] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = n
            },
            remove: function () {
                for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                    var s = arguments[a],
                        l = s.uuid,
                        u = n[l];
                    if (void 0 !== u && t <= u) {
                        var h = t++,
                            c = e[h];
                        n[c.uuid] = u, e[u] = c, n[l] = h, e[h] = s;
                        for (var d = 0, f = i; d !== f; ++d) {
                            var p = r[d],
                                g = p[h],
                                m = p[u];
                            p[u] = g, p[h] = m
                        }
                    }
                }
                this.nCachedObjects_ = t
            },
            uncache: function () {
                for (var e = this._objects, t = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, a = i.length, o = 0, s = arguments.length; o !== s; ++o) {
                    var l = arguments[o],
                        u = l.uuid,
                        h = r[u];
                    if (void 0 !== h)
                        if (delete r[u], h < n) {
                            var c = --n,
                                d = e[c],
                                f = --t,
                                p = e[f];
                            r[d.uuid] = h, e[h] = d, r[p.uuid] = c, e[c] = p, e.pop();
                            for (var g = 0, m = a; g !== m; ++g) {
                                var v = i[g],
                                    y = v[c],
                                    _ = v[f];
                                v[h] = y, v[c] = _, v.pop()
                            }
                        } else
                            for (f = --t, p = e[f], r[p.uuid] = h, e[h] = p, e.pop(), g = 0, m = a; g !== m; ++g) v = i[g], v[h] = v[f], v.pop()
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function (e, t) {
                var n = this._bindingsIndicesByPath,
                    r = n[e],
                    i = this._bindings;
                if (void 0 !== r) return i[r];
                var a = this._paths,
                    o = this._parsedPaths,
                    s = this._objects,
                    l = s.length,
                    u = this.nCachedObjects_,
                    h = new Array(l);
                r = i.length, n[e] = r, a.push(e), o.push(t), i.push(h);
                for (var c = u, d = s.length; c !== d; ++c) {
                    var f = s[c];
                    h[c] = new Fg(f, e, t)
                }
                return h
            },
            unsubscribe_: function (e) {
                var t = this._bindingsIndicesByPath,
                    n = t[e];
                if (void 0 !== n) {
                    var r = this._paths,
                        i = this._parsedPaths,
                        a = this._bindings,
                        o = a.length - 1,
                        s = a[o],
                        l = e[o];
                    t[l] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
                }
            }
        }), (0, We.default)(Gg.prototype, {
            play: function () {
                return this._mixer._activateAction(this), this
            },
            stop: function () {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function () {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function () {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function () {
                return this._mixer._isActiveAction(this)
            },
            startAt: function (e) {
                return this._startTime = e, this
            },
            setLoop: function (e, t) {
                return this.loop = e, this.repetitions = t, this
            },
            setEffectiveWeight: function (e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            },
            getEffectiveWeight: function () {
                return this._effectiveWeight
            },
            fadeIn: function (e) {
                return this._scheduleFading(e, 0, 1)
            },
            fadeOut: function (e) {
                return this._scheduleFading(e, 1, 0)
            },
            crossFadeFrom: function (e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    var r = this._clip.duration,
                        i = e._clip.duration,
                        a = i / r,
                        o = r / i;
                    e.warp(1, a, t), this.warp(o, 1, t)
                }
                return this
            },
            crossFadeTo: function (e, t, n) {
                return e.crossFadeFrom(this, t, n)
            },
            stopFading: function () {
                var e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            setEffectiveTimeScale: function (e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            },
            getEffectiveTimeScale: function () {
                return this._effectiveTimeScale
            },
            setDuration: function (e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            },
            syncWith: function (e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            },
            halt: function (e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            },
            warp: function (e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    a = this._timeScaleInterpolant,
                    o = this.timeScale;
                null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
                var s = a.parameterPositions,
                    l = a.sampleValues;
                return s[0] = i, s[1] = i + n, l[0] = e / o, l[1] = t / o, this
            },
            stopWarping: function () {
                var e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            },
            getMixer: function () {
                return this._mixer
            },
            getClip: function () {
                return this._clip
            },
            getRoot: function () {
                return this._localRoot || this._mixer._root
            },
            _update: function (e, t, n, r) {
                if (this.enabled) {
                    var i = this._startTime;
                    if (null !== i) {
                        var a = (e - i) * n;
                        if (a < 0 || 0 === n) return;
                        this._startTime = null, t = n * a
                    }
                    t *= this._updateTimeScale(e);
                    var o = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (0 < s)
                        for (var l = this._interpolants, u = this._propertyBindings, h = 0, c = l.length; h !== c; ++h) l[h].evaluate(o), u[h].accumulate(r, s)
                } else this._updateWeight(e)
            },
            _updateWeight: function (e) {
                var t = 0;
                if (this.enabled) {
                    t = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var r = n.evaluate(e)[0];
                        t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            },
            _updateTimeScale: function (e) {
                var t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) {
                        var r = n.evaluate(e)[0];
                        t *= r, e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t, t
            },
            _updateTime: function (e) {
                var t = this.time + e,
                    n = this._clip.duration,
                    r = this.loop,
                    i = this._loopCount,
                    a = r === fn;
                if (0 === e) return -1 === i ? t : a && 1 == (1 & i) ? n - t : t;
                if (r === cn) {
                    -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (n <= t) t = n;
                        else {
                            if (!(t < 0)) {
                                this.time = t;
                                break e
                            }
                            t = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = t,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === i && (0 <= e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), n <= t || t < 0) {
                        var o = Math.floor(t / n);
                        t -= n * o, i += Math.abs(o);
                        var s = this.repetitions - i;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = 0 < e ? n : 0, this.time = t, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < e ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                var l = e < 0;
                                this._setEndings(l, !l, a)
                            } else this._setEndings(!1, !1, a);
                            this._loopCount = i, this.time = t, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: o
                            })
                        }
                    } else this.time = t;
                    if (a && 1 == (1 & i)) return n - t
                }
                return t
            },
            _setEndings: function (e, t, n) {
                var r = this._interpolantSettings;
                n ? (r.endingStart = yn, r.endingEnd = yn) : (r.endingStart = e ? this.zeroSlopeAtStart ? yn : vn : _n, r.endingEnd = t ? this.zeroSlopeAtEnd ? yn : vn : _n)
            },
            _scheduleFading: function (e, t, n) {
                var r = this._mixer,
                    i = r.time,
                    a = this._weightInterpolant;
                null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
                var o = a.parameterPositions,
                    s = a.sampleValues;
                return o[0] = i, s[0] = t, o[1] = i + e, s[1] = n, this
            }
        }), Ug.prototype = (0, We.default)((0, s.default)(or.prototype), {
            constructor: Ug,
            _bindAction: function (e, t) {
                var n = e._localRoot || this._root,
                    r = e._clip.tracks,
                    i = r.length,
                    a = e._propertyBindings,
                    o = e._interpolants,
                    s = n.uuid,
                    l = this._bindingsByRootAndName,
                    u = l[s];
                void 0 === u && (u = {}, l[s] = u);
                for (var h = 0; h !== i; ++h) {
                    var c = r[h],
                        d = c.name,
                        f = u[d];
                    if (void 0 !== f) a[h] = f;
                    else {
                        if (f = a[h], void 0 !== f) {
                            null === f._cacheIndex && (++f.referenceCount, this._addInactiveBinding(f, s, d));
                            continue
                        }
                        var p = t && t._propertyBindings[h].binding.parsedPath;
                        f = new xg(Fg.create(n, d, p), c.ValueTypeName, c.getValueSize()), ++f.referenceCount, this._addInactiveBinding(f, s, d), a[h] = f
                    }
                    o[h].resultBuffer = f.buffer
                }
            },
            _activateAction: function (e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        var t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            r = this._actionsByClip[n];
                        this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) {
                        var s = i[a];
                        0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            },
            _deactivateAction: function (e) {
                if (this._isActiveAction(e)) {
                    for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                        var i = t[n];
                        0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                    }
                    this._takeBackAction(e)
                }
            },
            _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function (e) {
                var t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            },
            _addInactiveAction: function (e, t, n) {
                var r = this._actions,
                    i = this._actionsByClip,
                    a = i[t];
                if (void 0 === a) a = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, i[t] = a;
                else {
                    var o = a.knownActions;
                    e._byClipCacheIndex = o.length, o.push(e)
                }
                e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e
            },
            _removeInactiveAction: function (e) {
                var t = this._actions,
                    n = t[t.length - 1],
                    r = e._cacheIndex;
                n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                var i = e._clip.uuid,
                    a = this._actionsByClip,
                    o = a[i],
                    s = o.knownActions,
                    l = s[s.length - 1],
                    u = e._byClipCacheIndex;
                l._byClipCacheIndex = u, s[u] = l, s.pop(), e._byClipCacheIndex = null;
                var h = o.actionByRoot,
                    c = (e._localRoot || this._root).uuid;
                delete h[c], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(e)
            },
            _removeInactiveBindingsForAction: function (e) {
                for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) {
                    var i = t[n];
                    0 == --i.referenceCount && this._removeInactiveBinding(i)
                }
            },
            _lendAction: function (e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = this._nActiveActions++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackAction: function (e) {
                var t = this._actions,
                    n = e._cacheIndex,
                    r = --this._nActiveActions,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _addInactiveBinding: function (e, t, n) {
                var r = this._bindingsByRootAndName,
                    i = r[t],
                    a = this._bindings;
                void 0 === i && (i = {}, r[t] = i), i[n] = e, e._cacheIndex = a.length, a.push(e)
            },
            _removeInactiveBinding: function (e) {
                var t = this._bindings,
                    n = e.binding,
                    r = n.rootNode.uuid,
                    i = n.path,
                    a = this._bindingsByRootAndName,
                    o = a[r],
                    s = t[t.length - 1],
                    l = e._cacheIndex;
                s._cacheIndex = l, t[l] = s, t.pop(), delete o[i], 0 === (0, g.default)(o).length && delete a[r]
            },
            _lendBinding: function (e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = this._nActiveBindings++,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _takeBackBinding: function (e) {
                var t = this._bindings,
                    n = e._cacheIndex,
                    r = --this._nActiveBindings,
                    i = t[r];
                e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
            },
            _lendControlInterpolant: function () {
                var e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++,
                    n = e[t];
                return void 0 === n && (n = new If(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
            },
            _takeBackControlInterpolant: function (e) {
                var t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    r = --this._nActiveControlInterpolants,
                    i = t[r];
                e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function (e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? kf.findByName(n, e) : e,
                    a = null !== i ? i.uuid : e,
                    o = this._actionsByClip[a],
                    s = null;
                if (void 0 !== o) {
                    var l = o.actionByRoot[r];
                    if (void 0 !== l) return l;
                    s = o.knownActions[0], null === i && (i = s._clip)
                }
                if (null === i) return null;
                var u = new Gg(this, i, t);
                return this._bindAction(u, s), this._addInactiveAction(u, a, r), u
            },
            existingAction: function (e, t) {
                var n = t || this._root,
                    r = n.uuid,
                    i = "string" == typeof e ? kf.findByName(n, e) : e,
                    a = i ? i.uuid : e,
                    o = this._actionsByClip[a];
                return void 0 !== o && o.actionByRoot[r] || null
            },
            stopAllAction: function () {
                var e = this._actions,
                    t = this._nActiveActions,
                    n = this._bindings,
                    r = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var i = 0; i !== t; ++i) e[i].reset();
                for (i = 0; i !== r; ++i) n[i].useCount = 0;
                return this
            },
            update: function (e) {
                e *= this.timeScale;
                for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                    var s = t[o];
                    s._update(r, e, i, a)
                }
                var l = this._bindings,
                    u = this._nActiveBindings;
                for (o = 0; o !== u; ++o) l[o].apply(a);
                return this
            },
            setTime: function (e) {
                this.time = 0;
                for (var t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                return this.update(e)
            },
            getRoot: function () {
                return this._root
            },
            uncacheClip: function (e) {
                var t = this._actions,
                    n = e.uuid,
                    r = this._actionsByClip,
                    i = r[n];
                if (void 0 !== i) {
                    for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) {
                        var l = a[o];
                        this._deactivateAction(l);
                        var u = l._cacheIndex,
                            h = t[t.length - 1];
                        l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = u, t[u] = h, t.pop(), this._removeInactiveBindingsForAction(l)
                    }
                    delete r[n]
                }
            },
            uncacheRoot: function (e) {
                var t = e.uuid,
                    n = this._actionsByClip;
                for (var r in n) {
                    var i = n[r].actionByRoot,
                        a = i[t];
                    void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                }
                var o = this._bindingsByRootAndName,
                    s = o[t];
                if (void 0 !== s)
                    for (var l in s) {
                        var u = s[l];
                        u.restoreOriginalState(), this._removeInactiveBinding(u)
                    }
            },
            uncacheAction: function (e, t) {
                var n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), zg.prototype.clone = function () {
            return new zg(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Vg.prototype = (0, We.default)((0, s.default)(Vh.prototype), {
            constructor: Vg,
            isInstancedInterleavedBuffer: !0,
            copy: function (e) {
                return Vh.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }
        }), (0, We.default)(Hg.prototype, {
            set: function (e, t) {
                this.ray.set(e, t)
            },
            setFromCamera: function (e, t) {
                t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function (e, t, n) {
                var r = n || [];
                return jg(e, this, r, t), r.sort(Wg), r
            },
            intersectObjects: function (e, t, n) {
                var r = n || [];
                if (!1 === (0, He.default)(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                for (var i = 0, a = e.length; i < a; i++) jg(e[i], this, r, t);
                return r.sort(Wg), r
            }
        }), (0, We.default)(Yg.prototype, {
            set: function (e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
            },
            makeSafe: function () {
                var e = 1e-6;
                return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
            },
            setFromVector3: function (e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function (e, t, n) {
                return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(hr.clamp(t / this.radius, -1, 1))), this
            }
        }), (0, We.default)(qg.prototype, {
            set: function (e, t, n) {
                return this.radius = e, this.theta = t, this.y = n, this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
            },
            setFromVector3: function (e) {
                return this.setFromCartesianCoords(e.x, e.y, e.z)
            },
            setFromCartesianCoords: function (e, t, n) {
                return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
            }
        });
        var Xg = new cr;

        function Zg(e, t) {
            this.min = void 0 !== e ? e : new cr(Infinity, Infinity), this.max = void 0 !== t ? t : new cr(-Infinity, -Infinity)
        }(0, We.default)(Zg.prototype, {
            set: function (e, t) {
                return this.min.copy(e), this.max.copy(t), this
            },
            setFromPoints: function (e) {
                this.makeEmpty();
                for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            },
            setFromCenterAndSize: function (e, t) {
                var n = Xg.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            },
            makeEmpty: function () {
                return this.min.x = this.min.y = Infinity, this.max.x = this.max.y = -Infinity, this
            },
            isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new cr), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function (e) {
                return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new cr), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function (e) {
                return this.min.min(e), this.max.max(e), this
            },
            expandByVector: function (e) {
                return this.min.sub(e), this.max.add(e), this
            },
            expandByScalar: function (e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            },
            containsPoint: function (e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
            },
            containsBox: function (e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            },
            getParameter: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new cr), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function (e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
            },
            clampPoint: function (e, t) {
                return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new cr), t.copy(e).clamp(this.min, this.max)
            },
            distanceToPoint: function (e) {
                var t = Xg.copy(e).clamp(this.min, this.max);
                return t.sub(e).length()
            },
            intersect: function (e) {
                return this.min.max(e.min), this.max.min(e.max), this
            },
            union: function (e) {
                return this.min.min(e.min), this.max.max(e.max), this
            },
            translate: function (e) {
                return this.min.add(e), this.max.add(e), this
            },
            equals: function (e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        });
        var Jg = new Cr,
            Kg = new Cr;

        function Qg(e, t) {
            this.start = void 0 !== e ? e : new Cr, this.end = void 0 !== t ? t : new Cr
        }

        function $g(e) {
            Xr.call(this), this.material = e, this.render = function () {}
        }(0, We.default)(Qg.prototype, {
            set: function (e, t) {
                return this.start.copy(e), this.end.copy(t), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            },
            copy: function (e) {
                return this.start.copy(e.start), this.end.copy(e.end), this
            },
            getCenter: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Cr), e.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function (e) {
                return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Cr), e.subVectors(this.end, this.start)
            },
            distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            },
            distance: function () {
                return this.start.distanceTo(this.end)
            },
            at: function (e, t) {
                return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Cr), this.delta(t).multiplyScalar(e).add(this.start)
            },
            closestPointToPointParameter: function (e, t) {
                Jg.subVectors(e, this.start), Kg.subVectors(this.end, this.start);
                var n = Kg.dot(Kg),
                    r = Kg.dot(Jg),
                    i = r / n;
                return t && (i = hr.clamp(i, 0, 1)), i
            },
            closestPointToPoint: function (e, t, n) {
                var r = this.closestPointToPointParameter(e, t);
                return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Cr), this.delta(n).multiplyScalar(r).add(this.start)
            },
            applyMatrix4: function (e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
            },
            equals: function (e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
        }), $g.prototype = (0, s.default)(Xr.prototype), $g.prototype.constructor = $g, $g.prototype.isImmediateRenderObject = !0;
        var em = new Cr;

        function tm(e, t) {
            Xr.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
            for (var n = new fa, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, a = 1, o = 32; i < o; i++, a++) {
                var s = i / o * Math.PI * 2,
                    l = a / o * Math.PI * 2;
                r.push(Math.cos(s), Math.sin(s), 1, Math.cos(l), Math.sin(l), 1)
            }
            n.setAttribute("position", new na(r, 3));
            var u = new Ac({
                fog: !1,
                toneMapped: !1
            });
            this.cone = new Tc(n, u), this.add(this.cone), this.update()
        }
        tm.prototype = (0, s.default)(Xr.prototype), tm.prototype.constructor = tm, tm.prototype.dispose = function () {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, tm.prototype.update = function () {
            this.light.updateMatrixWorld();
            var e = this.light.distance ? this.light.distance : 1e3,
                t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e), em.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(em), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        };
        var nm = new Cr,
            rm = new Lr,
            im = new Lr;

        function am(e) {
            var t = [];
            e && e.isBone && t.push(e);
            for (var n = 0; n < e.children.length; n++) t.push.apply(t, am(e.children[n]));
            return t
        }

        function om(e) {
            for (var t = am(e), n = new fa, r = [], i = [], a = new Gi(0, 0, 1), o = new Gi(0, 1, 0), s = 0; s < t.length; s++) {
                var l = t[s];
                l.parent && l.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(a.r, a.g, a.b), i.push(o.r, o.g, o.b))
            }
            n.setAttribute("position", new na(r, 3)), n.setAttribute("color", new na(i, 3));
            var u = new Ac({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            });
            Tc.call(this, n, u), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
        }

        function sm(e, t, n) {
            this.light = e, this.light.updateMatrixWorld(), this.color = n;
            var r = new Yd(t, 4, 2),
                i = new Yi({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                });
            Na.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }
        om.prototype = (0, s.default)(Tc.prototype), om.prototype.constructor = om, om.prototype.isSkeletonHelper = !0, om.prototype.updateMatrixWorld = function (e) {
            var t = this.bones,
                n = this.geometry,
                r = n.getAttribute("position");
            im.getInverse(this.root.matrixWorld);
            for (var i = 0, a = 0; i < t.length; i++) {
                var o = t[i];
                o.parent && o.parent.isBone && (rm.multiplyMatrices(im, o.matrixWorld), nm.setFromMatrixPosition(rm), r.setXYZ(a, nm.x, nm.y, nm.z), rm.multiplyMatrices(im, o.parent.matrixWorld), nm.setFromMatrixPosition(rm), r.setXYZ(a + 1, nm.x, nm.y, nm.z), a += 2)
            }
            n.getAttribute("position").needsUpdate = !0, Xr.prototype.updateMatrixWorld.call(this, e)
        }, sm.prototype = (0, s.default)(Na.prototype), sm.prototype.constructor = sm, sm.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, sm.prototype.update = function () {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        };
        var lm = new Cr,
            um = new Gi,
            hm = new Gi;

        function cm(e, t, n) {
            Xr.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
            var r = new Jc(t);
            r.rotateY(.5 * Math.PI), this.material = new Yi({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            }), void 0 === this.color && (this.material.vertexColors = !0);
            var i = r.getAttribute("position"),
                a = new Float32Array(3 * i.count);
            r.setAttribute("color", new Xi(a, 3)), this.add(new Na(r, this.material)), this.update()
        }

        function dm(e, t, n, r) {
            e = e || 10, t = t || 10, n = new Gi(void 0 !== n ? n : 4473924), r = new Gi(void 0 !== r ? r : 8947848);
            for (var i = t / 2, a = e / t, o = e / 2, s = [], l = [], u = 0, h = 0, c = -o; u <= t; u++, c += a) {
                s.push(-o, 0, c, o, 0, c), s.push(c, 0, -o, c, 0, o);
                var d = u === i ? n : r;
                d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3
            }
            var f = new fa;
            f.setAttribute("position", new na(s, 3)), f.setAttribute("color", new na(l, 3));
            var p = new Ac({
                vertexColors: !0,
                toneMapped: !1
            });
            Tc.call(this, f, p)
        }

        function fm(e, t, n, r, i, a) {
            e = e || 10, t = t || 16, n = n || 8, r = r || 64, i = new Gi(void 0 !== i ? i : 4473924), a = new Gi(void 0 !== a ? a : 8947848);
            var o, s, l, u, h, c, d, f = [],
                p = [];
            for (u = 0; u <= t; u++) l = u / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, f.push(0, 0, 0), f.push(o, 0, s), d = 1 & u ? i : a, p.push(d.r, d.g, d.b), p.push(d.r, d.g, d.b);
            for (u = 0; u <= n; u++)
                for (d = 1 & u ? i : a, c = e - e / n * u, h = 0; h < r; h++) l = h / r * (2 * Math.PI), o = Math.sin(l) * c, s = Math.cos(l) * c, f.push(o, 0, s), p.push(d.r, d.g, d.b), l = (h + 1) / r * (2 * Math.PI), o = Math.sin(l) * c, s = Math.cos(l) * c, f.push(o, 0, s), p.push(d.r, d.g, d.b);
            var g = new fa;
            g.setAttribute("position", new na(f, 3)), g.setAttribute("color", new na(p, 3));
            var m = new Ac({
                vertexColors: !0,
                toneMapped: !1
            });
            Tc.call(this, g, m)
        }
        cm.prototype = (0, s.default)(Xr.prototype), cm.prototype.constructor = cm, cm.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, cm.prototype.update = function () {
            var e = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var t = e.geometry.getAttribute("color");
                um.copy(this.light.color), hm.copy(this.light.groundColor);
                for (var n = 0, r = t.count; n < r; n++) {
                    var i = n < r / 2 ? um : hm;
                    t.setXYZ(n, i.r, i.g, i.b)
                }
                t.needsUpdate = !0
            }
            e.lookAt(lm.setFromMatrixPosition(this.light.matrixWorld).negate())
        }, dm.prototype = (0, We.default)((0, s.default)(Tc.prototype), {
            constructor: dm,
            copy: function (e) {
                return Tc.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
            },
            clone: function () {
                return (new this.constructor).copy(this)
            }
        }), fm.prototype = (0, s.default)(Tc.prototype), fm.prototype.constructor = fm;
        var pm = new Cr,
            gm = new Cr,
            mm = new Cr;

        function vm(e, t, n) {
            Xr.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
            var r = new fa;
            r.setAttribute("position", new na([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
            var i = new Ac({
                fog: !1,
                toneMapped: !1
            });
            this.lightPlane = new bc(r, i), this.add(this.lightPlane), r = new fa, r.setAttribute("position", new na([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new bc(r, i), this.add(this.targetLine), this.update()
        }
        vm.prototype = (0, s.default)(Xr.prototype), vm.prototype.constructor = vm, vm.prototype.dispose = function () {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, vm.prototype.update = function () {
            pm.setFromMatrixPosition(this.light.matrixWorld), gm.setFromMatrixPosition(this.light.target.matrixWorld), mm.subVectors(gm, pm), this.lightPlane.lookAt(gm), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(gm), this.targetLine.scale.z = mm.length()
        };
        var ym = new Cr,
            _m = new qa;

        function Am(e) {
            var t = new fa,
                n = new Ac({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                }),
                r = [],
                i = [],
                a = {},
                o = new Gi(16755200),
                s = new Gi(16711680),
                l = new Gi(43775),
                u = new Gi(16777215),
                h = new Gi(3355443);

            function c(e, t, n) {
                d(e, n), d(t, n)
            }

            function d(e, t) {
                r.push(0, 0, 0), i.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1)
            }
            c("n1", "n2", o), c("n2", "n4", o), c("n4", "n3", o), c("n3", "n1", o), c("f1", "f2", o), c("f2", "f4", o), c("f4", "f3", o), c("f3", "f1", o), c("n1", "f1", o), c("n2", "f2", o), c("n3", "f3", o), c("n4", "f4", o), c("p", "n1", s), c("p", "n2", s), c("p", "n3", s), c("p", "n4", s), c("u1", "u2", l), c("u2", "u3", l), c("u3", "u1", l), c("c", "t", u), c("p", "c", h), c("cn1", "cn2", h), c("cn3", "cn4", h), c("cf1", "cf2", h), c("cf3", "cf4", h), t.setAttribute("position", new na(r, 3)), t.setAttribute("color", new na(i, 3)), Tc.call(this, t, n), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
        }

        function xm(e, t, n, r, i, a, o) {
            ym.set(i, a, o).unproject(r);
            var s = t[e];
            if (void 0 !== s)
                for (var l = n.getAttribute("position"), u = 0, h = s.length; u < h; u++) l.setXYZ(s[u], ym.x, ym.y, ym.z)
        }
        Am.prototype = (0, s.default)(Tc.prototype), Am.prototype.constructor = Am, Am.prototype.update = function () {
            var e = this.geometry,
                t = this.pointMap,
                n = 1,
                r = 1;
            _m.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), xm("c", t, e, _m, 0, 0, -1), xm("t", t, e, _m, 0, 0, 1), xm("n1", t, e, _m, -n, -r, -1), xm("n2", t, e, _m, n, -r, -1), xm("n3", t, e, _m, -n, r, -1), xm("n4", t, e, _m, n, r, -1), xm("f1", t, e, _m, -n, -r, 1), xm("f2", t, e, _m, n, -r, 1), xm("f3", t, e, _m, -n, r, 1), xm("f4", t, e, _m, n, r, 1), xm("u1", t, e, _m, .7 * n, 1.1 * r, -1), xm("u2", t, e, _m, .7 * -n, 1.1 * r, -1), xm("u3", t, e, _m, 0, 2 * r, -1), xm("cf1", t, e, _m, -n, 0, 1), xm("cf2", t, e, _m, n, 0, 1), xm("cf3", t, e, _m, 0, -r, 1), xm("cf4", t, e, _m, 0, r, 1), xm("cn1", t, e, _m, -n, 0, -1), xm("cn2", t, e, _m, n, 0, -1), xm("cn3", t, e, _m, 0, -r, -1), xm("cn4", t, e, _m, 0, r, -1), e.getAttribute("position").needsUpdate = !0
        };
        var Cm = new ui;

        function Im(e, t) {
            this.object = e, void 0 === t && (t = 16776960);
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                r = new Float32Array(24),
                i = new fa;
            i.setIndex(new Xi(n, 1)), i.setAttribute("position", new Xi(r, 3)), Tc.call(this, i, new Ac({
                color: t,
                toneMapped: !1
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function wm(e, t) {
            this.type = "Box3Helper", this.box = e, t = t || 16776960;
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                i = new fa;
            i.setIndex(new Xi(n, 1)), i.setAttribute("position", new na(r, 3)), Tc.call(this, i, new Ac({
                color: t,
                toneMapped: !1
            })), this.geometry.computeBoundingSphere()
        }

        function Mm(e, t, n) {
            this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
            var r = void 0 !== n ? n : 16776960,
                i = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                a = new fa;
            a.setAttribute("position", new na(i, 3)), a.computeBoundingSphere(), bc.call(this, a, new Ac({
                color: r,
                toneMapped: !1
            }));
            var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                s = new fa;
            s.setAttribute("position", new na(o, 3)), s.computeBoundingSphere(), this.add(new Na(s, new Yi({
                color: r,
                opacity: .2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1
            })))
        }
        Im.prototype = (0, s.default)(Tc.prototype), Im.prototype.constructor = Im, Im.prototype.update = function (e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Cm.setFromObject(this.object), !Cm.isEmpty()) {
                var t = Cm.min,
                    n = Cm.max,
                    r = this.geometry.attributes.position,
                    i = r.array;
                i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }, Im.prototype.setFromObject = function (e) {
            return this.object = e, this.update(), this
        }, Im.prototype.copy = function (e) {
            return Tc.prototype.copy.call(this, e), this.object = e.object, this
        }, Im.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, wm.prototype = (0, s.default)(Tc.prototype), wm.prototype.constructor = wm, wm.prototype.updateMatrixWorld = function (e) {
            var t = this.box;
            t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Xr.prototype.updateMatrixWorld.call(this, e))
        }, Mm.prototype = (0, s.default)(bc.prototype), Mm.prototype.constructor = Mm, Mm.prototype.updateMatrixWorld = function (e) {
            var t = -this.plane.constant;
            Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? je : k, this.lookAt(this.plane.normal), Xr.prototype.updateMatrixWorld.call(this, e)
        };
        var bm, Sm, Em = new Cr;

        function Tm(e, t, n, r, i, a) {
            Xr.call(this), void 0 === e && (e = new Cr(0, 0, 1)), void 0 === t && (t = new Cr(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === a && (a = .2 * i), void 0 === bm && (bm = new fa, bm.setAttribute("position", new na([0, 0, 0, 0, 1, 0], 3)), Sm = new nf(0, .5, 1, 5, 1), Sm.translate(0, -.5, 0)), this.position.copy(t), this.line = new bc(bm, new Ac({
                color: r,
                toneMapped: !1
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Na(Sm, new Yi({
                color: r,
                toneMapped: !1
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, a)
        }

        function Lm(e) {
            e = e || 1;
            var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
                r = new fa;
            r.setAttribute("position", new na(t, 3)), r.setAttribute("color", new na(n, 3));
            var i = new Ac({
                vertexColors: !0,
                toneMapped: !1
            });
            Tc.call(this, r, i)
        }
        Tm.prototype = (0, s.default)(Xr.prototype), Tm.prototype.constructor = Tm, Tm.prototype.setDirection = function (e) {
            if (.99999 < e.y) this.quaternion.set(0, 0, 0, 1);
            else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
            else {
                Em.set(e.z, 0, -e.x).normalize();
                var t = Math.acos(e.y);
                this.quaternion.setFromAxisAngle(Em, t)
            }
        }, Tm.prototype.setLength = function (e, t, n) {
            void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
        }, Tm.prototype.setColor = function (e) {
            this.line.material.color.set(e), this.cone.material.color.set(e)
        }, Tm.prototype.copy = function (e) {
            return Xr.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
        }, Tm.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, Lm.prototype = (0, s.default)(Tc.prototype), Lm.prototype.constructor = Lm;
        var Nm = 4,
            Rm = 8,
            km = Math.pow(2, Rm),
            Pm = [.125, .215, .35, .446, .526, .582],
            Dm = Rm - Nm + 1 + Pm.length,
            Om = 20,
            Fm = (A = {}, (0, pe.default)(A, In, 0), (0, pe.default)(A, wn, 1), (0, pe.default)(A, bn, 2), (0, pe.default)(A, En, 3), (0, pe.default)(A, Tn, 4), (0, pe.default)(A, Ln, 5), (0, pe.default)(A, Mn, 6), A),
            Bm = new Np,
            Gm = hv(Om),
            Um = null,
            zm = null,
            Vm = $m(),
            Hm = Vm._lodPlanes,
            Wm = Vm._sizeLods,
            jm = Vm._sigmas,
            Ym = null,
            qm = null,
            Xm = null,
            Zm = (1 + Math.sqrt(5)) / 2,
            Jm = 1 / Zm,
            Km = [new Cr(1, 1, 1), new Cr(-1, 1, 1), new Cr(1, 1, -1), new Cr(-1, 1, -1), new Cr(0, Zm, Jm), new Cr(0, Zm, -Jm), new Cr(Jm, 0, Zm), new Cr(-Jm, 0, Zm), new Cr(Zm, Jm, 0), new Cr(-Zm, Jm, 0)];

        function Qm(e) {
            qm = e, iv(Gm)
        }

        function $m() {
            for (var e = [], t = [], n = [], r = Rm, i = 0; i < Dm; i++) {
                var a = Math.pow(2, r);
                t.push(a);
                var o = 1 / a;
                Rm - Nm < i ? o = Pm[i - Rm + Nm - 1] : 0 == i && (o = 0), n.push(o);
                for (var s = 1 / (a - 1), l = -s / 2, u = 1 + s / 2, h = [l, l, u, l, u, u, l, l, u, u, l, u], c = 6, d = 6, f = 3, p = 2, g = 1, m = new Float32Array(f * d * c), v = new Float32Array(p * d * c), y = new Float32Array(g * d * c), _ = 0; _ < c; _++) {
                    var A = _ % 3 * 2 / 3 - 1,
                        x = 2 < _ ? 0 : -1,
                        C = [A, x, 0, A + 2 / 3, x, 0, A + 2 / 3, x + 1, 0, A, x, 0, A + 2 / 3, x + 1, 0, A, x + 1, 0];
                    m.set(C, f * d * _), v.set(h, p * d * _);
                    var I = [_, _, _, _, _, _];
                    y.set(I, g * d * _)
                }
                var w = new fa;
                w.setAttribute("position", new Xi(m, f)), w.setAttribute("uv", new Xi(v, p)), w.setAttribute("faceIndex", new Xi(y, g)), e.push(w), Nm < r && r--
            }
            return {
                _lodPlanes: e,
                _sizeLods: t,
                _sigmas: n
            }
        }

        function ev(e) {
            var t = {
                    magFilter: oe,
                    minFilter: oe,
                    generateMipmaps: !1,
                    type: e ? e.type : et,
                    format: e ? e.format : gt,
                    encoding: e ? e.encoding : bn,
                    depthBuffer: !1,
                    stencilBuffer: !1
                },
                n = av(t);
            return n.depthBuffer = !e, Ym = av(t), n
        }

        function tv(e) {
            Ym.dispose(), qm.setRenderTarget(Xm), e.scissorTest = !1, e.setSize(e.width, e.height)
        }

        function nv(e, t, n, r) {
            var i = 90,
                a = 1,
                o = new Xa(i, a, t, n),
                s = [1, 1, 1, 1, -1, 1],
                l = [1, 1, -1, -1, -1, 1],
                u = qm.outputEncoding,
                h = qm.toneMapping,
                c = qm.toneMappingExposure,
                d = qm.getClearColor(),
                f = qm.getClearAlpha();
            qm.toneMapping = $e, qm.toneMappingExposure = 1, qm.outputEncoding = In, e.scale.z *= -1;
            var p = e.background;
            if (p && p.isColor) {
                p.convertSRGBToLinear();
                var g = Math.max(p.r, p.g, p.b),
                    m = Math.min(Math.max(Math.ceil(Math.log2(g)), -128), 127);
                p = p.multiplyScalar(Math.pow(2, -m));
                var v = (m + 128) / 255;
                qm.setClearColor(p, v), e.background = null
            }
            for (var y = 0; y < 6; y++) {
                var _ = y % 3;
                0 == _ ? (o.up.set(0, s[y], 0), o.lookAt(l[y], 0, 0)) : 1 == _ ? (o.up.set(0, 0, s[y]), o.lookAt(0, l[y], 0)) : (o.up.set(0, s[y], 0), o.lookAt(0, 0, l[y])), ov(r, _ * km, 2 < y ? km : 0, km, km), qm.setRenderTarget(r), qm.render(e, o)
            }
            qm.toneMapping = h, qm.toneMappingExposure = c, qm.outputEncoding = u, qm.setClearColor(d, f), e.scale.z *= -1
        }

        function rv(e, t) {
            var n = new Zr;
            e.isCubeTexture ? null == zm && (zm = dv()) : null == Um && (Um = cv());
            var r = e.isCubeTexture ? zm : Um;
            n.add(new Na(Hm[0], r));
            var i = r.uniforms;
            i.envMap.value = e, e.isCubeTexture || i.texelSize.value.set(1 / e.image.width, 1 / e.image.height), i.inputEncoding.value = Fm[e.encoding], i.outputEncoding.value = Fm[e.encoding], ov(t, 0, 0, 3 * km, 2 * km), qm.setRenderTarget(t), qm.render(n, Bm)
        }

        function iv(e) {
            var t = new Zr;
            t.add(new Na(Hm[0], e)), qm.compile(t, Bm)
        }

        function av(e) {
            var t = new vr(3 * km, 3 * km, e);
            return t.texture.mapping = Z, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
        }

        function ov(e, t, n, r, i) {
            e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
        }

        function sv(e) {
            var t = qm.autoClear;
            qm.autoClear = !1;
            for (var n = 1; n < Dm; n++) {
                var r = Math.sqrt(jm[n] * jm[n] - jm[n - 1] * jm[n - 1]),
                    i = Km[(n - 1) % Km.length];
                lv(e, n - 1, n, r, i)
            }
            qm.autoClear = t
        }

        function lv(e, t, n, r, i) {
            uv(e, Ym, t, n, r, "latitudinal", i), uv(Ym, e, n, n, r, "longitudinal", i)
        }

        function uv(e, t, n, r, i, a, o) {
            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
            var s = 3,
                l = new Zr;
            l.add(new Na(Hm[r], Gm));
            var u = Gm.uniforms,
                h = Wm[n] - 1,
                c = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * Om - 1),
                d = i / c,
                f = isFinite(i) ? 1 + Math.floor(s * d) : Om;
            Om < f && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to ").concat(Om));
            for (var p = [], g = 0, m = 0; m < Om; ++m) {
                var v = m / d,
                    y = Math.exp(-v * v / 2);
                p.push(y), 0 == m ? g += y : m < f && (g += 2 * y)
            }
            for (m = 0; m < p.length; m++) p[m] = p[m] / g;
            u.envMap.value = e.texture, u.samples.value = f, u.weights.value = p, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o), u.dTheta.value = c, u.mipInt.value = Rm - n, u.inputEncoding.value = Fm[e.texture.encoding], u.outputEncoding.value = Fm[e.texture.encoding];
            var _ = Wm[r],
                A = (v = 3 * Math.max(0, km - 2 * _), (0 === r ? 0 : 2 * km) + 2 * _ * (Rm - Nm < r ? r - Rm + Nm : 0));
            ov(t, v, A, 3 * _, 2 * _), qm.setRenderTarget(t), qm.render(l, Bm)
        }

        function hv(e) {
            var t = new Float32Array(e),
                n = new Cr(0, 1, 0),
                r = new hf({
                    defines: {
                        n: e
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: t
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: n
                        },
                        inputEncoding: {
                            value: Fm[In]
                        },
                        outputEncoding: {
                            value: Fm[In]
                        }
                    },
                    vertexShader: fv(),
                    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n".concat(pv(), "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
                    blending: Ae,
                    depthTest: !1,
                    depthWrite: !1
                });
            return r.type = "SphericalGaussianBlur", r
        }

        function cv() {
            var e = new cr(1, 1),
                t = new hf({
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: e
                        },
                        inputEncoding: {
                            value: Fm[In]
                        },
                        outputEncoding: {
                            value: Fm[In]
                        }
                    },
                    vertexShader: fv(),
                    fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n".concat(pv(), "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
                    blending: Ae,
                    depthTest: !1,
                    depthWrite: !1
                });
            return t.type = "EquirectangularToCubeUV", t
        }

        function dv() {
            var e = new hf({
                uniforms: {
                    envMap: {
                        value: null
                    },
                    inputEncoding: {
                        value: Fm[In]
                    },
                    outputEncoding: {
                        value: Fm[In]
                    }
                },
                vertexShader: fv(),
                fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n".concat(pv(), "\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),
                blending: Ae,
                depthTest: !1,
                depthWrite: !1
            });
            return e.type = "CubemapToCubeUV", e
        }

        function fv() {
            return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"
        }

        function pv() {
            return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"
        }

        function gv(e, t, n, r, i, a, o) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Hi(e, t, n, i, a, o)
        }
        Qm.prototype = {
            constructor: Qm,
            fromScene: function (e, t, n, r) {
                var i = 1 < arguments.length && void 0 !== t ? arguments[1] : 0,
                    a = 2 < arguments.length && void 0 !== n ? arguments[2] : .1,
                    o = 3 < arguments.length && void 0 !== r ? arguments[3] : 100;
                Xm = qm.getRenderTarget();
                var s = ev();
                return nv(e, a, o, s), 0 < i && lv(s, 0, 0, i), sv(s), tv(s), s
            },
            fromEquirectangular: function (e) {
                return e.magFilter = oe, e.minFilter = oe, e.generateMipmaps = !1, this.fromCubemap(e)
            },
            fromCubemap: function (e) {
                Xm = qm.getRenderTarget();
                var t = ev(e);
                return rv(e, t), sv(t), tv(t), t
            },
            compileCubemapShader: function () {
                null == zm && (zm = dv(), iv(zm))
            },
            compileEquirectangularShader: function () {
                null == Um && (Um = cv(), iv(Um))
            },
            dispose: function () {
                Gm.dispose(), null != zm && zm.dispose(), null != Um && Um.dispose();
                for (var e = 0; e < Hm.length; e++) Hm[e].dispose()
            }
        };
        var mv = 0;
        t.LineStrip = mv;
        var vv = 1;
        t.LinePieces = vv;
        var yv = 0;
        t.NoColors = yv;
        var _v = 1;
        t.FaceColors = _v;
        var Av = 2;

        function xv(e) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
        }

        function Cv(e) {
            return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () {
                return e.slice()
            }, e
        }

        function Iv(e, t) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Oc(e, t)
        }

        function wv(e) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new ac(e)
        }

        function Mv(e, t) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Oc(e, t)
        }

        function bv(e) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Nc(e)
        }

        function Sv(e) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Nc(e)
        }

        function Ev(e) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Nc(e)
        }

        function Tv(e, t, n) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Cr(e, t, n)
        }

        function Lv(e, t) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new Xi(e, t).setUsage(Qn)
        }

        function Nv(e, t) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Zi(e, t)
        }

        function Rv(e, t) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Ji(e, t)
        }

        function kv(e, t) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Ki(e, t)
        }

        function Pv(e, t) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Qi(e, t)
        }

        function Dv(e, t) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new $i(e, t)
        }

        function Ov(e, t) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new ea(e, t)
        }

        function Fv(e, t) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new ta(e, t)
        }

        function Bv(e, t) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new na(e, t)
        }

        function Gv(e, t) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ra(e, t)
        }

        function Uv(e) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), np.call(this, e), this.type = "catmullrom", this.closed = !0
        }

        function zv(e) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), np.call(this, e), this.type = "catmullrom"
        }

        function Vv(e) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), np.call(this, e), this.type = "catmullrom"
        }

        function Hv(e) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Lm(e)
        }

        function Wv(e, t) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Im(e, t)
        }

        function jv(e, t) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Tc(new ef(e.geometry), new Ac({
                color: void 0 !== t ? t : 16777215
            }))
        }

        function Yv(e, t) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Tc(new Vc(e.geometry), new Ac({
                color: void 0 !== t ? t : 16777215
            }))
        }

        function qv(e) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new zf(e)
        }

        function Xv(e) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Wf(e)
        }

        function Zv(e, t, n) {
            return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Qa(e, n)
        }
        t.VertexColors = Av, Xf.create = function (e, t) {
            return e.prototype = (0, s.default)(Xf.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
        }, (0, We.default)(xp.prototype, {
            createPointsGeometry: function (e) {
                console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var t = this.getPoints(e);
                return this.createGeometry(t)
            },
            createSpacedPointsGeometry: function (e) {
                console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                var t = this.getSpacedPoints(e);
                return this.createGeometry(t)
            },
            createGeometry: function (e) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var t = new Ba, n = 0, r = e.length; n < r; n++) {
                    var i = e[n];
                    t.vertices.push(new Cr(i.x, i.y, i.z || 0))
                }
                return t
            }
        }), (0, We.default)(Cp.prototype, {
            fromPoints: function (e) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
            }
        }), Uv.prototype = (0, s.default)(np.prototype), zv.prototype = (0, s.default)(np.prototype), Vv.prototype = (0, s.default)(np.prototype), (0, We.default)(Vv.prototype, {
            initFromArray: function () {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function () {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function () {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), dm.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, om.prototype.update = function () {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, (0, We.default)(Gf.prototype, {
            extractUrlBase: function (e) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Fp.extractUrlBase(e)
            }
        }), Gf.Handlers = {
            add: function () {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function () {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, (0, We.default)(Vp.prototype, {
            setTexturePath: function (e) {
                return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
            }
        }), (0, We.default)(Zg.prototype, {
            center: function (e) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
            },
            empty: function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function (e) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            size: function (e) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
            }
        }), (0, We.default)(ui.prototype, {
            center: function (e) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            },
            empty: function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function (e) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            isIntersectionSphere: function (e) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            },
            size: function (e) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
            }
        }), no.prototype.setFromMatrix = function (e) {
            return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
        }, Qg.prototype.center = function (e) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        }, (0, We.default)(hr, {
            random16: function () {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            nearestPowerOfTwo: function (e) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), hr.floorPowerOfTwo(e)
            },
            nextPowerOfTwo: function (e) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), hr.ceilPowerOfTwo(e)
            }
        }), (0, We.default)(dr.prototype, {
            flattenToArrayOffset: function (e, t) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            },
            multiplyVector3: function (e) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBufferAttribute: function (e) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), (0, We.default)(Lr.prototype, {
            extractPosition: function (e) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
            },
            flattenToArrayOffset: function (e, t) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            },
            getPosition: function () {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Cr).setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function (e) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
            },
            multiplyToArray: function () {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            multiplyVector4: function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            multiplyVector3Array: function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function (e) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
            },
            crossVector: function (e) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            translate: function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBufferAttribute: function (e) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            },
            applyToVector3Array: function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function (e, t, n, r, i, a) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, a)
            }
        }), wi.prototype.isIntersectionLine = function (e) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
        }, _r.prototype.multiplyVector3 = function (e) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
        }, (0, We.default)(Ai.prototype, {
            isIntersectionBox: function (e) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            },
            isIntersectionPlane: function (e) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
            },
            isIntersectionSphere: function (e) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }
        }), (0, We.default)(Di.prototype, {
            area: function () {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            },
            barycoordFromPoint: function (e, t) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
            },
            midpoint: function (e) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
            },
            normal: function (e) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
            },
            plane: function (e) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
            }
        }), (0, We.default)(Di, {
            barycoordFromPoint: function (e, t, n, r, i) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Di.getBarycoord(e, t, n, r, i)
            },
            normal: function (e, t, n, r) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Di.getNormal(e, t, n, r)
            }
        }), (0, We.default)(Ip.prototype, {
            extractAllPoints: function (e) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
            },
            extrude: function (e) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Gd(this, e)
            },
            makeGeometry: function (e) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Kd(this, e)
            }
        }), (0, We.default)(cr.prototype, {
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            distanceToManhattan: function (e) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), (0, We.default)(Cr.prototype, {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function (e) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
            },
            getScaleFromMatrix: function (e) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
            },
            getColumnFromMatrix: function (e, t) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
            },
            applyProjection: function (e) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
            },
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            distanceToManhattan: function (e) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), (0, We.default)(mr.prototype, {
            fromAttribute: function (e, t, n) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            },
            lengthManhattan: function () {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), (0, We.default)(Ba.prototype, {
            computeTangents: function () {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function () {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            },
            applyMatrix: function (e) {
                return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), (0, We.default)(Xr.prototype, {
            getChildByName: function (e) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
            },
            renderDepth: function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function (e, t) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
            },
            getWorldRotation: function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            },
            applyMatrix: function (e) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), (0, l.default)(Xr.prototype, {
            eulerOrder: {
                get: function () {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function (e) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                }
            },
            useQuaternion: {
                get: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), (0, We.default)(Na.prototype, {
            setDrawMode: function () {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }), (0, l.default)(Na.prototype, {
            drawMode: {
                get: function () {
                    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), An
                },
                set: function () {
                    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }
        }), (0, l.default)(uc.prototype, {
            objects: {
                get: function () {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), (0, y.default)(fc.prototype, "useVertexTexture", {
            get: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function () {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), hc.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, (0, y.default)(Xf.prototype, "__arcLengthDivisions", {
            get: function () {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function (e) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
            }
        }), Xa.prototype.setLens = function (e, t) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
        }, (0, l.default)(wp.prototype, {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                }
            },
            shadowCameraLeft: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                }
            },
            shadowCameraRight: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                }
            },
            shadowCameraTop: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                }
            },
            shadowCameraBottom: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                }
            },
            shadowCameraNear: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                }
            },
            shadowCameraFar: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                }
            },
            shadowCameraVisible: {
                set: function () {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                }
            },
            shadowDarkness: {
                set: function () {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                }
            },
            shadowMapHeight: {
                set: function (e) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                }
            }
        }), (0, l.default)(Xi.prototype, {
            length: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            },
            dynamic: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Qn
                },
                set: function () {
                    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Qn)
                }
            }
        }), (0, We.default)(Xi.prototype, {
            setDynamic: function (e) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Qn : Kn), this
            },
            copyIndicesArray: function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            },
            setArray: function () {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }
        }), (0, We.default)(fa.prototype, {
            addIndex: function (e) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
            },
            addAttribute: function (e, t, n) {
                return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Xi(arguments[1], n)))
            },
            addDrawCall: function (e, t, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
            },
            clearDrawCalls: function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function () {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            },
            removeAttribute: function (e) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
            },
            applyMatrix: function (e) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }
        }), (0, l.default)(fa.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function () {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), (0, l.default)(Hg.prototype, {
            linePrecision: {
                get: function () {
                    return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                },
                set: function (e) {
                    console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e
                }
            }
        }), (0, l.default)(Vh.prototype, {
            dynamic: {
                get: function () {
                    return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === Qn
                },
                set: function (e) {
                    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e)
                }
            }
        }), (0, We.default)(Vh.prototype, {
            setDynamic: function (e) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Qn : Kn), this
            },
            setArray: function () {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }
        }), (0, We.default)(Ud.prototype, {
            getArrays: function () {
                console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
            },
            addShapeList: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
            },
            addShape: function () {
                console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
            }
        }), (0, l.default)(zg.prototype, {
            dynamic: {
                set: function () {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function () {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), (0, l.default)(ji.prototype, {
            wrapAround: {
                get: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function () {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function () {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function () {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new Gi
                }
            },
            shading: {
                get: function () {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function (e) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === L
                }
            },
            stencilMask: {
                get: function () {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function (e) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                }
            }
        }), (0, l.default)(ff.prototype, {
            metal: {
                get: function () {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function () {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), (0, l.default)(Ya.prototype, {
            derivatives: {
                get: function () {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function (e) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                }
            }
        }), (0, We.default)(Gh.prototype, {
            clearTarget: function (e, t, n, r) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r)
            },
            animate: function (e) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
            },
            getCurrentRenderTarget: function () {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            getMaxAnisotropy: function () {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function () {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            },
            resetGLState: function () {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            },
            supportsFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function (e) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
            },
            initMaterial: function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            },
            setFaceCulling: function () {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            },
            allocTextureUnit: function () {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            },
            setTexture: function () {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            },
            setTexture2D: function () {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            },
            setTextureCube: function () {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            },
            getActiveMipMapLevel: function () {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }
        }), (0, l.default)(Gh.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                }
            },
            shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                }
            },
            shadowMapCullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            },
            vr: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                }
            },
            gammaInput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                }
            },
            gammaOutput: {
                get: function () {
                    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? wn : In
                }
            }
        }), (0, l.default)(Rh.prototype, {
            cullFace: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function () {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), (0, l.default)(vr.prototype, {
            wrapS: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                }
            },
            wrapT: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                }
            },
            magFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                }
            },
            minFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                }
            },
            anisotropy: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                }
            },
            offset: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                }
            },
            repeat: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                }
            },
            format: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                }
            },
            type: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                }
            },
            generateMipmaps: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function (e) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                }
            }
        }), (0, l.default)(pg.prototype, {
            load: {
                value: function (e) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    var t = this,
                        n = new eg;
                    return n.load(e, function (e) {
                        t.setBuffer(e)
                    }), this
                }
            },
            startTime: {
                set: function () {
                    console.warn("THREE.Audio: .startTime is now .play( delay ).")
                }
            }
        }), Ag.prototype.getData = function () {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Ka.prototype.updateCubeMap = function (e, t) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
        };
        var Jv = {
            merge: function (e, t, n) {
                var r;
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry), e.merge(t, r, n)
            },
            center: function (e) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
            }
        };

        function Kv() {
            console.error("THREE.CanvasRenderer has been removed")
        }

        function Qv() {
            console.error("THREE.JSONLoader has been removed.")
        }
        t.GeometryUtils = Jv, fr.crossOrigin = void 0, fr.loadTexture = function (e, t, n, r) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var i = new qf;
            i.setCrossOrigin(this.crossOrigin);
            var a = i.load(e, n, void 0, r);
            return t && (a.mapping = t), a
        }, fr.loadTextureCube = function (e, t, n, r) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var i = new Yf;
            i.setCrossOrigin(this.crossOrigin);
            var a = i.load(e, n, void 0, r);
            return t && (a.mapping = t), a
        }, fr.loadCompressedTexture = function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, fr.loadCompressedTextureCube = function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        };
        var $v = {
            createMultiMaterialObject: function () {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            },
            detach: function () {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            },
            attach: function () {
                console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
            }
        };

        function ey() {
            console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
        }
        t.SceneUtils = $v, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: x
            }
        }))
    }, function (e) {
        var t = e.exports = {
            version: "2.6.11"
        };
        "number" == typeof __e && (__e = t)
    }, function (e) {
        e.exports = function (e, t) {
            return {
                enumerable: !(1 & e),
                configurable: !(2 & e),
                writable: !(4 & e),
                value: t
            }
        }
    }, function (e) {
        e.exports = !1
    }, function (e, t, n) {
        var a = n(119);
        e.exports = function (r, i, e) {
            if (a(r), void 0 === i) return r;
            switch (e) {
                case 1:
                    return function (e) {
                        return r.call(i, e)
                    };
                case 2:
                    return function (e, t) {
                        return r.call(i, e, t)
                    };
                case 3:
                    return function (e, t, n) {
                        return r.call(i, e, t, n)
                    }
            }
            return function () {
                return r.apply(i, arguments)
            }
        }
    }, function (e, t, n) {
        var r = n(121),
            i = n(51);
        e.exports = function (e) {
            return r(i(e))
        }
    }, function (e, t, n) {
        var r = n(162),
            i = n(123).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function (e) {
            return r(e, i)
        }
    }, function (e, t, n) {
        var r = n(46),
            i = Math.max,
            a = Math.min;
        e.exports = function (e, t) {
            return e = r(e), e < 0 ? i(e + t, 0) : a(e, t)
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(30);
        e.exports = function () {
            var e = r(this),
                t = "";
            return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.unicode && (t += "u"), e.sticky && (t += "y"), t
        }
    }, function (e) {
        e.exports = function (e) {
            if (null == e) throw TypeError("Can't call method on  " + e);
            return e
        }
    }, function (e, t, a) {
        var r = a(29),
            i = a(167),
            o = a(130),
            s = a(128)("IE_PROTO"),
            l = function () {},
            u = "prototype",
            h = function () {
                var e, t = a(116)("iframe"),
                    n = o.length,
                    r = "<",
                    i = ">";
                for (t.style.display = "none", a(169).appendChild(t), t.src = "javascript:", e = t.contentWindow.document, e.open(), e.write(r + "script" + i + "document.F=Object" + r + "/script" + i), e.close(), h = e.F; n--;) delete h[u][o[n]];
                return h()
            };
        e.exports = Object.create || function (e, t) {
            var n;
            return null !== e ? (l[u] = r(e), n = new l, l[u] = null, n[s] = e) : n = h(), void 0 === t ? n : i(n, t)
        }
    }, function (e, t, n) {
        var r = n(124),
            i = Math.min;
        e.exports = function (e) {
            return 0 < e ? i(r(e), 9007199254740991) : 0
        }
    }, function (e) {
        var t = 0,
            n = Math.random();
        e.exports = function (e) {
            return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++t + n).toString(36))
        }
    }, function (e, t, n) {
        var i = n(77),
            a = n(19)("toStringTag"),
            o = "Arguments" == i(function () {
                return arguments
            }()),
            s = function (e, t) {
                try {
                    return e[t]
                } catch (e) {}
            };
        e.exports = function (e) {
            var t, n, r;
            return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = s(t = Object(e), a)) ? n : o ? i(t) : "Object" == (r = i(t)) && "function" == typeof t.callee ? "Arguments" : r
        }
    }, function (e, t, n) {
        "use strict";
        var i = n(97),
            a = RegExp.prototype.exec;
        e.exports = function (e, t) {
            var n = e.exec;
            if ("function" == typeof n) {
                var r = n.call(e, t);
                if ("object" != typeof r) throw new TypeError("RegExp exec method returned something other than an Object or null");
                return r
            }
            if ("RegExp" !== i(e)) throw new TypeError("RegExp#exec called on incompatible receiver");
            return a.call(e, t)
        }
    }, function (e, t, n) {
        var i = n(74),
            a = n(15)("toStringTag"),
            o = "Arguments" == i(function () {
                return arguments
            }()),
            s = function (e, t) {
                try {
                    return e[t]
                } catch (e) {}
            };
        e.exports = function (e) {
            var t, n, r;
            return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (n = s(t = Object(e), a)) ? n : o ? i(t) : "Object" == (r = i(t)) && "function" == typeof t.callee ? "Arguments" : r
        }
    }, function (e, t, n) {
        "use strict";
        n(271);
        var h = n(38),
            c = n(32),
            d = n(18),
            f = n(51),
            p = n(15),
            g = n(132),
            m = p("species"),
            v = !d(function () {
                var e = /./;
                return e.exec = function () {
                    var e = [];
                    return e.groups = {
                        a: "7"
                    }, e
                }, "7" !== "".replace(e, "$<a>")
            }),
            y = function () {
                var e = /(?:)/,
                    t = e.exec;
                e.exec = function () {
                    return t.apply(this, arguments)
                };
                var n = "ab".split(e);
                return 2 === n.length && "a" === n[0] && "b" === n[1]
            }();
        e.exports = function (n, e, t) {
            var r = p(n),
                a = !d(function () {
                    var e = {};
                    return e[r] = function () {
                        return 7
                    }, 7 != "" [n](e)
                }),
                i = a ? !d(function () {
                    var e = !1,
                        t = /a/;
                    return t.exec = function () {
                        return e = !0, null
                    }, "split" === n && (t.constructor = {}, t.constructor[m] = function () {
                        return t
                    }), t[r](""), !e
                }) : void 0;
            if (!a || !i || "replace" === n && !v || "split" === n && !y) {
                var o = /./ [r],
                    s = t(f, r, "" [n], function (e, t, n, r, i) {
                        return t.exec === g ? a && !i ? {
                            done: !0,
                            value: o.call(t, n, r)
                        } : {
                            done: !0,
                            value: e.call(n, t, r)
                        } : {
                            done: !1
                        }
                    }),
                    l = s[0],
                    u = s[1];
                h(String.prototype, n, l), c(RegExp.prototype, r, 2 == e ? function (e, t) {
                    return u.call(e, this, t)
                } : function (e) {
                    return u.call(e, this)
                })
            }
        }
    }, function (e, t, n) {
        for (var r = n(62), i = n(134), a = n(38), o = n(24), s = n(32), l = n(63), u = n(15), h = u("iterator"), c = u("toStringTag"), d = l.Array, f = {
                CSSRuleList: !0,
                CSSStyleDeclaration: !1,
                CSSValueList: !1,
                ClientRectList: !1,
                DOMRectList: !1,
                DOMStringList: !1,
                DOMTokenList: !0,
                DataTransferItemList: !1,
                FileList: !1,
                HTMLAllCollection: !1,
                HTMLCollection: !1,
                HTMLFormElement: !1,
                HTMLSelectElement: !1,
                MediaList: !0,
                MimeTypeArray: !1,
                NamedNodeMap: !1,
                NodeList: !0,
                PaintRequestList: !1,
                Plugin: !1,
                PluginArray: !1,
                SVGLengthList: !1,
                SVGNumberList: !1,
                SVGPathSegList: !1,
                SVGPointList: !1,
                SVGStringList: !1,
                SVGTransformList: !1,
                SourceBufferList: !1,
                StyleSheetList: !0,
                TextTrackCueList: !1,
                TextTrackList: !1,
                TouchList: !1
            }, p = i(f), g = 0; g < p.length; g++) {
            var m, v = p[g],
                y = f[v],
                _ = o[v],
                A = _ && _.prototype;
            if (A && (A[h] || s(A, h, d), A[c] || s(A, c, v), l[v] = d, y))
                for (m in r) A[m] || a(A, m, r[m], !0)
        }
    }, function (e, t) {
        t.f = {}.propertyIsEnumerable
    }, function () {}, function (e, t, n) {
        var i = n(43);
        e.exports = function (e, t, n) {
            for (var r in t) n && e[r] ? e[r] = t[r] : i(e, r, t[r]);
            return e
        }
    }, function (e) {
        e.exports = function (e, t, n, r) {
            if (!(e instanceof t) || void 0 !== r && r in e) throw TypeError(n + ": incorrect invocation!");
            return e
        }
    }, function (e) {
        function t(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }
        e.exports = t
    }, function (e, t, n) {
        e.exports = n(337)
    }, function (e, t, n) {
        var r = n(22),
            i = n(18),
            o = n(51),
            s = /"/g,
            a = function (e, t, n, r) {
                var i = String(o(e)),
                    a = "<" + t;
                return "" !== n && (a += " " + n + '="' + String(r).replace(s, "&quot;") + '"'), a + ">" + i + "</" + t + ">"
            };
        e.exports = function (t, e) {
            var n = {};
            n[t] = e(a), r(r.P + r.F * i(function () {
                var e = "" [t]('"');
                return e !== e.toLowerCase() || 3 < e.split('"').length
            }), "String", n)
        }
    }, function (e, t, n) {
        e.exports = n(341)
    }, function (e, t, n) {
        "use strict";
        n(348);
        var r = n(30),
            i = n(90),
            a = n(23),
            o = "toString",
            s = /./ [o],
            l = function (e) {
                n(38)(RegExp.prototype, o, e, !0)
            };
        n(18)(function () {
            return "/a/b" != s.call({
                source: "a",
                flags: "b"
            })
        }) ? l(function () {
            var e = r(this);
            return "/".concat(e.source, "/", "flags" in e ? e.flags : !a && e instanceof RegExp ? i.call(e) : void 0)
        }) : s.name != o && l(function () {
            return s.call(this)
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = "https://console.fengmap.com/api-s/",
            a = i;
        t.default = a
    }, function (e, t, n) {
        var r = n(22);
        r(r.P, "Array", {
            fill: n(143)
        }), n(175)("fill")
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.netArea = t.LayerOrder = t.Prop2Alias = t.AliasLayerMap = t.LayerAlias = void 0;
        var a = r(n(181)),
            o = r(n(210)),
            s = r(n(383)),
            l = r(n(384)),
            u = r(n(213)),
            h = r(n(215)),
            c = r(n(217)),
            d = r(n(218)),
            f = r(n(219)),
            p = r(n(221)),
            g = r(n(389)),
            m = r(n(222)),
            v = r(n(391)),
            y = r(n(224)),
            _ = r(n(225)),
            A = r(n(392)),
            x = r(n(226)),
            C = r(n(227)),
            I = ["extent", "model", "label", "facility", "line", "locationMarker", "text", "textMarker", "polygonMarker", "gradientPolygonMarker", "extrudeMarker", "imageMarker", "stair", "externalModel", "heatmap", "dynmodel", "symbol", "domMarker", "waterMarker", "flmMarker"];
        t.LayerAlias = I;
        var w = new a.default;
        t.AliasLayerMap = w, w.set("extent", o.default), w.set("externalModel", s.default), w.set("model", l.default), w.set("label", u.default), w.set("facility", h.default), w.set("imageMarker", c.default), w.set("polygonMarker", d.default), w.set("gradientPolygonMarker", f.default), w.set("extrudeMarker", C.default), w.set("textMarker", p.default), w.set("stair", g.default), w.set("heatmap", m.default), w.set("symbol", v.default), w.set("domMarker", y.default), w.set("dynmodel", _.default), w.set("waterMarker", A.default), w.set("flmMarker", x.default);
        var M = {
            extentLayer: "extent",
            externalModelLayer: "externalModel",
            labelLayer: "label",
            modelLayer: "model",
            poiLayer: "facility",
            stairLayer: "stair"
        };
        t.Prop2Alias = M;
        var b = {
            extent: 0,
            line: 2,
            model: 1,
            externalModel: .5,
            heatmap: 3,
            polygonMarker: 3,
            gradientPolygonMarker: 3,
            extrudeMarker: 3,
            location: 4,
            facility: 3.5,
            label: 4,
            imageMarker: 4,
            textMarker: 4,
            domMarker: 4,
            waterMarker: 3,
            dynmodel: .5,
            flmMarker: 2
        };
        t.LayerOrder = b;
        var S = "https://www.fengmap.com/";
        t.netArea = S
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = function (e) {
                function t(e) {
                    return (0, a.default)(this, t), (0, s.default)(this, (0, l.default)(t).call(this, e))
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "raycast",
                    value: function (o, e) {
                        var c = this,
                            d = new fm.Vector3,
                            f = new fm.Vector3,
                            p = new fm.Vector3,
                            s = new fm.Vector2,
                            l = new fm.Vector2,
                            g = new fm.Matrix4,
                            m = new fm.Vector3,
                            v = new fm.Vector3,
                            y = new fm.Vector3,
                            _ = new fm.Vector2,
                            A = new fm.Vector2,
                            x = new fm.Vector2,
                            u = new fm.Vector4,
                            C = function (e, t, n, r, i, a) {
                                s.subVectors(e, n).addScalar(.5).multiply(r), o.perspective && !c.material.sizeAttenuation && (u.applyMatrix4(c.modelViewMatrix), s.multiplyScalar(Math.abs(u.z))), void 0 !== i ? (l.x = a * s.x - i * s.y, l.y = i * s.x + a * s.y) : l.copy(s), e.copy(t), e.x += l.x, e.y += l.y, e.applyMatrix4(g)
                            };
                        ! function (e, t) {
                            f.setFromMatrixScale(c.matrixWorld), g.getInverse(c.modelViewMatrix).premultiply(c.matrixWorld), p.setFromMatrixPosition(c.modelViewMatrix);
                            var n, r, i = c.material.rotation;
                            0 !== i && (r = Math.cos(i), n = Math.sin(i));
                            var a = c.center;
                            C(m.set(-.5, -.5, 0), p, a, f, n, r), C(v.set(.5, -.5, 0), p, a, f, n, r), C(y.set(.5, .5, 0), p, a, f, n, r), _.set(0, 0), A.set(1, 0), x.set(1, 1);
                            var o = e.ray.intersectTriangle(m, v, y, !1, d);
                            if (null !== o || (C(v.set(-.5, .5, 0), p, a, f, n, r), A.set(0, 1), o = e.ray.intersectTriangle(m, y, v, !1, d), null !== o)) {
                                var s = m.clone().project(e.camera),
                                    l = v.clone().project(e.camera),
                                    u = y.clone().project(e.camera);
                                if (!((s.x < -1 || 1 < s.x || s.y < -1 || 1 < s.y) && (l.x < -1 || 1 < l.x || l.y < -1 || 1 < l.y) && (u.x < -1 || 1 < u.x || u.y < -1 || 1 < u.y))) {
                                    var h = e.ray.origin.distanceTo(d);
                                    h < e.near || h > e.far || t.push({
                                        distance: h,
                                        point: d.clone(),
                                        uv: fm.Triangle.getUV(d, m, v, y, _, A, x, new fm.Vector2),
                                        face: null,
                                        object: c
                                    })
                                }
                            }
                        }(o, e)
                    }
                }]), t
            }(fm.Sprite),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        n(106)("anchor", function (t) {
            return function (e) {
                return t(this, "a", "name", e)
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(186)),
            v = (r(n(200)), r(n(238))),
            l = function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, null, [{
                    key: "search",
                    value: function () {}
                }, {
                    key: "drawNaviRoads",
                    value: function (e) {
                        if (e && e._currentSceneId && e.dataManager) {
                            var t = e.dataManager._sceneDecodeData[e._currentSceneId];
                            if (t) {
                                var n = t.floors;
                                if (0 != n.length) {
                                    var r = [{
                                            lineWidth: 1,
                                            alpha: 1,
                                            lineType: fengmap.FMLineType.FULL,
                                            color: "#00FFFF"
                                        }, {
                                            lineWidth: 1,
                                            alpha: 1,
                                            lineType: fengmap.FMLineType.FULL,
                                            color: "#00FF00"
                                        }, {
                                            lineWidth: 1,
                                            alpha: 1,
                                            lineType: fengmap.FMLineType.FULL,
                                            color: "#FF00FF"
                                        }, {
                                            lineWidth: 1,
                                            alpha: 1,
                                            lineType: fengmap.FMLineType.FULL,
                                            color: "#FF0000"
                                        }],
                                        i = 1,
                                        a = [];
                                    for (var o in n) {
                                        var s = n[o].gid;
                                        if (null != s) {
                                            var l = n[o].geo[0],
                                                u = n[o].biz[0],
                                                h = n[o].navi[0],
                                                c = new v.default({});
                                            c._scene = t;
                                            var d = c.convertToGroup(s, l, u, h);
                                            for (var f in d.naviSegments) {
                                                var p = d.naviSegments[f];
                                                if (p.geoArr) {
                                                    var g = new fengmap.FMLineMarker,
                                                        m = new fengmap.FMSegment;
                                                    m.groupId = s, m.points = p.geoArr, m.points.forEach(function (e) {
                                                        e.z = i
                                                    }), g.addSegment(m), e.drawLineMark(g, r[p.entry]), a.push(g)
                                                }
                                            }
                                        }
                                    }
                                    return a
                                }
                            }
                        }
                    }
                }, {
                    key: "convertPointCoordsByCenter",
                    value: function (e, t) {
                        return e.x = e.x - t.x, e.y = e.y - t.y, void 0 !== e.z && void 0 !== t.z && (e.z = e.z - t.z), e
                    }
                }, {
                    key: "convertPointsCoordsByCenter",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) this.convertPointCoordsByCenter(e[n], t);
                        return e
                    }
                }]), e
            }();
        (0, s.default)(l, "getLayerByAlias", function (e, t, n, r) {
            var i = e.getFMGroup(t);
            if (i && i.layers) {
                n = [].concat(n);
                for (var a = [], o = 0; o < i.layers.length; o++) {
                    var s = i.layers[o];
                    if (s._type_) - 1 < n.indexOf(s._type_) && (r && r(s, s._type_) && o--, a.push(s));
                    else
                        for (var l = 0; l < n.length; l++) {
                            var u = n[l];
                            fengmap.Map.layerAlias[u] && s instanceof fengmap.Map.layerAlias[u] && (r && r(s, u) && o--, a.push(s))
                        }
                }
                return 0 == a.length ? null : 1 == a.length ? a[0] : a
            }
        });
        var u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11));
        n(25);
        var o = r(n(2)),
            s = r(n(3)),
            l = function () {
                function i() {
                    (0, o.default)(this, i)
                }
                return (0, s.default)(i, null, [{
                    key: "createShape",
                    value: function (e, t) {
                        var n = new fm.Shape;
                        n.moveTo(e[0].x, e[0].y);
                        for (var r = 1; r < e.length; r++) n.lineTo(e[r].x, e[r].y);
                        return t && n.lineTo(e[0].x, e[0].y), n
                    }
                }, {
                    key: "createReactShape",
                    value: function (e, t) {
                        var n = new fm.Shape,
                            r = t / 2,
                            i = e / 2;
                        return n.moveTo(-i, -r), n.lineTo(-i, r), n.lineTo(i, r), n.lineTo(i, -r), n
                    }
                }, {
                    key: "createCircleShape",
                    value: function (e) {
                        var t = new fm.Shape;
                        return t.absarc(0, 0, e, 0, 2 * Math.PI, !1), t
                    }
                }, {
                    key: "createExtrudeBufferGeometry",
                    value: function (e, t) {
                        var n = {
                            steps: 1,
                            depth: t.depth,
                            bevelEnabled: !1,
                            bevelThickness: 0,
                            bevelSize: 0,
                            bevelOffset: 0,
                            bevelSegments: 1
                        };
                        return new fm.ExtrudeBufferGeometry(e, n)
                    }
                }, {
                    key: "createPointsExtrudeBufferGeometry",
                    value: function (e, t) {
                        var n = i.createShape(e, !0);
                        return this.createExtrudeBufferGeometry(n, t)
                    }
                }, {
                    key: "createReactExtrudeBufferGeometry",
                    value: function (e, t, n) {
                        var r = i.createReactShape(e, t);
                        return this.createExtrudeBufferGeometry(r, n)
                    }
                }, {
                    key: "createCircleExtrudeBufferGeometry",
                    value: function (e, t, n) {
                        var r = i.createCircleShape(e, t);
                        return this.createExtrudeBufferGeometry(r, n)
                    }
                }, {
                    key: "createShapeBufferGeometry",
                    value: function (e) {
                        var t = i.createShape(e);
                        return new fm.ShapeBufferGeometry(t)
                    }
                }, {
                    key: "createShapeBufferGeometryByCenter",
                    value: function (e, t) {
                        var n = new fm.Shape;
                        n.moveTo(e[0].x - t.x, -e[0].y + t.y);
                        for (var r = 1; r < e.length; r++) n.lineTo(e[r].x - t.x, -e[r].y + t.y);
                        return n.lineTo(e[0].x - t.x, -e[0].y + t.y), new fm.ShapeBufferGeometry(n)
                    }
                }, {
                    key: "createCenterBufferGeometry",
                    value: function (e, t) {
                        for (var n = [], r = 0; r < e.length - 1; r++)
                            for (var i = 2; i < 10; i += 2) n.push({
                                x: e[r].x + (e[r + 1].x - e[r].x) * i * .1,
                                y: e[r].y + (e[r + 1].y - e[r].y) * i * .1,
                                z: e[r].z + (e[r + 1].z - e[r].z) * i * .1
                            });
                        n.push({
                            x: n[0].x,
                            y: n[0].y,
                            z: n[0].z
                        });
                        for (var a = new fm.BufferGeometry, o = [], s = [], l = 0; l < n.length - 1; l++) o.push(n[l].x), o.push(n[l].y), o.push(n[l].z), o.push(n[l + 1].x), o.push(n[l + 1].y), o.push(n[l + 1].z), o.push(t.x), o.push(t.y), o.push(t.z), s.push(0, 0, 1);
                        var u = new Float32Array(o);
                        return a.setAttribute("position", new fm.Float32BufferAttribute(u, 3)), a.setAttribute("gradientAlpha", new fm.Float32BufferAttribute(s, 1)), a
                    }
                }, {
                    key: "scalePoints",
                    value: function (e, t, n) {
                        for (var r = [], i = 0; i < e.length; i++) {
                            var a = e[i].x,
                                o = e[i].y,
                                s = e[i].z;
                            r.push({
                                x: a + (a - t.x) * (n - 1),
                                y: o + (o - t.y) * (n - 1),
                                z: s
                            })
                        }
                        return r
                    }
                }, {
                    key: "scaleValuePoints",
                    value: function (e, t, n) {
                        for (var r = [], i = 0; i < e.length; i++) {
                            var a = {
                                x: e[i].x,
                                y: e[i].y,
                                z: e[i].z
                            };
                            a.x - t.x < 0 ? a.x -= n : a.x += n, a.y - t.y < 0 ? a.y -= n : a.y += n, r.push(a)
                        }
                        return r
                    }
                }, {
                    key: "closedPoints",
                    value: function (e) {
                        var t = e.length;
                        return !(t < 3 || (e[0].x === e[t - 1].x && e[0].y === e[t - 1].y || (e[t] = {}, (0, a.default)(e[t], e[0])), 0))
                    }
                }]), i
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        var r = n(17),
            i = n(14).document,
            a = r(i) && r(i.createElement);
        e.exports = function (e) {
            return a ? i.createElement(e) : {}
        }
    }, function (e, t, n) {
        var i = n(17);
        e.exports = function (e, t) {
            if (!i(e)) return e;
            var n, r;
            if (t && "function" == typeof (n = e.toString) && !i(r = n.call(e))) return r;
            if ("function" == typeof (n = e.valueOf) && !i(r = n.call(e))) return r;
            if (!t && "function" == typeof (n = e.toString) && !i(r = n.call(e))) return r;
            throw TypeError("Can't convert object to primitive value")
        }
    }, function (e, t, n) {
        var r = n(83),
            i = n(24),
            a = "__core-js_shared__",
            o = i[a] || (i[a] = {});
        (e.exports = function (e, t) {
            return o[e] || (o[e] = void 0 !== t ? t : {})
        })("versions", []).push({
            version: r.version,
            mode: n(85) ? "pure" : "global",
            copyright: " 2019 Denis Pushkarev (zloirock.ru)"
        })
    }, function (e) {
        e.exports = function (e) {
            if ("function" != typeof e) throw TypeError(e + " is not a function!");
            return e
        }
    }, function (e, t, n) {
        var r = n(161),
            i = n(84),
            a = n(87),
            o = n(72),
            s = n(50),
            l = n(158),
            u = Object.getOwnPropertyDescriptor;
        t.f = n(23) ? u : function (e, t) {
            if (e = a(e), t = o(t, !0), l) try {
                return u(e, t)
            } catch (e) {}
            if (s(e, t)) return i(!r.f.call(e, t), e[t])
        }
    }, function (e, t, n) {
        var r = n(74);
        e.exports = Object("z").propertyIsEnumerable(0) ? Object : function (e) {
            return "String" == r(e) ? e.split("") : Object(e)
        }
    }, function (e, t, n) {
        var r = n(118)("keys"),
            i = n(73);
        e.exports = function (e) {
            return r[e] || (r[e] = i(e))
        }
    }, function (e) {
        e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, function (e) {
        var t = Math.ceil,
            n = Math.floor;
        e.exports = function (e) {
            return isNaN(e = +e) ? 0 : (0 < e ? n : t)(e)
        }
    }, function (e, t, n) {
        "use strict";
        var _ = n(75),
            A = n(10),
            x = n(126),
            C = n(43),
            I = n(60),
            w = n(265),
            M = n(78),
            b = n(170),
            S = n(19)("iterator"),
            E = !([].keys && "next" in [].keys()),
            T = "@@iterator",
            L = "keys",
            N = "values",
            R = function () {
                return this
            };
        e.exports = function (e, t, n, r, i, a, o) {
            w(n, t, r);
            var s, l, u, h = function (e) {
                    if (!E && e in p) return p[e];
                    switch (e) {
                        case L:
                        case N:
                            return function () {
                                return new n(this, e)
                            }
                    }
                    return function () {
                        return new n(this, e)
                    }
                },
                c = t + " Iterator",
                d = i == N,
                f = !1,
                p = e.prototype,
                g = p[S] || p[T] || i && p[i],
                m = g || h(i),
                v = i ? d ? h("entries") : m : void 0,
                y = "Array" == t && p.entries || g;
            if (y && (u = b(y.call(new e)), u !== Object.prototype && u.next && (M(u, c, !0), _ || "function" == typeof u[S] || C(u, S, R))), d && g && g.name !== N && (f = !0, m = function () {
                    return g.call(this)
                }), _ && !o || !E && !f && p[S] || C(p, S, m), I[t] = m, I[c] = R, i)
                if (s = {
                        values: d ? m : h(N),
                        keys: a ? m : h(L),
                        entries: v
                    }, o)
                    for (l in s) l in p || x(p, l, s[l]);
                else A(A.P + A.F * (E || f), t, s);
            return s
        }
    }, function (e, t, n) {
        e.exports = n(43)
    }, function (e, t, n) {
        var r = n(77);
        e.exports = Object("z").propertyIsEnumerable(0) ? Object : function (e) {
            return "String" == r(e) ? e.split("") : Object(e)
        }
    }, function (e, t, n) {
        var r = n(129)("keys"),
            i = n(94);
        e.exports = function (e) {
            return r[e] || (r[e] = i(e))
        }
    }, function (e, t, n) {
        var r = n(9),
            i = n(14),
            a = "__core-js_shared__",
            o = i[a] || (i[a] = {});
        (e.exports = function (e, t) {
            return o[e] || (o[e] = void 0 !== t ? t : {})
        })("versions", []).push({
            version: r.version,
            mode: n(75) ? "pure" : "global",
            copyright: " 2019 Denis Pushkarev (zloirock.ru)"
        })
    }, function (e) {
        e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, function (e, t, n) {
        var r = n(95),
            i = n(19)("iterator"),
            a = n(60);
        e.exports = n(9).getIteratorMethod = function (e) {
            if (null != e) return e[i] || e["@@iterator"] || a[r(e)]
        }
    }, function (e, t, n) {
        "use strict";
        var r, i, o = n(90),
            s = RegExp.prototype.exec,
            l = String.prototype.replace,
            a = s,
            u = "lastIndex",
            h = (r = /a/, i = /b*/g, s.call(r, "a"), s.call(i, "a"), 0 !== r[u] || 0 !== i[u]),
            c = void 0 !== /()??/.exec("")[1],
            d = h || c;
        d && (a = function (e) {
            var t, n, r, i, a = this;
            return c && (n = new RegExp("^" + a.source + "$(?!\\s)", o.call(a))), h && (t = a[u]), r = s.call(a, e), h && r && (a[u] = a.global ? r.index + r[0].length : t), c && r && 1 < r.length && l.call(r[0], n, function () {
                for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (r[i] = void 0)
            }), r
        }), e.exports = a
    }, function (e, t, a) {
        var r = a(30),
            i = a(274),
            o = a(123),
            s = a(122)("IE_PROTO"),
            l = function () {},
            u = "prototype",
            h = function () {
                var e, t = a(159)("iframe"),
                    n = o.length,
                    r = "<",
                    i = ">";
                for (t.style.display = "none", a(275).appendChild(t), t.src = "javascript:", e = t.contentWindow.document, e.open(), e.write(r + "script" + i + "document.F=Object" + r + "/script" + i), e.close(), h = e.F; n--;) delete h[u][o[n]];
                return h()
            };
        e.exports = Object.create || function (e, t) {
            var n;
            return null !== e ? (l[u] = r(e), n = new l, l[u] = null, n[s] = e) : n = h(), void 0 === t ? n : i(n, t)
        }
    }, function (e, t, n) {
        var r = n(162),
            i = n(123);
        e.exports = Object.keys || function (e) {
            return r(e, i)
        }
    }, function (e, t, n) {
        var r = n(33).f,
            i = n(50),
            a = n(15)("toStringTag");
        e.exports = function (e, t, n) {
            e && !i(e = n ? e : e.prototype, a) && r(e, a, {
                configurable: !0,
                value: t
            })
        }
    }, function (e, t, n) {
        var i = n(10),
            a = n(9),
            o = n(44);
        e.exports = function (e, t) {
            var n = (a.Object || {})[e] || Object[e],
                r = {};
            r[e] = t(n), i(i.S + i.F * o(function () {
                n(1)
            }), "Object", r)
        }
    }, function (e, t, n) {
        t.f = n(19)
    }, function (e, t, n) {
        var r = n(14),
            i = n(9),
            a = n(75),
            o = n(137),
            s = n(28).f;
        e.exports = function (e) {
            var t = i.Symbol || (i.Symbol = a ? {} : r.Symbol || {});
            "_" == e.charAt(0) || e in t || s(t, e, {
                value: o.f(e)
            })
        }
    }, function (e, t) {
        t.f = Object.getOwnPropertySymbols
    }, function (e, t, n) {
        var r = n(77);
        e.exports = Array.isArray || function (e) {
            return "Array" == r(e)
        }
    }, function (e, t, n) {
        var _ = n(36),
            A = n(127),
            x = n(52),
            C = n(93),
            r = n(293);
        e.exports = function (c, e) {
            var d = 1 == c,
                f = 2 == c,
                p = 3 == c,
                g = 4 == c,
                m = 6 == c,
                v = 5 == c || m,
                y = e || r;
            return function (e, t, n) {
                for (var r, i, a = x(e), o = A(a), s = _(t, n, 3), l = C(o.length), u = 0, h = d ? y(e, l) : f ? y(e, 0) : void 0; u < l; u++)
                    if ((v || u in o) && (r = o[u], i = s(r, u, a), c))
                        if (d) h[u] = i;
                        else if (i) switch (c) {
                    case 3:
                        return !0;
                    case 5:
                        return r;
                    case 6:
                        return u;
                    case 2:
                        h.push(r)
                } else if (g) return !1;
                return m ? -1 : p || g ? g : h
            }
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(187)(!0);
        e.exports = function (e, t, n) {
            return t + (n ? r(e, t).length : 1)
        }
    }, function (e, t, n) {
        "use strict";
        var u = n(39),
            h = n(89),
            c = n(34);
        e.exports = function (e, t, n) {
            for (var r = u(this), i = c(r.length), a = arguments.length, o = h(1 < a ? t : void 0, i), s = 2 < a ? n : void 0, l = void 0 === s ? i : h(s, i); o < l;) r[o++] = e;
            return r
        }
    }, function (e, t, n) {
        n(40)("Uint16", 2, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        n(40)("Uint8", 1, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e) {
        e.exports = "\t\n\v\f\r  \u2028\u2029\ufeff"
    }, function (e, t, n) {
        var r = n(22);
        r(r.P, "String", {
            repeat: n(340)
        })
    }, function (e) {
        var n, r, t = e.exports = {};

        function i() {
            throw new Error("setTimeout has not been defined")
        }

        function a() {
            throw new Error("clearTimeout has not been defined")
        }

        function o(t) {
            if (n === setTimeout) return setTimeout(t, 0);
            if ((n === i || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0);
            try {
                return n(t, 0)
            } catch (e) {
                try {
                    return n.call(null, t, 0)
                } catch (e) {
                    return n.call(this, t, 0)
                }
            }
        }

        function s(t) {
            if (r === clearTimeout) return clearTimeout(t);
            if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t);
            try {
                return r(t)
            } catch (e) {
                try {
                    return r.call(null, t)
                } catch (e) {
                    return r.call(this, t)
                }
            }
        }! function () {
            try {
                n = "function" == typeof setTimeout ? setTimeout : i
            } catch (e) {
                n = i
            }
            try {
                r = "function" == typeof clearTimeout ? clearTimeout : a
            } catch (e) {
                r = a
            }
        }();
        var l, u = [],
            h = !1,
            c = -1;

        function d() {
            h && l && (h = !1, l.length ? u = l.concat(u) : c = -1, u.length && f())
        }

        function f() {
            if (!h) {
                var e = o(d);
                h = !0;
                for (var t = u.length; t;) {
                    for (l = u, u = []; ++c < t;) l && l[c].run();
                    c = -1, t = u.length
                }
                l = null, h = !1, s(e)
            }
        }

        function p(e, t) {
            this.fun = e, this.array = t
        }

        function g() {}
        t.nextTick = function (e) {
            var t = new Array(arguments.length - 1);
            if (1 < arguments.length)
                for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            u.push(new p(e, t)), 1 !== u.length || h || o(f)
        }, p.prototype.run = function () {
            this.fun.apply(null, this.array)
        }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", t.versions = {}, t.on = g, t.addListener = g, t.once = g, t.off = g, t.removeListener = g, t.removeAllListeners = g, t.emit = g, t.prependListener = g, t.prependOnceListener = g, t.listeners = function () {
            return []
        }, t.binding = function () {
            throw new Error("process.binding is not supported")
        }, t.cwd = function () {
            return "/"
        }, t.chdir = function () {
            throw new Error("process.chdir is not supported")
        }, t.umask = function () {
            return 0
        }
    }, function (e, ae, oe) {
        "use strict";
        (function (e) {
            var t = oe(1),
                n = oe(0);
            n(ae, "__esModule", {
                value: !0
            }), ae.ProtoBuf = void 0;
            var b = t(oe(105));
            oe(99), oe(62);
            var S = t(oe(54));
            oe(13);
            var E = t(oe(31)),
                T = t(oe(35)),
                h = t(oe(16));
            oe(48), oe(8), oe(110);
            var L = t(oe(47));
            oe(145), oe(55), oe(108), oe(67);
            var N = t(oe(27)),
                R = t(oe(0));

            function l(e, t, n) {
                this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n
            }

            function f(e) {
                return !0 === (e && e.__isLong__)
            }
            l.__isLong__, (0, R.default)(l.prototype, "__isLong__", {
                value: !0,
                enumerable: !1,
                configurable: !1
            }), l.isLong = f;
            var a = {},
                o = {};

            function r(e, t) {
                var n, r, i;
                return t ? (e >>>= 0, (i = 0 <= e && e < 256) && (r = o[e], r) ? r : (n = g(e, (0 | e) < 0 ? -1 : 0, !0), i && (o[e] = n), n)) : (e |= 0, (i = -128 <= e && e < 128) && (r = a[e], r) ? r : (n = g(e, e < 0 ? -1 : 0, !1), i && (a[e] = n), n))
            }

            function p(e, t) {
                if (isNaN(e) || !isFinite(e)) return t ? x : A;
                if (t) {
                    if (e < 0) return x;
                    if (v <= e) return k
                } else {
                    if (e <= -y) return P;
                    if (y <= e + 1) return M
                }
                return e < 0 ? p(-e, t).neg() : g(e % u | 0, e / u | 0, t)
            }

            function g(e, t, n) {
                return new l(e, t, n)
            }
            l.fromInt = r, l.fromNumber = p, l.fromBits = g;
            var c = Math.pow;

            function d(e, t, n) {
                if (0 === e.length) throw Error("empty string");
                if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return A;
                if ("number" == typeof t && (n = t, t = !1), n = n || 10, n < 2 || 36 < n) throw RangeError("radix");
                var r;
                if (0 < (r = e.indexOf("-"))) throw Error("interior hyphen");
                if (0 === r) return d(e.substring(1), t, n).neg();
                for (var i = p(c(n, 8)), a = A, o = 0; o < e.length; o += 8) {
                    var s = Math.min(8, e.length - o),
                        l = (0, N.default)(e.substring(o, o + s), n);
                    if (s < 8) {
                        var u = p(c(n, s));
                        a = a.mul(u).add(p(l))
                    } else a = a.mul(i), a = a.add(p(l))
                }
                return a.unsigned = t, a
            }

            function m(e) {
                return e instanceof l ? e : "number" == typeof e ? p(e) : "string" == typeof e ? d(e) : g(e.low, e.high, e.unsigned)
            }
            l.fromString = d, l.fromValue = m;
            var i = 65536,
                s = 1 << 24,
                u = i * i,
                v = u * u,
                y = v / 2,
                _ = r(s),
                A = r(0);
            l.ZERO = A;
            var x = r(0, !0);
            l.UZERO = x;
            var C = r(1);
            l.ONE = C;
            var I = r(1, !0);
            l.UONE = I;
            var w = r(-1);
            l.NEG_ONE = w;
            var M = g(-1, 2147483647, !1);
            l.MAX_VALUE = M;
            var k = g(-1, -1, !0);
            l.MAX_UNSIGNED_VALUE = k;
            var P = g(0, -2147483648, !1);
            l.MIN_VALUE = P;
            var D = l.prototype;
            D.toInt = function () {
                return this.unsigned ? this.low >>> 0 : this.low
            }, D.toNumber = function () {
                return this.unsigned ? (this.high >>> 0) * u + (this.low >>> 0) : this.high * u + (this.low >>> 0)
            }, D.toString = function (e) {
                if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
                if (this.isZero()) return "0";
                if (this.isNegative()) {
                    if (this.eq(P)) {
                        var t = p(e),
                            n = this.div(t),
                            r = n.mul(t).sub(this);
                        return n.toString(e) + r.toInt().toString(e)
                    }
                    return "-" + this.neg().toString(e)
                }
                for (var i = p(c(e, 6), this.unsigned), a = this, o = "";;) {
                    var s = a.div(i),
                        l = a.sub(s.mul(i)).toInt() >>> 0,
                        u = l.toString(e);
                    if (a = s, a.isZero()) return u + o;
                    for (; u.length < 6;) u = "0" + u;
                    o = "" + u + o
                }
            }, D.getHighBits = function () {
                return this.high
            }, D.getHighBitsUnsigned = function () {
                return this.high >>> 0
            }, D.getLowBits = function () {
                return this.low
            }, D.getLowBitsUnsigned = function () {
                return this.low >>> 0
            }, D.getNumBitsAbs = function () {
                if (this.isNegative()) return this.eq(P) ? 64 : this.neg().getNumBitsAbs();
                for (var e = 0 != this.high ? this.high : this.low, t = 31; 0 < t && 0 == (e & 1 << t); t--);
                return 0 != this.high ? t + 33 : t + 1
            }, D.isZero = function () {
                return 0 === this.high && 0 === this.low
            }, D.isNegative = function () {
                return !this.unsigned && this.high < 0
            }, D.isPositive = function () {
                return this.unsigned || 0 <= this.high
            }, D.isOdd = function () {
                return 1 == (1 & this.low)
            }, D.isEven = function () {
                return 0 == (1 & this.low)
            }, D.equals = function (e) {
                return f(e) || (e = m(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low
            }, D.eq = D.equals, D.notEquals = function (e) {
                return !this.eq(e)
            }, D.neq = D.notEquals, D.lessThan = function (e) {
                return this.comp(e) < 0
            }, D.lt = D.lessThan, D.lessThanOrEqual = function (e) {
                return this.comp(e) <= 0
            }, D.lte = D.lessThanOrEqual, D.greaterThan = function (e) {
                return 0 < this.comp(e)
            }, D.gt = D.greaterThan, D.greaterThanOrEqual = function (e) {
                return 0 <= this.comp(e)
            }, D.gte = D.greaterThanOrEqual, D.compare = function (e) {
                if (f(e) || (e = m(e)), this.eq(e)) return 0;
                var t = this.isNegative(),
                    n = e.isNegative();
                return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1
            }, D.comp = D.compare, D.negate = function () {
                return !this.unsigned && this.eq(P) ? P : this.not().add(C)
            }, D.neg = D.negate, D.add = function (e) {
                f(e) || (e = m(e));
                var t = this.high >>> 16,
                    n = 65535 & this.high,
                    r = this.low >>> 16,
                    i = 65535 & this.low,
                    a = e.high >>> 16,
                    o = 65535 & e.high,
                    s = e.low >>> 16,
                    l = 65535 & e.low,
                    u = 0,
                    h = 0,
                    c = 0,
                    d = 0;
                return d += i + l, c += d >>> 16, d &= 65535, c += r + s, h += c >>> 16, c &= 65535, h += n + o, u += h >>> 16, h &= 65535, u += t + a, u &= 65535, g(c << 16 | d, u << 16 | h, this.unsigned)
            }, D.subtract = function (e) {
                return f(e) || (e = m(e)), this.add(e.neg())
            }, D.sub = D.subtract, D.multiply = function (e) {
                if (this.isZero()) return A;
                if (f(e) || (e = m(e)), e.isZero()) return A;
                if (this.eq(P)) return e.isOdd() ? P : A;
                if (e.eq(P)) return this.isOdd() ? P : A;
                if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
                if (e.isNegative()) return this.mul(e.neg()).neg();
                if (this.lt(_) && e.lt(_)) return p(this.toNumber() * e.toNumber(), this.unsigned);
                var t = this.high >>> 16,
                    n = 65535 & this.high,
                    r = this.low >>> 16,
                    i = 65535 & this.low,
                    a = e.high >>> 16,
                    o = 65535 & e.high,
                    s = e.low >>> 16,
                    l = 65535 & e.low,
                    u = 0,
                    h = 0,
                    c = 0,
                    d = 0;
                return d += i * l, c += d >>> 16, d &= 65535, c += r * l, h += c >>> 16, c &= 65535, c += i * s, h += c >>> 16, c &= 65535, h += n * l, u += h >>> 16, h &= 65535, h += r * s, u += h >>> 16, h &= 65535, h += i * o, u += h >>> 16, h &= 65535, u += t * l + n * s + r * o + i * a, u &= 65535, g(c << 16 | d, u << 16 | h, this.unsigned)
            }, D.mul = D.multiply, D.divide = function (e) {
                if (f(e) || (e = m(e)), e.isZero()) throw Error("division by zero");
                if (this.isZero()) return this.unsigned ? x : A;
                var t, n, r;
                if (this.eq(P)) {
                    if (e.eq(C) || e.eq(w)) return P;
                    if (e.eq(P)) return C;
                    var i = this.shr(1);
                    return t = i.div(e).shl(1), t.eq(A) ? e.isNegative() ? C : w : (n = this.sub(e.mul(t)), r = t.add(n.div(e)), r)
                }
                if (e.eq(P)) return this.unsigned ? x : A;
                if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
                if (e.isNegative()) return this.div(e.neg()).neg();
                for (r = A, n = this; n.gte(e);) {
                    t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
                    for (var a = Math.ceil(Math.log(t) / Math.LN2), o = a <= 48 ? 1 : c(2, a - 48), s = p(t), l = s.mul(e); l.isNegative() || l.gt(n);) t -= o, s = p(t, this.unsigned), l = s.mul(e);
                    s.isZero() && (s = C), r = r.add(s), n = n.sub(l)
                }
                return r
            }, D.div = D.divide, D.modulo = function (e) {
                return f(e) || (e = m(e)), this.sub(this.div(e).mul(e))
            }, D.mod = D.modulo, D.not = function () {
                return g(~this.low, ~this.high, this.unsigned)
            }, D.and = function (e) {
                return f(e) || (e = m(e)), g(this.low & e.low, this.high & e.high, this.unsigned)
            }, D.or = function (e) {
                return f(e) || (e = m(e)), g(this.low | e.low, this.high | e.high, this.unsigned)
            }, D.xor = function (e) {
                return f(e) || (e = m(e)), g(this.low ^ e.low, this.high ^ e.high, this.unsigned)
            }, D.shiftLeft = function (e) {
                return f(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? g(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : g(0, this.low << e - 32, this.unsigned)
            }, D.shl = D.shiftLeft, D.shiftRight = function (e) {
                return f(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? g(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : g(this.high >> e - 32, 0 <= this.high ? 0 : -1, this.unsigned)
            }, D.shr = D.shiftRight, D.shiftRightUnsigned = function (e) {
                if (f(e) && (e = e.toInt()), e &= 63, 0 === e) return this;
                var t = this.high;
                if (e < 32) {
                    var n = this.low;
                    return g(n >>> e | t << 32 - e, t >>> e, this.unsigned)
                }
                return g(32 === e ? t : t >>> e - 32, 0, this.unsigned)
            }, D.shru = D.shiftRightUnsigned, D.toSigned = function () {
                return this.unsigned ? g(this.low, this.high, !1) : this
            }, D.toUnsigned = function () {
                return this.unsigned ? this : g(this.low, this.high, !0)
            };
            var O = function e(t, n, r) {
                if (void 0 === t && (t = e.DEFAULT_CAPACITY), void 0 === n && (n = e.DEFAULT_ENDIAN), void 0 === r && (r = e.DEFAULT_NOASSERT), !r) {
                    if (t |= 0, t < 0) throw RangeError("Illegal capacity");
                    n = !!n, r = !!r
                }
                this.buffer = 0 === t ? B : new ArrayBuffer(t), this.view = 0 === t ? null : new Uint8Array(this.buffer), this.offset = 0, this.markedOffset = -1, this.limit = t, this.littleEndian = n, this.noAssert = r
            };
            O.VERSION = "5.0.1", O.LITTLE_ENDIAN = !0, O.BIG_ENDIAN = !1, O.DEFAULT_CAPACITY = 16, O.DEFAULT_ENDIAN = O.BIG_ENDIAN, O.DEFAULT_NOASSERT = !1, O.Long = l || null;
            var F = O.prototype;
            F.__isByteBuffer__, (0, R.default)(F, "__isByteBuffer__", {
                value: !0,
                enumerable: !1,
                configurable: !1
            });
            var B = new ArrayBuffer(0),
                G = String.fromCharCode;

            function U(e) {
                var t = 0;
                return function () {
                    return t < e.length ? e.charCodeAt(t++) : null
                }
            }

            function z() {
                var e = [],
                    t = [];
                return function () {
                    if (0 === arguments.length) return t.join("") + G.apply(String, e);
                    1024 < e.length + arguments.length && (t.push(G.apply(String, e)), e.length = 0), Array.prototype.push.apply(e, arguments)
                }
            }

            function V(e, t, n, r, i) {
                var a, o, s = 8 * i - r - 1,
                    l = (1 << s) - 1,
                    u = l >> 1,
                    h = -7,
                    c = n ? i - 1 : 0,
                    d = n ? -1 : 1,
                    f = e[t + c];
                for (c += d, a = f & (1 << -h) - 1, f >>= -h, h += s; 0 < h; a = 256 * a + e[t + c], c += d, h -= 8);
                for (o = a & (1 << -h) - 1, a >>= -h, h += r; 0 < h; o = 256 * o + e[t + c], c += d, h -= 8);
                if (0 === a) a = 1 - u;
                else {
                    if (a === l) return o ? NaN : Infinity * (f ? -1 : 1);
                    o += Math.pow(2, r), a -= u
                }
                return (f ? -1 : 1) * o * Math.pow(2, a - r)
            }

            function H(e, t, n, r, i, a) {
                var o, s, l, u = 8 * a - i - 1,
                    h = (1 << u) - 1,
                    c = h >> 1,
                    d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    f = r ? 0 : a - 1,
                    p = r ? 1 : -1,
                    g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t), isNaN(t) || Infinity === t ? (s = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), t += 1 <= o + c ? d / l : d * Math.pow(2, 1 - c), 2 <= t * l && (o++, l /= 2), h <= o + c ? (s = 0, o = h) : 1 <= o + c ? (s = (t * l - 1) * Math.pow(2, i), o += c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, i), o = 0)); 8 <= i; e[n + f] = 255 & s, f += p, s /= 256, i -= 8);
                for (o = o << i | s, u += i; 0 < u; e[n + f] = 255 & o, f += p, o /= 256, u -= 8);
                e[n + f - p] |= 128 * g
            }
            O.accessor = function () {
                return Uint8Array
            }, O.allocate = function (e, t, n) {
                return new O(e, t, n)
            }, O.concat = function (e, t, n, r) {
                "boolean" != typeof t && "string" == typeof t || (r = n, n = t, t = void 0);
                for (var i, a = 0, o = 0, s = e.length; o < s; ++o) O.isByteBuffer(e[o]) || (e[o] = O.wrap(e[o], t)), i = e[o].limit - e[o].offset, 0 < i && (a += i);
                if (0 === a) return new O(0, n, r);
                var l, u = new O(a, n, r);
                for (o = 0; o < s;) l = e[o++], i = l.limit - l.offset, i <= 0 || (u.view.set(l.view.subarray(l.offset, l.limit), u.offset), u.offset += i);
                return u.limit = u.offset, u.offset = 0, u
            }, O.isByteBuffer = function (e) {
                return !0 === (e && e.__isByteBuffer__)
            }, O.type = function () {
                return ArrayBuffer
            }, O.wrap = function (e, t, n, r) {
                if ("string" != typeof t && (r = n, n = t, t = void 0), "string" == typeof e) switch (void 0 === t && (t = "utf8"), t) {
                    case "base64":
                        return O.fromBase64(e, n);
                    case "hex":
                        return O.fromHex(e, n);
                    case "binary":
                        return O.fromBinary(e, n);
                    case "utf8":
                        return O.fromUTF8(e, n);
                    case "debug":
                        return O.fromDebug(e, n);
                    default:
                        throw Error("Unsupported encoding: " + t)
                }
                if (null === e || "object" !== (0, L.default)(e)) throw TypeError("Illegal buffer");
                var i;
                if (O.isByteBuffer(e)) return i = F.clone.call(e), i.markedOffset = -1, i;
                if (e instanceof Uint8Array) i = new O(0, n, r), 0 < e.length && (i.buffer = e.buffer, i.offset = e.byteOffset, i.limit = e.byteOffset + e.byteLength, i.view = new Uint8Array(e.buffer));
                else if (e instanceof ArrayBuffer) i = new O(0, n, r), 0 < e.byteLength && (i.buffer = e, i.offset = 0, i.limit = e.byteLength, i.view = 0 < e.byteLength ? new Uint8Array(e) : null);
                else {
                    if ("[object Array]" !== Object.prototype.toString.call(e)) throw TypeError("Illegal buffer");
                    i = new O(e.length, n, r), i.limit = e.length;
                    for (var a = 0; a < e.length; ++a) i.view[a] = e[a]
                }
                return i
            }, F.writeBitSet = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if (!(e instanceof Array)) throw TypeError("Illegal BitSet: Not an array");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                var r, i = t,
                    a = e.length,
                    o = a >> 3,
                    s = 0;
                for (t += this.writeVarint32(a, t); o--;) r = 1 & !!e[s++] | (1 & !!e[s++]) << 1 | (1 & !!e[s++]) << 2 | (1 & !!e[s++]) << 3 | (1 & !!e[s++]) << 4 | (1 & !!e[s++]) << 5 | (1 & !!e[s++]) << 6 | (1 & !!e[s++]) << 7, this.writeByte(r, t++);
                if (s < a) {
                    var l = 0;
                    for (r = 0; s < a;) r |= (1 & !!e[s++]) << l++;
                    this.writeByte(r, t++)
                }
                return n ? (this.offset = t, this) : t - i
            }, F.readBitSet = function (e) {
                var t = void 0 === e;
                t && (e = this.offset);
                var n, r = this.readVarint32(e),
                    i = r.value,
                    a = i >> 3,
                    o = 0,
                    s = [];
                for (e += r.length; a--;) n = this.readByte(e++), s[o++] = !!(1 & n), s[o++] = !!(2 & n), s[o++] = !!(4 & n), s[o++] = !!(8 & n), s[o++] = !!(16 & n), s[o++] = !!(32 & n), s[o++] = !!(64 & n), s[o++] = !!(128 & n);
                if (o < i) {
                    var l = 0;
                    for (n = this.readByte(e++); o < i;) s[o++] = !!(n >> l++ & 1)
                }
                return t && (this.offset = e), s
            }, F.readBytes = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + e > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+" + e + ") <= " + this.buffer.byteLength)
                }
                var r = this.slice(t, t + e);
                return n && (this.offset += e), r
            }, F.writeBytes = F.append, F.writeInt8 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 1;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), --t, this.view[t] = e, n && (this.offset += 1), this
            }, F.writeByte = F.writeInt8, F.readInt8 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n = this.view[e];
                return 128 == (128 & n) && (n = -(255 - n + 1)), t && (this.offset += 1), n
            }, F.readByte = F.readInt8, F.writeUint8 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 1;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), --t, this.view[t] = e, n && (this.offset += 1), this
            }, F.writeUInt8 = F.writeUint8, F.readUint8 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n = this.view[e];
                return t && (this.offset += 1), n
            }, F.readUInt8 = F.readUint8, F.writeInt16 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 2;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 2, this.littleEndian ? (this.view[t + 1] = (65280 & e) >>> 8, this.view[t] = 255 & e) : (this.view[t] = (65280 & e) >>> 8, this.view[t + 1] = 255 & e), n && (this.offset += 2), this
            }, F.writeShort = F.writeInt16, F.readInt16 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+2) <= " + this.buffer.byteLength)
                }
                var n = 0;
                return this.littleEndian ? (n = this.view[e], n |= this.view[e + 1] << 8) : (n = this.view[e] << 8, n |= this.view[e + 1]), 32768 == (32768 & n) && (n = -(65535 - n + 1)), t && (this.offset += 2), n
            }, F.readShort = F.readInt16, F.writeUint16 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 2;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 2, this.littleEndian ? (this.view[t + 1] = (65280 & e) >>> 8, this.view[t] = 255 & e) : (this.view[t] = (65280 & e) >>> 8, this.view[t + 1] = 255 & e), n && (this.offset += 2), this
            }, F.writeUInt16 = F.writeUint16, F.readUint16 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+2) <= " + this.buffer.byteLength)
                }
                var n = 0;
                return this.littleEndian ? (n = this.view[e], n |= this.view[e + 1] << 8) : (n = this.view[e] << 8, n |= this.view[e + 1]), t && (this.offset += 2), n
            }, F.readUInt16 = F.readUint16, F.writeInt32 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 4;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 4, this.littleEndian ? (this.view[t + 3] = e >>> 24 & 255, this.view[t + 2] = e >>> 16 & 255, this.view[t + 1] = e >>> 8 & 255, this.view[t] = 255 & e) : (this.view[t] = e >>> 24 & 255, this.view[t + 1] = e >>> 16 & 255, this.view[t + 2] = e >>> 8 & 255, this.view[t + 3] = 255 & e), n && (this.offset += 4), this
            }, F.writeInt = F.writeInt32, F.readInt32 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+4) <= " + this.buffer.byteLength)
                }
                var n = 0;
                return this.littleEndian ? (n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0) : (n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0), n |= 0, t && (this.offset += 4), n
            }, F.readInt = F.readInt32, F.writeUint32 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 4;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 4, this.littleEndian ? (this.view[t + 3] = e >>> 24 & 255, this.view[t + 2] = e >>> 16 & 255, this.view[t + 1] = e >>> 8 & 255, this.view[t] = 255 & e) : (this.view[t] = e >>> 24 & 255, this.view[t + 1] = e >>> 16 & 255, this.view[t + 2] = e >>> 8 & 255, this.view[t + 3] = 255 & e), n && (this.offset += 4), this
            }, F.writeUInt32 = F.writeUint32, F.readUint32 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+4) <= " + this.buffer.byteLength)
                }
                var n = 0;
                return this.littleEndian ? (n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0) : (n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0), t && (this.offset += 4), n
            }, F.readUInt32 = F.readUint32, l && (F.writeInt64 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" == typeof e) e = l.fromNumber(e);
                    else if ("string" == typeof e) e = l.fromString(e);
                    else if (!(e && e instanceof l)) throw TypeError("Illegal value: " + e + " (not an integer or Long)");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                "number" == typeof e ? e = l.fromNumber(e) : "string" == typeof e && (e = l.fromString(e)), t += 8;
                var r = this.buffer.byteLength;
                r < t && this.resize((r *= 2) > t ? r : t), t -= 8;
                var i = e.low,
                    a = e.high;
                return this.littleEndian ? (this.view[t + 3] = i >>> 24 & 255, this.view[t + 2] = i >>> 16 & 255, this.view[t + 1] = i >>> 8 & 255, this.view[t] = 255 & i, t += 4, this.view[t + 3] = a >>> 24 & 255, this.view[t + 2] = a >>> 16 & 255, this.view[t + 1] = a >>> 8 & 255, this.view[t] = 255 & a) : (this.view[t] = a >>> 24 & 255, this.view[t + 1] = a >>> 16 & 255, this.view[t + 2] = a >>> 8 & 255, this.view[t + 3] = 255 & a, t += 4, this.view[t] = i >>> 24 & 255, this.view[t + 1] = i >>> 16 & 255, this.view[t + 2] = i >>> 8 & 255, this.view[t + 3] = 255 & i), n && (this.offset += 8), this
            }, F.writeLong = F.writeInt64, F.readInt64 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+8) <= " + this.buffer.byteLength)
                }
                var n = 0,
                    r = 0;
                this.littleEndian ? (n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0, e += 4, r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0) : (r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0, e += 4, n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0);
                var i = new l(n, r, !1);
                return t && (this.offset += 8), i
            }, F.readLong = F.readInt64, F.writeUint64 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" == typeof e) e = l.fromNumber(e);
                    else if ("string" == typeof e) e = l.fromString(e);
                    else if (!(e && e instanceof l)) throw TypeError("Illegal value: " + e + " (not an integer or Long)");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                "number" == typeof e ? e = l.fromNumber(e) : "string" == typeof e && (e = l.fromString(e)), t += 8;
                var r = this.buffer.byteLength;
                r < t && this.resize((r *= 2) > t ? r : t), t -= 8;
                var i = e.low,
                    a = e.high;
                return this.littleEndian ? (this.view[t + 3] = i >>> 24 & 255, this.view[t + 2] = i >>> 16 & 255, this.view[t + 1] = i >>> 8 & 255, this.view[t] = 255 & i, t += 4, this.view[t + 3] = a >>> 24 & 255, this.view[t + 2] = a >>> 16 & 255, this.view[t + 1] = a >>> 8 & 255, this.view[t] = 255 & a) : (this.view[t] = a >>> 24 & 255, this.view[t + 1] = a >>> 16 & 255, this.view[t + 2] = a >>> 8 & 255, this.view[t + 3] = 255 & a, t += 4, this.view[t] = i >>> 24 & 255, this.view[t + 1] = i >>> 16 & 255, this.view[t + 2] = i >>> 8 & 255, this.view[t + 3] = 255 & i), n && (this.offset += 8), this
            }, F.writeUInt64 = F.writeUint64, F.readUint64 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+8) <= " + this.buffer.byteLength)
                }
                var n = 0,
                    r = 0;
                this.littleEndian ? (n = this.view[e + 2] << 16, n |= this.view[e + 1] << 8, n |= this.view[e], n += this.view[e + 3] << 24 >>> 0, e += 4, r = this.view[e + 2] << 16, r |= this.view[e + 1] << 8, r |= this.view[e], r += this.view[e + 3] << 24 >>> 0) : (r = this.view[e + 1] << 16, r |= this.view[e + 2] << 8, r |= this.view[e + 3], r += this.view[e] << 24 >>> 0, e += 4, n = this.view[e + 1] << 16, n |= this.view[e + 2] << 8, n |= this.view[e + 3], n += this.view[e] << 24 >>> 0);
                var i = new l(n, r, !0);
                return t && (this.offset += 8), i
            }, F.readUInt64 = F.readUint64), F.writeFloat32 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e) throw TypeError("Illegal value: " + e + " (not a number)");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 4;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 4, H(this.view, e, t, this.littleEndian, 23, 4), n && (this.offset += 4), this
            }, F.writeFloat = F.writeFloat32, F.readFloat32 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+4) <= " + this.buffer.byteLength)
                }
                var n = V(this.view, e, this.littleEndian, 23, 4);
                return t && (this.offset += 4), n
            }, F.readFloat = F.readFloat32, F.writeFloat64 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e) throw TypeError("Illegal value: " + e + " (not a number)");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                t += 8;
                var r = this.buffer.byteLength;
                return r < t && this.resize((r *= 2) > t ? r : t), t -= 8, H(this.view, e, t, this.littleEndian, 52, 8), n && (this.offset += 8), this
            }, F.writeDouble = F.writeFloat64, F.readFloat64 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+8) <= " + this.buffer.byteLength)
                }
                var n = V(this.view, e, this.littleEndian, 52, 8);
                return t && (this.offset += 8), n
            }, F.readDouble = F.readFloat64, O.MAX_VARINT32_BYTES = 5, O.calculateVarint32 = function (e) {
                return e >>>= 0, e < 128 ? 1 : e < 16384 ? 2 : e < 1 << 21 ? 3 : e < 1 << 28 ? 4 : 5
            }, O.zigZagEncode32 = function (e) {
                return ((e |= 0) << 1 ^ e >> 31) >>> 0
            }, O.zigZagDecode32 = function (e) {
                return e >>> 1 ^ -(1 & e) | 0
            }, F.writeVarint32 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                var r, i = O.calculateVarint32(e);
                t += i;
                var a = this.buffer.byteLength;
                for (a < t && this.resize((a *= 2) > t ? a : t), t -= i, e >>>= 0; 128 <= e;) r = 127 & e | 128, this.view[t++] = r, e >>>= 7;
                return this.view[t++] = e, n ? (this.offset = t, this) : i
            }, F.writeVarint32ZigZag = function (e, t) {
                return this.writeVarint32(O.zigZagEncode32(e), t)
            }, F.readVarint32 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n, r = 0,
                    i = 0;
                do {
                    if (!this.noAssert && e > this.limit) {
                        var a = Error("Truncated");
                        throw a.truncated = !0, a
                    }
                    n = this.view[e++], r < 5 && (i |= (127 & n) << 7 * r), ++r
                } while (0 != (128 & n));
                return i |= 0, t ? (this.offset = e, i) : {
                    value: i,
                    length: r
                }
            }, F.readVarint32ZigZag = function (e) {
                var t = this.readVarint32(e);
                return "object" === (0, L.default)(t) ? t.value = O.zigZagDecode32(t.value) : t = O.zigZagDecode32(t), t
            }, l && (O.MAX_VARINT64_BYTES = 10, O.calculateVarint64 = function (e) {
                "number" == typeof e ? e = l.fromNumber(e) : "string" == typeof e && (e = l.fromString(e));
                var t = e.toInt() >>> 0,
                    n = e.shiftRightUnsigned(28).toInt() >>> 0,
                    r = e.shiftRightUnsigned(56).toInt() >>> 0;
                return 0 == r ? 0 == n ? t < 16384 ? t < 128 ? 1 : 2 : t < 1 << 21 ? 3 : 4 : n < 16384 ? n < 128 ? 5 : 6 : n < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10
            }, O.zigZagEncode64 = function (e) {
                return "number" == typeof e ? e = l.fromNumber(e, !1) : "string" == typeof e ? e = l.fromString(e, !1) : !1 !== e.unsigned && (e = e.toSigned()), e.shiftLeft(1).xor(e.shiftRight(63)).toUnsigned()
            }, O.zigZagDecode64 = function (e) {
                return "number" == typeof e ? e = l.fromNumber(e, !1) : "string" == typeof e ? e = l.fromString(e, !1) : !1 !== e.unsigned && (e = e.toSigned()), e.shiftRightUnsigned(1).xor(e.and(l.ONE).toSigned().negate()).toSigned()
            }, F.writeVarint64 = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("number" == typeof e) e = l.fromNumber(e);
                    else if ("string" == typeof e) e = l.fromString(e);
                    else if (!(e && e instanceof l)) throw TypeError("Illegal value: " + e + " (not an integer or Long)");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                "number" == typeof e ? e = l.fromNumber(e, !1) : "string" == typeof e ? e = l.fromString(e, !1) : !1 !== e.unsigned && (e = e.toSigned());
                var r = O.calculateVarint64(e),
                    i = e.toInt() >>> 0,
                    a = e.shiftRightUnsigned(28).toInt() >>> 0,
                    o = e.shiftRightUnsigned(56).toInt() >>> 0;
                t += r;
                var s = this.buffer.byteLength;
                switch (s < t && this.resize((s *= 2) > t ? s : t), t -= r, r) {
                    case 10:
                        this.view[t + 9] = o >>> 7 & 1;
                    case 9:
                        this.view[t + 8] = 9 !== r ? 128 | o : 127 & o;
                    case 8:
                        this.view[t + 7] = 8 !== r ? a >>> 21 | 128 : a >>> 21 & 127;
                    case 7:
                        this.view[t + 6] = 7 !== r ? a >>> 14 | 128 : a >>> 14 & 127;
                    case 6:
                        this.view[t + 5] = 6 !== r ? a >>> 7 | 128 : a >>> 7 & 127;
                    case 5:
                        this.view[t + 4] = 5 !== r ? 128 | a : 127 & a;
                    case 4:
                        this.view[t + 3] = 4 !== r ? i >>> 21 | 128 : i >>> 21 & 127;
                    case 3:
                        this.view[t + 2] = 3 !== r ? i >>> 14 | 128 : i >>> 14 & 127;
                    case 2:
                        this.view[t + 1] = 2 !== r ? i >>> 7 | 128 : i >>> 7 & 127;
                    case 1:
                        this.view[t] = 1 !== r ? 128 | i : 127 & i
                }
                return n ? (this.offset += r, this) : r
            }, F.writeVarint64ZigZag = function (e, t) {
                return this.writeVarint64(O.zigZagEncode64(e), t)
            }, F.readVarint64 = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n = e,
                    r = 0,
                    i = 0,
                    a = 0,
                    o = 0;
                if (o = this.view[e++], r = 127 & o, 128 & o && (o = this.view[e++], r |= (127 & o) << 7, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], r |= (127 & o) << 14, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], r |= (127 & o) << 21, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], i = 127 & o, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], i |= (127 & o) << 7, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], i |= (127 & o) << 14, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], i |= (127 & o) << 21, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], a = 127 & o, (128 & o || this.noAssert && void 0 === o) && (o = this.view[e++], a |= (127 & o) << 7, 128 & o || this.noAssert && void 0 === o)))))))))) throw Error("Buffer overrun");
                var s = l.fromBits(r | i << 28, i >>> 4 | a << 24, !1);
                return t ? (this.offset = e, s) : {
                    value: s,
                    length: e - n
                }
            }, F.readVarint64ZigZag = function (e) {
                var t = this.readVarint64(e);
                return t && t.value instanceof l ? t.value = O.zigZagDecode64(t.value) : t = O.zigZagDecode64(t), t
            }), F.writeCString = function (e, t) {
                var n = void 0 === t;
                n && (t = this.offset);
                var r, i = e.length;
                if (!this.noAssert) {
                    if ("string" != typeof e) throw TypeError("Illegal str: Not a string");
                    for (r = 0; r < i; ++r)
                        if (0 === e.charCodeAt(r)) throw RangeError("Illegal str: Contains NULL-characters");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                i = Y.calculateUTF16asUTF8(U(e))[1], t += i + 1;
                var a = this.buffer.byteLength;
                return a < t && this.resize((a *= 2) > t ? a : t), t -= i + 1, Y.encodeUTF16toUTF8(U(e), function (e) {
                    this.view[t++] = e
                }.bind(this)), this.view[t++] = 0, n ? (this.offset = t, this) : i
            }, F.readCString = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n, r = e,
                    i = -1;
                return Y.decodeUTF8toUTF16(function () {
                    if (0 === i) return null;
                    if (e >= this.limit) throw RangeError("Illegal range: Truncated data, " + e + " < " + this.limit);
                    return i = this.view[e++], 0 === i ? null : i
                }.bind(this), n = z(), !0), t ? (this.offset = e, n()) : {
                    string: n(),
                    length: e - r
                }
            }, F.writeIString = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("string" != typeof e) throw TypeError("Illegal str: Not a string");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                var r, i = t;
                r = Y.calculateUTF16asUTF8(U(e), this.noAssert)[1], t += 4 + r;
                var a = this.buffer.byteLength;
                if (a < t && this.resize((a *= 2) > t ? a : t), t -= 4 + r, this.littleEndian ? (this.view[t + 3] = r >>> 24 & 255, this.view[t + 2] = r >>> 16 & 255, this.view[t + 1] = r >>> 8 & 255, this.view[t] = 255 & r) : (this.view[t] = r >>> 24 & 255, this.view[t + 1] = r >>> 16 & 255, this.view[t + 2] = r >>> 8 & 255, this.view[t + 3] = 255 & r), t += 4, Y.encodeUTF16toUTF8(U(e), function (e) {
                        this.view[t++] = e
                    }.bind(this)), t !== i + 4 + r) throw RangeError("Illegal range: Truncated data, " + t + " == " + (t + 4 + r));
                return n ? (this.offset = t, this) : t - i
            }, F.readIString = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+4) <= " + this.buffer.byteLength)
                }
                var n = e,
                    r = this.readUint32(e),
                    i = this.readUTF8String(r, O.METRICS_BYTES, e += 4);
                return e += i.length, t ? (this.offset = e, i.string) : {
                    string: i.string,
                    length: e - n
                }
            }, O.METRICS_CHARS = "c", O.METRICS_BYTES = "b", F.writeUTF8String = function (e, t) {
                var n, r = void 0 === t;
                if (r && (t = this.offset), !this.noAssert) {
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                var i = t;
                n = Y.calculateUTF16asUTF8(U(e))[1], t += n;
                var a = this.buffer.byteLength;
                return a < t && this.resize((a *= 2) > t ? a : t), t -= n, Y.encodeUTF16toUTF8(U(e), function (e) {
                    this.view[t++] = e
                }.bind(this)), r ? (this.offset = t, this) : t - i
            }, F.writeString = F.writeUTF8String, O.calculateUTF8Chars = function (e) {
                return Y.calculateUTF16asUTF8(U(e))[0]
            }, O.calculateUTF8Bytes = function (e) {
                return Y.calculateUTF16asUTF8(U(e))[1]
            }, O.calculateString = O.calculateUTF8Bytes, F.readUTF8String = function (e, t, n) {
                "number" == typeof t && (n = t, t = void 0);
                var r = void 0 === n;
                if (r && (n = this.offset), void 0 === t && (t = O.METRICS_CHARS), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal length: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof n || n % 1 != 0) throw TypeError("Illegal offset: " + n + " (not an integer)");
                    if (n >>>= 0, n < 0 || n + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + n + " (+0) <= " + this.buffer.byteLength)
                }
                var i, a = 0,
                    o = n;
                if (t === O.METRICS_CHARS) {
                    if (i = z(), Y.decodeUTF8(function () {
                            return a < e && n < this.limit ? this.view[n++] : null
                        }.bind(this), function (e) {
                            ++a, Y.UTF8toUTF16(e, i)
                        }), a !== e) throw RangeError("Illegal range: Truncated data, " + a + " == " + e);
                    return r ? (this.offset = n, i()) : {
                        string: i(),
                        length: n - o
                    }
                }
                if (t !== O.METRICS_BYTES) throw TypeError("Unsupported metrics: " + t);
                if (!this.noAssert) {
                    if ("number" != typeof n || n % 1 != 0) throw TypeError("Illegal offset: " + n + " (not an integer)");
                    if (n >>>= 0, n < 0 || n + e > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + n + " (+" + e + ") <= " + this.buffer.byteLength)
                }
                var s = n + e;
                if (Y.decodeUTF8toUTF16(function () {
                        return n < s ? this.view[n++] : null
                    }.bind(this), i = z(), this.noAssert), n !== s) throw RangeError("Illegal range: Truncated data, " + n + " == " + s);
                return r ? (this.offset = n, i()) : {
                    string: i(),
                    length: n - o
                }
            }, F.readString = F.readUTF8String, F.writeVString = function (e, t) {
                var n = void 0 === t;
                if (n && (t = this.offset), !this.noAssert) {
                    if ("string" != typeof e) throw TypeError("Illegal str: Not a string");
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: " + t + " (not an integer)");
                    if (t >>>= 0, t < 0 || t + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + t + " (+0) <= " + this.buffer.byteLength)
                }
                var r, i, a = t;
                r = Y.calculateUTF16asUTF8(U(e), this.noAssert)[1], i = O.calculateVarint32(r), t += i + r;
                var o = this.buffer.byteLength;
                if (o < t && this.resize((o *= 2) > t ? o : t), t -= i + r, t += this.writeVarint32(r, t), Y.encodeUTF16toUTF8(U(e), function (e) {
                        this.view[t++] = e
                    }.bind(this)), t !== a + r + i) throw RangeError("Illegal range: Truncated data, " + t + " == " + (t + r + i));
                return n ? (this.offset = t, this) : t - a
            }, F.readVString = function (e) {
                var t = void 0 === e;
                if (t && (e = this.offset), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+1) <= " + this.buffer.byteLength)
                }
                var n = e,
                    r = this.readVarint32(e),
                    i = this.readUTF8String(r.value, O.METRICS_BYTES, e += r.length);
                return e += i.length, t ? (this.offset = e, i.string) : {
                    string: i.string,
                    length: e - n
                }
            }, F.append = function (e, t, n) {
                "number" != typeof t && "string" == typeof t || (n = t, t = void 0);
                var r = void 0 === n;
                if (r && (n = this.offset), !this.noAssert) {
                    if ("number" != typeof n || n % 1 != 0) throw TypeError("Illegal offset: " + n + " (not an integer)");
                    if (n >>>= 0, n < 0 || n + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + n + " (+0) <= " + this.buffer.byteLength)
                }
                e instanceof O || (e = O.wrap(e, t));
                var i = e.limit - e.offset;
                if (i <= 0) return this;
                n += i;
                var a = this.buffer.byteLength;
                return a < n && this.resize((a *= 2) > n ? a : n), n -= i, this.view.set(e.view.subarray(e.offset, e.limit), n), e.offset += i, r && (this.offset += i), this
            }, F.appendTo = function (e, t) {
                return e.append(this, t), this
            }, F.assert = function (e) {
                return this.noAssert = !e, this
            }, F.capacity = function () {
                return this.buffer.byteLength
            }, F.clear = function () {
                return this.offset = 0, this.limit = this.buffer.byteLength, this.markedOffset = -1, this
            }, F.clone = function (e) {
                var t = new O(0, this.littleEndian, this.noAssert);
                return e ? (t.buffer = new ArrayBuffer(this.buffer.byteLength), t.view = new Uint8Array(t.buffer)) : (t.buffer = this.buffer, t.view = this.view), t.offset = this.offset, t.markedOffset = this.markedOffset, t.limit = this.limit, t
            }, F.compact = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (t >>>= 0, e < 0 || t < e || t > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + e + " <= " + t + " <= " + this.buffer.byteLength)
                }
                if (0 === e && t === this.buffer.byteLength) return this;
                var n = t - e;
                if (0 === n) return this.buffer = B, this.view = null, 0 <= this.markedOffset && (this.markedOffset -= e), this.offset = 0, this.limit = 0, this;
                var r = new ArrayBuffer(n),
                    i = new Uint8Array(r);
                return i.set(this.view.subarray(e, t)), this.buffer = r, this.view = i, 0 <= this.markedOffset && (this.markedOffset -= e), this.offset = 0, this.limit = n, this
            }, F.copy = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (t >>>= 0, e < 0 || t < e || t > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + e + " <= " + t + " <= " + this.buffer.byteLength)
                }
                if (e === t) return new O(0, this.littleEndian, this.noAssert);
                var n = t - e,
                    r = new O(n, this.littleEndian, this.noAssert);
                return r.offset = 0, r.limit = n, 0 <= r.markedOffset && (r.markedOffset -= e), this.copyTo(r, 0, e, t), r
            }, F.copyTo = function (e, t, n, r) {
                var i, a;
                if (!this.noAssert && !O.isByteBuffer(e)) throw TypeError("Illegal target: Not a ByteBuffer");
                if (t = (a = void 0 === t) ? e.offset : 0 | t, n = (i = void 0 === n) ? this.offset : 0 | n, r = void 0 === r ? this.limit : 0 | r, t < 0 || t > e.buffer.byteLength) throw RangeError("Illegal target range: 0 <= " + t + " <= " + e.buffer.byteLength);
                if (n < 0 || r > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= " + n + " <= " + this.buffer.byteLength);
                var o = r - n;
                return 0 === o ? e : (e.ensureCapacity(t + o), e.view.set(this.view.subarray(n, r), t), i && (this.offset += o), a && (e.offset += o), this)
            }, F.ensureCapacity = function (e) {
                var t = this.buffer.byteLength;
                return t < e ? this.resize((t *= 2) > e ? t : e) : this
            }, F.fill = function (e, t, n) {
                var r = void 0 === t;
                if (r && (t = this.offset), "string" == typeof e && 0 < e.length && (e = e.charCodeAt(0)), void 0 === t && (t = this.offset), void 0 === n && (n = this.limit), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal value: " + e + " (not an integer)");
                    if (e |= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (t >>>= 0, "number" != typeof n || n % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (n >>>= 0, t < 0 || n < t || n > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + t + " <= " + n + " <= " + this.buffer.byteLength)
                }
                if (n <= t) return this;
                for (; t < n;) this.view[t++] = e;
                return r && (this.offset = t), this
            }, F.flip = function () {
                return this.limit = this.offset, this.offset = 0, this
            }, F.mark = function (e) {
                if (e = void 0 === e ? this.offset : e, !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal offset: " + e + " (not an integer)");
                    if (e >>>= 0, e < 0 || e + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + e + " (+0) <= " + this.buffer.byteLength)
                }
                return this.markedOffset = e, this
            }, F.order = function (e) {
                if (!this.noAssert && "boolean" != typeof e) throw TypeError("Illegal littleEndian: Not a boolean");
                return this.littleEndian = !!e, this
            }, F.LE = function (e) {
                return this.littleEndian = void 0 === e || !!e, this
            }, F.BE = function (e) {
                return this.littleEndian = void 0 !== e && !e, this
            }, F.prepend = function (e, t, n) {
                "number" != typeof t && "string" == typeof t || (n = t, t = void 0);
                var r = void 0 === n;
                if (r && (n = this.offset), !this.noAssert) {
                    if ("number" != typeof n || n % 1 != 0) throw TypeError("Illegal offset: " + n + " (not an integer)");
                    if (n >>>= 0, n < 0 || n + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + n + " (+0) <= " + this.buffer.byteLength)
                }
                e instanceof O || (e = O.wrap(e, t));
                var i = e.limit - e.offset;
                if (i <= 0) return this;
                var a = i - n;
                if (0 < a) {
                    var o = new ArrayBuffer(this.buffer.byteLength + a),
                        s = new Uint8Array(o);
                    s.set(this.view.subarray(n, this.buffer.byteLength), i), this.buffer = o, this.view = s, this.offset += a, 0 <= this.markedOffset && (this.markedOffset += a), this.limit += a, n += a
                } else new Uint8Array(this.buffer);
                return this.view.set(e.view.subarray(e.offset, e.limit), n - i), e.offset = e.limit, r && (this.offset -= i), this
            }, F.prependTo = function (e, t) {
                return e.prepend(this, t), this
            }, F.printDebug = function (e) {
                "function" != typeof e && (e = console.log.bind(console)), e(this.toString() + "\n-------------------------------------------------------------------\n" + this.toDebug(!0))
            }, F.remaining = function () {
                return this.limit - this.offset
            }, F.reset = function () {
                return 0 <= this.markedOffset ? (this.offset = this.markedOffset, this.markedOffset = -1) : this.offset = 0, this
            }, F.resize = function (e) {
                if (!this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal capacity: " + e + " (not an integer)");
                    if (e |= 0, e < 0) throw RangeError("Illegal capacity: 0 <= " + e)
                }
                if (this.buffer.byteLength < e) {
                    var t = new ArrayBuffer(e),
                        n = new Uint8Array(t);
                    n.set(this.view), this.buffer = t, this.view = n
                }
                return this
            }, F.reverse = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (t >>>= 0, e < 0 || t < e || t > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + e + " <= " + t + " <= " + this.buffer.byteLength)
                }
                return e === t || Array.prototype.reverse.call(this.view.subarray(e, t)), this
            }, F.skip = function (e) {
                if (!this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal length: " + e + " (not an integer)");
                    e |= 0
                }
                var t = this.offset + e;
                if (!this.noAssert && (t < 0 || t > this.buffer.byteLength)) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + e + " <= " + this.buffer.byteLength);
                return this.offset = t, this
            }, F.slice = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (t >>>= 0, e < 0 || t < e || t > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + e + " <= " + t + " <= " + this.buffer.byteLength)
                }
                var n = this.clone();
                return n.offset = e, n.limit = t, n
            }, F.toBuffer = function (e) {
                var t = this.offset,
                    n = this.limit;
                if (!this.noAssert) {
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal offset: Not an integer");
                    if (t >>>= 0, "number" != typeof n || n % 1 != 0) throw TypeError("Illegal limit: Not an integer");
                    if (n >>>= 0, t < 0 || n < t || n > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + t + " <= " + n + " <= " + this.buffer.byteLength)
                }
                if (!e && 0 === t && n === this.buffer.byteLength) return this.buffer;
                if (t === n) return B;
                var r = new ArrayBuffer(n - t);
                return new Uint8Array(r).set(new Uint8Array(this.buffer).subarray(t, n), 0), r
            }, F.toArrayBuffer = F.toBuffer, F.toString = function (e, t, n) {
                if (void 0 === e) return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
                switch ("number" == typeof e && (e = "utf8", t = e, n = t), e) {
                    case "utf8":
                        return this.toUTF8(t, n);
                    case "base64":
                        return this.toBase64(t, n);
                    case "hex":
                        return this.toHex(t, n);
                    case "binary":
                        return this.toBinary(t, n);
                    case "debug":
                        return this.toDebug();
                    case "columns":
                        return this.toColumns();
                    default:
                        throw Error("Unsupported encoding: " + e)
                }
            };
            var W = function () {
                for (var e = {}, i = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47], o = [], t = 0, n = i.length; t < n; ++t) o[i[t]] = t;
                return e.encode = function (e, t) {
                    for (var n, r; null !== (n = e());) t(i[n >> 2 & 63]), r = (3 & n) << 4, null !== (n = e()) ? (r |= n >> 4 & 15, t(i[63 & (r | n >> 4 & 15)]), r = (15 & n) << 2, null !== (n = e()) ? (t(i[63 & (r | n >> 6 & 3)]), t(i[63 & n])) : (t(i[63 & r]), t(61))) : (t(i[63 & r]), t(61), t(61))
                }, e.decode = function (e, t) {
                    var n, r, i;

                    function a(e) {
                        throw Error("Illegal character code: " + e)
                    }
                    for (; null !== (n = e());)
                        if (r = o[n], void 0 === r && a(n), null !== (n = e()) && (i = o[n], void 0 === i && a(n), t(r << 2 >>> 0 | (48 & i) >> 4), null !== (n = e()))) {
                            if (r = o[n], void 0 === r) {
                                if (61 === n) break;
                                a(n)
                            }
                            if (t((15 & i) << 4 >>> 0 | (60 & r) >> 2), null !== (n = e())) {
                                if (i = o[n], void 0 === i) {
                                    if (61 === n) break;
                                    a(n)
                                }
                                t((3 & r) << 6 >>> 0 | i)
                            }
                        }
                }, e.test = function (e) {
                    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)
                }, e
            }();
            F.toBase64 = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), e |= 0, t |= 0, e < 0 || t > this.capacity || t < e) throw RangeError("begin, end");
                var n;
                return W.encode(function () {
                    return e < t ? this.view[e++] : null
                }.bind(this), n = z()), n()
            }, O.fromBase64 = function (e, t) {
                if ("string" != typeof e) throw TypeError("str");
                var n = new O(e.length / 4 * 3, t),
                    r = 0;
                return W.decode(U(e), function (e) {
                    n.view[r++] = e
                }), n.limit = r, n
            }, O.btoa = function (e) {
                return O.fromBinary(e).toBase64()
            }, O.atob = function (e) {
                return O.fromBase64(e).toBinary()
            }, F.toBinary = function (e, t) {
                if (void 0 === e && (e = this.offset), void 0 === t && (t = this.limit), e |= 0, t |= 0, e < 0 || t > this.capacity() || t < e) throw RangeError("begin, end");
                if (e === t) return "";
                for (var n = [], r = []; e < t;) n.push(this.view[e++]), 1024 <= n.length && (r.push(String.fromCharCode.apply(String, n)), n = []);
                return r.join("") + String.fromCharCode.apply(String, n)
            }, O.fromBinary = function (e, t) {
                if ("string" != typeof e) throw TypeError("str");
                for (var n, r = 0, i = e.length, a = new O(i, t); r < i;) {
                    if (n = e.charCodeAt(r), 255 < n) throw RangeError("illegal char code: " + n);
                    a.view[r++] = n
                }
                return a.limit = i, a
            }, F.toDebug = function (e) {
                for (var t, n = -1, r = this.buffer.byteLength, i = "", a = "", o = ""; n < r;) {
                    if (-1 !== n && (t = this.view[n], i += t < 16 ? "0" + t.toString(16).toUpperCase() : t.toString(16).toUpperCase(), e && (a += 32 < t && t < 127 ? String.fromCharCode(t) : ".")), ++n, e && 0 < n && n % 16 == 0 && n !== r) {
                        for (; i.length < 51;) i += " ";
                        o += i + a + "\n", i = a = ""
                    }
                    n === this.offset && n === this.limit ? i += n === this.markedOffset ? "!" : "|" : n === this.offset ? i += n === this.markedOffset ? "[" : "<" : n === this.limit ? i += n === this.markedOffset ? "]" : ">" : i += n === this.markedOffset ? "'" : e || 0 !== n && n !== r ? " " : ""
                }
                if (e && " " !== i) {
                    for (; i.length < 51;) i += " ";
                    o += i + a + "\n"
                }
                return e ? o : i
            }, O.fromDebug = function (e, t, n) {
                for (var r, i, a = e.length, o = new O((a + 1) / 3 | 0, t, n), s = 0, l = 0, u = !1, h = !1, c = !1, d = !1, f = !1; s < a;) {
                    switch (r = e.charAt(s++)) {
                        case "!":
                            if (!n) {
                                if (h || c || d) {
                                    f = !0;
                                    break
                                }
                                h = c = d = !0
                            }
                            o.offset = o.markedOffset = o.limit = l, u = !1;
                            break;
                        case "|":
                            if (!n) {
                                if (h || d) {
                                    f = !0;
                                    break
                                }
                                h = d = !0
                            }
                            o.offset = o.limit = l, u = !1;
                            break;
                        case "[":
                            if (!n) {
                                if (h || c) {
                                    f = !0;
                                    break
                                }
                                h = c = !0
                            }
                            o.offset = o.markedOffset = l, u = !1;
                            break;
                        case "<":
                            if (!n) {
                                if (h) {
                                    f = !0;
                                    break
                                }
                                h = !0
                            }
                            o.offset = l, u = !1;
                            break;
                        case "]":
                            if (!n) {
                                if (d || c) {
                                    f = !0;
                                    break
                                }
                                d = c = !0
                            }
                            o.limit = o.markedOffset = l, u = !1;
                            break;
                        case ">":
                            if (!n) {
                                if (d) {
                                    f = !0;
                                    break
                                }
                                d = !0
                            }
                            o.limit = l, u = !1;
                            break;
                        case "'":
                            if (!n) {
                                if (c) {
                                    f = !0;
                                    break
                                }
                                c = !0
                            }
                            o.markedOffset = l, u = !1;
                            break;
                        case " ":
                            u = !1;
                            break;
                        default:
                            if (!n && u) {
                                f = !0;
                                break
                            }
                            if (i = (0, N.default)(r + e.charAt(s++), 16), !n && (isNaN(i) || i < 0 || 255 < i)) throw TypeError("Illegal str: Not a debug encoded string");
                            o.view[l++] = i, u = !0
                    }
                    if (f) throw TypeError("Illegal str: Invalid symbol at " + s)
                }
                if (!n) {
                    if (!h || !d) throw TypeError("Illegal str: Missing offset or limit");
                    if (l < o.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + l + " < " + a)
                }
                return o
            }, F.toHex = function (e, t) {
                if (e = void 0 === e ? this.offset : e, t = void 0 === t ? this.limit : t, !this.noAssert) {
                    if ("number" != typeof e || e % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (e >>>= 0, "number" != typeof t || t % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (t >>>= 0, e < 0 || t < e || t > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + e + " <= " + t + " <= " + this.buffer.byteLength)
                }
                for (var n, r = new Array(t - e); e < t;) n = this.view[e++], n < 16 ? r.push("0", n.toString(16)) : r.push(n.toString(16));
                return r.join("")
            }, O.fromHex = function (e, t, n) {
                if (!n) {
                    if ("string" != typeof e) throw TypeError("Illegal str: Not a string");
                    if (e.length % 2 != 0) throw TypeError("Illegal str: Length not a multiple of 2")
                }
                for (var r, i = e.length, a = new O(i / 2 | 0, t), o = 0, s = 0; o < i; o += 2) {
                    if (r = (0, N.default)(e.substring(o, o + 2), 16), !n && (!isFinite(r) || r < 0 || 255 < r)) throw TypeError("Illegal str: Contains non-hex characters");
                    a.view[s++] = r
                }
                return a.limit = s, a
            };
            var j, Y = (j = {
                MAX_CODEPOINT: 1114111,
                encodeUTF8: function (e, t) {
                    var n = null;
                    for ("number" == typeof e && (n = e, e = function () {
                            return null
                        }); null !== n || null !== (n = e());) n < 128 ? t(127 & n) : (n < 2048 ? t(n >> 6 & 31 | 192) : (n < 65536 ? t(n >> 12 & 15 | 224) : (t(n >> 18 & 7 | 240), t(n >> 12 & 63 | 128)), t(n >> 6 & 63 | 128)), t(63 & n | 128)), n = null
                },
                decodeUTF8: function (e, t) {
                    for (var n, r, i, a, o = function (e) {
                            e = e.slice(0, e.indexOf(null));
                            var t = Error(e.toString());
                            throw t.name = "TruncatedError", t.bytes = e, t
                        }; null !== (n = e());)
                        if (0 == (128 & n)) t(n);
                        else if (192 == (224 & n)) null === (r = e()) && o([n, r]), t((31 & n) << 6 | 63 & r);
                    else if (224 == (240 & n)) null !== (r = e()) && null !== (i = e()) || o([n, r, i]), t((15 & n) << 12 | (63 & r) << 6 | 63 & i);
                    else {
                        if (240 != (248 & n)) throw RangeError("Illegal starting byte: " + n);
                        null !== (r = e()) && null !== (i = e()) && null !== (a = e()) || o([n, r, i, a]), t((7 & n) << 18 | (63 & r) << 12 | (63 & i) << 6 | 63 & a)
                    }
                },
                UTF16toUTF8: function (e, t) {
                    for (var n, r = null; null !== (n = null !== r ? r : e());) 55296 <= n && n <= 57343 && null !== (r = e()) && 56320 <= r && r <= 57343 ? (t(1024 * (n - 55296) + r - 56320 + 65536), r = null) : t(n);
                    null !== r && t(r)
                },
                UTF8toUTF16: function (e, t) {
                    var n = null;
                    for ("number" == typeof e && (n = e, e = function () {
                            return null
                        }); null !== n || null !== (n = e());) n <= 65535 ? t(n) : (n -= 65536, t(55296 + (n >> 10)), t(n % 1024 + 56320)), n = null
                },
                encodeUTF16toUTF8: function (e, t) {
                    j.UTF16toUTF8(e, function (e) {
                        j.encodeUTF8(e, t)
                    })
                },
                decodeUTF8toUTF16: function (e, t) {
                    j.decodeUTF8(e, function (e) {
                        j.UTF8toUTF16(e, t)
                    })
                },
                calculateCodePoint: function (e) {
                    return e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4
                },
                calculateUTF8: function (e) {
                    for (var t, n = 0; null !== (t = e());) n += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
                    return n
                },
                calculateUTF16asUTF8: function (e) {
                    var t = 0,
                        n = 0;
                    return j.UTF16toUTF8(e, function (e) {
                        ++t, n += e < 128 ? 1 : e < 2048 ? 2 : e < 65536 ? 3 : 4
                    }), [t, n]
                }
            }, j);
            F.toUTF8 = function (t, n) {
                if (void 0 === t && (t = this.offset), void 0 === n && (n = this.limit), !this.noAssert) {
                    if ("number" != typeof t || t % 1 != 0) throw TypeError("Illegal begin: Not an integer");
                    if (t >>>= 0, "number" != typeof n || n % 1 != 0) throw TypeError("Illegal end: Not an integer");
                    if (n >>>= 0, t < 0 || n < t || n > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + t + " <= " + n + " <= " + this.buffer.byteLength)
                }
                var e;
                try {
                    Y.decodeUTF8toUTF16(function () {
                        return t < n ? this.view[t++] : null
                    }.bind(this), e = z())
                } catch (e) {
                    if (t !== n) throw RangeError("Illegal range: Truncated data, " + t + " != " + n)
                }
                return e()
            }, O.fromUTF8 = function (e, t, n) {
                if (!n && "string" != typeof e) throw TypeError("Illegal str: Not a string");
                var r = new O(Y.calculateUTF16asUTF8(U(e), !0)[1], t, n),
                    i = 0;
                return Y.encodeUTF16toUTF8(U(e), function (e) {
                    r.view[i++] = e
                }), r.limit = i, r
            };
            var q, X, Z, J, K, Q, $, ee, te, ne = {};

            function re(t) {
                t.messages && t.messages.forEach(function (e) {
                    e.syntax = t.syntax, re(e)
                }), t.enums && t.enums.forEach(function (e) {
                    e.syntax = t.syntax
                })
            }

            function ie(e) {
                var t = 0;
                return {
                    next: function () {
                        return t < e.length ? {
                            done: !1,
                            value: e[t++]
                        } : {
                            done: !0
                        }
                    }
                }
            }
            ae.ProtoBuf = ne, ne.ByteBuffer = O, ne.Long = O.Long || null, ne.VERSION = "5.0.1", ne.WIRE_TYPES = {}, ne.WIRE_TYPES.VARINT = 0, ne.WIRE_TYPES.BITS64 = 1, ne.WIRE_TYPES.LDELIM = 2, ne.WIRE_TYPES.STARTGROUP = 3, ne.WIRE_TYPES.ENDGROUP = 4, ne.WIRE_TYPES.BITS32 = 5, ne.PACKABLE_WIRE_TYPES = [ne.WIRE_TYPES.VARINT, ne.WIRE_TYPES.BITS64, ne.WIRE_TYPES.BITS32], ne.TYPES = {
                int32: {
                    name: "int32",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: 0
                },
                uint32: {
                    name: "uint32",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: 0
                },
                sint32: {
                    name: "sint32",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: 0
                },
                int64: {
                    name: "int64",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: ne.Long ? ne.Long.ZERO : void 0
                },
                uint64: {
                    name: "uint64",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: ne.Long ? ne.Long.UZERO : void 0
                },
                sint64: {
                    name: "sint64",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: ne.Long ? ne.Long.ZERO : void 0
                },
                bool: {
                    name: "bool",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: !1
                },
                double: {
                    name: "double",
                    wireType: ne.WIRE_TYPES.BITS64,
                    defaultValue: 0
                },
                string: {
                    name: "string",
                    wireType: ne.WIRE_TYPES.LDELIM,
                    defaultValue: ""
                },
                bytes: {
                    name: "bytes",
                    wireType: ne.WIRE_TYPES.LDELIM,
                    defaultValue: null
                },
                fixed32: {
                    name: "fixed32",
                    wireType: ne.WIRE_TYPES.BITS32,
                    defaultValue: 0
                },
                sfixed32: {
                    name: "sfixed32",
                    wireType: ne.WIRE_TYPES.BITS32,
                    defaultValue: 0
                },
                fixed64: {
                    name: "fixed64",
                    wireType: ne.WIRE_TYPES.BITS64,
                    defaultValue: ne.Long ? ne.Long.UZERO : void 0
                },
                sfixed64: {
                    name: "sfixed64",
                    wireType: ne.WIRE_TYPES.BITS64,
                    defaultValue: ne.Long ? ne.Long.ZERO : void 0
                },
                float: {
                    name: "float",
                    wireType: ne.WIRE_TYPES.BITS32,
                    defaultValue: 0
                },
                enum: {
                    name: "enum",
                    wireType: ne.WIRE_TYPES.VARINT,
                    defaultValue: 0
                },
                message: {
                    name: "message",
                    wireType: ne.WIRE_TYPES.LDELIM,
                    defaultValue: null
                },
                group: {
                    name: "group",
                    wireType: ne.WIRE_TYPES.STARTGROUP,
                    defaultValue: null
                }
            }, ne.MAP_KEY_TYPES = [ne.TYPES.int32, ne.TYPES.sint32, ne.TYPES.sfixed32, ne.TYPES.uint32, ne.TYPES.fixed32, ne.TYPES.int64, ne.TYPES.sint64, ne.TYPES.sfixed64, ne.TYPES.uint64, ne.TYPES.fixed64, ne.TYPES.bool, ne.TYPES.string, ne.TYPES.bytes], ne.ID_MIN = 1, ne.ID_MAX = 536870911, ne.convertFieldsToCamelCase = !1, ne.populateAccessors = !0, ne.populateDefaults = !0, ne.Util = (q = {}, q.IS_NODE = !("object" !== (void 0 === e ? "undefined" : (0, L.default)(e)) || e + "" != "[object process]" || e.browser), q.XHR = function () {
                for (var e = [function () {
                        return new XMLHttpRequest
                    }, function () {
                        return new ActiveXObject("Msxml2.XMLHTTP")
                    }, function () {
                        return new ActiveXObject("Msxml3.XMLHTTP")
                    }, function () {
                        return new ActiveXObject("Microsoft.XMLHTTP")
                    }], t = null, n = 0; n < e.length; n++) {
                    try {
                        t = e[n]()
                    } catch (e) {
                        continue
                    }
                    break
                }
                if (!t) throw Error("XMLHttpRequest is not supported");
                return t
            }, q.fetch = function (e, n) {
                if (n && "function" != typeof n && (n = null), q.IS_NODE) {
                    var t = oe(378);
                    if (n) t.readFile(e, function (e, t) {
                        n(e ? null : "" + t)
                    });
                    else try {
                        return t.readFileSync(e)
                    } catch (e) {
                        return null
                    }
                } else {
                    var r = q.XHR();
                    if (r.open("GET", e, !!n), r.setRequestHeader("Accept", "text/plain"), "function" == typeof r.overrideMimeType && r.overrideMimeType("text/plain"), !n) return r.send(null), 200 == r.status || 0 == r.status && "string" == typeof r.responseText ? r.responseText : null;
                    if (r.onreadystatechange = function () {
                            4 == r.readyState && (200 == r.status || 0 == r.status && "string" == typeof r.responseText ? n(r.responseText) : n(null))
                        }, 4 == r.readyState) return;
                    r.send(null)
                }
            }, q.toCamelCase = function (e) {
                return e.replace(/_([a-zA-Z])/g, function (e, t) {
                    return t.toUpperCase()
                })
            }, q), ne.Lang = {
                DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,
                RULE: /^(?:required|optional|repeated|map)$/,
                TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
                NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
                TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
                TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
                FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
                NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,
                NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
                NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,
                NUMBER_OCT: /^0[0-7]+$/,
                NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,
                BOOL: /^(?:true|false)$/i,
                ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
                NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
                WHITESPACE: /\s/,
                STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
                STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
                STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
            }, ne.DotProto = function (i, o) {
                var e = {},
                    t = function (e) {
                        this.source = e + "", this.index = 0, this.line = 1, this.stack = [], this._stringOpen = null
                    },
                    n = t.prototype;
                n._readString = function () {
                    var e = '"' === this._stringOpen ? o.STRING_DQ : o.STRING_SQ;
                    e.lastIndex = this.index - 1;
                    var t = e.exec(this.source);
                    if (!t) throw Error("unterminated string");
                    return this.index = e.lastIndex, this.stack.push(this._stringOpen), this._stringOpen = null, t[1]
                }, n.next = function () {
                    if (0 < this.stack.length) return this.stack.shift();
                    if (this.index >= this.source.length) return null;
                    if (null !== this._stringOpen) return this._readString();
                    var e, t, n;
                    do {
                        for (e = !1; o.WHITESPACE.test(n = this.source.charAt(this.index));)
                            if ("\n" === n && ++this.line, ++this.index === this.source.length) return null;
                        if ("/" === this.source.charAt(this.index))
                            if (++this.index, "/" === this.source.charAt(this.index)) {
                                for (;
                                    "\n" !== this.source.charAt(++this.index);)
                                    if (this.index == this.source.length) return null;
                                ++this.index, ++this.line, e = !0
                            } else {
                                if ("*" !== (n = this.source.charAt(this.index))) return "/";
                                do {
                                    if ("\n" === n && ++this.line, ++this.index === this.source.length) return null;
                                    t = n, n = this.source.charAt(this.index)
                                } while ("*" !== t || "/" !== n);
                                ++this.index, e = !0
                            }
                    } while (e);
                    if (this.index === this.source.length) return null;
                    var r = this.index;
                    o.DELIM.lastIndex = 0;
                    var i = o.DELIM.test(this.source.charAt(r++));
                    if (!i)
                        for (; r < this.source.length && !o.DELIM.test(this.source.charAt(r));) ++r;
                    var a = this.source.substring(this.index, this.index = r);
                    return '"' !== a && "'" !== a || (this._stringOpen = a), a
                }, n.peek = function () {
                    if (0 === this.stack.length) {
                        var e = this.next();
                        if (null === e) return null;
                        this.stack.push(e)
                    }
                    return this.stack[0]
                }, n.skip = function (e) {
                    var t = this.next();
                    if (t !== e) throw Error("illegal '" + t + "', '" + e + "' expected")
                }, n.omit = function (e) {
                    return this.peek() === e && (this.next(), !0)
                }, n.toString = function () {
                    return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")"
                }, e.Tokenizer = t;
                var r = function (e) {
                        this.tn = new t(e), this.proto3 = !1
                    },
                    a = r.prototype;

                function s(e, t) {
                    var n = -1,
                        r = 1;
                    if ("-" == e.charAt(0) && (r = -1, e = e.substring(1)), o.NUMBER_DEC.test(e)) n = (0, N.default)(e);
                    else if (o.NUMBER_HEX.test(e)) n = (0, N.default)(e.substring(2), 16);
                    else {
                        if (!o.NUMBER_OCT.test(e)) throw Error("illegal id value: " + (r < 0 ? "-" : "") + e);
                        n = (0, N.default)(e.substring(1), 8)
                    }
                    if (n = r * n | 0, !t && n < 0) throw Error("illegal id value: " + (r < 0 ? "-" : "") + e);
                    return n
                }

                function l(e) {
                    var t = 1;
                    if ("-" == e.charAt(0) && (t = -1, e = e.substring(1)), o.NUMBER_DEC.test(e)) return t * (0, N.default)(e, 10);
                    if (o.NUMBER_HEX.test(e)) return t * (0, N.default)(e.substring(2), 16);
                    if (o.NUMBER_OCT.test(e)) return t * (0, N.default)(e.substring(1), 8);
                    if ("inf" === e) return Infinity * t;
                    if ("nan" === e) return NaN;
                    if (o.NUMBER_FLT.test(e)) return t * (0, h.default)(e);
                    throw Error("illegal number value: " + (t < 0 ? "-" : "") + e)
                }

                function u(e, t, n) {
                    void 0 === e[t] ? e[t] = n : ((0, T.default)(e[t]) || (e[t] = [e[t]]), e[t].push(n))
                }
                return a.parse = function () {
                    var e, t, n = {
                            name: "[ROOT]",
                            package: null,
                            messages: [],
                            enums: [],
                            imports: [],
                            options: {},
                            services: []
                        },
                        r = !0;
                    try {
                        for (; e = this.tn.next();) switch (e) {
                            case "package":
                                if (!r || null !== n.package) throw Error("unexpected 'package'");
                                if (e = this.tn.next(), !o.TYPEREF.test(e)) throw Error("illegal package name: " + e);
                                this.tn.skip(";"), n.package = e;
                                break;
                            case "import":
                                if (!r) throw Error("unexpected 'import'");
                                e = this.tn.peek(), "public" !== e && !(t = "weak" === e) || this.tn.next(), e = this._readString(), this.tn.skip(";"), t || n.imports.push(e);
                                break;
                            case "syntax":
                                if (!r) throw Error("unexpected 'syntax'");
                                this.tn.skip("="), "proto3" === (n.syntax = this._readString()) && (this.proto3 = !0), this.tn.skip(";");
                                break;
                            case "message":
                                this._parseMessage(n, null), r = !1;
                                break;
                            case "enum":
                                this._parseEnum(n), r = !1;
                                break;
                            case "option":
                                this._parseOption(n);
                                break;
                            case "service":
                                this._parseService(n);
                                break;
                            case "extend":
                                this._parseExtend(n);
                                break;
                            default:
                                throw Error("unexpected '" + e + "'")
                        }
                    } catch (e) {
                        throw e.message = "Parse error at line " + this.tn.line + ": " + e.message, e
                    }
                    return delete n.name, n
                }, r.parse = function (e) {
                    return new r(e).parse()
                }, a._readString = function () {
                    var e, t, n = "";
                    do {
                        if (t = this.tn.next(), "'" !== t && '"' !== t) throw Error("illegal string delimiter: " + t);
                        n += this.tn.next(), this.tn.skip(t), e = this.tn.peek()
                    } while ('"' === e || '"' === e);
                    return n
                }, a._readValue = function (e) {
                    var t = this.tn.peek();
                    if ('"' === t || "'" === t) return this._readString();
                    if (this.tn.next(), o.NUMBER.test(t)) return l(t);
                    if (o.BOOL.test(t)) return "true" === t.toLowerCase();
                    if (e && o.TYPEREF.test(t)) return t;
                    throw Error("illegal value: " + t)
                }, a._parseOption = function (e, t) {
                    var n = this.tn.next(),
                        r = !1;
                    if ("(" === n && (r = !0, n = this.tn.next()), !o.TYPEREF.test(n)) throw Error("illegal option name: " + n);
                    var i = n;
                    r && (this.tn.skip(")"), i = "(" + i + ")", n = this.tn.peek(), o.FQTYPEREF.test(n) && (i += n, this.tn.next())), this.tn.skip("="), this._parseOptionValue(e, i), t || this.tn.skip(";")
                }, a._parseOptionValue = function (e, t) {
                    var n = this.tn.peek();
                    if ("{" !== n) u(e.options, t, this._readValue(!0));
                    else
                        for (this.tn.skip("{");
                            "}" !== (n = this.tn.next());) {
                            if (!o.NAME.test(n)) throw Error("illegal option name: " + t + "." + n);
                            this.tn.omit(":") ? u(e.options, t + "." + n, this._readValue(!0)) : this._parseOptionValue(e, t + "." + n)
                        }
                }, a._parseService = function (e) {
                    var t = this.tn.next();
                    if (!o.NAME.test(t)) throw Error("illegal service name at line " + this.tn.line + ": " + t);
                    var n = t,
                        r = {
                            name: n,
                            rpc: {},
                            options: {}
                        };
                    for (this.tn.skip("{");
                        "}" !== (t = this.tn.next());)
                        if ("option" === t) this._parseOption(r);
                        else {
                            if ("rpc" !== t) throw Error("illegal service token: " + t);
                            this._parseServiceRPC(r)
                        } this.tn.omit(";"), e.services.push(r)
                }, a._parseServiceRPC = function (e) {
                    var t = "rpc",
                        n = this.tn.next();
                    if (!o.NAME.test(n)) throw Error("illegal rpc service method name: " + n);
                    var r = n,
                        i = {
                            request: null,
                            response: null,
                            request_stream: !1,
                            response_stream: !1,
                            options: {}
                        };
                    if (this.tn.skip("("), n = this.tn.next(), "stream" === n.toLowerCase() && (i.request_stream = !0, n = this.tn.next()), !o.TYPEREF.test(n)) throw Error("illegal rpc service request type: " + n);
                    if (i.request = n, this.tn.skip(")"), n = this.tn.next(), "returns" !== n.toLowerCase()) throw Error("illegal rpc service request type delimiter: " + n);
                    if (this.tn.skip("("), n = this.tn.next(), "stream" === n.toLowerCase() && (i.response_stream = !0, n = this.tn.next()), i.response = n, this.tn.skip(")"), n = this.tn.peek(), "{" === n) {
                        for (this.tn.next();
                            "}" !== (n = this.tn.next());) {
                            if ("option" !== n) throw Error("illegal rpc service token: " + n);
                            this._parseOption(i)
                        }
                        this.tn.omit(";")
                    } else this.tn.skip(";");
                    void 0 === e[t] && (e[t] = {}), e[t][r] = i
                }, a._parseMessage = function (e, t) {
                    var n = !!t,
                        r = this.tn.next(),
                        i = {
                            name: "",
                            fields: [],
                            enums: [],
                            messages: [],
                            options: {},
                            services: [],
                            oneofs: {}
                        };
                    if (!o.NAME.test(r)) throw Error("illegal " + (n ? "group" : "message") + " name: " + r);
                    for (i.name = r, n && (this.tn.skip("="), t.id = s(this.tn.next()), i.isGroup = !0), r = this.tn.peek(), "[" === r && t && this._parseFieldOptions(t), this.tn.skip("{");
                        "}" !== (r = this.tn.next());)
                        if (o.RULE.test(r)) this._parseMessageField(i, r);
                        else if ("oneof" === r) this._parseMessageOneOf(i);
                    else if ("enum" === r) this._parseEnum(i);
                    else if ("message" === r) this._parseMessage(i);
                    else if ("option" === r) this._parseOption(i);
                    else if ("service" === r) this._parseService(i);
                    else if ("extensions" === r) i.extensions = this._parseExtensionRanges();
                    else if ("reserved" === r) this._parseIgnored();
                    else if ("extend" === r) this._parseExtend(i);
                    else {
                        if (!o.TYPEREF.test(r)) throw Error("illegal message token: " + r);
                        if (!this.proto3) throw Error("illegal field rule: " + r);
                        this._parseMessageField(i, "optional", r)
                    }
                    return this.tn.omit(";"), e.messages.push(i), i
                }, a._parseIgnored = function () {
                    for (;
                        ";" !== this.tn.peek();) this.tn.next();
                    this.tn.skip(";")
                }, a._parseMessageField = function (e, t, n) {
                    if (!o.RULE.test(t)) throw Error("illegal message field rule: " + t);
                    var r, i = {
                        rule: t,
                        type: "",
                        name: "",
                        options: {},
                        id: 0
                    };
                    if ("map" === t) {
                        if (n) throw Error("illegal type: " + n);
                        if (this.tn.skip("<"), r = this.tn.next(), !o.TYPE.test(r) && !o.TYPEREF.test(r)) throw Error("illegal message field type: " + r);
                        if (i.keytype = r, this.tn.skip(","), r = this.tn.next(), !o.TYPE.test(r) && !o.TYPEREF.test(r)) throw Error("illegal message field: " + r);
                        if (i.type = r, this.tn.skip(">"), r = this.tn.next(), !o.NAME.test(r)) throw Error("illegal message field name: " + r);
                        i.name = r, this.tn.skip("="), i.id = s(this.tn.next()), r = this.tn.peek(), "[" === r && this._parseFieldOptions(i), this.tn.skip(";")
                    } else if (n = void 0 !== n ? n : this.tn.next(), "group" === n) {
                        var a = this._parseMessage(e, i);
                        if (!/^[A-Z]/.test(a.name)) throw Error("illegal group name: " + a.name);
                        i.type = a.name, i.name = a.name.toLowerCase(), this.tn.omit(";")
                    } else {
                        if (!o.TYPE.test(n) && !o.TYPEREF.test(n)) throw Error("illegal message field type: " + n);
                        if (i.type = n, r = this.tn.next(), !o.NAME.test(r)) throw Error("illegal message field name: " + r);
                        i.name = r, this.tn.skip("="), i.id = s(this.tn.next()), r = this.tn.peek(), "[" === r && this._parseFieldOptions(i), this.tn.skip(";")
                    }
                    return e.fields.push(i), i
                }, a._parseMessageOneOf = function (e) {
                    var t = this.tn.next();
                    if (!o.NAME.test(t)) throw Error("illegal oneof name: " + t);
                    var n, r = t,
                        i = [];
                    for (this.tn.skip("{");
                        "}" !== (t = this.tn.next());) n = this._parseMessageField(e, "optional", t), n.oneof = r, i.push(n.id);
                    this.tn.omit(";"), e.oneofs[r] = i
                }, a._parseFieldOptions = function (e) {
                    this.tn.skip("[");
                    for (var t = !0;
                        "]" !== this.tn.peek();) t || this.tn.skip(","), this._parseOption(e, !0), t = !1;
                    this.tn.next()
                }, a._parseEnum = function (e) {
                    var t = {
                            name: "",
                            values: [],
                            options: {}
                        },
                        n = this.tn.next();
                    if (!o.NAME.test(n)) throw Error("illegal name: " + n);
                    for (t.name = n, this.tn.skip("{");
                        "}" !== (n = this.tn.next());)
                        if ("option" === n) this._parseOption(t);
                        else {
                            if (!o.NAME.test(n)) throw Error("illegal name: " + n);
                            this.tn.skip("=");
                            var r = {
                                name: n,
                                id: s(this.tn.next(), !0)
                            };
                            n = this.tn.peek(), "[" === n && this._parseFieldOptions({
                                options: {}
                            }), this.tn.skip(";"), t.values.push(r)
                        } this.tn.omit(";"), e.enums.push(t)
                }, a._parseExtensionRanges = function () {
                    var e, t, n, r = [];
                    do {
                        for (t = [];;) {
                            switch (e = this.tn.next(), e) {
                                case "min":
                                    n = i.ID_MIN;
                                    break;
                                case "max":
                                    n = i.ID_MAX;
                                    break;
                                default:
                                    n = l(e)
                            }
                            if (t.push(n), 2 === t.length) break;
                            if ("to" !== this.tn.peek()) {
                                t.push(n);
                                break
                            }
                            this.tn.next()
                        }
                        r.push(t)
                    } while (this.tn.omit(","));
                    return this.tn.skip(";"), r
                }, a._parseExtend = function (e) {
                    var t = this.tn.next();
                    if (!o.TYPEREF.test(t)) throw Error("illegal extend reference: " + t);
                    var n = {
                        ref: t,
                        fields: []
                    };
                    for (this.tn.skip("{");
                        "}" !== (t = this.tn.next());)
                        if (o.RULE.test(t)) this._parseMessageField(n, t);
                        else {
                            if (!o.TYPEREF.test(t)) throw Error("illegal extend token: " + t);
                            if (!this.proto3) throw Error("illegal field rule: " + t);
                            this._parseMessageField(n, "optional", t)
                        } return this.tn.omit(";"), e.messages.push(n), n
                }, a.toString = function () {
                    return "Parser at line " + this.tn.line
                }, e.Parser = r, e
            }(ne, ne.Lang), ne.Reflect = function (g) {
                var o = {},
                    h = function (e, t, n) {
                        this.builder = e, this.parent = t, this.name = n, this.className
                    },
                    e = h.prototype;
                e.fqn = function () {
                    for (var e = this.name, t = this; t = t.parent, null != t;) e = t.name + "." + e;
                    return e
                }, e.toString = function (e) {
                    return (e ? this.className + " " : "") + this.fqn()
                }, e.build = function () {
                    throw Error(this.toString(!0) + " cannot be built directly")
                }, o.T = h;
                var s = function (e, t, n, r, i) {
                        h.call(this, e, t, n), this.className = "Namespace", this.children = [], this.options = r || {}, this.syntax = i || "proto2"
                    },
                    t = s.prototype = (0, E.default)(h.prototype);
                t.getChildren = function (e) {
                    if (e = e || null, null == e) return this.children.slice();
                    for (var t = [], n = 0, r = this.children.length; n < r; ++n) this.children[n] instanceof e && t.push(this.children[n]);
                    return t
                }, t.addChild = function (e) {
                    var t;
                    if (t = this.getChild(e.name))
                        if (t instanceof d.Field && t.name !== t.originalName && null === this.getChild(t.originalName)) t.name = t.originalName;
                        else {
                            if (!(e instanceof d.Field && e.name !== e.originalName && null === this.getChild(e.originalName))) throw Error("Duplicate name in namespace " + this.toString(!0) + ": " + e.name);
                            e.name = e.originalName
                        } this.children.push(e)
                }, t.getChild = function (e) {
                    for (var t = "number" == typeof e ? "id" : "name", n = 0, r = this.children.length; n < r; ++n)
                        if (this.children[n][t] === e) return this.children[n];
                    return null
                }, t.resolve = function (e, t) {
                    var n, r = "string" == typeof e ? e.split(".") : e,
                        i = this,
                        a = 0;
                    if ("" === r[a]) {
                        for (; null !== i.parent;) i = i.parent;
                        a++
                    }
                    do {
                        do {
                            if (!(i instanceof o.Namespace)) {
                                i = null;
                                break
                            }
                            if (n = i.getChild(r[a]), !n || !(n instanceof o.T) || t && !(n instanceof o.Namespace)) {
                                i = null;
                                break
                            }
                            i = n, a++
                        } while (a < r.length);
                        if (null != i) break;
                        if (null !== this.parent) return this.parent.resolve(e, t)
                    } while (null != i);
                    return i
                }, t.qn = function (e) {
                    for (var t = [], n = e; t.unshift(n.name), n = n.parent, null !== n;);
                    for (var r = 1; r <= t.length; r++) {
                        var i = t.slice(t.length - r);
                        if (e === this.resolve(i, e instanceof o.Namespace)) return i.join(".")
                    }
                    return e.fqn()
                }, t.build = function () {
                    for (var e, t = {}, n = this.children, r = 0, i = n.length; r < i; ++r) e = n[r], e instanceof s && (t[e.name] = e.build());
                    return R.default && (0, R.default)(t, "$options", {
                        value: this.buildOpt()
                    }), t
                }, t.buildOpt = function () {
                    for (var e = {}, t = (0, S.default)(this.options), n = 0, r = t.length; n < r; ++n) {
                        var i = t[n],
                            a = this.options[t[n]];
                        e[i] = a
                    }
                    return e
                }, t.getOption = function (e) {
                    return void 0 === e ? this.options : void 0 !== this.options[e] ? this.options[e] : null
                }, o.Namespace = s;
                var c = function (e, t, n, r) {
                        if (this.type = e, this.resolvedType = t, this.isMapKey = n, this.syntax = r, n && g.MAP_KEY_TYPES.indexOf(e) < 0) throw Error("Invalid map key type: " + e.name)
                    },
                    n = c.prototype;

                function r(e) {
                    if ("string" == typeof e && (e = g.TYPES[e]), void 0 === e.defaultValue) throw Error("default value for type " + e.name + " is not supported");
                    return e == g.TYPES.bytes ? new O(0) : e.defaultValue
                }

                function l(e, t) {
                    if (e && "number" == typeof e.low && "number" == typeof e.high && "boolean" == typeof e.unsigned && e.low == e.low && e.high == e.high) return new g.Long(e.low, e.high, void 0 === t ? e.unsigned : t);
                    if ("string" == typeof e) return g.Long.fromString(e, t || !1, 10);
                    if ("number" == typeof e) return g.Long.fromNumber(e, t || !1);
                    throw Error("not convertible to Long")
                }
                c.defaultFieldValue = r, n.verifyValue = function (t) {
                    var n = this;

                    function r(e, t) {
                        throw Error("Illegal value for " + n.toString(!0) + " of type " + n.type.name + ": " + e + " (" + t + ")")
                    }
                    switch (this.type) {
                        case g.TYPES.int32:
                        case g.TYPES.sint32:
                        case g.TYPES.sfixed32:
                            return ("number" != typeof t || t == t && t % 1 != 0) && r((0, L.default)(t), "not an integer"), 4294967295 < t ? 0 | t : t;
                        case g.TYPES.uint32:
                        case g.TYPES.fixed32:
                            return ("number" != typeof t || t == t && t % 1 != 0) && r((0, L.default)(t), "not an integer"), t < 0 ? t >>> 0 : t;
                        case g.TYPES.int64:
                        case g.TYPES.sint64:
                        case g.TYPES.sfixed64:
                            if (g.Long) try {
                                return l(t, !1)
                            } catch (e) {
                                r((0, L.default)(t), e.message)
                            } else r((0, L.default)(t), "requires Long.js");
                        case g.TYPES.uint64:
                        case g.TYPES.fixed64:
                            if (g.Long) try {
                                return l(t, !0)
                            } catch (e) {
                                r((0, L.default)(t), e.message)
                            } else r((0, L.default)(t), "requires Long.js");
                        case g.TYPES.bool:
                            return "boolean" != typeof t && r((0, L.default)(t), "not a boolean"), t;
                        case g.TYPES.float:
                        case g.TYPES.double:
                            return "number" != typeof t && r((0, L.default)(t), "not a number"), t;
                        case g.TYPES.string:
                            return "string" == typeof t || t && t instanceof String || r((0, L.default)(t), "not a string"), "" + t;
                        case g.TYPES.bytes:
                            return O.isByteBuffer(t) ? t : O.wrap(t, "base64");
                        case g.TYPES.enum:
                            var e = this.resolvedType.getChildren(g.Reflect.Enum.Value);
                            for (a = 0; a < e.length; a++) {
                                if (e[a].name == t) return e[a].id;
                                if (e[a].id == t) return e[a].id
                            }
                            if ("proto3" === this.syntax) return ("number" != typeof t || t == t && t % 1 != 0) && r((0, L.default)(t), "not an integer"), (4294967295 < t || t < 0) && r((0, L.default)(t), "not in range for uint32"), t;
                            r(t, "not a valid enum value");
                        case g.TYPES.group:
                        case g.TYPES.message:
                            if (t && "object" === (0, L.default)(t) || r((0, L.default)(t), "object expected"), t instanceof this.resolvedType.clazz) return t;
                            if (t instanceof g.Builder.Message) {
                                var i = {};
                                for (var a in t) t.hasOwnProperty(a) && (i[a] = t[a]);
                                t = i
                            }
                            return new this.resolvedType.clazz(t)
                    }
                    throw Error("[INTERNAL] Illegal value for " + this.toString(!0) + ": " + t + " (undefined type " + this.type + ")")
                }, n.calculateLength = function (e, t) {
                    if (null === t) return 0;
                    var n;
                    switch (this.type) {
                        case g.TYPES.int32:
                            return t < 0 ? O.calculateVarint64(t) : O.calculateVarint32(t);
                        case g.TYPES.uint32:
                            return O.calculateVarint32(t);
                        case g.TYPES.sint32:
                            return O.calculateVarint32(O.zigZagEncode32(t));
                        case g.TYPES.fixed32:
                        case g.TYPES.sfixed32:
                        case g.TYPES.float:
                            return 4;
                        case g.TYPES.int64:
                        case g.TYPES.uint64:
                            return O.calculateVarint64(t);
                        case g.TYPES.sint64:
                            return O.calculateVarint64(O.zigZagEncode64(t));
                        case g.TYPES.fixed64:
                        case g.TYPES.sfixed64:
                            return 8;
                        case g.TYPES.bool:
                            return 1;
                        case g.TYPES.enum:
                            return O.calculateVarint32(t);
                        case g.TYPES.double:
                            return 8;
                        case g.TYPES.string:
                            return n = O.calculateUTF8Bytes(t), O.calculateVarint32(n) + n;
                        case g.TYPES.bytes:
                            if (t.remaining() < 0) throw Error("Illegal value for " + this.toString(!0) + ": " + t.remaining() + " bytes remaining");
                            return O.calculateVarint32(t.remaining()) + t.remaining();
                        case g.TYPES.message:
                            return n = this.resolvedType.calculate(t), O.calculateVarint32(n) + n;
                        case g.TYPES.group:
                            return n = this.resolvedType.calculate(t), n + O.calculateVarint32(e << 3 | g.WIRE_TYPES.ENDGROUP)
                    }
                    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + t + " (unknown type)")
                }, n.encodeValue = function (e, t, n) {
                    if (null === t) return n;
                    switch (this.type) {
                        case g.TYPES.int32:
                            t < 0 ? n.writeVarint64(t) : n.writeVarint32(t);
                            break;
                        case g.TYPES.uint32:
                            n.writeVarint32(t);
                            break;
                        case g.TYPES.sint32:
                            n.writeVarint32ZigZag(t);
                            break;
                        case g.TYPES.fixed32:
                            n.writeUint32(t);
                            break;
                        case g.TYPES.sfixed32:
                            n.writeInt32(t);
                            break;
                        case g.TYPES.int64:
                        case g.TYPES.uint64:
                            n.writeVarint64(t);
                            break;
                        case g.TYPES.sint64:
                            n.writeVarint64ZigZag(t);
                            break;
                        case g.TYPES.fixed64:
                            n.writeUint64(t);
                            break;
                        case g.TYPES.sfixed64:
                            n.writeInt64(t);
                            break;
                        case g.TYPES.bool:
                            "string" == typeof t ? n.writeVarint32("false" === t.toLowerCase() ? 0 : !!t) : n.writeVarint32(t ? 1 : 0);
                            break;
                        case g.TYPES.enum:
                            n.writeVarint32(t);
                            break;
                        case g.TYPES.float:
                            n.writeFloat32(t);
                            break;
                        case g.TYPES.double:
                            n.writeFloat64(t);
                            break;
                        case g.TYPES.string:
                            n.writeVString(t);
                            break;
                        case g.TYPES.bytes:
                            if (t.remaining() < 0) throw Error("Illegal value for " + this.toString(!0) + ": " + t.remaining() + " bytes remaining");
                            var r = t.offset;
                            n.writeVarint32(t.remaining()), n.append(t), t.offset = r;
                            break;
                        case g.TYPES.message:
                            var i = (new O).LE();
                            this.resolvedType.encode(t, i), n.writeVarint32(i.offset), n.append(i.flip());
                            break;
                        case g.TYPES.group:
                            this.resolvedType.encode(t, n), n.writeVarint32(e << 3 | g.WIRE_TYPES.ENDGROUP);
                            break;
                        default:
                            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + t + " (unknown type)")
                    }
                    return n
                }, n.decode = function (e, t, n) {
                    if (t != this.type.wireType) throw Error("Unexpected wire type for element");
                    var r, i;
                    switch (this.type) {
                        case g.TYPES.int32:
                            return 0 | e.readVarint32();
                        case g.TYPES.uint32:
                            return e.readVarint32() >>> 0;
                        case g.TYPES.sint32:
                            return 0 | e.readVarint32ZigZag();
                        case g.TYPES.fixed32:
                            return e.readUint32() >>> 0;
                        case g.TYPES.sfixed32:
                            return 0 | e.readInt32();
                        case g.TYPES.int64:
                            return e.readVarint64();
                        case g.TYPES.uint64:
                            return e.readVarint64().toUnsigned();
                        case g.TYPES.sint64:
                            return e.readVarint64ZigZag();
                        case g.TYPES.fixed64:
                            return e.readUint64();
                        case g.TYPES.sfixed64:
                            return e.readInt64();
                        case g.TYPES.bool:
                            return !!e.readVarint32();
                        case g.TYPES.enum:
                            return e.readVarint32();
                        case g.TYPES.float:
                            return e.readFloat();
                        case g.TYPES.double:
                            return e.readDouble();
                        case g.TYPES.string:
                            return e.readVString();
                        case g.TYPES.bytes:
                            if (i = e.readVarint32(), e.remaining() < i) throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + i + " required but got only " + e.remaining());
                            return r = e.clone(), r.limit = r.offset + i, e.offset += i, r;
                        case g.TYPES.message:
                            return i = e.readVarint32(), this.resolvedType.decode(e, i);
                        case g.TYPES.group:
                            return this.resolvedType.decode(e, -1, n)
                    }
                    throw Error("[INTERNAL] Illegal decode type")
                }, n.valueFromString = function (e) {
                    if (!this.isMapKey) throw Error("valueFromString() called on non-map-key element");
                    switch (this.type) {
                        case g.TYPES.int32:
                        case g.TYPES.sint32:
                        case g.TYPES.sfixed32:
                        case g.TYPES.uint32:
                        case g.TYPES.fixed32:
                            return this.verifyValue((0, N.default)(e));
                        case g.TYPES.int64:
                        case g.TYPES.sint64:
                        case g.TYPES.sfixed64:
                        case g.TYPES.uint64:
                        case g.TYPES.fixed64:
                            return this.verifyValue(e);
                        case g.TYPES.bool:
                            return "true" === e;
                        case g.TYPES.string:
                            return this.verifyValue(e);
                        case g.TYPES.bytes:
                            return O.fromBinary(e)
                    }
                }, n.valueToString = function (e) {
                    if (!this.isMapKey) throw Error("valueToString() called on non-map-key element");
                    return this.type === g.TYPES.bytes ? e.toString("binary") : e.toString()
                }, o.Element = c;
                var d = function (e, t, n, r, i, a) {
                        s.call(this, e, t, n, r, a), this.className = "Message", this.extensions = void 0, this.clazz = null, this.isGroup = !!i, this._fields = null, this._fieldsById = null, this._fieldsByName = null
                    },
                    i = d.prototype = (0, E.default)(s.prototype);

                function m(e, t) {
                    var n = t.readVarint32(),
                        r = 7 & n,
                        i = n >>> 3;
                    switch (r) {
                        case g.WIRE_TYPES.VARINT:
                            for (; n = t.readUint8(), 128 == (128 & n););
                            break;
                        case g.WIRE_TYPES.BITS64:
                            t.offset += 8;
                            break;
                        case g.WIRE_TYPES.LDELIM:
                            n = t.readVarint32(), t.offset += n;
                            break;
                        case g.WIRE_TYPES.STARTGROUP:
                            m(i, t);
                            break;
                        case g.WIRE_TYPES.ENDGROUP:
                            if (i === e) return !1;
                            throw Error("Illegal GROUPEND after unknown group: " + i + " (" + e + " expected)");
                        case g.WIRE_TYPES.BITS32:
                            t.offset += 4;
                            break;
                        default:
                            throw Error("Illegal wire type in unknown group " + e + ": " + r)
                    }
                    return !0
                }
                i.build = function (e) {
                    if (this.clazz && !e) return this.clazz;
                    var t = function (c, o) {
                        var s = o.getChildren(c.Reflect.Message.Field),
                            l = o.getChildren(c.Reflect.Message.OneOf),
                            r = function e(t) {
                                c.Builder.Message.call(this);
                                for (var n = 0, r = l.length; n < r; ++n) this[l[n].name] = null;
                                for (n = 0, r = s.length; n < r; ++n) {
                                    var i = s[n];
                                    this[i.name] = i.repeated ? [] : i.map ? new c.Map(i) : null, !i.required && "proto3" !== o.syntax || null === i.defaultValue || (this[i.name] = i.defaultValue)
                                }
                                var a;
                                if (0 < arguments.length)
                                    if (1 !== arguments.length || null === t || "object" !== (0, L.default)(t) || !("function" != typeof t.encode || t instanceof e) || (0, T.default)(t) || t instanceof c.Map || O.isByteBuffer(t) || t instanceof ArrayBuffer || c.Long && t instanceof c.Long)
                                        for (n = 0, r = arguments.length; n < r; ++n) void 0 !== (a = arguments[n]) && this.$set(s[n].name, a);
                                    else this.$set(t)
                            },
                            a = r.prototype = (0, E.default)(c.Builder.Message.prototype);
                        a.add = function (e, t, n) {
                            var r = o._fieldsByName[e];
                            if (!n) {
                                if (!r) throw Error(this + "#" + e + " is undefined");
                                if (!(r instanceof c.Reflect.Message.Field)) throw Error(this + "#" + e + " is not a field: " + r.toString(!0));
                                if (!r.repeated) throw Error(this + "#" + e + " is not a repeated field");
                                t = r.verifyValue(t, !0)
                            }
                            return null === this[e] && (this[e] = []), this[e].push(t), this
                        }, a.$add = a.add, a.set = function (e, t, n) {
                            if (e && "object" === (0, L.default)(e)) {
                                for (var r in n = t, e) e.hasOwnProperty(r) && void 0 !== (t = e[r]) && this.$set(r, t, n);
                                return this
                            }
                            var i = o._fieldsByName[e];
                            if (n) this[e] = t;
                            else {
                                if (!i) throw Error(this + "#" + e + " is not a field: undefined");
                                if (!(i instanceof c.Reflect.Message.Field)) throw Error(this + "#" + e + " is not a field: " + i.toString(!0));
                                this[i.name] = t = i.verifyValue(t)
                            }
                            if (i && i.oneof) {
                                var a = this[i.oneof.name];
                                null !== t ? (null !== a && a !== i.name && (this[a] = null), this[i.oneof.name] = i.name) : a === e && (this[i.oneof.name] = null)
                            }
                            return this
                        }, a.$set = a.set, a.get = function (e, t) {
                            if (t) return this[e];
                            var n = o._fieldsByName[e];
                            if (!(n && n instanceof c.Reflect.Message.Field)) throw Error(this + "#" + e + " is not a field: undefined");
                            if (!(n instanceof c.Reflect.Message.Field)) throw Error(this + "#" + e + " is not a field: " + n.toString(!0));
                            return this[n.name]
                        }, a.$get = a.get;
                        for (var e = 0; e < s.length; e++) {
                            var t = s[e];
                            t instanceof c.Reflect.Message.ExtensionField || o.builder.options.populateAccessors && function (n) {
                                var e = n.originalName.replace(/(_[a-zA-Z])/g, function (e) {
                                    return e.toUpperCase().replace("_", "")
                                });
                                e = e.substring(0, 1).toUpperCase() + e.substring(1);
                                var t = n.originalName.replace(/([A-Z])/g, function (e) {
                                        return "_" + e
                                    }),
                                    r = function (e, t) {
                                        return this[n.name] = t ? e : n.verifyValue(e), this
                                    },
                                    i = function () {
                                        return this[n.name]
                                    };
                                null === o.getChild("set" + e) && (a["set" + e] = r), null === o.getChild("set_" + t) && (a["set_" + t] = r), null === o.getChild("get" + e) && (a["get" + e] = i), null === o.getChild("get_" + t) && (a["get_" + t] = i)
                            }(t)
                        }

                        function d(e, n, r, i) {
                            if (null === e || "object" !== (0, L.default)(e)) {
                                if (i && i instanceof c.Reflect.Enum) {
                                    var t = c.Reflect.Enum.getName(i.object, e);
                                    if (null !== t) return t
                                }
                                return e
                            }
                            if (O.isByteBuffer(e)) return n ? e.toBase64() : e.toBuffer();
                            if (c.Long.isLong(e)) return r ? e.toString() : c.Long.fromValue(e);
                            var a;
                            if ((0, T.default)(e)) return a = [], e.forEach(function (e, t) {
                                a[t] = d(e, n, r, i)
                            }), a;
                            if (a = {}, e instanceof c.Map) {
                                for (var o = e.entries(), s = o.next(); !s.done; s = o.next()) a[e.keyElem.valueToString(s.value[0])] = d(s.value[1], n, r, e.valueElem.resolvedType);
                                return a
                            }
                            var l = e.$type,
                                u = void 0;
                            for (var h in e) e.hasOwnProperty(h) && (l && (u = l.getChild(h)) ? a[h] = d(e[h], n, r, u.resolvedType) : a[h] = d(e[h], n, r));
                            return a
                        }
                        return a.encode = function (t, e) {
                            "boolean" == typeof t && (e = t, t = void 0);
                            var n = !1;
                            t || (t = new O, n = !0);
                            var r = t.littleEndian;
                            try {
                                return o.encode(this, t.LE(), e), (n ? t.flip() : t).LE(r)
                            } catch (e) {
                                throw t.LE(r), e
                            }
                        }, r.encode = function (e, t, n) {
                            return new r(e).encode(t, n)
                        }, a.calculate = function () {
                            return o.calculate(this)
                        }, a.encodeDelimited = function (e, t) {
                            var n = !1;
                            e || (e = new O, n = !0);
                            var r = (new O).LE();
                            return o.encode(this, r, t).flip(), e.writeVarint32(r.remaining()), e.append(r), n ? e.flip() : e
                        }, a.encodeAB = function () {
                            try {
                                return this.encode().toArrayBuffer()
                            } catch (e) {
                                throw e.encoded && (e.encoded = e.encoded.toArrayBuffer()), e
                            }
                        }, a.toArrayBuffer = a.encodeAB, a.encodeNB = function () {
                            try {
                                return this.encode().toBuffer()
                            } catch (e) {
                                throw e.encoded && (e.encoded = e.encoded.toBuffer()), e
                            }
                        }, a.toBuffer = a.encodeNB, a.encode64 = function () {
                            try {
                                return this.encode().toBase64()
                            } catch (e) {
                                throw e.encoded && (e.encoded = e.encoded.toBase64()), e
                            }
                        }, a.toBase64 = a.encode64, a.encodeHex = function () {
                            try {
                                return this.encode().toHex()
                            } catch (e) {
                                throw e.encoded && (e.encoded = e.encoded.toHex()), e
                            }
                        }, a.toHex = a.encodeHex, a.toRaw = function (e, t) {
                            return d(this, !!e, !!t, this.$type)
                        }, a.encodeJSON = function () {
                            return (0, b.default)(d(this, !0, !0, this.$type))
                        }, r.decode = function (t, e, n) {
                            "string" == typeof e && (n = e, e = -1), "string" == typeof t && (t = O.wrap(t, n || "base64")), t = O.isByteBuffer(t) ? t : O.wrap(t);
                            var r = t.littleEndian;
                            try {
                                var i = o.decode(t.LE());
                                return t.LE(r), i
                            } catch (e) {
                                throw t.LE(r), e
                            }
                        }, r.decodeDelimited = function (t, e) {
                            if ("string" == typeof t && (t = O.wrap(t, e || "base64")), t = O.isByteBuffer(t) ? t : O.wrap(t), t.remaining() < 1) return null;
                            var n = t.offset,
                                r = t.readVarint32();
                            if (t.remaining() < r) return t.offset = n, null;
                            try {
                                var i = o.decode(t.slice(t.offset, t.offset + r).LE());
                                return t.offset += r, i
                            } catch (e) {
                                throw t.offset += r, e
                            }
                        }, r.decode64 = function (e) {
                            return r.decode(e, "base64")
                        }, r.decodeHex = function (e) {
                            return r.decode(e, "hex")
                        }, r.decodeJSON = function (e) {
                            return new r(JSON.parse(e))
                        }, a.toString = function () {
                            return o.toString()
                        }, R.default && ((0, R.default)(r, "$options", {
                            value: o.buildOpt()
                        }), (0, R.default)(a, "$options", {
                            value: r.$options
                        }), (0, R.default)(r, "$type", {
                            value: o
                        }), (0, R.default)(a, "$type", {
                            value: o
                        })), r
                    }(g, this);
                    this._fields = [], this._fieldsById = {}, this._fieldsByName = {};
                    for (var n, r = 0, i = this.children.length; r < i; r++)
                        if (n = this.children[r], n instanceof v || n instanceof d || n instanceof x) {
                            if (t.hasOwnProperty(n.name)) throw Error("Illegal reflect child of " + this.toString(!0) + ": " + n.toString(!0) + " cannot override static property '" + n.name + "'");
                            t[n.name] = n.build()
                        } else if (n instanceof d.Field) n.build(), this._fields.push(n), this._fieldsById[n.id] = n, this._fieldsByName[n.name] = n;
                    else if (!(n instanceof d.OneOf || n instanceof A)) throw Error("Illegal reflect child of " + this.toString(!0) + ": " + this.children[r].toString(!0));
                    return this.clazz = t
                }, i.encode = function (e, t, n) {
                    for (var r, i, a = null, o = 0, s = this._fields.length; o < s; ++o) r = this._fields[o], i = e[r.name], r.required && null === i ? null === a && (a = r) : r.encode(n ? i : r.verifyValue(i), t, e);
                    if (null === a) return t;
                    var l = Error("Missing at least one required field for " + this.toString(!0) + ": " + a);
                    throw l.encoded = t, l
                }, i.calculate = function (e) {
                    for (var t, n, r = 0, i = 0, a = this._fields.length; i < a; ++i) {
                        if (t = this._fields[i], n = e[t.name], t.required && null === n) throw Error("Missing at least one required field for " + this.toString(!0) + ": " + t);
                        r += t.calculate(n, e)
                    }
                    return r
                }, i.decode = function (e, t, n) {
                    t = "number" == typeof t ? t : -1;
                    for (var r, i, a, o, s = e.offset, l = new this.clazz; e.offset < s + t || -1 === t && 0 < e.remaining();) {
                        if (r = e.readVarint32(), i = 7 & r, a = r >>> 3, i === g.WIRE_TYPES.ENDGROUP) {
                            if (a !== n) throw Error("Illegal group end indicator for " + this.toString(!0) + ": " + a + " (" + (n ? n + " expected" : "not a group") + ")");
                            break
                        }
                        if (o = this._fieldsById[a]) {
                            if (o.repeated && !o.options.packed) l[o.name].push(o.decode(i, e));
                            else if (o.map) {
                                var u = o.decode(i, e);
                                l[o.name].set(u[0], u[1])
                            } else if (l[o.name] = o.decode(i, e), o.oneof) {
                                var h = l[o.oneof.name];
                                null !== h && h !== o.name && (l[h] = null), l[o.oneof.name] = o.name
                            }
                        } else switch (i) {
                            case g.WIRE_TYPES.VARINT:
                                e.readVarint32();
                                break;
                            case g.WIRE_TYPES.BITS32:
                                e.offset += 4;
                                break;
                            case g.WIRE_TYPES.BITS64:
                                e.offset += 8;
                                break;
                            case g.WIRE_TYPES.LDELIM:
                                var c = e.readVarint32();
                                e.offset += c;
                                break;
                            case g.WIRE_TYPES.STARTGROUP:
                                for (; m(a, e););
                                break;
                            default:
                                throw Error("Illegal wire type for unknown field " + a + " in " + this.toString(!0) + "#decode: " + i)
                        }
                    }
                    for (var d = 0, f = this._fields.length; d < f; ++d)
                        if (o = this._fields[d], null === l[o.name])
                            if ("proto3" === this.syntax) l[o.name] = o.defaultValue;
                            else {
                                if (o.required) {
                                    var p = Error("Missing at least one required field for " + this.toString(!0) + ": " + o.name);
                                    throw p.decoded = l, p
                                }
                                g.populateDefaults && null !== o.defaultValue && (l[o.name] = o.defaultValue)
                            } return l
                }, o.Message = d;
                var u = function (e, t, n, r, i, a, o, s, l, u) {
                        h.call(this, e, t, a), this.className = "Message.Field", this.required = "required" === n, this.repeated = "repeated" === n, this.map = "map" === n, this.keyType = r || null, this.type = i, this.resolvedType = null, this.id = o, this.options = s || {}, this.defaultValue = null, this.oneof = l || null, this.syntax = u || "proto2", this.originalName = this.name, this.element = null, this.keyElement = null, !this.builder.options.convertFieldsToCamelCase || this instanceof d.ExtensionField || (this.name = g.Util.toCamelCase(this.name))
                    },
                    a = u.prototype = (0, E.default)(h.prototype);
                a.build = function () {
                    this.element = new c(this.type, this.resolvedType, !1, this.syntax), this.map && (this.keyElement = new c(this.keyType, void 0, !0, this.syntax)), "proto3" !== this.syntax || this.repeated || this.map ? void 0 !== this.options.default && (this.defaultValue = this.verifyValue(this.options.default)) : this.defaultValue = c.defaultFieldValue(this.type)
                }, a.verifyValue = function (e, t) {
                    t = t || !1;
                    var n, r = this;

                    function i(e, t) {
                        throw Error("Illegal value for " + r.toString(!0) + " of type " + r.type.name + ": " + e + " (" + t + ")")
                    }
                    if (null === e) return this.required && i((0, L.default)(e), "required"), "proto3" === this.syntax && this.type !== g.TYPES.message && i((0, L.default)(e), "proto3 field without field presence cannot be null"), null;
                    if (!this.repeated || t) return this.map && !t ? e instanceof g.Map ? e : (e instanceof Object || i((0, L.default)(e), "expected ProtoBuf.Map or raw object for map field"), new g.Map(this, e)) : (!this.repeated && (0, T.default)(e) && i((0, L.default)(e), "no array expected"), this.element.verifyValue(e));
                    (0, T.default)(e) || (e = [e]);
                    var a = [];
                    for (n = 0; n < e.length; n++) a.push(this.element.verifyValue(e[n]));
                    return a
                }, a.hasWirePresence = function (e, t) {
                    if ("proto3" !== this.syntax) return null !== e;
                    if (this.oneof && t[this.oneof.name] === this.name) return !0;
                    switch (this.type) {
                        case g.TYPES.int32:
                        case g.TYPES.sint32:
                        case g.TYPES.sfixed32:
                        case g.TYPES.uint32:
                        case g.TYPES.fixed32:
                            return 0 !== e;
                        case g.TYPES.int64:
                        case g.TYPES.sint64:
                        case g.TYPES.sfixed64:
                        case g.TYPES.uint64:
                        case g.TYPES.fixed64:
                            return 0 !== e.low || 0 !== e.high;
                        case g.TYPES.bool:
                            return e;
                        case g.TYPES.float:
                        case g.TYPES.double:
                            return 0 !== e;
                        case g.TYPES.string:
                            return 0 < e.length;
                        case g.TYPES.bytes:
                            return 0 < e.remaining();
                        case g.TYPES.enum:
                            return 0 !== e;
                        case g.TYPES.message:
                            return null !== e;
                        default:
                            return !0
                    }
                }, a.encode = function (t, r, e) {
                    if (null === this.type || "object" !== (0, L.default)(this.type)) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
                    if (null === t || this.repeated && 0 == t.length) return r;
                    try {
                        var n;
                        if (this.repeated)
                            if (this.options.packed && 0 <= g.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType)) {
                                r.writeVarint32(this.id << 3 | g.WIRE_TYPES.LDELIM), r.ensureCapacity(r.offset += 1);
                                var i = r.offset;
                                for (n = 0; n < t.length; n++) this.element.encodeValue(this.id, t[n], r);
                                var a = r.offset - i,
                                    o = O.calculateVarint32(a);
                                if (1 < o) {
                                    var s = r.slice(i, r.offset);
                                    i += o - 1, r.offset = i, r.append(s)
                                }
                                r.writeVarint32(a, i - o)
                            } else
                                for (n = 0; n < t.length; n++) r.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, t[n], r);
                        else this.map ? t.forEach(function (e, t) {
                            var n = O.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, t) + O.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, e);
                            r.writeVarint32(this.id << 3 | g.WIRE_TYPES.LDELIM), r.writeVarint32(n), r.writeVarint32(8 | this.keyType.wireType), this.keyElement.encodeValue(1, t, r), r.writeVarint32(16 | this.type.wireType), this.element.encodeValue(2, e, r)
                        }, this) : this.hasWirePresence(t, e) && (r.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, t, r))
                    } catch (e) {
                        throw Error("Illegal value for " + this.toString(!0) + ": " + t + " (" + e + ")")
                    }
                    return r
                }, a.calculate = function (t, e) {
                    if (t = this.verifyValue(t), null === this.type || "object" !== (0, L.default)(this.type)) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
                    if (null === t || this.repeated && 0 == t.length) return 0;
                    var r = 0;
                    try {
                        var n, i;
                        if (this.repeated)
                            if (this.options.packed && 0 <= g.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType)) {
                                for (r += O.calculateVarint32(this.id << 3 | g.WIRE_TYPES.LDELIM), i = 0, n = 0; n < t.length; n++) i += this.element.calculateLength(this.id, t[n]);
                                r += O.calculateVarint32(i), r += i
                            } else
                                for (n = 0; n < t.length; n++) r += O.calculateVarint32(this.id << 3 | this.type.wireType), r += this.element.calculateLength(this.id, t[n]);
                        else this.map ? t.forEach(function (e, t) {
                            var n = O.calculateVarint32(8 | this.keyType.wireType) + this.keyElement.calculateLength(1, t) + O.calculateVarint32(16 | this.type.wireType) + this.element.calculateLength(2, e);
                            r += O.calculateVarint32(this.id << 3 | g.WIRE_TYPES.LDELIM), r += O.calculateVarint32(n), r += n
                        }, this) : this.hasWirePresence(t, e) && (r += O.calculateVarint32(this.id << 3 | this.type.wireType), r += this.element.calculateLength(this.id, t))
                    } catch (e) {
                        throw Error("Illegal value for " + this.toString(!0) + ": " + t + " (" + e + ")")
                    }
                    return r
                }, a.decode = function (e, t, n) {
                    var r, i, a = !this.map && e == this.type.wireType || !n && this.repeated && this.options.packed && e == g.WIRE_TYPES.LDELIM || this.map && e == g.WIRE_TYPES.LDELIM;
                    if (!a) throw Error("Illegal wire type for field " + this.toString(!0) + ": " + e + " (" + this.type.wireType + " expected)");
                    if (e == g.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && 0 <= g.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) && !n) {
                        i = t.readVarint32(), i = t.offset + i;
                        for (var o = []; t.offset < i;) o.push(this.decode(this.type.wireType, t, !0));
                        return o
                    }
                    if (this.map) {
                        var s = c.defaultFieldValue(this.keyType);
                        if (r = c.defaultFieldValue(this.type), i = t.readVarint32(), t.remaining() < i) throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + i + " required but got only " + t.remaining());
                        var l = t.clone();
                        for (l.limit = l.offset + i, t.offset += i; 0 < l.remaining();) {
                            var u = l.readVarint32();
                            e = 7 & u;
                            var h = u >>> 3;
                            if (1 === h) s = this.keyElement.decode(l, e, h);
                            else {
                                if (2 !== h) throw Error("Unexpected tag in map field key/value submessage");
                                r = this.element.decode(l, e, h)
                            }
                        }
                        return [s, r]
                    }
                    return this.element.decode(t, e, this.id)
                }, o.Message.Field = u;
                var f = function (e, t, n, r, i, a, o) {
                    u.call(this, e, t, n, null, r, i, a, o), this.extension
                };
                f.prototype = (0, E.default)(u.prototype), o.Message.ExtensionField = f;
                var p = function (e, t, n) {
                    h.call(this, e, t, n), this.fields = []
                };
                o.Message.OneOf = p;
                var v = function (e, t, n, r, i) {
                    s.call(this, e, t, n, r, i), this.className = "Enum", this.object = null
                };
                v.getName = function (e, t) {
                    for (var n, r = (0, S.default)(e), i = 0; i < r.length; ++i)
                        if (e[n = r[i]] === t) return n;
                    return null
                };
                var y = v.prototype = (0, E.default)(s.prototype);
                y.build = function (e) {
                    if (this.object && !e) return this.object;
                    for (var t = new g.Builder.Enum, n = this.getChildren(v.Value), r = 0, i = n.length; r < i; ++r) t[n[r].name] = n[r].id;
                    return R.default && (0, R.default)(t, "$options", {
                        value: this.buildOpt(),
                        enumerable: !1
                    }), this.object = t
                }, o.Enum = v;
                var _ = function (e, t, n, r) {
                    h.call(this, e, t, n), this.className = "Enum.Value", this.id = r
                };
                _.prototype = (0, E.default)(h.prototype), o.Enum.Value = _;
                var A = function (e, t, n, r) {
                    h.call(this, e, t, n), this.field = r
                };
                A.prototype = (0, E.default)(h.prototype), o.Extension = A;
                var x = function (e, t, n, r) {
                        s.call(this, e, t, n, r), this.className = "Service", this.clazz = null
                    },
                    C = x.prototype = (0, E.default)(s.prototype);
                C.build = function (e) {
                    return this.clazz && !e ? this.clazz : this.clazz = function (t, i) {
                        for (var a = function (e) {
                                t.Builder.Service.call(this), this.rpcImpl = e || function (e, t, n) {
                                    setTimeout(n.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0)
                                }
                            }, e = a.prototype = (0, E.default)(t.Builder.Service.prototype), n = i.getChildren(t.Reflect.Service.RPCMethod), r = 0; r < n.length; r++) ! function (r) {
                            e[r.name] = function (e, n) {
                                try {
                                    try {
                                        e = r.resolvedRequestType.clazz.decode(O.wrap(e))
                                    } catch (e) {
                                        if (!(e instanceof TypeError)) throw e
                                    }
                                    if (null === e || "object" !== (0, L.default)(e)) throw Error("Illegal arguments");
                                    e instanceof r.resolvedRequestType.clazz || (e = new r.resolvedRequestType.clazz(e)), this.rpcImpl(r.fqn(), e, function (e, t) {
                                        if (e) n(e);
                                        else {
                                            null === t && (t = "");
                                            try {
                                                t = r.resolvedResponseType.clazz.decode(t)
                                            } catch (e) {}
                                            t && t instanceof r.resolvedResponseType.clazz ? n(null, t) : n(Error("Illegal response type received in service method " + i.name + "#" + r.name))
                                        }
                                    })
                                } catch (e) {
                                    setTimeout(n.bind(this, e), 0)
                                }
                            }, a[r.name] = function (e, t, n) {
                                new a(e)[r.name](t, n)
                            }, R.default && ((0, R.default)(a[r.name], "$options", {
                                value: r.buildOpt()
                            }), (0, R.default)(e[r.name], "$options", {
                                value: a[r.name].$options
                            }))
                        }(n[r]);
                        return R.default && ((0, R.default)(a, "$options", {
                            value: i.buildOpt()
                        }), (0, R.default)(e, "$options", {
                            value: a.$options
                        }), (0, R.default)(a, "$type", {
                            value: i
                        }), (0, R.default)(e, "$type", {
                            value: i
                        })), a
                    }(g, this)
                }, o.Service = x;
                var I = function (e, t, n, r) {
                        h.call(this, e, t, n), this.className = "Service.Method", this.options = r || {}
                    },
                    w = I.prototype = (0, E.default)(h.prototype);
                w.buildOpt = t.buildOpt, o.Service.Method = I;
                var M = function (e, t, n, r, i, a, o, s) {
                    I.call(this, e, t, n, s), this.className = "Service.RPCMethod", this.requestName = r, this.responseName = i, this.requestStream = a, this.responseStream = o, this.resolvedRequestType = null, this.resolvedResponseType = null
                };
                return M.prototype = (0, E.default)(I.prototype), o.Service.RPCMethod = M, o
            }(ne), ne.Builder = (X = ne, Z = ne.Lang, J = ne.Reflect, K = function (e) {
                this.ns = new J.Namespace(this, null, ""), this.ptr = this.ns, this.resolved = !1, this.result = null, this.files = {}, this.importRoot = null, this.options = e || {}
            }, Q = K.prototype, K.isMessage = function (e) {
                return "string" == typeof e.name && void 0 === e.values && void 0 === e.rpc
            }, K.isMessageField = function (e) {
                return "string" == typeof e.rule && "string" == typeof e.name && "string" == typeof e.type && void 0 !== e.id
            }, K.isEnum = function (e) {
                return "string" == typeof e.name && !(void 0 === e.values || !(0, T.default)(e.values) || 0 === e.values.length)
            }, K.isService = function (e) {
                return !("string" != typeof e.name || "object" !== (0, L.default)(e.rpc) || !e.rpc)
            }, K.isExtend = function (e) {
                return "string" == typeof e.ref
            }, Q.reset = function () {
                return this.ptr = this.ns, this
            }, Q.define = function (e) {
                if ("string" != typeof e || !Z.TYPEREF.test(e)) throw Error("illegal namespace: " + e);
                return e.split(".").forEach(function (e) {
                    var t = this.ptr.getChild(e);
                    null === t && this.ptr.addChild(t = new J.Namespace(this, this.ptr, e)), this.ptr = t
                }, this), this
            }, Q.create = function (e) {
                if (!e) return this;
                if ((0, T.default)(e)) {
                    if (0 === e.length) return this;
                    e = e.slice()
                } else e = [e];
                for (var t = [e]; 0 < t.length;) {
                    if (e = t.pop(), !(0, T.default)(e)) throw Error("not a valid namespace: " + (0, b.default)(e));
                    for (; 0 < e.length;) {
                        var n = e.shift();
                        if (K.isMessage(n)) {
                            var a = new J.Message(this, this.ptr, n.name, n.options, n.isGroup, n.syntax),
                                r = {};
                            n.oneofs && (0, S.default)(n.oneofs).forEach(function (e) {
                                a.addChild(r[e] = new J.Message.OneOf(this, a, e))
                            }, this), n.fields && n.fields.forEach(function (e) {
                                if (null !== a.getChild(0 | e.id)) throw Error("duplicate or invalid field id in " + a.name + ": " + e.id);
                                if (e.options && "object" !== (0, L.default)(e.options)) throw Error("illegal field options in " + a.name + "#" + e.name);
                                var t = null;
                                if ("string" == typeof e.oneof && !(t = r[e.oneof])) throw Error("illegal oneof in " + a.name + "#" + e.name + ": " + e.oneof);
                                e = new J.Message.Field(this, a, e.rule, e.keytype, e.type, e.name, e.id, e.options, t, n.syntax), t && t.fields.push(e), a.addChild(e)
                            }, this);
                            var i = [];
                            if (n.enums && n.enums.forEach(function (e) {
                                    i.push(e)
                                }), n.messages && n.messages.forEach(function (e) {
                                    i.push(e)
                                }), n.services && n.services.forEach(function (e) {
                                    i.push(e)
                                }), n.extensions && ("number" == typeof n.extensions[0] ? a.extensions = [n.extensions] : a.extensions = n.extensions), this.ptr.addChild(a), 0 < i.length) {
                                t.push(e), e = i, i = null, this.ptr = a, a = null;
                                continue
                            }
                            i = null
                        } else if (K.isEnum(n)) a = new J.Enum(this, this.ptr, n.name, n.options, n.syntax), n.values.forEach(function (e) {
                            a.addChild(new J.Enum.Value(this, a, e.name, e.id))
                        }, this), this.ptr.addChild(a);
                        else if (K.isService(n)) a = new J.Service(this, this.ptr, n.name, n.options), (0, S.default)(n.rpc).forEach(function (e) {
                            var t = n.rpc[e];
                            a.addChild(new J.Service.RPCMethod(this, a, e, t.request, t.response, !!t.request_stream, !!t.response_stream, t.options))
                        }, this), this.ptr.addChild(a);
                        else {
                            if (!K.isExtend(n)) throw Error("not a valid definition: " + (0, b.default)(n));
                            if (a = this.ptr.resolve(n.ref, !0), a) n.fields.forEach(function (t) {
                                if (null !== a.getChild(0 | t.id)) throw Error("duplicate extended field id in " + a.name + ": " + t.id);
                                if (a.extensions) {
                                    var n = !1;
                                    if (a.extensions.forEach(function (e) {
                                            t.id >= e[0] && t.id <= e[1] && (n = !0)
                                        }), !n) throw Error("illegal extended field id in " + a.name + ": " + t.id + " (not within valid ranges)")
                                }
                                var e = t.name;
                                this.options.convertFieldsToCamelCase && (e = X.Util.toCamelCase(e));
                                var r = new J.Message.ExtensionField(this, a, t.rule, t.type, this.ptr.fqn() + "." + e, t.id, t.options),
                                    i = new J.Extension(this, this.ptr, t.name, r);
                                r.extension = i, this.ptr.addChild(i), a.addChild(r)
                            }, this);
                            else if (!/\.?google\.protobuf\./.test(n.ref)) throw Error("extended message " + n.ref + " is not defined")
                        }
                        n = null, a = null
                    }
                    e = null, this.ptr = this.ptr.parent
                }
                return this.resolved = !1, this.result = null, this
            }, Q.import = function (t, e) {
                var n = "/";
                if ("string" == typeof e) {
                    if (X.Util.IS_NODE && (e = oe(204).resolve(e)), !0 === this.files[e]) return this.reset();
                    this.files[e] = !0
                } else if ("object" === (0, L.default)(e)) {
                    var r = e.root;
                    X.Util.IS_NODE && (r = oe(204).resolve(r)), (0 <= r.indexOf("\\") || 0 <= e.file.indexOf("\\")) && (n = "\\");
                    var i = r + n + e.file;
                    if (!0 === this.files[i]) return this.reset();
                    this.files[i] = !0
                }
                if (t.imports && 0 < t.imports.length) {
                    var a, o = !1;
                    "object" === (0, L.default)(e) ? (this.importRoot = e.root, o = !0, a = this.importRoot, e = e.file, (0 <= a.indexOf("\\") || 0 <= e.indexOf("\\")) && (n = "\\")) : "string" == typeof e ? this.importRoot ? a = this.importRoot : 0 <= e.indexOf("/") ? (a = e.replace(/\/[^\/]*$/, ""), "" === a && (a = "/")) : 0 <= e.indexOf("\\") ? (a = e.replace(/\\[^\\]*$/, ""), n = "\\") : a = "." : a = null;
                    for (var s = 0; s < t.imports.length; s++)
                        if ("string" == typeof t.imports[s]) {
                            if (!a) throw Error("cannot determine import root");
                            var l = t.imports[s];
                            if ("google/protobuf/descriptor.proto" === l) continue;
                            if (l = a + n + l, !0 === this.files[l]) continue;
                            /\.proto$/i.test(l) && !X.DotProto && (l = l.replace(/\.proto$/, ".json"));
                            var u = X.Util.fetch(l);
                            if (null === u) throw Error("failed to import '" + l + "' in '" + e + "': file not found");
                            /\.json$/i.test(l) ? this.import(JSON.parse(u + ""), l) : this.import(X.DotProto.Parser.parse(u), l)
                        } else e ? /\.(\w+)$/.test(e) ? this.import(t.imports[s], e.replace(/^(.+)\.(\w+)$/, function (e, t, n) {
                            return t + "_import" + s + "." + n
                        })) : this.import(t.imports[s], e + "_import" + s) : this.import(t.imports[s]);
                    o && (this.importRoot = null)
                }
                t.package && this.define(t.package), t.syntax && re(t);
                var h = this.ptr;
                return t.options && (0, S.default)(t.options).forEach(function (e) {
                    h.options[e] = t.options[e]
                }), t.messages && (this.create(t.messages), this.ptr = h), t.enums && (this.create(t.enums), this.ptr = h), t.services && (this.create(t.services), this.ptr = h), t.extends && this.create(t.extends), this.reset()
            }, Q.resolveAll = function () {
                var e;
                if (null == this.ptr || "object" === (0, L.default)(this.ptr.type)) return this;
                if (this.ptr instanceof J.Namespace) this.ptr.children.forEach(function (e) {
                    this.ptr = e, this.resolveAll()
                }, this);
                else if (this.ptr instanceof J.Message.Field) {
                    if (Z.TYPE.test(this.ptr.type)) this.ptr.type = X.TYPES[this.ptr.type];
                    else {
                        if (!Z.TYPEREF.test(this.ptr.type)) throw Error("illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                        if (e = (this.ptr instanceof J.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, !0), !e) throw Error("unresolvable type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                        if (this.ptr.resolvedType = e, e instanceof J.Enum) {
                            if (this.ptr.type = X.TYPES.enum, "proto3" === this.ptr.syntax && "proto3" !== e.syntax) throw Error("proto3 message cannot reference proto2 enum")
                        } else {
                            if (!(e instanceof J.Message)) throw Error("illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                            this.ptr.type = e.isGroup ? X.TYPES.group : X.TYPES.message
                        }
                    }
                    if (this.ptr.map) {
                        if (!Z.TYPE.test(this.ptr.keyType)) throw Error("illegal key type for map field in " + this.ptr.toString(!0) + ": " + this.ptr.keyType);
                        this.ptr.keyType = X.TYPES[this.ptr.keyType]
                    }
                } else if (this.ptr instanceof X.Reflect.Service.Method) {
                    if (!(this.ptr instanceof X.Reflect.Service.RPCMethod)) throw Error("illegal service type in " + this.ptr.toString(!0));
                    if (e = this.ptr.parent.resolve(this.ptr.requestName, !0), !(e && e instanceof X.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.requestName);
                    if (this.ptr.resolvedRequestType = e, e = this.ptr.parent.resolve(this.ptr.responseName, !0), !(e && e instanceof X.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.responseName);
                    this.ptr.resolvedResponseType = e
                } else if (!(this.ptr instanceof X.Reflect.Message.OneOf || this.ptr instanceof X.Reflect.Extension || this.ptr instanceof X.Reflect.Enum.Value)) throw Error("illegal object in namespace: " + (0, L.default)(this.ptr) + ": " + this.ptr);
                return this.reset()
            }, Q.build = function (e) {
                if (this.reset(), this.resolved || (this.resolveAll(), this.resolved = !0, this.result = null), null === this.result && (this.result = this.ns.build()), !e) return this.result;
                for (var t = "string" == typeof e ? e.split(".") : e, n = this.result, r = 0; r < t.length; r++) {
                    if (!n[t[r]]) {
                        n = null;
                        break
                    }
                    n = n[t[r]]
                }
                return n
            }, Q.lookup = function (e, t) {
                return e ? this.ns.resolve(e, t) : this.ns
            }, Q.toString = function () {
                return "Builder"
            }, K.Message = function () {}, K.Enum = function () {}, K.Service = function () {}, K), ne.Map = ($ = ne.Reflect, ee = function (e, t) {
                if (!e.map) throw Error("field is not a map");
                if (this.field = e, this.keyElem = new $.Element(e.keyType, null, !0, e.syntax), this.valueElem = new $.Element(e.type, e.resolvedType, !1, e.syntax), this.map = {}, (0, R.default)(this, "size", {
                        get: function () {
                            return (0, S.default)(this.map).length
                        }
                    }), t)
                    for (var n = (0, S.default)(t), r = 0; r < n.length; r++) {
                        var i = this.keyElem.valueFromString(n[r]),
                            a = this.valueElem.verifyValue(t[n[r]]);
                        this.map[this.keyElem.valueToString(i)] = {
                            key: i,
                            value: a
                        }
                    }
            }, te = ee.prototype, te.clear = function () {
                this.map = {}
            }, te.delete = function (e) {
                var t = this.keyElem.valueToString(this.keyElem.verifyValue(e)),
                    n = t in this.map;
                return delete this.map[t], n
            }, te.entries = function () {
                for (var e, t = [], n = (0, S.default)(this.map), r = 0; r < n.length; r++) t.push([(e = this.map[n[r]]).key, e.value]);
                return ie(t)
            }, te.keys = function () {
                for (var e = [], t = (0, S.default)(this.map), n = 0; n < t.length; n++) e.push(this.map[t[n]].key);
                return ie(e)
            }, te.values = function () {
                for (var e = [], t = (0, S.default)(this.map), n = 0; n < t.length; n++) e.push(this.map[t[n]].value);
                return ie(e)
            }, te.forEach = function (e, t) {
                for (var n, r = (0, S.default)(this.map), i = 0; i < r.length; i++) e.call(t, (n = this.map[r[i]]).value, n.key, this)
            }, te.set = function (e, t) {
                var n = this.keyElem.verifyValue(e),
                    r = this.valueElem.verifyValue(t);
                return this.map[this.keyElem.valueToString(n)] = {
                    key: n,
                    value: r
                }, this
            }, te.get = function (e) {
                var t = this.keyElem.valueToString(this.keyElem.verifyValue(e));
                if (t in this.map) return this.map[t].value
            }, te.has = function (e) {
                var t = this.keyElem.valueToString(this.keyElem.verifyValue(e));
                return t in this.map
            }, ee), ne.loadProto = function (e, t, n) {
                return ("string" == typeof t || t && "string" == typeof t.file && "string" == typeof t.root) && (n = t, t = void 0), ne.loadJson(ne.DotProto.Parser.parse(e), t, n)
            }, ne.protoFromString = ne.loadProto, ne.loadProtoFile = function (t, n, r) {
                if (n && "object" === (0, L.default)(n) ? (r = n, n = null) : n && "function" == typeof n || (n = null), n) return ne.Util.fetch("string" == typeof t ? t : t.root + "/" + t.file, function (e) {
                    if (null !== e) try {
                        n(null, ne.loadProto(e, r, t))
                    } catch (e) {
                        n(e)
                    } else n(Error("Failed to fetch file"))
                });
                var e = ne.Util.fetch("object" === (0, L.default)(t) ? t.root + "/" + t.file : t);
                return null === e ? null : ne.loadProto(e, r, t)
            }, ne.protoFromFile = ne.loadProtoFile, ne.newBuilder = function (e) {
                return e = e || {}, void 0 === e.convertFieldsToCamelCase && (e.convertFieldsToCamelCase = ne.convertFieldsToCamelCase), void 0 === e.populateAccessors && (e.populateAccessors = ne.populateAccessors), new ne.Builder(e)
            }, ne.loadJson = function (e, t, n) {
                return ("string" == typeof t || t && "string" == typeof t.file && "string" == typeof t.root) && (n = t, t = null), t && "object" === (0, L.default)(t) || (t = ne.newBuilder()), "string" == typeof e && (e = JSON.parse(e)), t.import(e, n), t.resolveAll(), t
            }, ne.loadJsonFile = function (t, n, r) {
                if (n && "object" === (0, L.default)(n) ? (r = n, n = null) : n && "function" == typeof n || (n = null), n) return ne.Util.fetch("string" == typeof t ? t : t.root + "/" + t.file, function (e) {
                    if (null !== e) try {
                        n(null, ne.loadJson(JSON.parse(e), r, t))
                    } catch (e) {
                        n(e)
                    } else n(Error("Failed to fetch file"))
                });
                var e = ne.Util.fetch("object" === (0, L.default)(t) ? t.root + "/" + t.file : t);
                return null === e ? null : ne.loadJson(JSON.parse(e), r, t)
            }
        }).call(this, oe(148))
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var u = r(n(41));
        n(53), n(13), n(8);
        var o = r(n(11)),
            M = r(n(12)),
            s = r(n(27)),
            a = r(n(2)),
            l = r(n(3)),
            f = r(n(80)),
            h = r(n(209)),
            c = function () {
                function r(e, t, n) {
                    (0, a.default)(this, r), this.groups = {}, this._id = e, this._center = new fm.Vector2, this._mapcenter = new fm.Vector2(t.scene.x, t.scene.y), this._theme = null, this.parent = n, this.layerGroups = t.scene.layerGroups, this._bbox = {
                        max: new fm.Vector2(-Infinity, -Infinity),
                        min: new fm.Vector2(Infinity, Infinity)
                    }, this._bboxTh = {
                        max: new fm.Vector2(-Infinity, -Infinity),
                        min: new fm.Vector2(Infinity, Infinity)
                    }, this._bbox.max.x = t.scene.maxX, this._bbox.max.y = t.scene.maxY, this._bbox.min.x = t.scene.minX, this._bbox.min.y = t.scene.minY, this._bboxTh.max.x = t.scene.maxX - t.scene.x, this._bboxTh.max.y = t.scene.maxY - t.scene.y, this._bboxTh.min.x = t.scene.minX - t.scene.x, this._bboxTh.min.y = t.scene.minY - t.scene.y, this._groupIds = [], this.initGroupByData(t), this._spcace = (0, s.default)(t.scene.layerGroups[0].height)
                }
                return (0, l.default)(r, [{
                    key: "getNeedLoadGroup",
                    value: function (e, t) {
                        var n = [],
                            r = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, M.default)(this.layerGroups); !(r = (o = s.next()).done); r = !0) {
                                var l = o.value,
                                    u = -1 < e.indexOf(l.gid);
                                t && (u = !u), !l.loaded && u && n.push({
                                    gid: l.gid,
                                    url: this.getGroupLoadUrl(l.gname, l.gid),
                                    layerData: l
                                })
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                r || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        return n
                    }
                }, {
                    key: "getGroupLoadUrl",
                    value: function (e) {
                        return "floor." + e
                    }
                }, {
                    key: "getLastAndNextName",
                    value: function (e, t) {
                        var n, r, i = "" + e,
                            a = !0,
                            o = !1,
                            s = void 0;
                        try {
                            for (var l, u = (0, M.default)(this.layerGroups); !(a = (l = u.next()).done); a = !0) {
                                var h = l.value;
                                h.gid === t - 1 && (n = "_" + h.gname), h.gid === t + 1 && (r = "_" + h.gname)
                            }
                        } catch (e) {
                            o = !0, s = e
                        } finally {
                            try {
                                a || null == u.return || u.return()
                            } finally {
                                if (o) throw s
                            }
                        }
                        return n = n || "_no", r = r || "_no", i += n + r, i
                    }
                }, {
                    key: "initGroupByData",
                    value: function (e) {
                        var t = e.floors;
                        this._groupLength = t.length;
                        for (var n = 0; n < t.length; n++) this.addGroup(t[n].gid, t[n], e.scene.layerGroups[n])
                    }
                }, {
                    key: "addGroup",
                    value: function (e, t, n) {
                        this._groupIds.push(e);
                        var r = new h.default(e, t, n);
                        r.hideWithFree = this.parent.map.MapOptions.autoDispose, r.parent = this;
                        var i = (0, s.default)(e);
                        r.height = this._space * i, -1 < this.parent.map.visibleGroupIDs.indexOf(e) ? r.visible = !0 : r.visible = !1, this.groups[e + ""] = r
                    }
                }, {
                    key: "changeTheme",
                    value: function (r) {
                        var i = this;
                        this._theme = r;
                        var a, e = ["extent", "model", "label", "facility"],
                            t = function (n) {
                                i.groups[n].traverseByAlias(e, function (e, t) {
                                    switch (t) {
                                        case "extent":
                                            a = r;
                                            break;
                                        case "model":
                                            a = i.parent.map.MapOptions.useStoreApply ? r.getStoreApplyTheme(e.bdata.fid) : void 0, a = a || r.getModelTheme(e.bdata), a = (0, o.default)(a, {
                                                logoPath: r.data.logoPath
                                            });
                                            break;
                                        case "label":
                                            a = r.getLabelTheme(e.bdata);
                                            break;
                                        case "facility":
                                            a = r.getPoiTheme(e.bdata)
                                    }
                                    e.renderNodeInited && (e.setByTheme(a), i.parent.checkMaterialAlpha(e.renderNode, (0, s.default)(n)), "model" == t && i.parent.checkMaterialAlpha(e.line, (0, s.default)(n)))
                                })
                            };
                        for (var n in this.groups) t(n)
                    }
                }, {
                    key: "getAllGroupLayerByAlias",
                    value: function (e, t) {
                        for (var n in this.groups) {
                            var r = this.groups[n].layers[e],
                                i = !0,
                                a = !1,
                                o = void 0;
                            try {
                                for (var s, l = (0, M.default)(r); !(i = (s = l.next()).done); i = !0) {
                                    var u = s.value;
                                    t(u)
                                }
                            } catch (e) {
                                a = !0, o = e
                            } finally {
                                try {
                                    i || null == l.return || l.return()
                                } finally {
                                    if (a) throw o
                                }
                            }
                        }
                    }
                }, {
                    key: "getFacilityByFilter",
                    value: function (e, t) {
                        var n = [],
                            r = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, M.default)(e); !(r = (o = s.next()).done); r = !0) {
                                var l = o.value,
                                    u = this.groups[l];
                                if (u) {
                                    for (var h = ["imageMarker", "textMarker", "facility"], c = 0, d = h; c < d.length; c++) {
                                        var f = d[c],
                                            p = u.getLayers(f),
                                            g = !0,
                                            m = !1,
                                            v = void 0;
                                        try {
                                            for (var y, _ = (0, M.default)(p); !(g = (y = _.next()).done); g = !0)
                                                for (var A = y.value, x = 0; x < A.scene.children.length; x++) t ? t(A.scene.children[x]) && n.push(A.scene.children[x]) : n.push(A.scene.children[x])
                                        } catch (e) {
                                            m = !0, v = e
                                        } finally {
                                            try {
                                                g || null == _.return || _.return()
                                            } finally {
                                                if (m) throw v
                                            }
                                        }
                                    }
                                    for (var C = u._locationScene.children, I = 0; I < C.length; I++) t ? t(C[I]) && n.push(C[I]) : n.push(C[I])
                                }
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                r || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        return n
                    }
                }, {
                    key: "getSpriteInfo",
                    value: function (e, t, n, r) {
                        e.updateMatrixWorld(!0);
                        var i, a = (new fm.Vector3).setFromMatrixPosition(e.matrixWorld),
                            o = a.applyMatrix4(n.matrixWorldInverse),
                            s = o.applyMatrix4(n.projectionMatrix),
                            l = e.mapNode.size / r * 2;
                        if (t) {
                            var u = this.parent._map.labelLanguage == f.default.ZH ? e.mapNode.name : e.mapNode.ename;
                            if (u) {
                                var h = u.split("%rn%").length;
                                l *= h
                            }
                            i = l / e.material.userData.scaleRatio
                        } else i = l;
                        "PerspectiveCamera" === n.type && (s.x *= n.aspect);
                        var c = {
                                x: s.x - i / 2,
                                y: s.y + l / 2
                            },
                            d = {
                                x: s.x + i / 2,
                                y: s.y - l / 2
                            };
                        return {
                            target: e,
                            z: e.mapNode.eid,
                            position: s,
                            leftTop: c,
                            rightDown: d
                        }
                    }
                }, {
                    key: "getMarkers",
                    value: function (e, t, n) {
                        var r = [],
                            i = this.groups[e];
                        if (!i) return r;
                        var a = i.getLayers("facility"),
                            o = !0,
                            s = !1,
                            l = void 0;
                        try {
                            for (var u, h = (0, M.default)(a); !(o = (u = h.next()).done); o = !0) {
                                var c = u.value;
                                if (c.needAvoid)
                                    for (var d = 0; d < c.scene.children.length; d++) {
                                        var f = c.scene.children[d];
                                        if (f.mapNode.needAvoid && f.mapNode.show) {
                                            var p = this.getSpriteInfo(f, !1, t, n);
                                            r.push(p)
                                        }
                                    }
                            }
                        } catch (e) {
                            s = !0, l = e
                        } finally {
                            try {
                                o || null == h.return || h.return()
                            } finally {
                                if (s) throw l
                            }
                        }
                        var g = i.getLayers("label"),
                            m = !0,
                            v = !1,
                            y = void 0;
                        try {
                            for (var _, A = (0, M.default)(g); !(m = (_ = A.next()).done); m = !0)
                                for (var x = _.value, C = 0; C < x.scene.children.length; C++) {
                                    var I = x.scene.children[C];
                                    if (I.mapNode.needAvoid && x.needAvoid && I.mapNode.show) {
                                        I.mapNode.renderNode.visible = !0;
                                        var w = this.getSpriteInfo(I, !0, t, n);
                                        r.push(w)
                                    }
                                }
                        } catch (e) {
                            v = !0, y = e
                        } finally {
                            try {
                                m || null == A.return || A.return()
                            } finally {
                                if (v) throw y
                            }
                        }
                        return r.sort(function (e, t) {
                            return e.z - t.z
                        }), r
                    }
                }, {
                    key: "getAllImageMarker",
                    value: function (e) {
                        var t = [],
                            n = this.groups[e];
                        if (!n) return t;
                        for (var r = n.layers.imageMarker, i = 0; i < r.length; i++)
                            for (var a = 0; a < r[i].scene.children.length; a++) {
                                var o = r[i].scene.children[a];
                                t.push(o)
                            }
                        return t
                    }
                }, {
                    key: "getUserMarkers",
                    value: function (e, t, n) {
                        var r = [],
                            i = this.groups[e];
                        if (!i) return r;
                        for (var a = i.layers.imageMarker, o = 0; o < a.length; o++) {
                            var s = [];
                            if (a[o].needAvoid) {
                                for (var l = 0; l < a[o].scene.children.length; l++) {
                                    var u = a[o].scene.children[l];
                                    if (u.mapNode.needAvoid && u.mapNode.show) {
                                        var h = this.getSpriteInfo(u, !1, t, n);
                                        s.push(h)
                                    }
                                }
                                r.push(s)
                            }
                        }
                        for (var c = i.layers.textMarker, d = 0; d < c.length; d++) {
                            var f = [];
                            if (c[d].needAvoid) {
                                for (var p = 0; p < c[d].scene.children.length; p++) {
                                    var g = c[d].scene.children[p];
                                    if (g.mapNode.needAvoid && g.mapNode.show) {
                                        var m = this.getSpriteInfo(g, !0, t, n);
                                        f.push(m)
                                    }
                                }
                                r.push(f)
                            }
                        }
                        return r
                    }
                }, {
                    key: "getNodesExceptFacility",
                    value: function (e, n) {
                        var r = [],
                            t = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, M.default)(e); !(t = (o = s.next()).done); t = !0) {
                                var l = o.value,
                                    u = this.groups[l];
                                u && u.everyLayers(["facility", "label", "imageMarker", "textMarker", "dynmodel"], function (e) {
                                    for (var t = 0; t < e.children.length; t++) n ? n(e.children[t]) && r.push(e.children[t]) : r.push(e.children[t])
                                })
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                t || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        return r
                    }
                }, {
                    key: "getDynnodes",
                    value: function (n, e) {
                        var r = [],
                            t = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, M.default)(e); !(t = (o = s.next()).done); t = !0) {
                                var l = o.value,
                                    u = this.groups[l];
                                u && u.getDynmodel(function (e) {
                                    for (var t = 0; t < e.children.length; t++) n ? n(e.children[t]) && r.push(e.children[t]) : r.push(e.children[t])
                                })
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                t || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        return r
                    }
                }, {
                    key: "getGroupsModels",
                    value: function (e) {
                        var t = [],
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, M.default)(e); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value,
                                    l = this.groups[s];
                                if (l) {
                                    var u = l.getLayers("model"),
                                        h = !0,
                                        c = !1,
                                        d = void 0;
                                    try {
                                        for (var f, p = (0, M.default)(u); !(h = (f = p.next()).done); h = !0) {
                                            var g = f.value;
                                            g.checkSceneNode(), t = t.concat(g.scene.children)
                                        }
                                    } catch (e) {
                                        c = !0, d = e
                                    } finally {
                                        try {
                                            h || null == p.return || p.return()
                                        } finally {
                                            if (c) throw d
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return t
                    }
                }, {
                    key: "getGroupsExternalModels",
                    value: function (e) {
                        var t = [],
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, M.default)(e); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value,
                                    l = this.groups[s];
                                if (l) {
                                    var u = l.getLayers("externalModel"),
                                        h = !0,
                                        c = !1,
                                        d = void 0;
                                    try {
                                        for (var f, p = (0, M.default)(u); !(h = (f = p.next()).done); h = !0) {
                                            var g = f.value;
                                            g.checkSceneNode();
                                            for (var m = 0; m < g.scene.children.length; m++) g.scene.children[m].traverse(function (e) {
                                                e instanceof fm.Mesh && t.push(e)
                                            })
                                        }
                                    } catch (e) {
                                        c = !0, d = e
                                    } finally {
                                        try {
                                            h || null == p.return || p.return()
                                        } finally {
                                            if (c) throw d
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return t
                    }
                }, {
                    key: "getGroupsNodelsByFilter",
                    value: function (e, t, n) {
                        var r = [],
                            i = !0,
                            a = !1,
                            o = void 0;
                        try {
                            for (var s, l = (0, M.default)(e); !(i = (s = l.next()).done); i = !0) {
                                var u = s.value,
                                    h = this.groups[u];
                                for (var c in h.layers)
                                    if (t === c) {
                                        var d = h.layers[c],
                                            f = !0,
                                            p = !1,
                                            g = void 0;
                                        try {
                                            for (var m, v = (0, M.default)(d); !(f = (m = v.next()).done); f = !0) {
                                                var y = m.value;
                                                y.traverse(function (e) {
                                                    n(e) && r.push({
                                                        nodeType: e.nodeType,
                                                        typeID: e.bdata && e.bdata.type,
                                                        data: e.bdata,
                                                        target: e
                                                    })
                                                })
                                            }
                                        } catch (e) {
                                            p = !0, g = e
                                        } finally {
                                            try {
                                                f || null == v.return || v.return()
                                            } finally {
                                                if (p) throw g
                                            }
                                        }
                                    }
                            }
                        } catch (e) {
                            a = !0, o = e
                        } finally {
                            try {
                                i || null == l.return || l.return()
                            } finally {
                                if (a) throw o
                            }
                        }
                        return r
                    }
                }, {
                    key: "getNodesExpectExtent",
                    value: function (e) {
                        var t = [],
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, M.default)(e); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value,
                                    l = this.groups[s];
                                l.everyLayers(["extent"], function (e) {
                                    t.push.apply(t, (0, u.default)(e.children))
                                })
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return t
                    }
                }, {
                    key: "getRenderGroup",
                    value: function () {
                        var e = [];
                        for (var t in this.groups) this.groups[t].visible && e.push(this.groups[t]);
                        return e.sort(function (e, t) {
                            return e.getHeight() - t.getHeight()
                        })
                    }
                }, {
                    key: "getLastRenderArray",
                    value: function () {
                        var e = [];
                        for (var t in this.groups) e.push.apply(e, (0, u.default)(this.groups[t].alwaysShowMarkers));
                        return e
                    }
                }, {
                    key: "getHeight",
                    value: function (e) {
                        var t;
                        return t = this.groups["" + e] ? this.groups["" + e].getHeight() : this._space * e, t
                    }
                }, {
                    key: "setLabelLanguage",
                    value: function (t) {
                        for (var e in this.groups) this.groups[e].traverseByAlias(["label"], function (e) {
                            e.setByLanguage(t)
                        })
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this.groups) this.groups[e].dispose(), this.groups[e].parent = void 0, this.groups[e] = void 0;
                        this.groups = void 0, this._theme && (this._theme.dispose(), this._theme = void 0)
                    }
                }, {
                    key: "mapcenter",
                    get: function () {
                        return (new fm.Vector2).copy(this._mapcenter)
                    }
                }, {
                    key: "groupLength",
                    get: function () {
                        return this._groupIds.length
                    }
                }, {
                    key: "groupIds",
                    get: function () {
                        return this._groupIds
                    }
                }, {
                    key: "center",
                    get: function () {
                        return (new fm.Vector2).copy(this._center)
                    },
                    set: function (e) {
                        this._center = e
                    }
                }, {
                    key: "theme",
                    set: function (e) {
                        this._theme = e
                    },
                    get: function () {
                        return this._theme
                    }
                }, {
                    key: "bbox",
                    get: function () {
                        return this._bbox
                    }
                }, {
                    key: "bboxTh",
                    get: function () {
                        return this._bboxTh
                    }
                }, {
                    key: "space",
                    get: function () {
                        return this._space
                    },
                    set: function (e) {
                        for (var t in this._space = e, this.groups) {
                            var n = (0, s.default)(t);
                            this.groups[t].height = e * n
                        }
                    }
                }]), r
            }(),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var i = n(70);

        function r(e) {
            var n, r;
            this.promise = new e(function (e, t) {
                if (void 0 !== n || void 0 !== r) throw TypeError("Bad Promise constructor");
                n = e, r = t
            }), this.resolve = i(n), this.reject = i(r)
        }
        e.exports.f = function (e) {
            return new r(e)
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                ALL_LINES_TYPE: 40,
                TOP_LINES_TYPE: 41
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                RIGHT: 1,
                LEFT: 2,
                BOTTOM: 3,
                TOP: 4,
                RIGHT_BOTTOM: 5,
                LEFT_BOTTOM: 6,
                RIGHT_TOP: 7,
                LEFT_TOP: 8,
                CENTER: 9
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.LineMaterial = void 0;
        var a = r(n(31)),
            o = r(n(107)),
            s = n(82);
        s.UniformsLib.line2 = {
            linewidth: {
                value: 1
            },
            resolution: {
                value: new s.Vector2(1, 1)
            },
            dashScale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            gapSize: {
                value: 1
            }
        }, s.ShaderLib.line2 = {
            uniforms: s.UniformsUtils.merge([s.UniformsLib.common, s.UniformsLib.fog, s.UniformsLib.line2]),
            vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
            fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
        };
        var l = function (e) {
            s.ShaderMaterial.call(this, {
                type: "LineMaterial",
                uniforms: s.UniformsUtils.clone(s.ShaderLib.line2.uniforms),
                vertexShader: s.ShaderLib.line2.vertexShader,
                fragmentShader: s.ShaderLib.line2.fragmentShader,
                clipping: !0
            }), this.dashed = !1, (0, o.default)(this, {
                color: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.diffuse.value
                    },
                    set: function (e) {
                        this.uniforms.diffuse.value = e
                    }
                },
                lineWidth: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.linewidth.value
                    },
                    set: function (e) {
                        this.uniforms.linewidth.value = e
                    }
                },
                dashScale: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.dashScale.value
                    },
                    set: function (e) {
                        this.uniforms.dashScale.value = e
                    }
                },
                dashSize: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.dashSize.value
                    },
                    set: function (e) {
                        this.uniforms.dashSize.value = e
                    }
                },
                gapSize: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.gapSize.value
                    },
                    set: function (e) {
                        this.uniforms.gapSize.value = e
                    }
                },
                resolution: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.resolution.value
                    },
                    set: function (e) {
                        this.uniforms.resolution.value.copy(e)
                    }
                }
            }), this.setValues(e)
        };
        t.LineMaterial = l, l.prototype = (0, a.default)(s.ShaderMaterial.prototype), l.prototype.constructor = l, l.prototype.isLineMaterial = !0
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(147);
        var g = r(n(11)),
            a = r(n(41)),
            o = r(n(2)),
            s = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(12)),
            d = r(n(7));
        n(244);
        var f = r(n(245)),
            p = r(n(430)),
            m = r(n(247)),
            v = r(n(243)),
            y = n(69),
            _ = function (e) {
                var t = !0,
                    n = !1,
                    r = void 0;
                try {
                    for (var i, a = (0, c.default)(this._lineNodes); !(t = (i = a.next()).done); t = !0) {
                        var o = i.value;
                        if (o.line.material.uniforms.offset.value.y -= .001 * e.delTime, this.passed) {
                            if (o.gid !== this._passedGid) continue;
                            o.line.material.uniforms.miny.value = this.specific
                        }
                    }
                } catch (e) {
                    n = !0, r = e
                } finally {
                    try {
                        t || null == a.return || a.return()
                    } finally {
                        if (n) throw r
                    }
                }
            },
            A = function (e) {
                function t() {
                    var e;
                    return (0, o.default)(this, t), e = (0, l.default)(this, (0, u.default)(t).call(this)), e._renderNode = null, e._segment = [], e._noAnimate = !0, e._lineDis = [], e._lineNodes = [], e._style = null, e._secLen = 60, e._hwProp = 10, e._passed = !0, e._passedColor = "#aeaeae", e._specific = 0, e
                }
                return (0, h.default)(t, e), (0, s.default)(t, [{
                    key: "addSegment",
                    value: function (e) {
                        this._segment.push(e)
                    }
                }, {
                    key: "convertPointByCenter",
                    value: function (e, t) {
                        return [e.x - t.x, e.z, -e.y + t.y]
                    }
                }, {
                    key: "segPointsToLinePnts",
                    value: function (e) {
                        for (var t = [], n = 0; n < this._segment.points.length; n++)
                            if (0 < n && n < this._segment.points.length - 1 && this._segment.points[n - 1], t.push.apply(t, (0, a.default)(this.convertPointByCenter(this._segment.points[n], e))), 0 !== n) {
                                var r = new fm.Vector3(this._segment.points[n].x, this._segment.points[n].y, this._segment.points[n].z),
                                    i = new fm.Vector3(this._segment.points[n - 1].x, this._segment.points[n - 1].y, this._segment.points[n - 1].z);
                                this._lineDis.push(r.distanceTo(i))
                            } return t
                    }
                }, {
                    key: "getIndexDis",
                    value: function (e) {
                        for (var t = 0, n = 0; n < this._lineDis.length; n++) n < e && (t += this._lineDis[n]);
                        return t
                    }
                }, {
                    key: "computerUVY",
                    value: function () {
                        for (var e = [], t = this.getIndexDis(this._lineDis.length), n = 0; n < this._segment.points.length; n++)
                            if (0 === n) e.push(0);
                            else if (n === this._segment.points.length - 1) e.push(1);
                        else {
                            var r = this.getIndexDis(n) / t;
                            e.push(r), e.push(r)
                        }
                        return e
                    }
                }, {
                    key: "initLine",
                    value: function (e, t, n) {
                        this._style = t;
                        var r = this.getLineTextureParams(t.lineType, t.lineWidth, t.godColor, t.godEdgeColor, t.color);
                        t.mapUrl ? t.useMap = !0 : (t.useMap = r.useMap, t.map = n.nodeManager.materialManager[r.txtureCommand](r), t.map.minFilter = fm.LinearFilter, t.map.generateMipmaps = !1, t.map.anisotropy = 4);
                        for (var i = this._segment.length - 1; - 1 < i; i--) {
                            var a = this.createLine(this._segment[i], e, t, n),
                                o = n.getFMGroup(this._segment[i].groupId);
                            if (o) {
                                if (this._lineNodes.push({
                                        line: a,
                                        gid: this._segment[i].groupId,
                                        seg: this._segment[i],
                                        isCross: !1
                                    }), o.addLine(a), -1 < i - 1 && this._segment[i].groupId != this._segment[i - 1].groupId) {
                                    var s = n.getFMGroup(this._segment[i - 1].groupId);
                                    if (!s) {
                                        console.warn(y.tileMessage.noGroup);
                                        continue
                                    }
                                    var l = s.height + s.offsetHeight,
                                        u = (0, g.default)({}, this._segment[i - 1].points[this._segment[i - 1].points.length - 1]),
                                        h = (0, g.default)({}, this._segment[i].points[0]),
                                        c = n.getFMGroup(this._segment[i].groupId);
                                    if (!c) {
                                        console.warn(y.tileMessage.noGroup);
                                        continue
                                    }
                                    u.z = l - c.height - c.offsetHeight + u.z - h.z;
                                    var d = new m.default([u, h]);
                                    d.groupId = this._segment[i].groupId;
                                    var f = this.createLine(d, e, t, n);
                                    this._lineNodes.push({
                                        line: f,
                                        gid: this._segment[i - 1].groupId,
                                        gidAn: this._segment[i].groupId,
                                        seg: d,
                                        isCross: !0
                                    }), s.addLine(f)
                                }
                            } else console.warn(y.tileMessage.noGroup)
                        }
                        this._noAnimate = t.noAnimate, this._noAnimate || n.on("frameLoop", _.bind(this))
                    }
                }, {
                    key: "conputeMaterialRepeat",
                    value: function (e, t, n, r) {
                        var i = t.allLength,
                            a = i * n.getPixelTo3DdisByGid(t.groupId),
                            o = Math.floor(a * window.devicePixelRatio / r);
                        e.uniforms.repeat.value.y = o
                    }
                }, {
                    key: "resetRepeat",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, c.default)(this._lineNodes); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                this.conputeMaterialRepeat(o.line.material, o.seg, e, this._secLen)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "rebuildLine",
                    value: function (e, t, n, r) {
                        this.removeByMap(t);
                        for (var i = this._style, a = this._segment.length - 1; - 1 < a; a--) {
                            var o = this.createLine(this._segment[a], e, i, t),
                                s = t.getFMGroup(this._segment[a].groupId);
                            if (this._lineNodes.push({
                                    line: o,
                                    gid: this._segment[a].groupId,
                                    seg: this._segment[a],
                                    isCross: !1
                                }), s.addLine(o), -1 < a - 1 && this._segment[a].groupId != this._segment[a - 1].groupId) {
                                var l = t.getFMGroup(this._segment[a - 1].groupId),
                                    u = l.height + l.offsetHeight,
                                    h = (0, g.default)({}, this._segment[a].points[this._segment[a].points.length - 1]),
                                    c = (0, g.default)({}, this._segment[a - 1].points[0]),
                                    d = t.getFMGroup(this._segment[a].groupId);
                                h.z = u - d.height - d.offsetHeight + h.z - c.z;
                                var f = new m.default([h, c]);
                                f.groupId = this._segment[a].groupId;
                                var p = this.createLine(f, e, i, t);
                                this._lineNodes.push({
                                    line: p,
                                    gid: this._segment[a - 1].groupId,
                                    gidAn: this._segment[a].groupId,
                                    seg: f,
                                    isCross: !0
                                }), l.addLine(p)
                            }
                        }
                        this.hideOrShowBy(n, r)
                    }
                }, {
                    key: "removeByMap",
                    value: function (e, t) {
                        var n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, c.default)(this._lineNodes); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value;
                                s.line.material.dispose(), s.line.geometry.dispose();
                                var l = e.getFMGroup(s.gid);
                                l.removeLine(s.line)
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        t && e.off("frameLoop", _), this._lineNodes.length = 0
                    }
                }, {
                    key: "dispose",
                    value: function (e) {
                        this.removeByMap(e, !0)
                    }
                }, {
                    key: "hideOrShowBy",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, c.default)(this._lineNodes); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                o.isCross ? e.indexOf(o.gid) < 0 || e.indexOf(o.gidAn) < 0 ? o.line.visible = !1 : o.line.visible = !0 : -1 < e.indexOf(o.gid) ? o.line.visible = !0 : o.line.visible = !1
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "createLine",
                    value: function (e, t, n, r) {
                        var i = r.getFMGroup(e.groupId),
                            a = i.height + i.offsetHeight,
                            o = new fm.Vector3(0, a, 0),
                            s = new f.default;
                        e.needSmooth = !1 !== n.smooth, e.initSegement(t, n.radius);
                        for (var l = [], u = 0; u < e.linePoints.length; u++) l.push(e.linePoints[u]);
                        var h = e.uvys;
                        s.setPositions(l), s.setUvys(h);
                        var c = new fm.LineMaterial({
                            color: n.color,
                            linewidth: 5,
                            vertexColors: fm.VertexColors,
                            dashed: !1,
                            transparent: !0
                        });
                        c.resolution.set(n.resolution.x, n.resolution.y), c.linewidth = n.lineWidth, n.useMap && (c.defines.USE_MMAP = !0, n.mapUrl ? (n.useMap = !0, r.nodeManager.materialManager.loadTexture(n.mapUrl, function (e) {
                            c.uniforms.mmap.value = e, e.minFilter = fm.LinearFilter, e.generateMipmaps = !1, e.anisotropy = 4, e.wrapS = fm.RepeatWrapping, e.wrapT = fm.RepeatWrapping, c.needsUpdate = !0
                        })) : (c.uniforms.mmap.value = n.map, n.map.wrapS = fm.RepeatWrapping, n.map.wrapT = fm.RepeatWrapping), this.conputeMaterialRepeat(c, e, r, this._secLen), c.needsUpdate = !0);
                        var d = new p.default(s, c);
                        return d.computeLineDistances(), d.position.set(o.x, o.y, o.z), d
                    }
                }, {
                    key: "initLinePoints",
                    value: function (e, t) {
                        var n = new f.default;
                        n.setPositions(e);
                        var r = new fm.LineMaterial({
                            color: t.color,
                            linewidth: t.lineWidth,
                            vertexColors: fm.VertexColors,
                            dashed: !1,
                            transparent: !0
                        });
                        r.lineWidth = t.lineWidth, r.resolution.set(t.resolution.x, t.resolution.y), this._renderNode = new p.default(n, r), this._renderNode.computeLineDistances()
                    }
                }, {
                    key: "moveUv",
                    value: function (e) {
                        if (this._noAnimate) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = (0, c.default)(this._lineNodes); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    o.line.material.uniforms.offset.value.y -= e
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                    }
                }, {
                    key: "getLineTextureParams",
                    value: function (e, t, n, r, i) {
                        t = t || 6;
                        var a = t * this._hwProp;
                        this._secLen = a;
                        var o = {
                            type: "normal",
                            width: 128,
                            height: 128,
                            color: "#ff0000",
                            arrowHeightPercent: .6,
                            arrowWidthPercent: 1,
                            arrowPercent: .1,
                            lineType: null,
                            dashArray: [2, 1],
                            txtureCommand: "createNormalLineTexture",
                            godHeightPercent: 1,
                            godEdgePercent: .2,
                            godArrowPercent: .15,
                            arrawWidth: 20,
                            godColor: "#33cc61",
                            godEdgeColor: "#4a82d2",
                            godArrowColor: "#F4FEFB",
                            godArrowXScale: 4,
                            godArrowWidthPercent: .9
                        };
                        switch (n && (o.godColor = n), r && (o.godEdgeColor = r), i && (o.color = i), e) {
                            case v.default.FULL:
                                o.useMap = !1;
                                break;
                            case v.default.DOTTED:
                                o.dashArray = [1, 1], o.useMap = !0;
                                break;
                            case v.default.DOT_DASH:
                                o.dashArray = [2.5, 1, .5, 1], o.useMap = !0;
                                break;
                            case v.default.CENTER:
                                o.dashArray = [3, 1, 1.5, 1], o.useMap = !0;
                                break;
                            case v.default.DASH:
                                o.dashArray = [2, 1], o.useMap = !0;
                                break;
                            case v.default.DOUBLE_DOT_DASH:
                                o.dashArray = [2.5, .5, .5, .5, .5, .5], o.useMap = !0;
                                break;
                            case v.default.TRI_DOT_DASH:
                                o.dashArray = [2.5, .5, .5, .5, .5, .5, .5, .5], o.useMap = !0;
                                break;
                            case v.default.ARROW:
                                o.dashArray = [5, 0], o.useMap = !0, o.txtureCommand = "createArrowLineTexture";
                                break;
                            case v.default.FMARROW:
                                o.width = 5 * t, o.height = 5 * a, o.arrawWidth = o.height / 12, o.dashArray = [7, 0], o.useMap = !0, o.txtureCommand = "createArrowWidthBackTexture";
                                break;
                            default:
                                o.useMap = !1
                        }
                        return o
                    }
                }, {
                    key: "setPassed",
                    value: function (e, t) {
                        for (var n = 0, r = 0, i = [], a = 0; a < this._segment.length; a++)
                            if (this._segment[a].groupId === e) {
                                i = this._segment[a]._points;
                                break
                            } for (var o = 0; o < i.length; o++) 0 !== o && (t < o && (r += Math.abs(Math.sqrt(Math.pow(i[o].y - i[o - 1].y, 2) + Math.pow(i[o].x - i[o - 1].x, 2)))), n += Math.abs(Math.sqrt(Math.pow(i[o].y - i[o - 1].y, 2) + Math.pow(i[o].x - i[o - 1].x, 2))));
                        this._specific = r / n, this._passedGid = e
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "segment",
                    get: function () {
                        return this._segment
                    }
                }, {
                    key: "passed",
                    get: function () {
                        return this._passed
                    },
                    set: function (e) {
                        this._passed = e
                    }
                }, {
                    key: "passedColor",
                    get: function () {
                        return this._passedColor
                    },
                    set: function (e) {
                        this._passedColor = e
                    }
                }, {
                    key: "specific",
                    get: function () {
                        return this._specific
                    },
                    set: function (e) {
                        this._specific = e
                    }
                }]), t
            }(d.default),
            x = A,
            C = x;
        t.default = C
    }, function (e, t, n) {
        e.exports = !n(26) && !n(44)(function () {
            return 7 != Object.defineProperty(n(116)("div"), "a", {
                get: function () {
                    return 7
                }
            }).a
        })
    }, function (e) {
        var t;
        t = function () {
            return this
        }();
        try {
            t = t || new Function("return this")()
        } catch (e) {
            "object" == typeof window && (t = window)
        }
        e.exports = t
    }, function (e, t, n) {
        e.exports = !n(23) && !n(18)(function () {
            return 7 != Object.defineProperty(n(159)("div"), "a", {
                get: function () {
                    return 7
                }
            }).a
        })
    }, function (e, t, n) {
        var r = n(37),
            i = n(24).document,
            a = r(i) && r(i.createElement);
        e.exports = function (e) {
            return a ? i.createElement(e) : {}
        }
    }, function (e, t, n) {
        var a = n(37),
            o = n(262).set;
        e.exports = function (e, t, n) {
            var r, i = t.constructor;
            return i !== n && "function" == typeof i && (r = i.prototype) !== n.prototype && a(r) && o && o(e, r), e
        }
    }, function (e, t) {
        t.f = {}.propertyIsEnumerable
    }, function (e, t, n) {
        var o = n(50),
            s = n(87),
            l = n(163)(!1),
            u = n(122)("IE_PROTO");
        e.exports = function (e, t) {
            var n, r = s(e),
                i = 0,
                a = [];
            for (n in r) n != u && o(r, n) && a.push(n);
            for (; t.length > i;) o(r, n = t[i++]) && (~l(a, n) || a.push(n));
            return a
        }
    }, function (e, t, n) {
        var l = n(87),
            u = n(34),
            h = n(89);
        e.exports = function (s) {
            return function (e, t, n) {
                var r, i = l(e),
                    a = u(i.length),
                    o = h(n, a);
                if (s && t != t) {
                    for (; o < a;)
                        if (r = i[o++], r != r) return !0
                } else
                    for (; o < a; o++)
                        if ((s || o in i) && i[o] === t) return s || o || 0;
                return !s && -1
            }
        }
    }, function (e, t, n) {
        var r = n(37),
            i = n(74),
            a = n(15)("match");
        e.exports = function (e) {
            var t;
            return r(e) && (void 0 !== (t = e[a]) ? !!t : "RegExp" == i(e))
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(24),
            i = n(33),
            a = n(23),
            o = n(15)("species");
        e.exports = function (e) {
            var t = r[e];
            a && t && !t[o] && i.f(t, o, {
                configurable: !0,
                get: function () {
                    return this
                }
            })
        }
    }, function (e, t, n) {
        e.exports = n(263)
    }, function (e, t, n) {
        var o = n(28),
            s = n(29),
            l = n(76);
        e.exports = n(26) ? Object.defineProperties : function (e, t) {
            s(e);
            for (var n, r = l(t), i = r.length, a = 0; a < i;) o.f(e, n = r[a++], t[n]);
            return e
        }
    }, function (e, t, n) {
        var o = n(45),
            s = n(61),
            l = n(266)(!1),
            u = n(128)("IE_PROTO");
        e.exports = function (e, t) {
            var n, r = s(e),
                i = 0,
                a = [];
            for (n in r) n != u && o(r, n) && a.push(n);
            for (; t.length > i;) o(r, n = t[i++]) && (~l(a, n) || a.push(n));
            return a
        }
    }, function (e, t, n) {
        var r = n(14).document;
        e.exports = r && r.documentElement
    }, function (e, t, n) {
        var r = n(45),
            i = n(52),
            a = n(128)("IE_PROTO"),
            o = Object.prototype;
        e.exports = Object.getPrototypeOf || function (e) {
            return e = i(e), r(e, a) ? e[a] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? o : null
        }
    }, function (e, t, n) {
        var a = n(29);
        e.exports = function (t, e, n, r) {
            try {
                return r ? e(a(n)[0], n[1]) : e(n)
            } catch (e) {
                var i = t.return;
                throw void 0 !== i && a(i.call(t)), e
            }
        }
    }, function (e, t, n) {
        var r = n(60),
            i = n(19)("iterator"),
            a = Array.prototype;
        e.exports = function (e) {
            return void 0 !== e && (r.Array === e || a[i] === e)
        }
    }, function (e, t, n) {
        var a = n(19)("iterator"),
            o = !1;
        try {
            var r = [7][a]();
            r.return = function () {
                o = !0
            }, Array.from(r, function () {
                throw 2
            })
        } catch (e) {}
        e.exports = function (e, t) {
            if (!t && !o) return !1;
            var n = !1;
            try {
                var r = [7],
                    i = r[a]();
                i.next = function () {
                    return {
                        done: n = !0
                    }
                }, r[a] = function () {
                    return i
                }, e(r)
            } catch (e) {}
            return n
        }
    }, function (e, t, n) {
        "use strict";
        var l = n(30),
            u = n(270),
            h = n(96);
        n(98)("search", 1, function (r, i, o, s) {
            return [function (e) {
                var t = r(this),
                    n = null == e ? void 0 : e[i];
                return void 0 !== n ? n.call(e, t) : new RegExp(e)[i](String(t))
            }, function (e) {
                var t = s(o, e, this);
                if (t.done) return t.value;
                var n = l(e),
                    r = String(this),
                    i = n.lastIndex;
                u(i, 0) || (n.lastIndex = 0);
                var a = h(n, r);
                return u(n.lastIndex, i) || (n.lastIndex = i), null === a ? -1 : a.index
            }]
        })
    }, function (e, t, n) {
        var r = n(15)("unscopables"),
            i = Array.prototype;
        null == i[r] && n(32)(i, r, {}), e.exports = function (e) {
            i[r][e] = !0
        }
    }, function (e, t, n) {
        "use strict";
        var _ = n(85),
            A = n(22),
            x = n(38),
            C = n(32),
            I = n(63),
            w = n(273),
            M = n(135),
            b = n(177),
            S = n(15)("iterator"),
            E = !([].keys && "next" in [].keys()),
            T = "@@iterator",
            L = "keys",
            N = "values",
            R = function () {
                return this
            };
        e.exports = function (e, t, n, r, i, a, o) {
            w(n, t, r);
            var s, l, u, h = function (e) {
                    if (!E && e in p) return p[e];
                    switch (e) {
                        case L:
                        case N:
                            return function () {
                                return new n(this, e)
                            }
                    }
                    return function () {
                        return new n(this, e)
                    }
                },
                c = t + " Iterator",
                d = i == N,
                f = !1,
                p = e.prototype,
                g = p[S] || p[T] || i && p[i],
                m = g || h(i),
                v = i ? d ? h("entries") : m : void 0,
                y = "Array" == t && p.entries || g;
            if (y && (u = b(y.call(new e)), u !== Object.prototype && u.next && (M(u, c, !0), _ || "function" == typeof u[S] || C(u, S, R))), d && g && g.name !== N && (f = !0, m = function () {
                    return g.call(this)
                }), _ && !o || !E && !f && p[S] || C(p, S, m), I[t] = m, I[c] = R, i)
                if (s = {
                        values: d ? m : h(N),
                        keys: a ? m : h(L),
                        entries: v
                    }, o)
                    for (l in s) l in p || x(p, l, s[l]);
                else A(A.P + A.F * (E || f), t, s);
            return s
        }
    }, function (e, t, n) {
        var r = n(50),
            i = n(39),
            a = n(122)("IE_PROTO"),
            o = Object.prototype;
        e.exports = Object.getPrototypeOf || function (e) {
            return e = i(e), r(e, a) ? e[a] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? o : null
        }
    }, function (e) {
        e.exports = function (e, t) {
            return {
                value: t,
                done: !!e
            }
        }
    }, function (e, t, n) {
        var r = n(168),
            i = n(130).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function (e) {
            return r(e, i)
        }
    }, function (e, t, n) {
        var r = n(100),
            i = n(71),
            a = n(61),
            o = n(117),
            s = n(45),
            l = n(156),
            u = Object.getOwnPropertyDescriptor;
        t.f = n(26) ? u : function (e, t) {
            if (e = a(e), t = o(t, !0), l) try {
                return u(e, t)
            } catch (e) {}
            if (s(e, t)) return i(!r.f.call(e, t), e[t])
        }
    }, function (e, t, n) {
        e.exports = n(290)
    }, function (e, t, n) {
        "use strict";
        var r = n(14),
            i = n(9),
            a = n(28),
            o = n(26),
            s = n(19)("species");
        e.exports = function (e) {
            var t = "function" == typeof i[e] ? i[e] : r[e];
            o && t && !t[s] && a.f(t, s, {
                configurable: !0,
                get: function () {
                    return this
                }
            })
        }
    }, function (e, t, n) {
        "use strict";
        var c = n(14),
            d = n(10),
            f = n(64),
            p = n(44),
            g = n(43),
            m = n(102),
            v = n(66),
            y = n(103),
            _ = n(17),
            A = n(78),
            x = n(28).f,
            C = n(141)(0),
            I = n(26);
        e.exports = function (n, e, t, r, i, a) {
            var o = c[n],
                s = o,
                l = i ? "set" : "add",
                u = s && s.prototype,
                h = {};
            return I && "function" == typeof s && (a || u.forEach && !p(function () {
                (new s).entries().next()
            })) ? (s = e(function (e, t) {
                y(e, s, n, "_c"), e._c = new o, null != t && v(t, i, e[l], e)
            }), C("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function (r) {
                var i = "add" == r || "set" == r;
                r in u && (!a || "clear" != r) && g(s.prototype, r, function (e, t) {
                    if (y(this, s, r), !i && a && !_(e)) return "get" == r && void 0;
                    var n = this._c[r](0 === e ? 0 : e, t);
                    return i ? this : n
                })
            }), a || x(s.prototype, "size", {
                get: function () {
                    return this._c.size
                }
            })) : (s = r.getConstructor(e, n, i, l), m(s.prototype, t), f.NEED = !0), A(s, n), h[n] = s, d(d.G + d.W + d.F, h), a || r.setStrong(s, n, i), s
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(10);
        e.exports = function (e) {
            r(r.S, e, {
                of: function () {
                    for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];
                    return new this(t)
                }
            })
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(10),
            l = n(70),
            u = n(36),
            h = n(66);
        e.exports = function (e) {
            r(r.S, e, {
                from: function (e, t, n) {
                    var r, i, a, o, s = t;
                    return l(this), r = void 0 !== s, r && l(s), null == e ? new this : (i = [], r ? (a = 0, o = u(s, n, 2), h(e, !1, function (e) {
                        i.push(o(e, a++))
                    })) : h(e, !1, i.push, i), new this(i))
                }
            })
        }
    }, function (e, t, n) {
        var r = n(0);

        function i(e, t, n) {
            return t in e ? r(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        e.exports = i
    }, function (e, t, n) {
        var l = n(46),
            u = n(51);
        e.exports = function (s) {
            return function (e, t) {
                var n, r, i = String(u(e)),
                    a = l(t),
                    o = i.length;
                return a < 0 || o <= a ? s ? "" : void 0 : (n = i.charCodeAt(a), n < 55296 || 56319 < n || a + 1 === o || (r = i.charCodeAt(a + 1)) < 56320 || 57343 < r ? s ? i.charAt(a) : n : s ? i.slice(a, a + 2) : r - 56320 + (n - 55296 << 10) + 65536)
            }
        }
    }, function (e, t, n) {
        var i = n(30),
            a = n(119),
            o = n(15)("species");
        e.exports = function (e, t) {
            var n, r = i(e).constructor;
            return void 0 === r || null == (n = i(r)[o]) ? t : a(n)
        }
    }, function (e, t, n) {
        "use strict";
        var c = n(26),
            d = n(76),
            f = n(139),
            p = n(100),
            g = n(52),
            m = n(127),
            i = Object.assign;
        e.exports = !i || n(44)(function () {
            var e = {},
                t = {},
                n = Symbol(),
                r = "abcdefghijklmnopqrst";
            return e[n] = 7, r.split("").forEach(function (e) {
                t[e] = e
            }), 7 != i({}, e)[n] || Object.keys(i({}, t)).join("") != r
        }) ? function (e) {
            for (var t = g(e), n = arguments.length, r = 1, i = f.f, a = p.f; r < n;)
                for (var o, s = m(arguments[r++]), l = i ? d(s).concat(i(s)) : d(s), u = l.length, h = 0; h < u;) o = l[h++], c && !a.call(s, o) || (t[o] = s[o]);
            return t
        } : i
    }, function (e, t, n) {
        e.exports = n(309)
    }, function (e, t, n) {
        for (var r, i = n(24), a = n(32), o = n(73), s = o("typed_array"), l = o("view"), u = !(!i.ArrayBuffer || !i.DataView), h = u, c = 0, d = 9, f = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); c < d;)(r = i[f[c++]]) ? (a(r.prototype, s, !0), a(r.prototype, l, !0)) : h = !1;
        e.exports = {
            ABV: u,
            CONSTR: h,
            TYPED: s,
            VIEW: l
        }
    }, function (e, t, n) {
        var i = n(38);
        e.exports = function (e, t, n) {
            for (var r in t) i(e, r, t[r], n);
            return e
        }
    }, function (e) {
        e.exports = function (e, t, n, r) {
            if (!(e instanceof t) || void 0 !== r && r in e) throw TypeError(n + ": incorrect invocation!");
            return e
        }
    }, function (e, t, n) {
        var r = n(46),
            i = n(34);
        e.exports = function (e) {
            if (void 0 === e) return 0;
            var t = r(e),
                n = i(t);
            if (t !== n) throw RangeError("Wrong length!");
            return n
        }
    }, function (e, t, n) {
        n(40)("Uint32", 4, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        n(40)("Int16", 2, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        n(40)("Int8", 1, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        var o = n(10),
            r = n(91),
            s = n(44),
            l = n(146),
            i = "[" + l + "]",
            u = "",
            a = RegExp("^" + i + i + "*"),
            h = RegExp(i + i + "*$"),
            c = function (e, t, n) {
                var r = {},
                    i = s(function () {
                        return !!l[e]() || u[e]() != u
                    }),
                    a = r[e] = i ? t(d) : l[e];
                n && (r[n] = a), o(o.P + o.F * i, "String", r)
            },
            d = c.trim = function (e, t) {
                return e = String(r(e)), 1 & t && (e = e.replace(a, "")), 2 & t && (e = e.replace(h, "")), e
            };
        e.exports = c
    }, function (e, t, n) {
        "use strict";
        var c = n(30),
            d = n(34),
            f = n(142),
            p = n(96);
        n(98)("match", 1, function (r, i, u, h) {
            return [function (e) {
                var t = r(this),
                    n = null == e ? void 0 : e[i];
                return void 0 !== n ? n.call(e, t) : new RegExp(e)[i](String(t))
            }, function (e) {
                var t = h(u, e, this);
                if (t.done) return t.value;
                var n = c(e),
                    r = String(this);
                if (!n.global) return p(n, r);
                var i = n.unicode;
                n.lastIndex = 0;
                for (var a, o = [], s = 0; null !== (a = p(n, r));) {
                    var l = String(a[0]);
                    o[s] = l, "" === l && (n.lastIndex = f(r, d(n.lastIndex), i)), s++
                }
                return 0 === s ? null : o
            }]
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(41));
        n(13);
        var o = r(n(47));
        n(55);
        var s = r(n(54)),
            l = r(n(27)),
            u = r(n(35)),
            m = r(n(12));
        n(8);
        var g = r(n(16));
        n(174);
        var c = r(n(2)),
            d = r(n(3)),
            f = r(n(4)),
            p = r(n(5)),
            v = r(n(104)),
            y = r(n(6));
        n(48);
        var _, A = r(n(105)),
            x = r(n(201)),
            C = r(n(375)),
            I = r(n(42)),
            w = r(n(20)),
            M = r(n(414)),
            b = r(n(58)),
            S = r(n(81)),
            E = r(n(57)),
            T = r(n(234)),
            h = r(n(235)),
            L = r(n(21)),
            N = r(n(236)),
            R = r(n(49)),
            k = r(n(416)),
            P = n(69),
            D = r(n(109)),
            O = r(n(205)),
            F = r(n(237)),
            B = r(n(114)),
            G = n(69),
            U = r(n(239)),
            z = r(n(419)),
            V = n(111);

        function H(o) {
            var e = this.MapOptions.mapThemeURL + "/" + this.MapOptions.defaultThemeName + "/" + this.MapOptions.defaultThemeName + ".theme",
                s = this;
            this.fmServer.getTheme(e, function (e) {
                s.initTheme(s.MapOptions.defaultThemeName, e, function (n) {
                    var r = null,
                        e = s.MapOptions.mapServerURL,
                        t = "GET";
                    if ("fengmap" === s.MapOptions.mapServerURL) {
                        e = D.default+"sdk/auth/downMaps", s.obtainMapRoute && (e = D.default+"sdk/auth/obtainMapRoute"), s.MapOptions.tile && (e = D.default+"sdk/authLayered/downMaps", s.obtainMapRoute && (e = D.default+"sdk/authLayered/obtainMapRoute"));
                        var i = O.default.getCerityData(s.MapOptions.key, s.MapOptions.appName, o),
                            a = {
                                newFlag: "2",
                                mapId: i.mapId,
                                keyValue: i.appKey,
                                appName: i.appName,
                                webUrl: i.webURL,
                                keyType: 3,
                                isSeparate: s.MapOptions.tile
                            };
                        r = (0, A.default)(a), t = "POST"
                    } else s.obtainMapRoute = !1;
                    s.obtainMapRoute ? s.fmServer.getUrl(e, o, s.MapOptions.tile, r, t, function (e, t) {
                        e = e.replace('"', "").replace('"', ""), s.fmServer.getScene(e, null, s.MapOptions.tile, null, "GET", function (e) {
                            s.dataExcute(n, e, t, r)
                        }, function (e) {
                            _ && _(e)
                        })
                    }, function (e) {
                        _ && _(e)
                    }) : s.fmServer.getScene(e, o, s.MapOptions.tile, r, t, function (e, t) {
                        s.dataExcute(n, e, t, r)
                    }, function (e) {
                        _ && _(e)
                    }), s._currentSceneId = o
                })
            })
        }
        var W = function (e) {
                function h(e) {
                    var t;
                    return (0, c.default)(this, h), t = (0, f.default)(this, (0, p.default)(h).call(this)), t.uuid = fm.Math.generateUUID(), S.default[t.uuid] = {}, t.MapOptions = new C.default(e), t.fmServer = new x.default, t.dataManager = new I.default, t.nodeManager = new w.default(t.MapOptions, (0, v.default)(t)), t.isMarkerTip = !1, e.isMarkerTip && (t.isMarkerTip = !0), t.isMarkerMove = !1, e.isMarkerMove && (t.isMarkerMove = !0), t.render = null, t.getRenderOption(), e.lightEffects ? S.default.light = !0 : S.default.light = !1, t.renderer = new U.default(t.MapOptions, (0, v.default)(t)), t.controls = new fm.OrbitControls("3d" === t.MapOptions.defaultViewMode ? t.renderer.perspectiveCamera : t.renderer.orthographicCamera, t.renderer.canvas, (0, v.default)(t)), t.mapScaleLevels = [295829355.45, 147914677.73, 73957338.86, 36978669.43, 18489334.72, 9244667.36, 4622333.68, 2311166.84, 1155583.42, 577791.71, 288895.85, 144447.93, 72223.96, 36111.98, 18056, 9028, 4514, 2257, 1128, 564, 282, 141, 70, 35, 17, 8, 4, 2, 1], t._mapScaleLevel = 20, t._mapScale = 564, t._minScale = 1, t._maxScale = 295829355.45, t._minScaleLevel = 1, t._maxScaleLevel = 29, t._animaters = [], t._windowPops = [], t._currentSceneId = "10347", t._currentFocusGroup = t.MapOptions.defaultFocusGroup, t._visibleGroups = t.MapOptions.defaultVisibleGroups, t._viewMode = t.MapOptions.defaultViewMode, t.renderer.viewMode = t.MapOptions.defaultViewMode, t._currentTime = (new Date).getTime(), t._showAllGroup = !1, t._lineMarkers = [], t._lastMoveEvent = null, t._mouseHoverTime = 0, t._mouseHoverStart = !0, t._compassBG = t.MapOptions.compassBg, t._compassFG = t.MapOptions.compassFg, t.getMapScaleInfo(), t.scaleLevelInit(), t.controlEventInit(), t._loopHander = requestAnimationFrame(t.update.bind((0, v.default)(t))), t.allowRender = !0, t._sweep = {}, t.isOneShot = !0, t.pickFilterFunction = null, t.animationMixers = [], t.hoverFilterFunction = null, t._eventId = 0, t._modelSelectColor = {
                        r: .97,
                        g: .388,
                        b: .196,
                        a: 1
                    }, t._fullScreen = !1, t._enterControl = new F.default, t._enterControl.enableMapHover = t.MapOptions.modelHoverEffect, t._allowfps = 60, t._renderTime = 0, t.controls.setEnterCtrl(t._enterControl), t.otherFocus = [], t.autoRotateBymodel = !1, t.autoRotateBymodelSpeed = 1, t.autoRotateBymodelPause = !1, t.tileLoading = !1, t.letUpdate = !1, t._shotIndex = 0, t.isOneShot = !0, t.selectedObjects = [], t.isFpsDisplay = !1, t.stats = null, e.isFpsDisplay && (t.isFpsDisplay = e.isFpsDisplay), t.isFpsDisplay && (t.stats = new k.default, t.stats.showPanel(0), document.body.appendChild(t.stats.dom)), t.obtainMapRoute = !0, t.videoMemory = new z.default((0, v.default)(t)), t.getStation(), t.animaModels = [], t.layerRenderOrder = V.LayerOrder, t
                }
                return (0, y.default)(h, e), (0, d.default)(h, [{
                    key: "getRenderOption",
                    value: function () {
                        try {
                            this.MapOptions.logarithmicDepthBuffer ? this.render = new fm.WebGLRenderer({
                                antialias: !0,
                                alpha: !0,
                                logarithmicDepthBuffer: !0
                            }) : this.render = new fm.WebGLRenderer({
                                antialias: !0,
                                alpha: !0
                            })
                        } catch (e) {
                            return console.error("WebGLRenderer ERROR: ", e), (new fengmap.MapError).noWebGL(this.renderOption.container), !1
                        }
                        this.canvas = this.render.domElement;
                        var e = this.MapOptions.container.clientWidth,
                            t = this.MapOptions.container.clientHeight;
                        return this.perspectiveCamera = new fm.PerspectiveCamera(35, e / t, 2, 1e5), this.orthographicCamera = new fm.OrthographicCamera(-e / 2, e / 2, t / 2, -t / 2, 1, 1e5), !0
                    }
                }, {
                    key: "isOnLine",
                    value: function (e, t) {
                        var n = new Image;
                        n.onload = function () {
                            e && e()
                        }, n.onerror = function () {
                            t && t()
                        }, n.style.display = "none", n.src = "http://www.baidu.com/img/baidu_sylogo1.gif?" + ("" + Math.random()).slice(-6)
                    }
                }, {
                    key: "openMapById",
                    value: function (t, n) {
                        if (_ = n, t)
                            if (this.MapOptions.key) {
                                var e = /^[a-zA-z\d]{32}$/;
                                if (e.test(this.MapOptions.key))
                                    if (this.MapOptions.appName) {
                                        this._zopStep_ = 1;
                                        var r = this;
                                        this.MapOptions.useCompatibleOnLineCheck ? this.isOnLine(i, a) : (navigator.onLine ? i : a)()
                                    } else console.warn(decodeURIComponent(P.cerityMessage.warn_noappname));
                                else console.warn(decodeURIComponent(P.cerityMessage.warn_keynotright))
                            } else console.warn(decodeURIComponent(P.cerityMessage.warn_nokey));
                        else console.warn(decodeURIComponent(P.cerityMessage.warn_nomapid));

                        function i() {
                            "fengmap" === r.MapOptions.mapServerURL ? O.default.checkIsOnLine(function () {
                                O.default.checkOnLine(r.MapOptions.key, r.MapOptions.appName, t, function () {
                                    H.call(r, t, !0)
                                }, function (e) {
                                    e ? (console.warn(e.error_code, e.error_message), n && n({
                                        msg: "!",
                                        data: e
                                    })) : (console.warn("offLine 2"), H.call(r, t))
                                }, "POST")
                            }, function () {
                                console.warn("offLine 1"), H.call(r, t)
                            }, 1e3) : H.call(r, t)
                        }

                        function a() {
                            H.call(r, t)
                        }
                    }
                }, {
                    key: "search",
                    value: function (e, t, n) {
                        return B.default.search(this, e, t, n)
                    }
                }, {
                    key: "changeFocusToGroup",
                    value: function (n) {
                        var r = this,
                            e = this.nodeManager.getSceneCenter(this._currentSceneId),
                            t = this.controls.target.y;
                        this.currentFocusGroup = n.gid;
                        var i = this.nodeManager.getHeight(this._currentSceneId, this.currentFocusGroup) + e.y,
                            a = this.getFMGroup(n.gid).mapCoordRange,
                            o = {
                                x: (a[0].x + a[1].x) / 2,
                                y: (a[0].y + a[1].y) / 2
                            },
                            s = o.x - this.center.x,
                            l = -o.y + this.center.y;
                        if (this.controls.target.x = s, this.controls.target.z = l, this.controls.update(), !this.MapOptions.focusAnimateMode) return this.controls.panUp(i - t), this.controls.update(), n.callback && n.callback(), void this.setRenderList();
                        S.default[this.uuid].currentGroupChangeAnimater && (S.default[this.uuid].currentGroupChangeAnimater.stop(), this.removeAnimater(S.default[this.uuid].currentGroupChangeAnimater));
                        var u = new b.default({
                            h: t
                        }, {
                            h: i
                        }, n.duration ? 1e3 * n.duration : 800, function () {
                            r.removeAnimater(u), S.default[r.uuid].currentGroupChangeAnimater = null, n.callback && n.callback()
                        }, function (e, t) {
                            r.controls.panUp(t.h), n.update && n.update()
                        }).start();
                        S.default[this.uuid].currentGroupChangeAnimater = u, this._animaters.push(u)
                    }
                }, {
                    key: "dataExcute",
                    value: function (e, t, n, r) {
                        var i = this;
                        if (this && this.MapOptions) {
                            var a = new fm.Color(e.selectedColor);
                            this._modelSelectColor.r = a.r, this._modelSelectColor.g = a.g, this._modelSelectColor.b = a.b, 0 === this.MapOptions.defaultBackgroundColor ? this.MapOptions.defaultBackgroundColor = 0 : this.MapOptions.defaultBackgroundColor || (this.MapOptions.defaultBackgroundColor = E.default.toColor(e.data.viewtheme.clearcolor)), null === this.MapOptions.defaultBackgroundAlpha && (this.MapOptions.defaultBackgroundAlpha = (0, g.default)(e.data.viewtheme.clearalpha)), this.renderer.setClearColor(this.MapOptions.defaultBackgroundColor, this.MapOptions.defaultBackgroundAlpha), this.dataManager.putRawScene(t, n);
                            var o = this.dataManager.parseScene(n, this.MapOptions.tile, this.MapOptions.license, this.obtainMapRoute);
                            if (o) {
                                var s = !o.scene.key || O.default.checkOffLine(this.MapOptions.key, this.MapOptions.appName, "", o.scene.key);
                                if (!s) return console.warn(decodeURIComponent(P.cerityMessage.warn_offline)), void(_ && _({
                                    message: decodeURIComponent(P.cerityMessage.warn_local)
                                }));
                                this.dataManager.putDecodeScene(o, n), this.nodeManager.conformatScene(o, n, e), this.groupSpace = this.MapOptions.defaultGroupSpace, this.initCameraPosition(), this.renderer.perspectiveCamera.position;
                                var l = this.renderer.getFrustumByViewMode(this._viewMode),
                                    u = this.getVisibleGroups();
                                if (this.MapOptions.tile) {
                                    var h = this.nodeManager.getSceneById(this._currentSceneId);
                                    h.sdata = r;
                                    var c = h.getNeedLoadGroup(u),
                                        d = function () {
                                            var t = function () {
                                                var t = h.getNeedLoadGroup(u, !0);
                                                if (t.length < 1) return i.focusGroupID = i._currentFocusGroup, void i.dispatchEvent({
                                                    type: "loadComplete"
                                                });
                                                i.loadAndExcuteData(t, h, 0, !1, function (e) {
                                                    i.tileLoading = !1, e === t.length - 1 && (i.focusGroupID = i._currentFocusGroup, i.dispatchEvent({
                                                        type: "loadComplete"
                                                    }))
                                                })
                                            };
                                            if (c.length < 1) return i.dispatchEvent({
                                                type: "visibleGroupLoaded"
                                            }), void t();
                                            i.loadAndExcuteData(c, h, 0, !1, function (e) {
                                                i.nodeManager.checkNodeByFrustum(i.dataManager.getDecodeScene(i._currentSceneId), i.renderer.getFrustumByViewMode(i._viewMode), i.getVisibleGroups(), i.mapScaleLevel, n), i.setRenderList(), i.avoidMarkers(), e === c.length - 1 && (i.dispatchEvent({
                                                    type: "visibleGroupLoaded"
                                                }), t())
                                            })
                                        };
                                    this.tileLoading = !0;
                                    for (var f = -1, p = 0; p < c.length; p++)
                                        if (c[p].gid && c[p].gid == this._currentFocusGroup) {
                                            f = p;
                                            break
                                        } if (f < 0) return void console.error(G.tileMessage.noFocus);
                                    this.loadAndExcuteData(c, h, f, !0, function () {
                                        i.nodeManager.checkNodeByFrustum(i.dataManager.getDecodeScene(i._currentSceneId), i.renderer.getFrustumByViewMode(i._viewMode), i.getVisibleGroups(), i.mapScaleLevel, n), i.setRenderList(), i.avoidMarkers(), c.splice(f, 1), d()
                                    })
                                } else this.nodeManager.checkNodeByFrustum(o, l, u, this.mapScaleLevel, n), this.setRenderList(), this.avoidMarkers(), this.dispatchEvent({
                                    type: "visibleGroupLoaded"
                                }), this.dispatchEvent({
                                    type: "loadComplete"
                                }), this.renderer.setClearColor(this.MapOptions.defaultBackgroundColor, this.MapOptions.defaultBackgroundAlpha), this.focusGroupID = this._currentFocusGroup;
                                this.letUpdate = !0, setTimeout(function () {
                                    i.animationPlay()
                                }, 3e3)
                            }
                        }
                    }
                }, {
                    key: "animationPlay",
                    value: function () {
                        for (var e = 0; e < this.animaModels.length; e++) {
                            for (var t = this.animaModels[e].animations, n = this.animaModels[e].model, r = new fm.AnimationMixer(n), i = {}, a = 0; a < t.length; a++) {
                                var o = t[a],
                                    s = r.clipAction(o);
                                i[o.name] = s
                            }
                            this.addAnimationMixer(r), i[t[0].name].clampWhenFinished = !0, i[t[0].name].reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(.2).play()
                        }
                    }
                }, {
                    key: "loadAndExcuteData",
                    value: function (o, s, l, u, h) {
                        var c = this,
                            d = o[l];
                        this.fmServer.getFloor(this.MapOptions.mapServerURL, d.url, this._currentSceneId, d.gid, function (e, t, n, r) {
                            var i = c.dataManager.parseFloor(e, t, n),
                                a = {
                                    geo: [i[0]],
                                    biz: [i[1]],
                                    navi: [i[2]],
                                    gid: r
                                };
                            c.dataManager.getDecodeScene(c._currentSceneId).floors.push(a), d.layerData.loaded = !0, s.addGroup(r, a, d.layerData), h && h(l), u || (l++, l < o.length && c.loadAndExcuteData(o, s, l, !1, h))
                        }, s.sdata, this.obtainMapRoute)
                    }
                }, {
                    key: "moveLinesUv",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, m.default)(this._lineMarkers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                o.moveUv(e)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "resetLineRepeat",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, m.default)(this._lineMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.resetRepeat(this)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "hideOrShowLine",
                    value: function () {
                        var e = this.groupIDs[this.groupIDs.length - 1],
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, m.default)(this._lineMarkers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                o.hideOrShowBy(this._visibleGroups, e)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "getVisibleGroups",
                    value: function () {
                        return this._visibleGroups
                    }
                }, {
                    key: "setVisibleGroups",
                    value: function (e) {
                        this._visibleGroups = e, this.checkNode(), this.setRenderList(), this.dispatchEvent({
                            type: "visibleGroupIDsChanged",
                            gids: e
                        })
                    }
                }, {
                    key: "getFloorIdByGid",
                    value: function (e) {
                        var t = this.getFMGroup(e);
                        return t._groupMessage.floorid
                    }
                }, {
                    key: "initCameraPosition",
                    value: function () {
                        var e = this.getCameraDistanceByScale(this.mapScale),
                            t = this.MapOptions.defaultViewCenter;
                        try {
                            if (t) {
                                var n = this.nodeManager.getSceneById(this._currentSceneId).mapcenter;
                                t.x -= n.x, t.y -= n.y, t.z = -t.y, t.y = 0
                            } else t = this.nodeManager.getSceneById(this._currentSceneId).center;
                            var r = this.nodeManager.getHeight(this._currentSceneId, this._currentFocusGroup);
                            t.z = 0, t.y += r, this.controls.target = (new fm.Vector3).copy(t)
                        } catch (e) {
                            console.error(G.mapOptionMessage.defaultViewCenterError)
                        }
                        if ("3d" === this._viewMode) {
                            this.controls.minPolarAngle = (90 - this.MapOptions.defaultMaxTiltAngle) * fm.Math.DEG2RAD, this.controls.maxPolarAngle = (90 - this.MapOptions.defaultMinTiltAngle) * fm.Math.DEG2RAD;
                            var i = (90 - this.MapOptions.defaultTiltAngle) * fm.Math.DEG2RAD,
                                a = e * Math.cos(i),
                                o = e * Math.sin(i),
                                s = new fm.Vector3(0, a, o);
                            this.controls.object.position.set(t.x + s.x, t.y + s.y, t.z + s.z), this.controls.object.lookAt(t), this.renderer.orthographicCamera.position.set(t.x + s.x, t.y + s.y, t.z + s.z), this.renderer.orthographicCamera.lookAt(t)
                        } else {
                            var l = this.getCameraScaleByScale(this.mapScale);
                            this.controls.minPolarAngle = 0, this.controls.maxPolarAngle = 0, this.controls.object.position.set(t.x, t.y + e, t.z), this.controls.object.zoom = 1 / l, this.controls.object.lookAt(t), this.renderer.orthographicCamera.updateProjectionMatrix()
                        }
                        var u = this.MapOptions.computePoseToAngle();
                        this.controls.rotateLeft(u * fm.Math.DEG2RAD), this._changePanrange(e, t), this.controls.update()
                    }
                }, {
                    key: "_changePanrange",
                    value: function () {
                        if (this.MapOptions.enabledPanRange) {
                            var e = .5,
                                t = this.nodeManager.getSceneById(this._currentSceneId).bboxTh;
                            this.controls.viewBox = new fm.Box3(new fm.Vector3(t.min.x, 0, t.min.y), new fm.Vector3(t.max.x, this.getGroupHeight(this.groupIDs[this.groupIDs.length - 1]) + this.groupSpace, t.max.y)), this.controls.viewBox.min.multiplyScalar(e), this.controls.viewBox.max.multiplyScalar(e), this.controls.useRange = !0
                        }
                    }
                }, {
                    key: "scaleLevelInit",
                    value: function () {
                        if (this.MapOptions.mapScaleLevelRange && this.setMapScaleLevelRange(this.MapOptions.mapScaleLevelRange), this.MapOptions.mapScaleRange && this.setMapScaleRange(this.MapOptions.mapScaleRange), this.MapOptions.defaultMapScaleLevel) {
                            var e = this.MapOptions.defaultMapScaleLevel;
                            this._mapScaleLevel = e, this._mapScale = this.levelToScale(e)
                        }
                        this.MapOptions.defaultMapScale && (this.mapScale = this.MapOptions.defaultMapScale)
                    }
                }, {
                    key: "setMapScaleRange",
                    value: function (e, t) {
                        (0, u.default)(e) ? (this.minScale = e[0], this.maxScale = e[1]) : (this.minScale = e, this.maxScale = t)
                    }
                }, {
                    key: "setMapScaleLevelRange",
                    value: function (e, t) {
                        (0, u.default)(e) ? (this.minScaleLevel = e[0], this.maxScaleLevel = e[1]) : (this.minScaleLevel = e, this.maxScaleLevel = t)
                    }
                }, {
                    key: "showSingerOrMultiGroup",
                    value: function (e) {
                        this._showAllGroup = e, this.visibleGroupIDs = e ? this.getCurrGroupIds().slice(0) : [this._currentFocusGroup]
                    }
                }, {
                    key: "removeAnimater",
                    value: function (e) {
                        var t = this._animaters.indexOf(e); - 1 < t && this._animaters.splice(t, 1)
                    }
                }, {
                    key: "dollyOut",
                    value: function () {
                        var n = this,
                            r = 1,
                            e = new b.default({
                                scale: 1
                            }, {
                                scale: 2
                            }, 500, function () {
                                n.removeAnimater(e)
                            }, function (e) {
                                var t = e.scale / r;
                                r = e.scale, n.controls.dollyOut(t)
                            }).start();
                        this._animaters.push(e)
                    }
                }, {
                    key: "dollyIn",
                    value: function () {
                        var n = this,
                            r = 1,
                            e = new b.default({
                                scale: 1
                            }, {
                                scale: 2
                            }, 500, function () {
                                n.removeAnimater(e)
                            }, function (e) {
                                var t = e.scale / r;
                                r = e.scale, n.controls.dollyIn(t)
                            }).start();
                        this._animaters.push(e)
                    }
                }, {
                    key: "zoomIn",
                    value: function () {
                        this.dollyIn()
                    }
                }, {
                    key: "zoomOut",
                    value: function () {
                        this.dollyOut()
                    }
                }, {
                    key: "checkNode",
                    value: function () {
                        if (this.renderer) {
                            var e, t = this.renderer.getFrustumByViewMode(this._viewMode),
                                n = this._currentSceneId,
                                r = this.dataManager.getDecodeScene(n);
                            e = "top" === this._viewMode ? this.getScaleByCameraScale() : this.getScaleByCameraDistance();
                            var i = this.scaleTolevel(e);
                            this.nodeManager.checkNodeByFrustum(r, t, this.getVisibleGroups(), i, n)
                        }
                    }
                }, {
                    key: "getCurrDecodeData",
                    value: function () {
                        var e = this._currentSceneId,
                            t = this.dataManager.getDecodeScene(e);
                        return t
                    }
                }, {
                    key: "setBackgroundColor",
                    value: function (e, t) {
                        var n = this;
                        "string" == typeof e && (e = (0, l.default)(e.replace("#", "0x"))), setTimeout(function () {
                            n.renderer.setClearColor(e, t)
                        }, 500)
                    }
                }, {
                    key: "setBackground",
                    value: function (e) {
                        this.renderer.setClearColor(0, 0), this.renderer.setBackground(e)
                    }
                }, {
                    key: "addAnimationMixer",
                    value: function (e) {
                        this.animationMixers.push(e)
                    }
                }, {
                    key: "setRenderList",
                    value: function () {
                        var e = this;
                        if (this.nodeManager) {
                            if (1 < this.visibleGroupIDs.length)
                                for (var r = this.nodeManager._scenes[this._currentSceneId].groups[this.focusGroupID]._layers.extent[0]._scene.rotation.y, t = 0; t < this.visibleGroupIDs.length; t++) this.visibleGroupIDs[t] !== this.focusGroupID && function () {
                                    var n = e.nodeManager._scenes[e._currentSceneId].groups[e.visibleGroupIDs[t]]._layers;
                                    (0, s.default)(n).forEach(function (e) {
                                        if ("domMarker" !== e) {
                                            var t = n[e];
                                            0 < t.length && (t[0]._scene.rotation.y = r)
                                        }
                                    })
                                }();
                            var n = this.nodeManager.getRenderList();
                            this.renderer.renderList = n, this.renderer.resetSpriteSize()
                        }
                    }
                }, {
                    key: "rushRenderNode",
                    value: function () {
                        this.setRenderList(), this.renderer.resetSpriteSize()
                    }
                }, {
                    key: "controlEventInit",
                    value: function () {
                        var i = this;
                        this.controls.addEventListener("change", function () {
                            var e;
                            i.checkNode(), i.setRenderList(), i.avoidMarkers(), i.renderer.compassNode && (i.renderer.compassNode.material.uniforms.rotation.value = -i.controls.getAzimuthalAngle()), e = "top" === i._viewMode ? i.getScaleByCameraScale() : i.getScaleByCameraDistance(), i.dispatchEvent({
                                type: "mapViewChanged"
                            }), .5 < Math.abs(e - i._mapScale) && i.dispatchEvent({
                                type: "scaleLevelChanged",
                                scale: e
                            }), i._mapScale = e;
                            var t = i.scaleTolevel(e);
                            t !== i._mapScaleLevel && (i._mapScaleLevel = t, i.dispatchEvent({
                                type: "mapScaleLevelChanged",
                                mapScale: t
                            })), i._mapScaleLevel = t, i.renderer.resetSpriteSize(), i.moveLinesUv(.01), i.resetLineRepeat(), i.renderer.resetLocationsSize()
                        });
                        var n = 0,
                            r = 0,
                            a = null;
                        this.isMarkerMove && this.MapOptions.container.addEventListener("mousedown", function (e) {
                            var t = {
                                x: 2 * e.offsetX / i.MapOptions.container.clientWidth - 1,
                                y: 1 - 2 * e.offsetY / i.MapOptions.container.clientHeight
                            };
                            n = (new Date).getTime(), a = setInterval(function () {
                                if (r = (new Date).getTime(), 500 < r - n) {
                                    var e = i.nodeManager.getFacility(i._currentSceneId, i.getVisibleGroups(), t, i.renderer.getCameraByViewMode(i._viewMode));
                                    0 < e.length && i.dispatchEvent({
                                        type: "press",
                                        target: e[0].object.mapNode
                                    }), clearInterval(a)
                                }
                            }, 250)
                        }), this.controls.addEventListener("mouseup", function (e) {
                            var t = e.mousePoint,
                                n = {
                                    x: 2 * t.x / t.w - 1,
                                    y: 1 - 2 * t.y / t.h
                                };
                            i._eventId++;
                            var r = i.dispatchClickEvent(n, e.event);
                            e.mouseButton === fm.MOUSE.LEFT && r && null != r.target && (4 != r.target._nodeType ? i.modelFire(n) : i.selectNull()), i.checkCompassClick(n), null !== a && (clearInterval(a), a = null), i.dispatchEvent({
                                type: "pressover"
                            })
                        }), this.controls.addEventListener("mousemove", function (e) {
                            (i.isMarkerTip || i.isMarkerMove) && i.mouseIntoInfo(e), i._lastMoveEvent = e, i._mouseHoverTime = 0, i._mouseHoverStart = !0, null !== a && (clearInterval(a), a = null)
                        })
                    }
                }, {
                    key: "mouseIntoInfo",
                    value: function (e) {
                        var t = e.mousePoint,
                            n = {
                                x: 2 * t.x / t.w - 1,
                                y: 1 - 2 * t.y / t.h
                            };
                        if (!this.isMarkerTip) {
                            var r = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), n, this.renderer.getCameraByViewMode(this._viewMode));
                            0 !== r.length ? this.dispatchEvent({
                                type: "hover",
                                target: r[0].object.mapNode
                            }) : this.dispatchEvent({
                                type: "mouseleave"
                            })
                        }
                    }
                }, {
                    key: "checkCompassClick",
                    value: function (e) {
                        if (this.renderer && this.renderer.compassNode && this.showCompass) {
                            var t = this.renderer.compassNode.userData;
                            R.default.pointIsInRect(e, t.coord, t.width, t.width) && this.dispatchEvent({
                                type: "mapClickCompass",
                                target: this.renderer.compassNode
                            })
                        }
                    }
                }, {
                    key: "dispatchClickEvent",
                    value: function (e, t) {
                        if (this._enterControl.enableMapSingleTap) {
                            var n, r = this.nodeManager.getNode(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode)),
                                i = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode)),
                                a = this.nodeManager.getExternalModels(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode)),
                                o = {
                                    type: "mapClickNode",
                                    target: null,
                                    mouse: t.mouse,
                                    domEvent: t,
                                    eventInfo: {
                                        domEvent: t,
                                        coord: null,
                                        eventID: this._eventId
                                    },
                                    nodeType: null
                                };
                            if (r.length < 1 && i.length < 1 && a.length < 1) return this.dispatchEvent(o), n = {
                                target: !0
                            }, n;
                            if (1 <= i.length) {
                                var s = 0;
                                if (this.pickFilterFunction) {
                                    var l = this.pickFilterFunction({
                                        nodeType: i[0].object.mapNode.nodeType,
                                        typeID: i[0].object.mapNode.bdata && i[0].object.mapNode.bdata.type,
                                        data: i[0].object.mapNode.bdata
                                    });
                                    l || (s = 1)
                                }
                                n = {
                                    type: "mapClickNode",
                                    target: i[0].object.mapNode,
                                    mouse: t.mouse,
                                    domEvent: t,
                                    eventInfo: {
                                        domEvent: t,
                                        coord: {
                                            x: i[0].object.mapNode.x,
                                            y: i[0].object.mapNode.y
                                        },
                                        eventID: this._eventId
                                    },
                                    mapCoord: {
                                        x: i[0].object.mapNode.x,
                                        y: i[0].object.mapNode.y
                                    },
                                    nodeType: i[0].object.mapNode.nodeType
                                }, 1 === s ? this.dispatchEvent(o) : this.dispatchEvent(n)
                            }
                            if (1 <= r.length) {
                                var u = 0;
                                if (this.pickFilterFunction) {
                                    var h = this.pickFilterFunction({
                                        nodeType: r[0].object.mapNode.nodeType,
                                        typeID: r[0].object.mapNode.bdata && r[0].object.mapNode.bdata.type,
                                        data: r[0].object.mapNode.bdata
                                    });
                                    h || (u = 1)
                                }
                                var c = (new fm.Vector3).copy(r[0].point);
                                return n = {
                                    type: "mapClickNode",
                                    target: r[0].object.mapNode,
                                    mouse: t.mouse,
                                    domEvent: t,
                                    eventInfo: {
                                        domEvent: t,
                                        threeCoord: c,
                                        coord: {
                                            x: c.x + this.center.x,
                                            y: this.center.y - c.z
                                        },
                                        eventID: this._eventId
                                    },
                                    mapCoord: {
                                        x: c.x + this.center.x,
                                        y: this.center.y - c.z
                                    },
                                    nodeType: r[0].object.mapNode.nodeType
                                }, 1 === u ? (this.dispatchEvent(o), o) : (this.dispatchEvent(n), n)
                            }
                            if (1 <= a.length) {
                                var d = (new fm.Vector3).copy(a[0].point);
                                return n = {
                                    type: "mapClickNode",
                                    target: a[0].object,
                                    mouse: t.mouse,
                                    domEvent: t,
                                    eventInfo: {
                                        domEvent: t,
                                        threeCoord: d,
                                        coord: {
                                            x: d.x + this.center.x,
                                            y: this.center.y - d.z
                                        },
                                        eventID: this._eventId
                                    },
                                    mapCoord: {
                                        x: d.x + this.center.x,
                                        y: this.center.y - d.z
                                    },
                                    nodeType: 35
                                }, this.dispatchEvent(n), n
                            }
                        }
                    }
                }, {
                    key: "getDatasByAlias",
                    value: function (e, t, n) {
                        n = n || function () {
                            return !0
                        };
                        var r = this.nodeManager.getSceneById(this._currentSceneId);
                        return r.getGroupsNodelsByFilter([e], t, n)
                    }
                }, {
                    key: "mouseHoverEventFire",
                    value: function (e) {
                        if (this._mouseHoverStart)
                            if (this._mouseHoverTime > this.MapOptions.modelHoverTime) {
                                if (!this._enterControl.enableMapHover) return;
                                if (!this._lastMoveEvent) return;
                                var t = this._lastMoveEvent,
                                    n = t.mousePoint,
                                    r = {
                                        x: 2 * n.x / n.w - 1,
                                        y: 1 - 2 * n.y / n.h
                                    },
                                    i = this.nodeManager.getNode(this._currentSceneId, this.getVisibleGroups(), r, this.renderer.getCameraByViewMode(this._viewMode)),
                                    a = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), r, this.renderer.getCameraByViewMode(this._viewMode));
                                if (i.length < 1 && a.length < 1) return;
                                if (i[0]) {
                                    var o = (new fm.Vector3).copy(i[0].point),
                                        s = {
                                            type: "mapHoverNode",
                                            target: i[0].object.mapNode,
                                            mouse: n,
                                            eventInfo: {
                                                domEvent: t.event,
                                                threeCoord: i[0].point,
                                                eventID: t.eventID,
                                                coord: {
                                                    x: o.x + this.center.x,
                                                    y: i[0].object.mapNode.y - o.z
                                                }
                                            },
                                            groupID: i[0].object.mapNode.groupID,
                                            nodeType: i[0].object.mapNode.nodeType
                                        };
                                    if (this.hoverFilterFunction) {
                                        var l = this.hoverFilterFunction({
                                            nodeType: i[0].object.mapNode.nodeType,
                                            typeID: i[0].object.mapNode.bdata && i[0].object.mapNode.bdata.type,
                                            data: i[0].object.mapNode.bdata
                                        });
                                        l && (i[0].object.mapNode.nodeType === L.default.MODEL && this.MapOptions.modelHoverEffect && this.storeSelect(i[0].object), this.dispatchEvent(s))
                                    } else i[0].object.mapNode.nodeType === L.default.MODEL && this.MapOptions.modelHoverEffect && this.storeSelect(i[0].object), this.dispatchEvent(s)
                                }
                                if (a[0]) {
                                    var u = (new fm.Vector3).copy(a[0].point),
                                        h = {
                                            type: "mapHoverNode",
                                            target: a[0].object.mapNode,
                                            mouse: n,
                                            eventInfo: {
                                                domEvent: t.event,
                                                threeCoord: a[0].point,
                                                eventID: t.eventID,
                                                coord: {
                                                    x: u.x + this.center.x,
                                                    y: a[0].object.mapNode.y - u.z
                                                }
                                            },
                                            groupID: a[0].object.mapNode.groupID,
                                            nodeType: a[0].object.mapNode.nodeType
                                        };
                                    if (this.hoverFilterFunction) {
                                        var c = this.hoverFilterFunction({
                                            nodeType: a[0].object.mapNode.nodeType,
                                            typeID: a[0].object.mapNode.bdata && a[0].object.mapNode.bdata.type,
                                            data: a[0].object.mapNode.bdata
                                        });
                                        c && this.dispatchEvent(h)
                                    } else this.dispatchEvent(h)
                                }
                                this._mouseHoverStart = !1, this._mouseHoverTime = 0
                            } else this._mouseHoverTime += e
                    }
                }, {
                    key: "selectNull",
                    value: function () {
                        if (S.default[this.uuid].currentModel) {
                            S.default[this.uuid].currentAnimater && (S.default[this.uuid].currentAnimater.stop(), S.default[this.uuid].currentAnimater = void 0);
                            var e = S.default[this.uuid].currentModel;
                            if (void 0 === S.default[this.uuid].currentModel.material.length) e.material.color = S.default[this.uuid].currentModel.material.userData.color, e.material.opacity = S.default[this.uuid].currentModel.material.userData.opacity, e.material.userData.opacity = void 0, e.material.userData.color = void 0, e.material.update = !0, S.default[this.uuid].currentModel = void 0;
                            else {
                                for (var t = 0; t < S.default[this.uuid].currentModel.material.length; t++) e.material[t].color = S.default[this.uuid].currentModel.material[t].userData.color, e.material[t].opacity = S.default[this.uuid].currentModel.material[t].userData.opacity, e.material[t].userData.opacity = void 0, e.material[t].userData.color = void 0, e.material[t].update = !0;
                                S.default[this.uuid].currentModel = void 0
                            }
                        }
                    }
                }, {
                    key: "callAllLayersByAlias",
                    value: function (e, t) {
                        this.nodeManager.getSceneById(this._currentSceneId).getAllGroupLayerByAlias(e, t)
                    }
                }, {
                    key: "storeSelect",
                    value: function (e) {
                        var t = this,
                            n = e;
                        if (e.nodeType && e.nodeType === L.default.MODEL) {
                            if (!e.renderNodeInited) return;
                            n = e.renderNode
                        }
                        if (S.default[this.uuid].currentModel && S.default[this.uuid].currentModel !== n)
                            if (S.default[this.uuid].currentAnimater && (S.default[this.uuid].currentAnimater.stop(), S.default[this.uuid].currentAnimater = void 0), void 0 === S.default[this.uuid].currentModel.material.length) S.default[this.uuid].currentModel.material.color = S.default[this.uuid].currentModel.material.userData.color, S.default[this.uuid].currentModel.material.opacity = S.default[this.uuid].currentModel.material.userData.opacity, S.default[this.uuid].currentModel.material.update = !0;
                            else
                                for (var r = 0; r < S.default[this.uuid].currentModel.material.length; r++) S.default[this.uuid].currentModel.material[r].color = S.default[this.uuid].currentModel.material[r].userData.color, S.default[this.uuid].currentModel.material[r].opacity = S.default[this.uuid].currentModel.material[r].userData.opacity, S.default[this.uuid].currentModel.material[r].update = !0;
                        if (S.default[this.uuid].currentModel = n, void 0 === n.material.length) n.material.userData.color || (n.material.userData.color = n.material.color, n.material.userData.opacity = n.material.opacity);
                        else
                            for (var i = 0; i < n.material.length; i++) n.material[i].userData.color || (n.material[i].userData.color = n.material[i].color, n.material[i].userData.opacity = n.material[i].opacity);
                        if (!S.default[this.uuid].currentAnimater) {
                            var a = this._modelSelectColor.a;
                            0 === a && (a = 1);
                            var o = new b.default({
                                r: this._modelSelectColor.r / 2,
                                g: this._modelSelectColor.g / 2,
                                b: this._modelSelectColor.b / 2,
                                a: a / 2
                            }, this._modelSelectColor, 500, function () {
                                t.removeAnimater(o), S.default[t.uuid].currentAnimater = null
                            }, function (e) {
                                if (void 0 === n.material.length) n.material.userData.color && (n.material.color = new fm.Color(e.r, e.g, e.b), n.material.opacity = a, n.material.update = !0);
                                else
                                    for (var t = 0; t < n.material.length; t++) n.material[t].userData.color && (n.material[t].color = new fm.Color(e.r, e.g, e.b), n.material[t].opacity = a, n.material[t].update = !0)
                            });
                            S.default[this.uuid].currentAnimater = o, o.start(), this._animaters.push(o)
                        }
                    }
                }, {
                    key: "modelFire",
                    value: function (e) {
                        var t = [],
                            n = [];
                        if (this.MapOptions)
                            if (this.MapOptions.lightEffects) {
                                t = this.nodeManager.getExternalModels(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode)), n = this.nodeManager.getModel(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode));
                                var r = t.concat(n);
                                if (r.length < 1) return void this.selectNull();
                                if (!this.MapOptions.modelSelectedEffect) return;
                                this.storeSelect(r[0].object)
                            } else {
                                if (t = this.nodeManager.getModelExternal(this._currentSceneId, this.getVisibleGroups(), e, this.renderer.getCameraByViewMode(this._viewMode)), t.length < 1) return void this.selectNull();
                                if (!this.MapOptions.modelSelectedEffect) return;
                                for (var i = 0; i < t.length && !t[i].object.visible; i++);
                                this.storeSelect(t[i].object)
                            }
                    }
                }, {
                    key: "setModelSelectColor",
                    value: function (e, t) {
                        var n = new fm.Color;
                        n.set(e), this._modelSelectColor = {
                            r: n.r,
                            g: n.g,
                            b: n.b,
                            a: t
                        }
                    }
                }, {
                    key: "checkMarkerAvoid",
                    value: function (e) {
                        if (!(e.length < 1)) {
                            for (var t = e[0], n = [], r = 1; r < e.length; r++) R.default.isRectCross(t.leftTop, t.rightDown, e[r].leftTop, e[r].rightDown) ? e[r].target.visible = !1 : (e[r].target.visible = !0, n.push(e[r]));
                            1 < n.length && (n.reverse(), this.checkMarkerAvoid(n))
                        }
                    }
                }, {
                    key: "avoidMarkers",
                    value: function () {
                        var e = this.nodeManager.getSceneById(this._currentSceneId);
                        if (e)
                            for (var t = this.renderer.getCameraByViewMode(this._viewMode), n = 0; n < this._visibleGroups.length; n++) {
                                var r = e.getMarkers(this._visibleGroups[n], t, this.renderer.domElementHeight);
                                this.checkMarkerAvoid(r);
                                for (var i = e.getUserMarkers(this._visibleGroups[n], t, this.renderer.domElementHeight), a = 0; a < i.length; a++) this.checkMarkerAvoid(i[a])
                            }
                    }
                }, {
                    key: "addAnimater",
                    value: function (e) {
                        this._animaters.push(e)
                    }
                }, {
                    key: "initTheme",
                    value: function (e, t, n) {
                        var r = this.MapOptions.themeFileType || t.filetype || t.fileType || t.image,
                            i = new M.default(this.MapOptions.mapThemeURL, e);
                        if (i.clearColor = this.MapOptions.defaultBackgroundColor, i.clearAlpha = this.MapOptions.defaultBackgroundAlpha, i.version = this.MapOptions.themeVersion, "rtheme" == r) {
                            var a = this.MapOptions.mapThemeURL + "/" + this.MapOptions.themeName + "/" + e + ".rtheme";
                            this.fmServer.getTheme(a, function (e) {
                                i.rtheme = e, i.data = t, n && (i.fileType = r, n(i))
                            }, function () {
                                i.rtheme = null, console.warn(" rtheme !")
                            })
                        } else i.rtheme = null, i.data = t, n && n(i);
                        this._modelSelectColor = i.getModelSelectColor()
                    }
                }, {
                    key: "levelToScale",
                    value: function (e) {
                        return this.mapScaleLevels[e - 1]
                    }
                }, {
                    key: "scaleTolevel",
                    value: function (e) {
                        if (e > this.mapScaleLevels[0]) return 1;
                        if (e < this.mapScaleLevels[this.mapScaleLevels.length - 1]) return this.mapScaleLevels.length;
                        for (var t = 0; t < this.mapScaleLevels.length - 1; t++)
                            if (e >= this.mapScaleLevels[t + 1] && e <= this.mapScaleLevels[t]) {
                                var n = e - this.mapScaleLevels[t + 1],
                                    r = this.mapScaleLevels[t] - e;
                                return n < r ? t + 2 : t + 1
                            }
                    }
                }, {
                    key: "getMapScaleInfo",
                    value: function () {
                        for (var e, t = 56; t < 2e3; t++) !0 === matchMedia("(max-resolution: " + t + "dpi)").matches && (e = t / window.devicePixelRatio);
                        if (window.screen.deviceXDPI) e = window.screen.deviceXDPI;
                        else {
                            var n = document.createElement("DIV");
                            n.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden", document.body.appendChild(n), e = (0, l.default)(n.offsetWidth), n.parentNode.removeChild(n)
                        }
                        this._pixelsPerCentimeter = e / 2.54
                    }
                }, {
                    key: "getOrthoCameraSizeByPerspectiveCamera",
                    value: function (e, t, n) {
                        e instanceof h && (n = t, t = e.controls, e = e.mapView.camera);
                        var r = e.fov,
                            i = e.aspect,
                            a = null != n ? n : t.target.distanceTo(e.position),
                            o = Math.tan(r * fm.Math.DEG2RAD / 2) * a,
                            s = 2 * o,
                            l = s * i,
                            u = l / 2;
                        return {
                            top: o || 1,
                            right: u
                        }
                    }
                }, {
                    key: "getCameraDistanceByScale",
                    value: function (e) {
                        var t = this.renderer.perspectiveCamera.fov,
                            n = e / 100 * (this.renderer.domElementHeight / this._pixelsPerCentimeter) / 2 / Math.tan(t / 2 * fm.Math.DEG2RAD);
                        return n
                    }
                }, {
                    key: "getScaleByCameraDistance",
                    value: function () {
                        var e = this.renderer.perspectiveCamera.fov,
                            t = (new fm.Vector3).copy(this.controls.object.position).sub(this.controls.target).length(),
                            n = 100 * Math.tan(e / 2 * fm.Math.DEG2RAD) * 2 / (this.renderer.domElementHeight / this._pixelsPerCentimeter);
                        return t * n
                    }
                }, {
                    key: "getCameraScaleByScale",
                    value: function (e) {
                        var t = this.renderer.orthographicCamera.top,
                            n = this.renderer.orthographicCamera.bottom,
                            r = Math.abs(t - n) * this._pixelsPerCentimeter * 100 / this.renderer.domElementHeight;
                        return e / r
                    }
                }, {
                    key: "getScaleByCameraScale",
                    value: function () {
                        var e = this.renderer.orthographicCamera.top,
                            t = this.renderer.orthographicCamera.bottom,
                            n = Math.abs(e - t) * this._pixelsPerCentimeter * 100 / this.renderer.domElementHeight;
                        return n / this.renderer.orthographicCamera.zoom
                    }
                }, {
                    key: "getLayerByAlias",
                    value: function (e, t, n) {
                        var r = [],
                            i = this.getFMGroup(e);
                        return i.traverseByAlias([t], function (e) {
                            r.push(e), n && n(e)
                        }, !0), r
                    }
                }, {
                    key: "moveTo",
                    value: function (e) {
                        return this._moveTo(e, !1)
                    }
                }, {
                    key: "_moveTo",
                    value: function (n, e) {
                        var t, r, i = this,
                            a = this.center,
                            o = n.x - a.x,
                            s = -n.y + a.y,
                            l = this.controls.target.x,
                            u = this.controls.target.z,
                            h = n.groupID;
                        if (t = h ? (r = this.controls.target.y, this.currentFocusGroup = h, this.nodeManager.getHeight(this._currentSceneId, this.currentFocusGroup)) : (r = 0, 0), !this.MapOptions.moveToAnimateMode && !e) return h && this.controls.panUp(t - r), this.controls.panAdd({
                            x: o - l,
                            z: s - u,
                            y: 0
                        }), this.controls.update(), null;
                        S.default[this.uuid].currentMoveMapAnimater && (S.default[this.uuid].currentMoveMapAnimater.stop(), this.removeAnimater(S.default[this.uuid].currentMoveMapAnimater));
                        var c = new b.default({
                            h: r,
                            x: l,
                            z: u
                        }, {
                            h: t,
                            x: o,
                            z: s
                        }, n.time ? 1e3 * n.time : 500, function () {
                            i.removeAnimater(c), S.default[i.uuid].currentMoveMapAnimater = null, n.callback && n.callback()
                        }, function (e, t) {
                            h && i.controls.panUp(t.h), i.controls.panAdd({
                                x: t.x,
                                z: t.z,
                                y: 0
                            }), i.controls.update(), n.update && n.update()
                        }).start();
                        return S.default[this.uuid].currentMoveMapAnimater = c, this._animaters.push(c), c
                    }
                }, {
                    key: "moveToCenter",
                    value: function (e) {
                        if ("object" !== (0, o.default)(e)) {
                            var t = this.center;
                            this.moveTo({
                                x: t.x,
                                y: t.y,
                                groupID: e || this.focusGroupID
                            })
                        } else this.moveTo(e)
                    }
                }, {
                    key: "rotateTo",
                    value: function (n) {
                        var r = this,
                            e = this.controls.getAzimuthalAngle(),
                            t = -n.to % 360 * fm.Math.DEG2RAD,
                            i = t,
                            a = 0;
                        t - e != 0 && (a = Math.sin(t - e) / Math.abs(Math.sin(t - e)) * Math.acos(Math.cos(t - e))), t = e + a, S.default[this.uuid].currentRotateAnimater && (S.default[this.uuid].currentRotateAnimater.stop(), this.removeAnimater(S.default[this.uuid].currentRotateAnimater));
                        var o = new b.default({
                            theta: e
                        }, {
                            theta: t
                        }, n.duration ? 1e3 * n.duration : 500, function () {
                            r.removeAnimater(o), r.controls.setUpdate(void 0, void 0, void 0, i), n.callback && n.callback()
                        }, function (e, t) {
                            r.controls.setUpdate(void 0, t.theta), n.update && n.update()
                        }).start();
                        return S.default[this.uuid].currentRotateAnimater = o, this._animaters.push(o), o
                    }
                }, {
                    key: "scaleTo",
                    value: function (i, e) {
                        var a = this;
                        if (i.scale) {
                            var t = i.scale,
                                n = this.mapScale,
                                r = this.getCameraDistanceByScale(t),
                                o = this.controls.object.position.distanceTo(this.controls.target),
                                s = (new fm.Vector3).copy(this.controls.object.position).sub(this.controls.target).normalize();
                            if (!this.MapOptions.scaleToAnimateMode && !e) {
                                var l = (new fm.Vector3).copy(s).multiplyScalar(r - o);
                                this.controls.setUpdate(0, 0, l);
                                var u = this.getCameraScaleByScale(t);
                                return this.renderer.orthographicCamera.zoom = 1 / u, this.renderer.orthographicCamera.updateProjectionMatrix(), this.renderer.resetSpriteSize(), null
                            }
                            var h = new b.default({
                                phi: o,
                                scale: n
                            }, {
                                phi: r,
                                scale: t
                            }, i.duration ? 1e3 * i.duration : 500, function () {
                                a.removeAnimater(h), i.callback && i.callback(), a.renderer.resetSpriteSize()
                            }, function (e, t) {
                                var n = (new fm.Vector3).copy(s).multiplyScalar(t.phi);
                                a.controls.setUpdate(0, 0, n), i.update && i.update();
                                var r = a.getCameraScaleByScale(e.scale);
                                a.renderer.orthographicCamera.zoom = 1 / r, a.renderer.orthographicCamera.updateProjectionMatrix()
                            }).start();
                            return this._animaters.push(h), h
                        }
                    }
                }, {
                    key: "scaleLevelIn",
                    value: function () {
                        var e = this.scaleLevel;
                        e--, this.scaleLevelTo({
                            level: e
                        })
                    }
                }, {
                    key: "scaleLevelOut",
                    value: function () {
                        var e = this.scaleLevel;
                        e++, this.scaleLevelTo({
                            level: e
                        })
                    }
                }, {
                    key: "scaleLevelTo",
                    value: function (i) {
                        var a = this;
                        if (i.level) {
                            var e = this.levelToScale(i.level),
                                t = this.mapScale,
                                n = this.getCameraDistanceByScale(e),
                                r = this.controls.object.position.distanceTo(this.controls.target),
                                o = (new fm.Vector3).copy(this.controls.object.position).sub(this.controls.target).normalize();
                            if (!i.duration) {
                                var s = (new fm.Vector3).copy(o).multiplyScalar(n - r);
                                this.controls.setUpdate(0, 0, s);
                                var l = this.getCameraScaleByScale(e);
                                return this.renderer.orthographicCamera.zoom = 1 / l, this.renderer.orthographicCamera.updateProjectionMatrix(), void this.controls.update()
                            }
                            var u = new b.default({
                                phi: r,
                                scale: t
                            }, {
                                phi: n,
                                scale: e
                            }, i.duration ? 1e3 * i.duration : 500, function () {
                                a.removeAnimater(u), i.callback && i.callback(), a.renderer.resetSpriteSize()
                            }, function (e, t) {
                                var n = (new fm.Vector3).copy(o).multiplyScalar(t.phi);
                                a.controls.setUpdate(0, 0, n), i.update && i.update();
                                var r = a.getCameraScaleByScale(e.scale);
                                a.renderer.orthographicCamera.zoom = 1 / r, a.renderer.orthographicCamera.updateProjectionMatrix()
                            }).start();
                            return this._animaters.push(u), u
                        }
                    }
                }, {
                    key: "tiltTo",
                    value: function (n) {
                        var r = this;
                        if (0 !== n.to && n.to) {
                            var e = this.controls.getPolarAngle(),
                                t = (90 - n.to) * fm.Math.DEG2RAD,
                                i = new b.default({
                                    phi: e
                                }, {
                                    phi: t
                                }, n.duration ? 1e3 * n.duration : 500, function () {
                                    r.removeAnimater(i), n.callback && n.callback(), r.renderer.resetSpriteSize()
                                }, function (e, t) {
                                    r.controls.setUpdate(t.phi), n.update && n.update(e)
                                }).start();
                            return this._animaters.push(i), i
                        }
                    }
                }, {
                    key: "fullScreenAvaliable",
                    value: function () {
                        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                    }
                }, {
                    key: "coordMapToScreen",
                    value: function (e, t, n) {
                        var r = this.threeCenter,
                            i = this.center,
                            a = this.controls.object,
                            o = this.getRotationCoord(e, t, !0),
                            s = new fm.Vector3(o.x - i.x, r.y + n, -o.y + r.y + i.y),
                            l = s.project(a),
                            u = this.renderer.container.clientWidth,
                            h = this.renderer.container.clientHeight,
                            c = u / 2 * s.x + u / 2,
                            d = -h / 2 * s.y + h / 2,
                            f = !0;
                        return (1 < Math.abs(l.x) || 1 < Math.abs(l.y) || 1 < Math.abs(l.z)) && (f = !1), {
                            x: c,
                            y: d,
                            domvisible: f
                        }
                    }
                }, {
                    key: "getRotationCoord",
                    value: function (e, t, n) {
                        var r = e - this.center.x,
                            i = t - this.center.y,
                            a = 1;
                        n && (a = -1);
                        var o = this.nodeManager._scenes[this._currentSceneId].groups[this.focusGroupID]._layers.extent[0]._scene.rotation.y,
                            s = Math.sin(a * o) * i + Math.cos(a * o) * r,
                            l = Math.cos(a * o) * i - Math.sin(a * o) * r,
                            u = s - r,
                            h = l - i;
                        return {
                            x: e + u,
                            y: t + h
                        }
                    }
                }, {
                    key: "coordScreenToMap",
                    value: function (e, t, n, r, i) {
                        var a = this.controls.object,
                            o = 1e-4,
                            s = this.center,
                            l = this.threeCenter,
                            u = this.getFMGroup(this._currentFocusGroup).height;
                        if (null != u) {
                            n = void 0 === n ? u + this.MapOptions.pickCoordHeight : n;
                            var h = null;
                            h = r ? new fm.Vector3(e, t, n) : new fm.Vector3(e / this.renderer.domElementWidth * 2 - 1, 1 - t / this.renderer.domElementHeight * 2, .5);
                            var c = new fm.Vector3,
                                d = new fm.Vector3;
                            a && a.isPerspectiveCamera ? (c.setFromMatrixPosition(a.matrixWorld), d.set(h.x, h.y, .5).unproject(a).sub(c).normalize()) : a && a.isOrthographicCamera && (c.set(h.x, h.y, (a.near + a.far) / (a.near - a.far)).unproject(a), d.set(0, 0, -1).transformDirection(a.matrixWorld));
                            var f = new fm.Vector3(0, 1, 0),
                                p = f.dot(d);
                            if (!(Math.abs(p) < o)) {
                                var g = -c.y + n + l.y,
                                    m = g / d.y,
                                    v = (new fm.Vector3).copy(c).add((new fm.Vector3).copy(d).multiplyScalar(m));
                                return i ? v : {
                                    x: v.x + s.x,
                                    y: s.y - v.z,
                                    z: n
                                }
                            }
                        }
                    }
                }, {
                    key: "getScalelevelValueByVectics",
                    value: function (e, t) {
                        return this.scaleTolevel(this.getScaleValueByVectics(e, t))
                    }
                }, {
                    key: "getScaleValueByVectics",
                    value: function (e, t) {
                        var n = Math.abs(t.x - e.x),
                            r = Math.abs(t.y - e.y),
                            i = this.renderer.domElementHeight,
                            a = this.renderer.domElementWidth,
                            o = null;
                        if (a <= i)
                            if (n / r <= a / i) {
                                var s = i / this._pixelsPerCentimeter;
                                o = 100 * r / s
                            } else {
                                var l = a / this._pixelsPerCentimeter;
                                o = 100 * n / l
                            }
                        else if (n / r <= a / i) {
                            var u = i / this._pixelsPerCentimeter;
                            o = 100 * r / u
                        } else {
                            var h = a / this._pixelsPerCentimeter;
                            o = 100 * n / h
                        }
                        return o
                    }
                }, {
                    key: "toggleToTop",
                    value: function (n, e) {
                        var r = this,
                            t = 1 < arguments.length && void 0 !== e ? arguments[1] : 1e3;
                        this.controls.minPolarAngle = 0, this.controls.update();
                        var i = this.controls.getPolarAngle();
                        S.default[this.uuid].curPolarAngle = i, this.MapOptions.viewModeAnimateMode || (t = .001);
                        var a = new b.default({
                            phi: i
                        }, {
                            phi: 0
                        }, t, function () {
                            r.removeAnimater(a), r.controls.maxPolarAngle = 0;
                            var e = r.getScaleByCameraDistance(),
                                t = r.getCameraScaleByScale(e);
                            r.renderer.orthographicCamera.zoom = 1 / t, r.renderer.orthographicCamera.quaternion.copy(r.controls.object.quaternion), r.renderer.orthographicCamera.position.copy(r.controls.object.position), r.renderer.orthographicCamera.updateProjectionMatrix(), r.controls.object = r.renderer.orthographicCamera, n && n(), r.renderer.resetSpriteSize(), S.default[r.uuid].isToggleViewMode = !1
                        }, function (e, t) {
                            r.controls.setUpdate(t.phi)
                        }).start();
                        S.default[this.uuid].isToggleViewMode = !0, this._animaters.push(a)
                    }
                }, {
                    key: "toggleTo3D",
                    value: function (e, t) {
                        var n = this,
                            r = 1 < arguments.length && void 0 !== t ? arguments[1] : 1e3;
                        this.controls.maxPolarAngle = (90 - this.MapOptions.defaultMinTiltAngle) * fm.Math.DEG2RAD;
                        var i = this.getScaleByCameraScale(),
                            a = this.getCameraDistanceByScale(i);
                        this.renderer.perspectiveCamera.quaternion.copy(this.controls.object.quaternion), this.renderer.perspectiveCamera.position.copy(this.controls.object.position), this.renderer.perspectiveCamera.position.setY(this.controls.target.y + a), this.renderer.perspectiveCamera.updateMatrix(), this.controls.object = this.renderer.perspectiveCamera, this.renderer.resetSpriteSize();
                        var o = S.default[this.uuid].curPolarAngle ? S.default[this.uuid].curPolarAngle : (90 - this.MapOptions.defaultTiltAngle) * fm.Math.DEG2RAD;
                        this.MapOptions.viewModeAnimateMode || (r = .001);
                        var s = new b.default({
                            phi: 0
                        }, {
                            phi: o
                        }, r, function () {
                            e && e(), n.removeAnimater(s), S.default[n.uuid].isToggleViewMode = !1, n.renderer.resetSpriteSize()
                        }, function (e, t) {
                            n.controls.setUpdate(t.phi)
                        }).start();
                        S.default[this.uuid].isToggleViewMode = !0, this._animaters.push(s)
                    }
                }, {
                    key: "getPixelTo3DdisByGid",
                    value: function (e) {
                        var t, n, r = (new fm.Vector3).copy(this.controls.target),
                            i = this.nodeManager.getSceneCenter(this._currentSceneId);
                        if (r.y = this.getFMGroup(e).height + this.getFMGroup(e).offsetHeight + i.y, "top" === this._viewMode) {
                            var a = this.renderer.orthographicCamera.top,
                                o = this.renderer.orthographicCamera.bottom;
                            n = 10 * Math.abs(a - o) / this.renderer.domElementHeight / this.renderer.orthographicCamera.zoom
                        } else {
                            var s = this.renderer.perspectiveCamera.near,
                                l = this.renderer.perspectiveCamera.fov,
                                u = this.controls.object.position.distanceTo(r);
                            t = 10 * s * Math.tan(l / 2 * fm.Math.DEG2RAD) * 2 / this.renderer.domElementHeight, n = t * u / s
                        }
                        return 10 / n
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        cancelAnimationFrame(this._loopHander), this.dispatchEvent({
                            type: "dispose"
                        });
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, m.default)(this._lineMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose(this)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.nodeManager.dispose(), this.dataManager.dispose(), this.controls.dispose(), this.renderer.dispose(), S.default.dispose(this.uuid), this._lineMarkers.length = 0, this._windowPops.length = 0, this.nodeManager = void 0, this.dataManager = void 0, this.controls = void 0, this.renderer = void 0, this.fmServer = void 0, this.MapOptions = void 0
                    }
                }, {
                    key: "disposeById",
                    value: function (e) {
                        this.nodeManager.disposeById(e), this.dataManager.disposeById(e)
                    }
                }, {
                    key: "addLocationMarker",
                    value: function (e) {
                        e.map = this, e.scene = this.nodeManager.getSceneById(this._currentSceneId), e.initSprite(this.nodeManager), this.addLocationToGroup(e, this._currentSceneId, e.groupID), e.renderNode.updateMatrixWorld(!0), this.renderer.setLocationSize(e.renderNode, e.size)
                    }
                }, {
                    key: "addLocationToGroup",
                    value: function (e, t, n) {
                        var r = this.nodeManager.getGroup(t, n);
                        r.addLocation(e)
                    }
                }, {
                    key: "removeLocationMarker",
                    value: function (e) {
                        this.removeLocationByGroup(e, this._currentSceneId, e.groupID), e.dispose()
                    }
                }, {
                    key: "removeLocationByGroup",
                    value: function (e, t, n) {
                        var r = this.nodeManager.getGroup(t, n);
                        r.removeLocation(e)
                    }
                }, {
                    key: "addLineMarker",
                    value: function (e, t) {
                        var n = this.center;
                        e.initLine(n, t, this), this._lineMarkers.push(e), e.hideOrShowBy(this.visibleGroupIDs)
                    }
                }, {
                    key: "removeLineMarker",
                    value: function (e) {
                        var t = this._lineMarkers.indexOf(e); - 1 < t && this._lineMarkers.splice(t, 1), e.removeByMap(this)
                    }
                }, {
                    key: "removeAllMarkers",
                    value: function () {
                        for (var e = this._lineMarkers.length - 1; - 1 < e; e--) this._lineMarkers[e].removeByMap(this);
                        this._lineMarkers.length = 0
                    }
                }, {
                    key: "clearLineMark",
                    value: function (e) {
                        if (e)
                            if ((0, u.default)(e)) {
                                var t = !0,
                                    n = !1,
                                    r = void 0;
                                try {
                                    for (var i, a = (0, m.default)(e); !(t = (i = a.next()).done); t = !0) {
                                        var o = i.value;
                                        this.removeLineMarker(o)
                                    }
                                } catch (e) {
                                    n = !0, r = e
                                } finally {
                                    try {
                                        t || null == a.return || a.return()
                                    } finally {
                                        if (n) throw r
                                    }
                                }
                            } else this.removeLineMarker(e);
                        else this.removeAllMarkers()
                    }
                }, {
                    key: "drawLineMark",
                    value: function (e, t, n) {
                        t.resolution = new fm.Vector2(this.renderer.container.clientWidth, this.renderer.container.clientHeight);
                        var r = this.renderer.getCameraByViewMode(this._viewMode);
                        t.near = r.near, t.far = r.far, t.url && (t.map = this.nodeManager.materialManager.loadTexture(t.url, function () {}), t.map.wrapS = fm.RepeatWrapping, t.map.wrapT = fm.RepeatWrapping), this.addLineMarker(e, t), n && n()
                    }
                }, {
                    key: "setLastRender",
                    value: function () {
                        var e = this.nodeManager.getSceneById(this._currentSceneId);
                        if (e) {
                            var t = e.getLastRenderArray();
                            this.renderer.setBackRender(t)
                        }
                    }
                }, {
                    key: "update",
                    value: function () {
                        if (this._loopHander = requestAnimationFrame(this.update.bind(this)), this.letUpdate) {
                            this.isFpsDisplay && this.stats.begin();
                            var e = (new Date).getTime(),
                                t = e - this._currentTime;
                            this._currentTime = e, this.mouseHoverEventFire(t);
                            var n = !0,
                                r = !1,
                                i = void 0;
                            try {
                                for (var a, o = (0, m.default)(this._animaters); !(n = (a = o.next()).done); n = !0) {
                                    var s = a.value;
                                    s.enable && s.run(t)
                                }
                            } catch (e) {
                                r = !0, i = e
                            } finally {
                                try {
                                    n || null == o.return || o.return()
                                } finally {
                                    if (r) throw i
                                }
                            }
                            var l = !0,
                                u = !1,
                                h = void 0;
                            try {
                                for (var c, d = (0, m.default)(this.animationMixers); !(l = (c = d.next()).done); l = !0) {
                                    var f = c.value;
                                    f.update(t / 1e3)
                                }
                            } catch (e) {
                                u = !0, h = e
                            } finally {
                                try {
                                    l || null == d.return || d.return()
                                } finally {
                                    if (u) throw h
                                }
                            }
                            this.dispatchEvent({
                                type: "frameLoop",
                                delTime: t
                            }), this.controls.update();
                            var p, g = !1;
                            this._renderTime += t, 1e3 / this._allowfps < this._renderTime && (p = this._renderTime, this._renderTime = 0, g = !0), this.renderer && g && (this.updatePopsPosition(), this.allowRender && (this.setLastRender(), this.renderer.update(this._viewMode)), this.dispatchEvent({
                                type: "update",
                                fps: 1e3 / p
                            })), this.isFpsDisplay && this.stats.end()
                        }
                    }
                }, {
                    key: "on",
                    value: function (e, t) {
                        this.addEventListener(e, t)
                    }
                }, {
                    key: "off",
                    value: function (e, t) {
                        this.removeEventListener(e, t)
                    }
                }, {
                    key: "registeredPop",
                    value: function (e) {
                        this._windowPops.push(e)
                    }
                }, {
                    key: "logoutPop",
                    value: function (e) {
                        var t = this._windowPops.indexOf(e); - 1 < t && this._windowPops.splice(t, 1)
                    }
                }, {
                    key: "updatePopsPosition",
                    value: function () {
                        var e = this.renderer.getCameraByViewMode(this._viewMode),
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, m.default)(this._windowPops); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                this.updatePopPosition(o, e)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "updatePopPosition",
                    value: function (e, t) {
                        t = t || this.renderer.getCameraByViewMode(this._viewMode);
                        var n = new fm.Vector3;
                        if (e.threeCoord) n.copy(e.threeCoord);
                        else if (e.marker) e.marker instanceof N.default ? 0 < e.marker._meshes.length && (e.marker._meshes[0].updateMatrixWorld(), e.marker._meshes[0].updateMatrixWorld(!0), n = (new fm.Vector3).setFromMatrixPosition(e.marker._meshes[0].matrixWorld)) : (e.marker.renderNode.parent.updateMatrixWorld(), e.marker.renderNode.updateMatrixWorld(!0), n = (new fm.Vector3).setFromMatrixPosition(e.marker.renderNode.matrixWorld));
                        else {
                            var r = this.center;
                            n = n.set(e.coord.x - r.x, this.getFMGroup(e.coord.groupID).getHeight() + e.coord.height, -e.coord.y + r.y)
                        }
                        var i = n.project(t),
                            a = (i.x + 1) / 2 * this.renderer.container.clientWidth,
                            o = (1 - i.y) / 2 * this.renderer.container.clientHeight;
                        e.updateCoord(a, o)
                    }
                }, {
                    key: "getFMGroup",
                    value: function (e) {
                        return this.nodeManager.getGroup(this._currentSceneId, e)
                    }
                }, {
                    key: "getGroupHeight",
                    value: function (e) {
                        var t = 50;
                        return this.getFMGroup(e) && (t = this.getFMGroup(e).getHeight()), t
                    }
                }, {
                    key: "getContainer",
                    value: function () {
                        return this.renderer.container
                    }
                }, {
                    key: "getCurrGroupLength",
                    value: function () {
                        this.nodeManager.getGroupLength(this._currentSceneId)
                    }
                }, {
                    key: "getCurrGroupIds",
                    value: function () {
                        return this.nodeManager.getGroupIds(this._currentSceneId)
                    }
                }, {
                    key: "Printing",
                    value: function (i) {
                        var a = this;
                        if (this.isOneShot = !0, this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.textMarker[0])
                            for (var e = 0; e < this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.textMarker[0].textMarkers.length; e++) this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.textMarker[0].textMarkers[e]._renderNode && (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.textMarker[0].textMarkers[e]._renderNode.visible = !0);
                        for (var t in this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.facility[0]._facility) this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.facility[0]._facility["" + t]._renderNode && (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.facility[0]._facility["" + t]._renderNode.visible = !0);
                        for (var n in this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.label[0]._labels) this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.label[0]._labels["" + n]._renderNode && (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers.label[0]._labels["" + n]._renderNode.visible = !0);
                        var o = this.mapScaleLevel,
                            r = {
                                level: 21
                            };
                        this.scaleLevelTo(r);
                        var s = this.controls.target.x,
                            l = this.controls.target.z;
                        this.controls.panAdd({
                            x: -s,
                            z: -l,
                            y: 0
                        });
                        var u = this.renderer.renderer.domElement.width,
                            h = this.renderer.renderer.domElement.height,
                            c = this.tiltAngle,
                            d = this.rotateAngle;
                        if (this.tiltAngle = 90, this.rotateAngle = 0, "3d" === this._viewMode) {
                            var f = this.renderer.orthographicCamera.zoom;
                            this.viewMode = "top", this.on("viewModeChange", function () {
                                var e = document.createElement("canvas");
                                e.width = 6 * u, e.height = 6 * h;
                                var t = e.getContext("2d"),
                                    n = 0,
                                    r = "3d";
                                a._shot(e, t, n, f, s, l, o, r, c, d, i)
                            })
                        } else {
                            var p = this.renderer.orthographicCamera.zoom,
                                g = document.createElement("canvas");
                            g.width = 6 * u, g.height = 6 * h;
                            var m = g.getContext("2d"),
                                v = 0,
                                y = "top";
                            this._shot(g, m, v, p, s, l, o, y, c, d, i)
                        }
                    }
                }, {
                    key: "_shot",
                    value: function (t, n, e, r, i, a, o, s, l, u, h) {
                        if (this.isOneShot && e < 36) {
                            var c = null,
                                d = null;
                            e < 6 ? (c = 0, d = +e) : e < 12 ? (c = 1, d = e - 6) : e < 18 ? (c = 2, d = e - 12) : e < 24 ? (c = 3, d = e - 18) : e < 30 ? (c = 4, d = e - 24) : e < 36 && (c = 5, d = e - 30);
                            var f = this,
                                p = this.renderer.renderer.domElement.width,
                                g = this.renderer.renderer.domElement.height;
                            this.renderer.orthographicCamera.setViewOffset(p, g, 2.5 * -p + p * c, 2.5 * -g + g * d, p, g), this.renderer.orthographicCamera.updateProjectionMatrix();
                            var m = new Image;
                            m.indexI = c, m.indexJ = d;
                            var v = {};
                            return v.level = o, m.onload = function (e) {
                                f._shotIndex++, n.drawImage(e.path[0], p * e.path[0].indexI, g * e.path[0].indexJ), 36 === f._shotIndex && (t.toBlob(function (e) {
                                    h(e), f.renderer.orthographicCamera.zoom = 6 * r, f.renderer.orthographicCamera.updateProjectionMatrix(), f.viewMode = s, f.renderer.orthographicCamera.clearViewOffset(), f.checkNode(), f.setRenderList(), f.controls.panAdd({
                                        x: i,
                                        z: a,
                                        y: 0
                                    }), f.tiltAngle = l, f.rotateAngle = u, f.scaleLevelTo(v), f.renderer.resetSpriteSize(), f.controls.update(), f.renderer.update(), f.isOneShot = !1
                                }), f._shotIndex = 0)
                            }, this.checkNode(), this.setRenderList(), this.renderer.resetSpriteSize(), this.controls.update(), this.renderer.update(), m.src = this.renderer.renderer.domElement.toDataURL(), e++, this._shot(t, n, e, r, i, a, o, s, l, u, h)
                        }
                    }
                }, {
                    key: "screenshot",
                    value: function (e, t, n, l, u) {
                        var h = t.x - e.x,
                            c = t.y - e.y,
                            r = {
                                x: 0,
                                y: 0
                            };
                        r.x = (t.x + e.x) / 2, r.y = (t.y + e.y) / 2;
                        var i = this.renderer.container.getElementsByTagName("canvas")[0].style.width,
                            a = this.renderer.container.getElementsByTagName("canvas")[0].style.height,
                            o = i.split("p")[0],
                            d = a.split("p")[0],
                            f = null;
                        f = (t.x - e.x) / (t.y - e.y) > o / d ? o / (t.x - e.x) : d / (t.y - e.y);
                        var s = r.x - o / 2,
                            p = r.y - d / 2,
                            g = document.getElementsByTagName("canvas")[0],
                            m = document.createElement("canvas"),
                            v = document.createElement("canvas"),
                            y = document.createElement("canvas"),
                            _ = window.devicePixelRatio,
                            A = new Image;
                        "3d" === this.viewMode ? this.renderer.perspectiveCamera.setViewOffset(o * f, d * f, o * (f - 1) / 2 + s * f, d * (f - 1) / 2 + p * f, o, d) : this.renderer.orthographicCamera.setViewOffset(o * f, d * f, o * (f - 1) / 2 + s * f, d * (f - 1) / 2 + p * f, o, d), this.renderer.update(), m.width = h * f * _, m.height = c * f * _, m.style.width = h * f * _ + "px", m.style.height = c * f * _ + "px", n ? (v.width = 1240 * Math.pow(1.414, l - 1), v.height = 1754 * Math.pow(1.414, l - 1), v.style.width = 1240 * Math.pow(1.414, l - 1) + "px", v.style.height = 1754 * Math.pow(1.414, l - 1) + "px") : (v.height = 1240 * Math.pow(1.414, l - 1), v.width = 1754 * Math.pow(1.414, l - 1), v.style.height = 1240 * Math.pow(1.414, l - 1) + "px", v.style.width = 1754 * Math.pow(1.414, l - 1) + "px"), y.height = c * Math.pow(1.414, l - 1), y.width = h * Math.pow(1.414, l - 1), y.style.height = c * Math.pow(1.414, l - 1) + "px", y.style.width = h * Math.pow(1.414, l - 1) + "px", A.src = g.toDataURL("image/png"), "3d" === this.viewMode ? this.renderer.perspectiveCamera.clearViewOffset() : this.renderer.orthographicCamera.clearViewOffset();
                        var x = m.getContext("2d"),
                            C = v.getContext("2d"),
                            I = y.getContext("2d"),
                            w = this;
                        A.onload = function () {
                            w.viewMode, x.drawImage(A, -(o * _ - h * f * _) / 2, -(d * _ - c * f * _) / 2);
                            var s = new Image;
                            s.src = m.toDataURL("image/png"), s.onload = function () {
                                var e = Math.min(1240 * Math.pow(1.414, l - 1) / (h * f), 1754 * Math.pow(1.414, l - 1) / (c * f)),
                                    t = (v.width - h * f * e) / 2,
                                    n = (v.height - c * f * e) / 2;
                                C.drawImage(s, t, n, h * f * e, c * f * e), I.drawImage(s, 0, 0, h * Math.pow(1.414, l - 1), c * Math.pow(1.414, l - 1));
                                var r = v.toDataURL("image/png"),
                                    i = y.toDataURL("image/png");
                                if (-1 < navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf(".NET4.0C")) {
                                    var a = null,
                                        o = null;
                                    u(r, a, i, o)
                                } else v.toBlob(function (t) {
                                    y.toBlob(function (e) {
                                        u(r, t, i, e)
                                    })
                                })
                            }
                        }
                    }
                }, {
                    key: "enableKeys",
                    value: function (e) {
                        this.controls.enableKeys = e
                    }
                }, {
                    key: "getSearchObjects",
                    value: function (e) {
                        for (var t = [], n = 0; n < e.length; n++) {
                            var r = null;
                            5 === e[n].nodeType ? r = "model" : 4 === e[n].nodeType ? r = "extent" : 12 === e[n].nodeType ? r = "label" : 11 === e[n].nodeType ? r = "facility" : 35 === e[n].nodeType && (r = "externalModel"), t.push(this.getFMGroup(e[n].groupID).getNodeByLayerId(r, e[n].ID))
                        }
                        return t
                    }
                }, {
                    key: "getEffectRenderer",
                    value: function () {
                        var e = new EffectRenderer(this.MapOptions, this);
                        return this.renderer = e, e
                    }
                }, {
                    key: "getCompassOffset",
                    value: function () {
                        return {
                            left: this.MapOptions.compassOffset[0],
                            top: this.MapOptions.compassOffset[1]
                        }
                    }
                }, {
                    key: "setCompassOffset",
                    value: function (e, t) {
                        this.MapOptions.compassOffset[0] = t, this.MapOptions.compassOffset[1] = e, this.renderer.resetCompass()
                    }
                }, {
                    key: "getCompassScale",
                    value: function () {
                        return this.MapOptions.compassSize
                    }
                }, {
                    key: "setCompassScale",
                    value: function (e) {
                        this.MapOptions.compassSize = e, this.renderer.resetCompass()
                    }
                }, {
                    key: "getStation",
                    value: function () {
                        var e = {}; - 1 < navigator.userAgent.indexOf("Opera") && (e.userAgent = "Opera"), -1 < navigator.userAgent.indexOf("Firefox") && (e.userAgent = "FF"), -1 < navigator.userAgent.indexOf("Chrome") && (e.userAgent = "Chrome"), -1 < navigator.userAgent.indexOf("Safari") && 0 === navigator.userAgent.indexOf("Chrome") && (e.userAgent = "Safari"), -1 < navigator.userAgent.indexOf("compatible") && -1 < navigator.userAgent.indexOf("MSIE") && !isOpera && (e.userAgent = "IE"), -1 < navigator.userAgent.indexOf("Trident") && (e.userAgent = "Edge"), e.sdkVersion = T.default.VERSION + "." + T.default.BUILD, e.appName = this.MapOptions.appName;
                        var t = document.createElement("canvas"),
                            n = t.getContext("experimental-webgl"),
                            r = n.getExtension("WEBGL_debug_renderer_info");
                        e.gpu = r ? n.getParameter(r.UNMASKED_RENDERER_WEBGL) : null, e.os = navigator.platform;
                        for (var i = !0, a = navigator.userAgent, o = new Array("Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"), s = 0; s < o.length; s++)
                            if (0 < a.indexOf(o[s])) {
                                i = !1;
                                break
                            } i && (e.device = "pc"), e.appkey = this.MapOptions.key, e.product = "JS";
                        var l = (0, A.default)(e),
                            u = new XMLHttpRequest;
                        return u.open("POST", D.default+"sdk/collect", !0), u.setRequestHeader("Content-type", "application/json"), u.setRequestHeader("X-Requested-With", "XMLHttpRequest"), u.onreadystatechange = function () {
                            4 === u.readyState && u.status
                        }, u.send(l), e
                    }
                }, {
                    key: "getVideoMemoryAmount",
                    value: function (e) {
                        var t = null;
                        return t = this.videoMemory.getVideoMemoryAmount(e), t
                    }
                }, {
                    key: "setCompass",
                    value: function () {
                        if (!this.renderer.compassNode) {
                            var e = this.renderer.getAspect(),
                                t = this.renderer.getScaleByPixels(1, this.MapOptions.compassSize),
                                n = -this.renderer.getScaleByPixels(1, i[1]),
                                r = this.renderer.getScaleByPixels(1, i[0]) / e,
                                i = this.renderer.getCompassOffset(this.MapOptions.compassPosition, t, e, r, n);
                            this.renderer.compassNode = this.nodeManager.createCompassNode(t, this._compassBG, this._compassFG, i.ox, i.oy), this.renderer.compassNode.material.uniforms.rotation.value = this.controls.getAzimuthalAngle()
                        }
                    }
                }, {
                    key: "setThemeByJson",
                    value: function (e, t) {
                        var n = this,
                            r = this.nodeManager.getSceneById(this._currentSceneId);
                        n.initTheme(e, t, function (e) {
                            n.setBackgroundColor(e.clearColor, e.clearAlpha), r.theme = e, r.changeTheme(e)
                        })
                    }
                }, {
                    key: "setAutoRotateBymodel",
                    value: function (e) {
                        this.autoRotateBymodel = e
                    }
                }, {
                    key: "getAutoRotateBymodel",
                    value: function () {
                        return this.autoRotateBymodel
                    }
                }, {
                    key: "setAutoRotateBymodelSpeed",
                    value: function (e) {
                        this.autoRotateBymodelSpeed = e
                    }
                }, {
                    key: "getAutoRotateBymodelSpeed",
                    value: function () {
                        return this.autoRotateBymodelSpeed
                    }
                }, {
                    key: "showAllGroup",
                    get: function () {
                        return this._showAllGroup
                    }
                }, {
                    key: "compass",
                    get: function () {
                        var t = this,
                            n = this.renderer,
                            r = this.nodeManager.materialManager;
                        return {
                            setBgImage: function (e) {
                                t._compassBG = e, n.compassNode && (n.compassNode.material.uniforms.mapBack.value = r.loadTexture(e, function () {
                                    n.compassNode.material.needsUpdate = !0
                                }))
                            },
                            setFgImage: function (e) {
                                t._compassFG = e, n.compassNode && (n.compassNode.material.uniforms.mapfront.value = r.loadTexture(e, function () {
                                    n.compassNode.material.needsUpdate = !0
                                }))
                            }
                        }
                    }
                }, {
                    key: "modelSelectColor",
                    get: function () {
                        return this._modelSelectColor
                    }
                }, {
                    key: "groupIDs",
                    get: function () {
                        var e = [];
                        return e.push.apply(e, (0, a.default)(this.nodeManager.getSceneById(this._currentSceneId).groupIds)), e
                    }
                }, {
                    key: "visibleGroupIDs",
                    get: function () {
                        return this.getVisibleGroups()
                    },
                    set: function (e) {
                        this._visibleGroups = e, this.hideOrShowLine(), this.checkNode(), this.setRenderList(), this.avoidMarkers(), this.renderer.resetSpriteSize(), this.dispatchEvent({
                            type: "visibleGroupIDsChanged",
                            gids: e
                        })
                    }
                }, {
                    key: "mapScaleLevel",
                    set: function (e) {
                        var t, n;
                        "object" === (0, o.default)(e) && (t = e.duration, n = e.callback, e = e.level), e < this.minScaleLevel ? e = this.minScaleLevel : e > this.maxScaleLevel && (e = this.maxScaleLevel), this.scaleLevelTo({
                            level: e,
                            duration: t,
                            callback: n
                        }), this._mapScale = this.levelToScale(e), this._mapScaleLevel = e
                    },
                    get: function () {
                        return this._mapScaleLevel
                    }
                }, {
                    key: "mapScale",
                    get: function () {
                        return this._mapScale
                    },
                    set: function (e) {
                        e < this.minScale ? e = this.minScale : e > this.maxScale && (e = this.maxScale), this.scaleTo({
                            scale: e
                        }), this._mapScaleLevel = this.scaleTolevel(e), this._mapScale = e
                    }
                }, {
                    key: "scaleLevel",
                    get: function () {
                        return this.mapScaleLevel
                    }
                }, {
                    key: "maxScale",
                    set: function (e) {
                        e <= this.mapScaleLevels[this.mapScaleLevels.length - 1] ? e = this.mapScaleLevels[this.mapScaleLevels.length - 2] : e > this.mapScaleLevels[0] && (e = this.mapScaleLevels[0]), this._minScaleLevel = this.scaleTolevel(e), this._maxScale = e, this.controls.maxDistance = this.getCameraDistanceByScale(this._maxScale), this.controls.minZoom = 1 / this.getCameraScaleByScale(this._maxScale)
                    },
                    get: function () {
                        return this._maxScale
                    }
                }, {
                    key: "minScale",
                    set: function (e) {
                        e < this.mapScaleLevels[this.mapScaleLevels.length - 1] ? e = this.mapScaleLevels[this.mapScaleLevels.length - 1] : e >= this.mapScaleLevels[0] && (e = this.mapScaleLevels[1]), this._maxScaleLevel = this.scaleTolevel(e), this._minScale = e, this.controls.minDistance = this.getCameraDistanceByScale(this._minScale), this.controls.maxZoom = 1 / this.getCameraScaleByScale(this._minScale)
                    },
                    get: function () {
                        return this._minScale
                    }
                }, {
                    key: "minScaleLevel",
                    set: function (e) {
                        e < 1 && (e = 1), 29 <= e && (e = 28), this._maxScale = this.levelToScale(e), this.controls.maxDistance = this.getCameraDistanceByScale(this._maxScale), this.controls.minZoom = 1 / this.getCameraScaleByScale(this._maxScale), this._minScaleLevel = e
                    },
                    get: function () {
                        return this._minScaleLevel
                    }
                }, {
                    key: "maxScaleLevel",
                    set: function (e) {
                        e <= 1 && (e = 2), 29 < e && (e = 29), this._minScale = this.levelToScale(e), this._maxScaleLevel = e, this.controls.minDistance = this.getCameraDistanceByScale(this._minScale), this.controls.maxZoom = 1 / this.getCameraScaleByScale(this._minScale)
                    },
                    get: function () {
                        return this._maxScaleLevel
                    }
                }, {
                    key: "maxFps",
                    set: function (e) {
                        this._allowfps = e
                    },
                    get: function () {
                        return this._allowfps
                    }
                }, {
                    key: "viewMode",
                    get: function () {
                        return this._viewMode
                    },
                    set: function (t) {
                        var n = this;
                        if (!S.default[this.uuid].isToggleViewMode) {
                            var r = function () {
                                n.dispatchEvent({
                                    type: "viewModeChange",
                                    mode: t
                                })
                            };
                            if ("3d" == t && "3d" != this._viewMode) {
                                this.renderer.viewMode = t, this._viewMode = t;
                                var e = this.nodeManager.getRenderList();
                                this.renderer.renderList = e, this.toggleTo3D(function () {
                                    r()
                                }, 1e3 * this.MapOptions.viewModeAnimateTime)
                            } else "top" == t && "top" != this._viewMode && this.toggleToTop(function () {
                                n._viewMode = t, n.renderer.viewMode = t;
                                var e = n.nodeManager.getRenderList();
                                n.renderer.renderList = e, r()
                            }, 1e3 * this.MapOptions.viewModeAnimateTime)
                        }
                    }
                }, {
                    key: "showCompass",
                    set: function (e) {
                        if (e && !this.renderer.compassNode) {
                            var t = this.renderer.getAspect(),
                                n = this.renderer.getScaleByPixels(1, this.MapOptions.compassSize),
                                r = -this.renderer.getScaleByPixels(1, this.MapOptions.compassOffset[1]),
                                i = this.renderer.getScaleByPixels(1, this.MapOptions.compassOffset[0]) / t,
                                a = this.renderer.getCompassOffset(this.MapOptions.compassPosition, n, t, i, r);
                            this.renderer.compassNode = this.nodeManager.createCompassNode(n, this._compassBG, this._compassFG, a.ox, a.oy), this.renderer.compassNode.material.uniforms.rotation.value = -this.controls.getAzimuthalAngle()
                        }
                        this.renderer.showCompass = e
                    },
                    get: function () {
                        return this.renderer.showCompass
                    }
                }, {
                    key: "currentFocusGroup",
                    get: function () {
                        return this._currentFocusGroup
                    },
                    set: function (e) {
                        this._currentFocusGroup = e, 1 < this.visibleGroupIDs.length ? -1 < this.visibleGroupIDs.indexOf(e) || (this.visibleGroupIDs.push(e), this.visibleGroupIDs = this.visibleGroupIDs, this.checkNode(), this.setRenderList()) : this.visibleGroupIDs = [e], this.dispatchEvent({
                            type: "focusGroupIDChanged",
                            gid: e
                        })
                    }
                }, {
                    key: "focusGroupID",
                    set: function (e) {
                        this.changeFocusToGroup({
                            gid: e
                        })
                    },
                    get: function () {
                        return this.currentFocusGroup
                    }
                }, {
                    key: "center",
                    get: function () {
                        return (new fm.Vector3).copy(this.nodeManager.getSceneById(this._currentSceneId).mapcenter)
                    }
                }, {
                    key: "threeCenter",
                    get: function () {
                        return (new fm.Vector3).copy(this.nodeManager.getSceneById(this._currentSceneId).center)
                    }
                }, {
                    key: "maxX",
                    get: function () {
                        return this.nodeManager.getSceneById(this._currentSceneId).bbox.max.x
                    }
                }, {
                    key: "maxY",
                    get: function () {
                        return this.nodeManager.getSceneById(this._currentSceneId).bbox.max.y
                    }
                }, {
                    key: "minX",
                    get: function () {
                        return this.nodeManager.getSceneById(this._currentSceneId).bbox.min.x
                    }
                }, {
                    key: "minY",
                    get: function () {
                        return this.nodeManager.getSceneById(this._currentSceneId).bbox.min.y
                    }
                }, {
                    key: "groupSpace",
                    get: function () {
                        return this.nodeManager.getSceneById(this._currentSceneId).space
                    },
                    set: function (e) {
                        var t = this.nodeManager.getSceneById(this._currentSceneId);
                        t.space = e;
                        var n = t.mapcenter,
                            r = this.groupIDs[this.groupIDs.length - 1];
                        this.nodeManager.checkNodeByFrustum(this.dataManager.getDecodeScene(this._currentSceneId), this.renderer.getFrustumByViewMode(this._viewMode), this.getVisibleGroups(), this.mapScaleLevel, this._currentSceneId);
                        var i = !0,
                            a = !1,
                            o = void 0;
                        try {
                            for (var s, l = (0, m.default)(this._lineMarkers); !(i = (s = l.next()).done); i = !0) {
                                var u = s.value;
                                u.rebuildLine(n, this, this._visibleGroups, r)
                            }
                        } catch (e) {
                            a = !0, o = e
                        } finally {
                            try {
                                i || null == l.return || l.return()
                            } finally {
                                if (a) throw o
                            }
                        }
                    }
                }, {
                    key: "themeName",
                    set: function (t) {
                        var e = this.MapOptions.mapThemeURL + "/" + t + "/" + t + ".theme",
                            n = this,
                            r = this.nodeManager.getSceneById(this._currentSceneId),
                            i = r.theme.themeName;
                        i !== t && (this.MapOptions.defaultThemeName = t, this.fmServer.getTheme(e, function (e) {
                            n.initTheme(t, e, function (e) {
                                n.setBackgroundColor(e.clearColor, e.clearAlpha), r.theme = e, r.changeTheme(e)
                            })
                        }))
                    },
                    get: function () {
                        var e = this.nodeManager.getSceneById(this._currentSceneId);
                        return e.theme.themeName
                    }
                }, {
                    key: "fullScreen",
                    get: function () {
                        return this._fullScreen
                    },
                    set: function (e) {
                        var t = this.renderer.container;
                        t = t || document.body;
                        try {
                            e ? (t.webkitRequestFullScreen || t.mozRequestFullScreen).call(t) : (document.webkitCancelFullScreen || document.mozCancelFullScreen).call(document), this._fullScreen = e
                        } catch (e) {
                            console.error(e)
                        }
                    }
                }, {
                    key: "rotateAngle",
                    get: function () {
                        return -this.controls.getAzimuthalAngle() * fm.Math.RAD2DEG
                    },
                    set: function (e) {
                        e = -e * fm.Math.DEG2RAD, e > Math.PI ? e -= 2 * Math.PI : e < -Math.PI && (e = 2 * Math.PI + e), e < this.controls.minAzimuthAngle && (e = this.controls.minAzimuthAngle), e > this.controls.maxAzimuthAngle && (e = this.controls.maxAzimuthAngle), this.controls.setUpdate(void 0, void 0, void 0, e), this.controls.update()
                    }
                }, {
                    key: "maxTitleAngle",
                    get: function () {
                        return (Math.PI / 2 - this.controls.minPolarAngle) * fm.Math.RAD2DEG
                    },
                    set: function (e) {
                        "3d" === this._viewMode && (this.controls.minPolarAngle = (90 - e) * fm.Math.DEG2RAD), this.MapOptions.defaultMaxTiltAngle = e
                    }
                }, {
                    key: "minTitleAngle",
                    get: function () {
                        return (Math.PI / 2 - this.controls.maxPolarAngle) * fm.Math.RAD2DEG
                    },
                    set: function (e) {
                        "3d" === this._viewMode && (this.controls.maxPolarAngle = (90 - e) * fm.Math.DEG2RAD), this.MapOptions.defaultMinTiltAngle = e
                    }
                }, {
                    key: "labelLanguage",
                    get: function () {
                        return this.MapOptions.defaultLabelLanguage
                    },
                    set: function (e) {
                        if (e !== this.labelLanguage) {
                            this.MapOptions.defaultLabelLanguage = e;
                            var t = this.nodeManager.getSceneById(this._currentSceneId);
                            t && t.setLabelLanguage(e)
                        }
                    }
                }, {
                    key: "backgroundColor",
                    set: function (e) {
                        this.renderer.renderer.setClearColor((0, l.default)(e))
                    }
                }, {
                    key: "tiltAngle",
                    get: function () {
                        return (Math.PI / 2 - this.controls.getPolarAngle()) * fm.Math.RAD2DEG
                    },
                    set: function (e) {
                        e = (90 - e) * fm.Math.DEG2RAD, e < this.controls.minPolarAngle && (e = this.controls.minPolarAngle), e > this.controls.maxPolarAngle && (e = this.controls.maxPolarAngle), this.controls.setUpdate(void 0, void 0, void 0, void 0, e)
                    }
                }, {
                    key: "listGroups",
                    get: function () {
                        return this.dataManager.getDecodeScene(this._currentSceneId).scene.layerGroups
                    }
                }, {
                    key: "layerLocalHeight",
                    get: function () {
                        return 0
                    }
                }, {
                    key: "gestureEnableController",
                    get: function () {
                        return this._enterControl
                    }
                }]), h
            }(h.default),
            j = W;
        t.default = j
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(48);
        var a = r(n(2)),
            o = r(n(3)),
            c = r(n(202)),
            s = r(n(109)),
            l = function () {
                function e() {
                    (0, a.default)(this, e), this.netArea = s.default
                }
                return (0, o.default)(e, [{
                    key: "getScene",
                    value: function (e, t, n, r, i, a, o) {
                        var s;
                        s = n ? t + ".scene" : t;
                        var l = e + "/" + s + ".fmap";
                        null === t && (l = e);
                        var u = new c.default;
                        r && (n || (l = e), u.setRequestHeader({
                            "X-Requested-With": "XMLHttpRequest",
                            "Content-type": "application/json;charset=utf-8"
                        })), u.requestMethod = i || "GET", u.sendData = r, u.setResponseType("arraybuffer"), u.getFile(l, function (e) {
                            a(e, t)
                        }, function (e) {
                            console.error(""), o && o(e)
                        })
                    }
                }, {
                    key: "getFloor",
                    value: function (e, t, n, r, i, a, o) {
                        if (o) this.getUrlFloor(e, t, n, r, i, a);
                        else {
                            var s = new c.default;
                            "fengmap" == e && (e = this.netArea + "sdk/authLayered/downMaps", s.requestMethod = "POST", s.sendData = a, s.setRequestHeader({
                                "X-Requested-With": "XMLHttpRequest",
                                "Content-type": "application/json;charset=utf-8"
                            }));
                            var l = e + "/" + n + "." + t + ".biz.fmap",
                                u = e + "/" + n + "." + t + ".geo.fmap",
                                h = e + "/" + n + "." + t + ".navi.fmap";
                            s.setResponseType("arraybuffer"), s.getFile(u, function (n) {
                                s.getFile(l, function (t) {
                                    s.getFile(h, function (e) {
                                        i(n, t, e, r)
                                    }, function () {
                                        console.error("")
                                    })
                                }, function () {
                                    console.error("")
                                })
                            }, function () {
                                console.error("")
                            })
                        }
                    }
                }, {
                    key: "getUrlFloor",
                    value: function (e, t, n, o, s, l) {
                        var r = new c.default;
                        "fengmap" == e && (e = this.netArea + "sdk/authLayered/obtainMapRoute", r.requestMethod = "POST", r.sendData = l, r.setRequestHeader({
                            "X-Requested-With": "XMLHttpRequest",
                            "Content-type": "application/json;charset=utf-8"
                        }));
                        var i = e + "/" + n + "." + t + ".biz.fmap",
                            a = e + "/" + n + "." + t + ".geo.fmap",
                            u = e + "/" + n + "." + t + ".navi.fmap",
                            h = this;
                        r.getFile(a, function (a) {
                            r.getFile(i, function (i) {
                                r.getFile(u, function (e) {
                                    var t = e.replace('"', "").replace('"', ""),
                                        n = i.replace('"', "").replace('"', ""),
                                        r = a.replace('"', "").replace('"', "");
                                    h.getUrlFloorData(n, r, t, o, l, s)
                                }, function () {
                                    console.error("")
                                })
                            }, function () {
                                console.error("")
                            })
                        }, function () {
                            console.error("")
                        })
                    }
                }, {
                    key: "getUrlFloorData",
                    value: function (e, t, r, i, n, a) {
                        var o = new c.default;
                        o.sendData = null, o.requestMethod = "GET", o.setRequestHeader({
                            "X-Requested-With": "XMLHttpRequest"
                        }), o.setResponseType("arraybuffer"), o.getFile(t, function (n) {
                            o.getFile(e, function (t) {
                                o.getFile(r, function (e) {
                                    a(n, t, e, i)
                                }, function () {
                                    console.error("")
                                })
                            }, function () {
                                console.error("")
                            })
                        }, function () {
                            console.error("")
                        })
                    }
                }, {
                    key: "getTheme",
                    value: function (e, n) {
                        var t = new c.default;
                        t.getFile(e, function (e) {
                            var t = JSON.parse(e);
                            n(t)
                        }, function () {})
                    }
                }, {
                    key: "getData",
                    value: function (e, t, n, r, i, a) {
                        var o = new c.default;
                        o.requestMethod = r || "GET", o.sendData = i, o.setRequestHeader(a), o.getFile(e, function (e) {
                            e = JSON.parse(e), t(e)
                        }, function (e) {
                            n(e)
                        })
                    }
                }, {
                    key: "getUrl",
                    value: function (e, t, n, r, i, a, o) {
                        var s;
                        s = n ? t + ".scene" : t;
                        var l = e + "/" + s + ".fmap",
                            u = new c.default;
                        r && (n || (l = e), u.setRequestHeader({
                            "X-Requested-With": "XMLHttpRequest",
                            "Content-type": "application/json;charset=utf-8"
                        })), u.requestMethod = i || "GET", u.sendData = r, u.getFile(l, function (e) {
                            a(e, t)
                        }, function (e) {
                            console.error(""), o && o(e)
                        })
                    }
                }]), e
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e), this.requestMethod = "GET", this._requestHeader = {}, this.sendData = null
                }
                return (0, o.default)(e, [{
                    key: "getFile",
                    value: function (e, t, n, r, i) {
                        void 0 !== this._path && (e = this._path + e);
                        var a = new XMLHttpRequest;
                        for (var o in a.open(this.requestMethod, e, !0), a.addEventListener("load", function () {
                                var e = this.response;
                                200 === this.status || 0 === this.status || 201 === this.status ? (0 === this.status && console.warn("FMMap FileLoader: HTTP Status 0 received."), t(e)) : n(e)
                            }, !1), a.addEventListener("progress", function () {
                                r && r()
                            }, !1), a.addEventListener("error", function () {
                                n()
                            }, !1), a.addEventListener("abort", function () {
                                i && i()
                            }, !1), void 0 !== this._responseType && (a.responseType = this._responseType), void 0 !== this._withCredentials && (a.withCredentials = this._withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this._mimeType ? this._mimeType : "text/plain"), this._requestHeader) a.setRequestHeader(o, this._requestHeader[o]);
                        a.send(this.sendData)
                    }
                }, {
                    key: "setPath",
                    value: function (e) {
                        return this._path = e, this
                    }
                }, {
                    key: "setResponseType",
                    value: function (e) {
                        return this._responseType = e, this
                    }
                }, {
                    key: "setWithCredentials",
                    value: function (e) {
                        return this._withCredentials = e, this
                    }
                }, {
                    key: "setMimeType",
                    value: function (e) {
                        return this._mimeType = e, this
                    }
                }, {
                    key: "setRequestHeader",
                    value: function (e) {
                        return e && (this._requestHeader = e), this
                    }
                }]), e
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                NORTH: "n",
                n: 0,
                SOUTH: "s",
                s: 180,
                WEST: "w",
                w: -90,
                EAST: "e",
                e: 90,
                NORTH_EAST: "ne",
                ne: 45,
                NORTH_WEST: "nw",
                nw: -45,
                SOUTH_EAST: "se",
                se: 135,
                SOUTH_WEST: "sw",
                sw: -135
            },
            a = i;
        t.default = a
    }, function (e, u, t) {
        (function (i) {
            function a(e, t) {
                for (var n = 0, r = e.length - 1; 0 <= r; r--) {
                    var i = e[r];
                    "." === i ? e.splice(r, 1) : ".." === i ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--)
                }
                if (t)
                    for (; n--;) e.unshift("..");
                return e
            }

            function r(e) {
                "string" != typeof e && (e += "");
                var t, n = 0,
                    r = -1,
                    i = !0;
                for (t = e.length - 1; 0 <= t; --t)
                    if (47 === e.charCodeAt(t)) {
                        if (!i) {
                            n = t + 1;
                            break
                        }
                    } else -1 === r && (i = !1, r = t + 1);
                return -1 === r ? "" : e.slice(n, r)
            }

            function o(e, t) {
                if (e.filter) return e.filter(t);
                for (var n = [], r = 0; r < e.length; r++) t(e[r], r, e) && n.push(e[r]);
                return n
            }
            u.resolve = function () {
                for (var e = "", t = !1, n = arguments.length - 1; - 1 <= n && !t; n--) {
                    var r = 0 <= n ? arguments[n] : i.cwd();
                    if ("string" != typeof r) throw new TypeError("Arguments to path.resolve must be strings");
                    r && (e = r + "/" + e, t = "/" === r.charAt(0))
                }
                return e = a(o(e.split("/"), function (e) {
                    return !!e
                }), !t).join("/"), (t ? "/" : "") + e || "."
            }, u.normalize = function (e) {
                var t = u.isAbsolute(e),
                    n = "/" === s(e, -1);
                return e = a(o(e.split("/"), function (e) {
                    return !!e
                }), !t).join("/"), e || t || (e = "."), e && n && (e += "/"), (t ? "/" : "") + e
            }, u.isAbsolute = function (e) {
                return "/" === e.charAt(0)
            }, u.join = function () {
                var e = Array.prototype.slice.call(arguments, 0);
                return u.normalize(o(e, function (e) {
                    if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
                    return e
                }).join("/"))
            }, u.relative = function (e, t) {
                function n(e) {
                    for (var t = 0; t < e.length && "" === e[t]; t++);
                    for (var n = e.length - 1; 0 <= n && "" === e[n]; n--);
                    return n < t ? [] : e.slice(t, n - t + 1)
                }
                e = u.resolve(e).substr(1), t = u.resolve(t).substr(1);
                for (var r = n(e.split("/")), i = n(t.split("/")), a = Math.min(r.length, i.length), o = a, s = 0; s < a; s++)
                    if (r[s] !== i[s]) {
                        o = s;
                        break
                    } var l = [];
                for (s = o; s < r.length; s++) l.push("..");
                return l = l.concat(i.slice(o)), l.join("/")
            }, u.sep = "/", u.delimiter = ":", u.dirname = function (e) {
                if ("string" != typeof e && (e += ""), 0 === e.length) return ".";
                for (var t = e.charCodeAt(0), n = 47 === t, r = -1, i = !0, a = e.length - 1; 1 <= a; --a)
                    if (t = e.charCodeAt(a), 47 === t) {
                        if (!i) {
                            r = a;
                            break
                        }
                    } else i = !1;
                return -1 === r ? n ? "/" : "." : n && 1 === r ? "/" : e.slice(0, r)
            }, u.basename = function (e, t) {
                var n = r(e);
                return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n
            }, u.extname = function (e) {
                "string" != typeof e && (e += "");
                for (var t = -1, n = 0, r = -1, i = !0, a = 0, o = e.length - 1; 0 <= o; --o) {
                    var s = e.charCodeAt(o);
                    if (47 === s) {
                        if (i) continue;
                        n = o + 1;
                        break
                    } - 1 === r && (i = !1, r = o + 1), 46 === s ? -1 === t ? t = o : 1 !== a && (a = 1) : -1 !== t && (a = -1)
                }
                return -1 === t || -1 === r || 0 === a || 1 === a && t === r - 1 && t === n + 1 ? "" : e.slice(t, r)
            };
            var s = "b" === "ab".substr(-1) ? function (e, t, n) {
                return e.substr(t, n)
            } : function (e, t, n) {
                return t < 0 && (t = e.length + t), e.substr(t, n)
            }
        }).call(this, t(148))
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var l = r(n(105)),
            a = r(n(206)),
            o = r(n(381)),
            s = r(n(201)),
            u = new s.default,
            h = u.netArea,
            c = {
                check: h + "sdk/check",
                onlineCheck: h + "sdk/auth/web",
                fmFileServer: h + "sdk/auth/downMaps"
            },
            d = "026685bf295f587b5dffc1f18d5dc27c",
            f = function (e, t, n) {
                if (!e || "string" != typeof t || 32 != t.length) return !1;
                if (null == e || "" == e) return !0;
                var r = a.default.decryption(t, d),
                    i = o.default.encryption(n);
                return r = a.default.decryption(r, i), r == e
            },
            p = function (e, t, n) {
                n = n || "fengmap.localhost:";
                var r = o.default.encryption(n + t),
                    i = a.default.decryption(e, r);
                return i
            },
            g = function () {
                var e = new Date,
                    t = (e.getFullYear(), e.getMonth() + 1),
                    n = (e = e.getDate(), e % 2 == 0 ? 1 : -1),
                    r = Math.max(Math.pow(e % 10 + +n, 2) + n * t, 0),
                    i = Math.abs(2 * e + n * t);
                return "" + r + i
            },
            m = (g(), function (e, t, n) {
                p(e, t);
                var r = window.location.host,
                    i = r.indexOf(":"); - 1 < i && (r = r.slice(0, i));
                var a = r || "0.0.0.0";
                return {
                    webURL: a,
                    appKey: e,
                    mapId: n,
                    appName: t
                }
            }),
            v = {
                checkOffLine: function (e, t, n, r) {
                    n = n || r;
                    var i = p(e, t);
                    return n == i
                },
                checkIsOnLine: function (e, t) {
                    u.getData(c.check, function () {
                        e && e()
                    }, function () {
                        t && t()
                    })
                },
                checkOnLine: function (e, t, n, r, i, a) {
                    var o = c.onlineCheck,
                        s = m(e, t, n);
                    s = (0, l.default)(s), u.getData(o, function (e) {
                        e ? e.success ? r && r(e) : i && i(e) : i && i()
                    }, function (e) {
                        e ? (e = JSON.parse(e), i && i(e)) : i && i()
                    }, a, s, {
                        "X-Requested-With": "XMLHttpRequest",
                        "Content-type": "application/json;charset=utf-8"
                    })
                },
                checkLicense: f,
                getCerityData: m,
                ls: 0
            },
            y = v;
        t.default = y
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(108), n(67);
        var a, o, p, g, m, v, y, _, A, x, C, s = r(n(27)),
            l = (a = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], o = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], p = 0, g = 0, m = [2, 0, 0, 0], v = function (e, t) {
                var n = 0,
                    r = 0,
                    i = 0;
                for (r = 0; r < 8; r++) 1 & t && (n ^= e), i = 128 & e, e <<= 1, i && (e ^= 27), t >>= 1;
                return n
            }, y = function (e, t, n) {
                var r;
                for (r = 0; r < 4; r++) e[0 + r] ^= t[16 * n + 4 * r], e[4 + r] ^= t[16 * n + 4 * r + 1], e[8 + r] ^= t[16 * n + 4 * r + 2], e[12 + r] ^= t[16 * n + 4 * r + 3]
            }, _ = function (e) {
                var t, n, r, i;
                for (t = 1; t < 4; t++)
                    for (r = 0; r < t;) {
                        for (i = e[4 * t + 4 - 1], n = 3; 0 < n; n--) e[4 * t + n] = e[4 * t + n - 1];
                        e[4 * t + 0] = i, r++
                    }
            }, A = function (e) {
                var t, n, r, i;
                for (t = 0; t < 4; t++)
                    for (n = 0; n < 4; n++) r = (240 & e[4 * t + n]) >> 4, i = 15 & e[4 * t + n], e[4 * t + n] = o[16 * r + i]
            }, x = function (e) {
                var t;
                for (t = 0; t < 4; t++) e[t] = a[16 * ((240 & e[t]) >> 4) + (15 & e[t])]
            }, C = function (e) {
                return (0, s.default)(e, 16)
            }, {
                decryption: function (e, t) {
                    var n, r = Array(16);
                    for (n = 0; n < 16; n++) r[n] = 16 * C(t.substr(2 * n, 1)) + C(t.substr(2 * n + 1, 1));
                    var i = Array(16);
                    for (n = 0; n < 16; n++) i[n] = 16 * C(e.substr(2 * n, 1)) + C(e.substr(2 * n + 1, 1));
                    var a = Array(16);
                    switch (n = [], r.length) {
                        default:
                        case 16:
                            p = 4, g = 10;
                            break;
                        case 24:
                            p = 6, g = 12;
                            break;
                        case 32:
                            p = 8, g = 14
                    }
                    var o, s = n = Array(16 * (g + 1)),
                        l = Array(4),
                        u = 4 * (g + 1);
                    for (o = 0; o < p; o++) s[4 * o + 0] = r[4 * o + 0], s[4 * o + 1] = r[4 * o + 1], s[4 * o + 2] = r[4 * o + 2], s[4 * o + 3] = r[4 * o + 3];
                    for (o = p; o < u; o++) {
                        if (l[0] = s[4 * (o - 1) + 0], l[1] = s[4 * (o - 1) + 1], l[2] = s[4 * (o - 1) + 2], l[3] = s[4 * (o - 1) + 3], 0 == o % p) {
                            r = l;
                            var h = void 0,
                                c = void 0;
                            for (h = r[0], c = 0; c < 3; c++) r[c] = r[c + 1];
                            if (r[3] = h, x(l), r = o / p, 1 == r) m[0] = 1;
                            else if (1 < r)
                                for (m[0] = 2, r--; 0 < r - 1;) m[0] = v(m[0], 2), r--;
                            r = l, h = m, c = l, c[0] = r[0] ^ h[0], c[1] = r[1] ^ h[1], c[2] = r[2] ^ h[2], c[3] = r[3] ^ h[3]
                        } else 6 < p && 4 == o % p && x(l);
                        s[4 * o + 0] = s[4 * (o - p) + 0] ^ l[0], s[4 * o + 1] = s[4 * (o - p) + 1] ^ l[1], s[4 * o + 2] = s[4 * (o - p) + 2] ^ l[2], s[4 * o + 3] = s[4 * (o - p) + 3] ^ l[3]
                    }
                    for (s = Array(16), l = 0; l < 4; l++)
                        for (o = 0; o < 4; o++) s[4 * l + o] = i[l + 4 * o];
                    for (y(s, n, g), i = g - 1; 1 <= i; i--)
                        for (_(s), A(s), y(s, n, i), l = s, o = [14, 9, 13, 11], u = c = void 0, r = Array(4), h = Array(4), u = 0; u < 4; u++) {
                            for (c = 0; c < 4; c++) r[c] = l[4 * c + u];
                            c = o;
                            var d = r,
                                f = h;
                            for (f[0] = v(c[0], d[0]) ^ v(c[3], d[1]) ^ v(c[2], d[2]) ^ v(c[1], d[3]), f[1] = v(c[1], d[0]) ^ v(c[0], d[1]) ^ v(c[3], d[2]) ^ v(c[2], d[3]), f[2] = v(c[2], d[0]) ^ v(c[1], d[1]) ^ v(c[0], d[2]) ^ v(c[3], d[3]), f[3] = v(c[3], d[0]) ^ v(c[2], d[1]) ^ v(c[1], d[2]) ^ v(c[0], d[3]), c = 0; c < 4; c++) l[4 * c + u] = h[c]
                        }
                    for (_(s), A(s), y(s, n, 0), l = 0; l < 4; l++)
                        for (o = 0; o < 4; o++) a[l + 4 * o] = s[4 * l + o];
                    for (i = "", n = 0; n < 16; ++n) s = a[n].toString(16), s.length < 2 && (s = "0" + s), i += s;
                    return i
                }
            }),
            u = l;
        t.default = u
    }, function (e, n, r) {
        "use strict";
        var i = r(1),
            a = r(0);
        a(n, "__esModule", {
            value: !0
        }), n.default = void 0;
        var s = i(r(16));
        r(13);
        var o = i(r(2)),
            l = i(r(3)),
            u = u || {};
        u.GLEN1 = "MULTIPOLYGON(((".length, u.GLEN2 = "POINT(".length, u.GLEN3 = "MULTILINESTRING((".length;
        var h = function () {
                function e() {
                    (0, o.default)(this, e), this._points, this._holes
                }
                return (0, l.default)(e, [{
                    key: "parse",
                    value: function (e) {
                        if (this._points = [], this._holes = [], 0 == e.indexOf("MULTIPOLYGON((("))
                            for (var t = e.substring(u.GLEN1, e.length - 3).split(/\),\(/), n = 0; n < t.length; n++) {
                                var r = t[n].split(/,/);
                                if (0 == n)
                                    for (var i = 0; i < r.length; i++) {
                                        var a = r[i].split(" ");
                                        this._points.push({
                                            x: (0, s.default)(a[0]),
                                            y: (0, s.default)(a[1])
                                        })
                                    } else {
                                        var o = [];
                                        for (i = 0; i < r.length; i++) a = r[i].split(" "), o.push({
                                            x: (0, s.default)(a[0]),
                                            y: (0, s.default)(a[1])
                                        });
                                        this._holes.push(o)
                                    }
                            } else if (0 == e.indexOf("POINT(")) a = e.substring(u.GLEN2, e.length - 1).split(" "), this._points.push({
                                x: (0, s.default)(a[0]),
                                y: (0, s.default)(a[1])
                            });
                            else if (0 == e.indexOf("MULTILINESTRING(("))
                            for (r = e.substring(u.GLEN3, e.length - 2).split(","), i = 0; i < r.length; i++) a = r[i].split(" "), this._points.push({
                                x: (0, s.default)(a[0]),
                                y: (0, s.default)(a[1])
                            });
                        return this
                    }
                }, {
                    key: "toFixed",
                    value: function (e) {
                        return +e.toFixed(2)
                    }
                }, {
                    key: "parsePnt",
                    value: function (e) {
                        if (this._points = [], 0 == e.indexOf("MULTIPOLYGON((("))
                            for (var t = e.substring(u.GLEN1, e.length - 3).split(","), n = 0; n < t.length; n++) {
                                var r = t[n].split(" ");
                                this._points.push({
                                    x: (0, s.default)(r[0]),
                                    y: (0, s.default)(r[1])
                                })
                            } else if (0 == e.indexOf("POINT(")) r = e.substring(u.GLEN2, e.length - 1).split(" "), this._points.push({
                                x: (0, s.default)(r[0]),
                                y: (0, s.default)(r[1])
                            });
                            else if (0 == e.indexOf("MULTILINESTRING(("))
                            for (t = e.substring(u.GLEN3, e.length - 2).split(","), n = 0; n < t.length; n++) r = t[n].split(" "), this._points.push({
                                x: (0, s.default)(r[0]),
                                y: (0, s.default)(r[1])
                            });
                        return this
                    }
                }, {
                    key: "toPntStrip",
                    value: function (e) {
                        var t = [],
                            n = this._points.length;
                        if (!0 === e) {
                            if (1 <= n)
                                for (var r = 0; r < n - 1; r++) {
                                    var i = this._points[r];
                                    t.push(i.x, i.y)
                                }
                        } else
                            for (r = 0; r < n; r++) i = this._points[r], t.push(i.x, i.y);
                        return t
                    }
                }, {
                    key: "mergePnts",
                    value: function (e) {
                        for (var t = [], n = e.length, r = 0; r < n; r++) {
                            for (var i = e[r], a = {
                                    x: this.toFixed(i.x),
                                    y: this.toFixed(i.y)
                                }, o = t.length, s = !1, l = 0; l < o; l++) {
                                var u = t[l];
                                if (u.x == a.x && u.y == a.y) {
                                    s = !0;
                                    break
                                }
                            }
                            s || t.push(a)
                        }
                        return t
                    }
                }, {
                    key: "toStrip",
                    value: function (e) {
                        var n = [],
                            r = this._points.length;
                        if (r <= 0) return n;
                        for (var i = this._points.splice(r - 1, 1)[0], a = this.mergePnts(this._points), o = a.length, s = 0; s < o; s++) {
                            var l = a[s];
                            n.push(l.x, l.y)
                        }
                        return !0 === e || (t = {
                            x: this.toFixed(i.x),
                            y: this.toFixed(i.y)
                        }, n.push(t.x, t.y), this._points.push(i)), n
                    }
                }, {
                    key: "hasHoles",
                    value: function () {
                        return null != this._holes && 0 < this._holes.length
                    }
                }, {
                    key: "toStripHoles",
                    value: function (e) {
                        for (var n = [], r = 0; r < this._holes.length; r++) {
                            for (var i = this._holes[r], a = [], o = i.length, s = i.splice(o - 1, 1)[0], l = this.mergePnts(i), u = l.length, h = 0; h < u; h++) {
                                var c = l[h];
                                a.push(c.x, c.y)
                            }!0 === e || (t = {
                                x: this.toFixed(s.x),
                                y: this.toFixed(s.y)
                            }, a.push(t.x, t.y)), n.push(a)
                        }
                        return n
                    }
                }, {
                    key: "holes",
                    set: function (e) {
                        this._holes = e
                    },
                    get: function () {
                        return this._holes
                    }
                }, {
                    key: "points",
                    get: function () {
                        return this._points
                    },
                    set: function (e) {
                        this._points = e
                    }
                }]), e
            }(),
            c = h;
        n.default = c
    }, function (e, n, r) {
        "use strict";
        var i = r(1),
            a = r(0);
        a(n, "__esModule", {
            value: !0
        }), n.default = void 0;
        var o = i(r(2)),
            s = i(r(3)),
            l = function () {
                function e() {
                    (0, o.default)(this, e), this._points, this._holes
                }
                return (0, s.default)(e, [{
                    key: "parse",
                    value: function (e, t) {
                        this._points = [], this._holes = [];
                        for (var n = 0, r = 0; r < e.length; r++) {
                            var i = e[r].idxs;
                            if (i = i || e[r], "number" == typeof i)
                                for (; n < i;) this._points.push({
                                    x: t[n],
                                    y: t[n + 1]
                                }), n += 2;
                            else
                                for (var a = 0; a < i.length; a++)
                                    for (var o = i[a]; n < o;) this._points.push({
                                        x: t[n],
                                        y: t[n + 1]
                                    }), n += 2
                        }
                        return this
                    }
                }, {
                    key: "parseGeometry",
                    value: function (e, t) {
                        this._points = [], this._holes = [];
                        for (var n = 0, r = 0; r < e.length; r++) {
                            var i = e[r].idxs;
                            if (i = i || e[r], "number" == typeof i)
                                for (; n < i;) this._points.push({
                                    x: t[n],
                                    y: t[n + 1]
                                }), n += 2;
                            else
                                for (var a = 0; a < i.length; a++)
                                    if (0 === a)
                                        for (var o = i[a]; n < o;) this._points.push({
                                            x: t[n],
                                            y: t[n + 1]
                                        }), n += 2;
                                    else {
                                        for (var s = [], l = i[a]; n < l;) s.push({
                                            x: t[n],
                                            y: t[n + 1]
                                        }), n += 2;
                                        this._holes.push(s)
                                    }
                        }
                        return this
                    }
                }, {
                    key: "mergePnts",
                    value: function (e) {
                        for (var t = [], n = e.length, r = 0; r < n; r++) {
                            for (var i = e[r], a = {
                                    x: this.toFixed(i.x),
                                    y: this.toFixed(i.y)
                                }, o = t.length, s = !1, l = 0; l < o; l++) {
                                var u = t[l];
                                if (u.x == a.x && u.y == a.y) {
                                    s = !0;
                                    break
                                }
                            }
                            s || t.push(a)
                        }
                        return t
                    }
                }, {
                    key: "toStrip",
                    value: function (e) {
                        var n = [],
                            r = this._points.length;
                        if (r <= 0) return n;
                        for (var i = this._points.splice(r - 1, 1)[0], a = this._points, o = a.length, s = 0; s < o; s++) {
                            var l = a[s];
                            n.push(l.x, l.y)
                        }
                        return !0 === e || (t = {
                            x: this.toFixed(i.x),
                            y: this.toFixed(i.y)
                        }, n.push(t.x, t.y), this._points.push(i)), n
                    }
                }, {
                    key: "toFixed",
                    value: function (e) {
                        return +e.toFixed(2)
                    }
                }, {
                    key: "hasHoles",
                    value: function () {
                        return null != this._holes && 0 < this._holes.length
                    }
                }, {
                    key: "toStripHoles",
                    value: function (e) {
                        for (var n = [], r = 0; r < this._holes.length; r++) {
                            for (var i = this._holes[r], a = [], o = i.length, s = i.splice(o - 1, 1)[0], l = this.mergePnts(i), u = l.length, h = 0; h < u; h++) {
                                var c = l[h];
                                a.push(c.x, c.y)
                            }!0 === e || (t = {
                                x: this.toFixed(s.x),
                                y: this.toFixed(s.y)
                            }, a.push(t.x, t.y)), n.push(a)
                        }
                        return n
                    }
                }, {
                    key: "holes",
                    set: function (e) {
                        this._holes = e
                    },
                    get: function () {
                        return this._holes
                    }
                }, {
                    key: "points",
                    get: function () {
                        return this._points
                    },
                    set: function (e) {
                        this._points = e
                    }
                }]), e
            }(),
            u = l;
        n.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(56);
        var d = r(n(54)),
            f = r(n(12)),
            s = r(n(41)),
            a = r(n(2)),
            o = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(7)),
            p = n(111),
            g = (r(n(393)), r(n(49))),
            m = r(n(42)),
            v = function (e) {
                function i(e, t, n) {
                    var r;
                    return (0, a.default)(this, i), r = (0, l.default)(this, (0, u.default)(i).call(this, e)), r._layers = {}, r.initLayers(), r.initLayersByData(t), r._visible = !0, r._groupMessage = n, r._locations = [], r._height = n.height, r._locationScene = new fm.Scene, r._locationScene.userData.type = "location", r._locationScene.position.setY(r._height), r._locationScene.updateMatrix(), r._locationScene.updateWorldMatrix(), r._offsetHeight = 0, r._lineScene = new fm.Scene, r._lineScene.userData.type = "line", r.externalModels = {}, r.isGroup = !0, r.alwaysShowMarkers = [], r._groupAlias = n.alias, r._groupDesc = n.desc, r._groupName = n.gname, r._hideWithFree = !1, r.modelShadow = {}, r._group = new fm.Scene, r._mainLight = null, r.initScene(), r
                }
                return (0, h.default)(i, e), (0, o.default)(i, [{
                    key: "initScene",
                    value: function () {
                        this._layers.extent[0] && this._group.add(this._layers.extent[0]._scene), this._layers.model[0] && this._group.add(this._layers.model[0]._scene)
                    }
                }, {
                    key: "getHeight",
                    value: function () {
                        return this.height + this._offsetHeight
                    }
                }, {
                    key: "getOrCreateLayer",
                    value: function (e) {
                        if (this._layers[e][0]) return this._layers[e][0];
                        var t = p.AliasLayerMap.get(e),
                            n = new t;
                        return n.scene.position.setY(this._height), n.scene.updateMatrix(), n.scene.updateWorldMatrix(), n.parent = this, n._scene.visible = !0, this._layers[e].push(n), this.parent.parent.map.setRenderList(), this._layers[e][0]
                    }
                }, {
                    key: "getLayers",
                    value: function (e) {
                        var t = [],
                            n = this._layers[e];
                        return t.push.apply(t, (0, s.default)(n)), t
                    }
                }, {
                    key: "getDynmodel",
                    value: function (e) {
                        for (var t = this._layers.dynmodel, n = 0; n < t.length; n++) {
                            var r = t[n].scene;
                            r && e(r)
                        }
                    }
                }, {
                    key: "everyLayers",
                    value: function (e, t) {
                        if (this._layers)
                            for (var n in this._layers)
                                if (!(-1 < e.indexOf(n)))
                                    for (var r = this._layers[n], i = 0; i < r.length; i++) {
                                        var a = r[i].scene;
                                        a && t(a)
                                    }
                    }
                }, {
                    key: "getNodeByLayerId",
                    value: function (e, t) {
                        if (this._layers) return this._layers[e][0] ? this._layers[e][0].getNodeById(t) : void 0
                    }
                }, {
                    key: "bcross",
                    value: function (e, t) {
                        var n = e.renderNode.boundingBox.min,
                            r = e.renderNode.boundingBox.max,
                            i = t.renderNode.boundingBox.min,
                            a = t.renderNode.boundingBox.max;
                        return g.default.isRectCross(new vector2(n.x, n.z), new vector2(r.x, r.z), new vector2(i.x, i.z), new vector2(a.x, a.z))
                    }
                }, {
                    key: "mergeModels",
                    value: function (e) {
                        var t = this._layers.model[0],
                            n = [];
                        for (var r in t._models) t._models[r].FID in e && n.push(t._models[r]);
                        var i = this.checkModelsNearly(n),
                            a = !0,
                            o = !1,
                            s = void 0;
                        try {
                            for (var l, u = (0, f.default)(i.l); !(a = (l = u.next()).done); a = !0) {
                                var h = l.value;
                                t.removeNode(h)
                            }
                        } catch (e) {
                            o = !0, s = e
                        } finally {
                            try {
                                a || null == u.return || u.return()
                            } finally {
                                if (o) throw s
                            }
                        }
                    }
                }, {
                    key: "mergeModel",
                    value: function (e, t) {
                        var n = new ThreeBSP(e.renderNode.geometry),
                            r = new ThreeBSP(t.renderNode.geometry),
                            i = n.union(r.tree),
                            a = i.toMesh(e.material);
                        return e._renderNode = a
                    }
                }, {
                    key: "couldMerge",
                    value: function (e, t) {
                        var n = new ThreeBSP(e.renderNode.geometry),
                            r = new ThreeBSP(t.renderNode.geometry),
                            i = n.intersect(r.tree);
                        return 0 < i.tree.polygons.length
                    }
                }, {
                    key: "checkModelsNearly",
                    value: function (e) {
                        for (var t = [], n = 0; n < e.length; n++) {
                            for (var r = 0, i = 0; i < e.length; i++) this.bcross(e[n], e[i]) && r++;
                            r || t.push(n)
                        }
                        for (var a = t.length - 1; - 1 < a; a--) {
                            var o = e.indexOf(e[t[a]]); - 1 < o && e.splice(o, 1)
                        }
                        for (var s = 0, l = 1, u = [], h = []; 0 < e.length;)
                            if (this.couldMerge(e[s], e[l])) {
                                var c = this.mergeM(e[s], e[l]);
                                h.push(e[l]), e.splice(l, 1), e.splice(s, 1), e.push(c), s = 0, l = 1
                            } else {
                                if (l !== e.length - 1) return l++, {
                                    e: u,
                                    l: h
                                };
                                var d = e.splice(s, 1);
                                u.push(d), s = 0, l = 1
                            }
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        if (this._layers)
                            for (var t in this._layers)
                                for (var n = this._layers[t], r = 0; r < n.length; r++) e(n[r])
                    }
                }, {
                    key: "traverseByAlias",
                    value: function (r, i, a) {
                        var o = this;
                        if (this._layers) {
                            var e = function (t) {
                                if (-1 < r.indexOf(t))
                                    for (var e = o._layers[t], n = 0; n < e.length; n++) a ? i(e[n], t) : e[n].traverse(function (e) {
                                        i(e, t)
                                    })
                            };
                            for (var t in this._layers) e(t)
                        }
                    }
                }, {
                    key: "setExtentImage",
                    value: function (e) {
                        var t = this.parent.parent.materialManager.loadTexture(e, function () {}),
                            n = this.getLayers("extent"),
                            r = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, f.default)(n); !(r = (o = s.next()).done); r = !0) {
                                var l = o.value;
                                for (var u in l.extents) {
                                    var h = l.extents[u];
                                    h.renderNode.material.map && h.renderNode.material.map.dispose(), h.renderNode.material.map = t, h.renderNode.material.needsUpdate = !0
                                }
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                r || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                    }
                }, {
                    key: "clearExtentImage",
                    value: function () {
                        var e = this.getLayers("extent"),
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, f.default)(e); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                for (var s in o.extents) {
                                    var l = o.extents[s];
                                    l.renderNode.material.map.dispose(), l.renderNode.material.map = null, l.renderNode.material.needsUpdate = !0
                                }
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "_getLayers",
                    value: function (e) {
                        if (this._layers) {
                            var t = {};
                            for (var n in this._layers) {
                                for (var r = this._layers[n], i = [], a = 0; a < r.length; a++) {
                                    e && r[a].checkSceneNode();
                                    var o = r[a].scene;
                                    r[a].visible && o && i.push(o)
                                }
                                t[n] = i
                            }
                            return t
                        }
                    }
                }, {
                    key: "initLayers",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, f.default)(p.LayerAlias); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                this._layers[a] = []
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "initLayersByData",
                    value: function (e) {
                        var t = e.geo[0],
                            n = e.biz[0],
                            r = (0, d.default)(t),
                            i = !0,
                            a = !1,
                            o = void 0;
                        try {
                            for (var s, l = (0, f.default)(r); !(i = (s = l.next()).done); i = !0) {
                                var u = s.value;
                                if (t[u] && 0 < t[u].length && p.Prop2Alias[u]) {
                                    var h = p.AliasLayerMap.get(p.Prop2Alias[u]),
                                        c = new h(t[u], n[u]);
                                    c.scene.position.setY(this._height), c.scene.updateMatrix(), c.scene.updateWorldMatrix(), c.parent = this, this._layers[p.Prop2Alias[u]].push(c)
                                }
                            }
                        } catch (e) {
                            a = !0, o = e
                        } finally {
                            try {
                                i || null == l.return || l.return()
                            } finally {
                                if (a) throw o
                            }
                        }
                    }
                }, {
                    key: "removeAlwaysShowMarker",
                    value: function (e) {
                        var t = this.alwaysShowMarkers.indexOf(e); - 1 < t && this.alwaysShowMarkers.splice(t, 1)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this.alwaysShowMarkers.length = 0, this.layers) {
                            for (var t = this.layers[e], n = 0; n < t.length; n++) t[n].dispose(), t[n].parent = void 0;
                            t.length = 0, this._layers[e] = void 0
                        }
                        for (var r = this._locationScene.children.length - 1; - 1 < r; r--) this._locationScene.remove(this._locationScene.children[r]);
                        var i = !0,
                            a = !1,
                            o = void 0;
                        try {
                            for (var s, l = (0, f.default)(this._locations); !(i = (s = l.next()).done); i = !0) {
                                var u = s.value;
                                u.parent = void 0, u.dispose()
                            }
                        } catch (e) {
                            a = !0, o = e
                        } finally {
                            try {
                                i || null == l.return || l.return()
                            } finally {
                                if (a) throw o
                            }
                        }
                        this._groupMessage = void 0, this._layers = void 0
                    }
                }, {
                    key: "addLayer",
                    value: function (e) {
                        e.parent = this, e.scene.position.setY(this._height), e.scene.updateMatrix(), e.scene.updateWorldMatrix(), this._layers[e.alias].push(e), this.parent.parent.map.setRenderList(), (e.prepareInited || 0 < e.prepareInitObjects.length) && e.initPrepare()
                    }
                }, {
                    key: "removeLayer",
                    value: function (e) {
                        e.removeAll && e.removeAll(), e.parent = void 0;
                        var t = this._layers[e.alias].indexOf(e); - 1 < t && this._layers[e.alias].splice(t, 1), this.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "getLayer",
                    value: function (e) {
                        var t = this._layers[e];
                        if (1 < t.length) {
                            var n = [];
                            return n.push.apply(n, (0, s.default)(t)), n
                        }
                        return t[0]
                    }
                }, {
                    key: "getFirstLayer",
                    value: function () {
                        var e = this._layers[layer.alias];
                        return e[0]
                    }
                }, {
                    key: "addLocation",
                    value: function (e) {
                        e.parent = this, this._locations.push(e), this._locationScene.add(e.renderNode)
                    }
                }, {
                    key: "removeLocation",
                    value: function (e) {
                        var t = this._locations.indexOf(e);
                        e.isAlwaysShow && this.removeAlwaysShowMarker(e), e.parent = void 0, -1 < t && this._locations.splice(t, 1), this._locationScene.remove(e.renderNode)
                    }
                }, {
                    key: "getCenterPosition",
                    value: function () {
                        return new fm.Vector3(this.parent.center.x, this.parent.center.y + this._height, 0)
                    }
                }, {
                    key: "getModelMeshs",
                    value: function () {
                        var e = [],
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, f.default)(this._layers.model); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e.push.apply(e, (0, s.default)(o.getAllMesh()))
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                        return e
                    }
                }, {
                    key: "getExtentMeshs",
                    value: function () {
                        var e = [],
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, f.default)(this._layers.extent); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e.push.apply(e, (0, s.default)(o.getAllMesh()))
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                        return e
                    }
                }, {
                    key: "applyHeatMap",
                    value: function (e) {
                        e && (e.renderToMap(this._groupId), this.heatmap_ = e)
                    }
                }, {
                    key: "removeHeatMap",
                    value: function (e) {
                        e.disposeHeatMap(this._groupId), this.heatmap_ = null
                    }
                }, {
                    key: "addLine",
                    value: function (e) {
                        this._lineScene.add(e)
                    }
                }, {
                    key: "removeLine",
                    value: function (e) {
                        this._lineScene.remove(e)
                    }
                }, {
                    key: "locationScene",
                    get: function () {
                        return this._locationScene
                    }
                }, {
                    key: "lineScene",
                    get: function () {
                        return this._lineScene
                    }
                }, {
                    key: "groupAlias",
                    get: function () {
                        return this._groupAlias
                    }
                }, {
                    key: "groupDesc",
                    get: function () {
                        return this._groupDesc
                    }
                }, {
                    key: "groupName",
                    get: function () {
                        return this._groupName
                    }
                }, {
                    key: "groupHeight",
                    get: function () {
                        return this._groupHeight
                    }
                }, {
                    key: "height",
                    set: function (t) {
                        this._height = t, this.traverse(function (e) {
                            e.scene.position.setY(t), e.scene.updateMatrix(), e.scene.updateWorldMatrix()
                        }), this._locationScene.position.setY(t), this._locationScene.updateMatrix(), this._locationScene.updateWorldMatrix()
                    },
                    get: function () {
                        return this._height
                    }
                }, {
                    key: "layers",
                    get: function () {
                        return this._layers
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._hideWithFree && (e || this.traverseByAlias(["extent", "label", "facility", "model"], function (e) {
                            e.releaseGpuMemory()
                        })), this._visible = e
                    }
                }, {
                    key: "offsetHeight",
                    set: function (e) {
                        this._offsetHeight = e
                    },
                    get: function () {
                        return this._offsetHeight
                    }
                }, {
                    key: "hideWithFree",
                    set: function (e) {
                        this._hideWithFree = e
                    }
                }, {
                    key: "mapCoord",
                    get: function () {
                        return (new fm.Vector2).copy(this.parent.mapcenter)
                    }
                }, {
                    key: "mapCoordRange",
                    get: function () {
                        for (var e = [{
                                x: Number.MAX_VALUE,
                                y: Number.MAX_VALUE
                            }, {
                                x: -Number.MAX_VALUE,
                                y: -Number.MAX_VALUE
                            }], t = this._layers.extent, n = 0; n < t.length; n++) {
                            var r = t[n],
                                i = r._extents;
                            for (var a in i) {
                                var o = i[a],
                                    s = o.gdata.geo,
                                    l = null;
                                l = null !== s ? m.default.convertGeo2Geometry(s).vertices : m.default.convertArray2Geometry(o.gdata.idxs, o.gdata.pts).vertices;
                                for (var u = 0; u < l.length; u++) u % 2 == 0 ? (l[u] < e[0].x && (e[0].x = l[u]), l[u] > e[1].x && (e[1].x = l[u])) : (l[u] < e[0].y && (e[0].y = l[u]), l[u] > e[1].y && (e[1].y = l[u]))
                            }
                        }
                        return e
                    }
                }]), i
            }(c.default),
            y = v;
        t.default = y
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(382)),
            d = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, "extentLayer")), n._scene = new fm.Scene, n._scene.name = "extent", n._scene.userData.type = "extent", n._extents = {}, n.initNode(e, t), n._visible = !0, n.initLight(), n.putLight(), n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "initLight",
                    value: function () {
                        this._ambientLight = new fm.AmbientLight(7631988), this._target = new fm.Object3D, this._mainLight = new fm.DirectionalLight(8947848, 1.2), this._mainLight.position.set(-1, 1, 1).normalize(), this._mainLight.castShadow = !1, this._mainLight.target = this._target, this._secondLight = new fm.DirectionalLight(3355443), this._secondLight.position.set(-.5, 1, -1).normalize(), this._secondLight.target = this._target
                    }
                }, {
                    key: "initNode",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) this.createNode(e[n], t[n])
                    }
                }, {
                    key: "createNode",
                    value: function (e, t) {
                        var n = new c.default(e, t);
                        n.parent = this, this._extents["" + n.eid] = n
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._extents["" + e.eid] = e
                    }
                }, {
                    key: "putLight",
                    value: function () {
                        var e = this;
                        this.scene.add(this._mainLight), this.scene.add(this._ambientLight), this.scene.add(this._secondLight), this.scene.add(this._target), this.scene.removeLight = function () {
                            e.removeLight()
                        }
                    }
                }, {
                    key: "removeLight",
                    value: function () {
                        this.scene.remove(this._mainLight), this.scene.remove(this._ambientLight), this.scene.remove(this._secondLight)
                    }
                }, {
                    key: "disposeLight",
                    value: function () {
                        this._mainLight = void 0, this._ambientLight = void 0, this._secondLight = void 0
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._extents["" + e]
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._extents) e && e(this._extents[t])
                    }
                }, {
                    key: "getVideoMemoryAmount",
                    value: function () {
                        var t = null;
                        return this.traverse(function (e) {
                            e._renderNode && e._renderNode.geometry && e._renderNode.geometry._bufferGeometry && (t += e._renderNode.geometry._bufferGeometry.attributes.position.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.color.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.normal.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.uv.array.byteLength)
                        }), t
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._extents) this._extents[e].visible && this._extents[e].renderNode && this._scene.add(this._extents[e].renderNode);
                        this.putLight()
                    }
                }, {
                    key: "getAllMesh",
                    value: function () {
                        var e = [];
                        for (var t in this._extents) this._extents[t].renderNode && e.push(this._extents[t].renderNode);
                        return e
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._extents) this._extents[e].dispose(), this._scene.remove(this._extents[e].renderNode), this._extents[e].parent = void 0, this._extents[e] = void 0;
                        this.removeLight(), this.disposeLight(), this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "extents",
                    get: function () {
                        return this._extents
                    },
                    set: function (e) {
                        this._extents = e
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), r
            }(h.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var c = r(n(27));
        n(13);
        var d = r(n(12)),
            f = r(n(35));
        n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            p = r(n(21)),
            g = r(n(57)),
            m = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, t.eid, p.default.EXTERANL_MODEL)), n._parseData = null, n._isInitMesh = !0, n._visible = !0, n._renderNode = null, n._geometry = void 0, n._line = null, n._bdata = t, n._selected = !1, n._preColor = null, n._preOpacity = null, n.name = t.name, n.FID = t.fid, n.ID = t.eid, n.typeID = t.type, n.gdata = e, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "initMesh",
                    value: function (e, t) {
                        this._geometry && (this._renderNode = new fm.Mesh(this._geometry.geometry, e), this._renderNode.mapNode = this, this._renderNode.scale.set(-1, 1, 1), this._renderNode.rotation.set(Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.copy(t), this._renderNode.parent = this.parent.scene, this._renderNode.visible = this.show)
                    }
                }, {
                    key: "setByTheme",
                    value: function (e) {
                        var t = this._renderNode.material,
                            n = this._renderNode;
                        if ((0, f.default)(t)) {
                            var r = !0,
                                i = !1,
                                a = void 0;
                            try {
                                for (var o, s = (0, d.default)(t); !(r = (o = s.next()).done); r = !0) {
                                    var l = o.value;
                                    l.color = new fm.Color(g.default.toColor(e.color)), l.userData.opacity = t.opacity
                                }
                            } catch (e) {
                                i = !0, a = e
                            } finally {
                                try {
                                    r || null == s.return || s.return()
                                } finally {
                                    if (i) throw a
                                }
                            }
                        } else t.color = new fm.Color(g.default.toColor(e.color)), t.userData.opacity = t.opacity;
                        var u = e.scale.split(","),
                            h = e.rotate.split(",");
                        e.translate.split(","), n.scale.set((0, c.default)(u[0]), (0, c.default)(u[1]), (0, c.default)(u[2])), n.rotation.set((0, c.default)(h[0]) * fm.Math.DEG2RAD, (0, c.default)(h[2]) * fm.Math.DEG2RAD, (0, c.default)(h[1]) * fm.Math.DEG2RAD)
                    }
                }, {
                    key: "checkByFrustum",
                    value: function () {
                        var e = !0;
                        this._renderNode && ("Mesh" === this._renderNode.type || "Scene" === this._renderNode.type && this._renderNode.traverse(function () {
                            fm.Mesh
                        }), this._renderNode.updateMatrixWorld(!0), this.visible = e)
                    }
                }, {
                    key: "setColor",
                    value: function (n, r) {
                        var i = this;
                        this._renderNode.traverse(function (e) {
                            if (e instanceof fm.Mesh)
                                if (void 0 !== e.material.length)
                                    for (var t = 0; t < e.material.length; t++) i._preColor = e.material[t].color, e.material[t].color = new fm.Color(g.default.toRgba(n)), i._preOpacity = e.material[t].opacity, "number" == typeof r && (e.material[t].opacity = r), e.material[t].needsUpdate = !0;
                                else i._preColor = e.material.color, e.material.color = new fm.Color(g.default.toRgba(n)), i._preOpacity = e.material.opacity, "number" == typeof r && (e.material.opacity = r), e.material.needsUpdate = !0
                        })
                    }
                }, {
                    key: "setColorToDefault",
                    value: function () {
                        var n = this;
                        this._renderNode.traverse(function (e) {
                            if (e instanceof fm.Mesh)
                                if (void 0 !== e.material.length)
                                    for (var t = 0; t < e.material.length; t++) e.material[t].color = n._preColor, e.material[t].opacity = n._preOpacity, e.material[t].needsUpdate = !0;
                                else e.material.color = n._preColor, e.material.opacity = n._preOpacity, e.material.needsUpdate = !0
                        })
                    }
                }, {
                    key: "gradientColor",
                    value: function () {
                        var t = this;
                        if (this._renderNode) {
                            this._renderNode.material.userData.color = this._renderNode.material.color;
                            var e = this.findParent(NodeManager),
                                n = e.map,
                                r = n.modelSelectColor;
                            animater = new Animater({
                                r: r.r / 2,
                                g: r.g / 2,
                                b: r.b / 2,
                                a: r.a / 2
                            }, r, 500, function () {
                                n.removeAnimater(animater), animater = void 0
                            }, function (e) {
                                t._renderNode.material.color = new fm.Color(e.r, e.g, e.b), t._renderNode.material.alpha = e.a, t._renderNode.material.update = !0
                            }).start(), n.addAnimater(animater)
                        }
                    }
                }, {
                    key: "clearGradient",
                    value: function () {
                        if (this._renderNode) {
                            var e = this.findParent(NodeManager),
                                t = e.map;
                            animater && t.removeAnimater(animater), this._renderNode.material.color = this._renderNode.material.userData.color, this._renderNode.material.userData.color = void 0
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        if (this._renderNode && "Mesh" === this._renderNode.type) {
                            for (var e in this._renderNode.material.uniforms) e.value instanceof fm.Texture && e.value.dispose();
                            if ((0, f.default)(this._renderNode.material)) {
                                var t = !0,
                                    n = !1,
                                    r = void 0;
                                try {
                                    for (var i, a = (0, d.default)(this._renderNode.material); !(t = (i = a.next()).done); t = !0) {
                                        var o = i.value;
                                        o.dispose()
                                    }
                                } catch (e) {
                                    n = !0, r = e
                                } finally {
                                    try {
                                        t || null == a.return || a.return()
                                    } finally {
                                        if (n) throw r
                                    }
                                }
                            } else this._renderNode.material.dispose();
                            this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0
                        }
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : (this._renderNode && this.parent.scene.remove(this._renderNode), this._renderNode.parent = this.parent.scene), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this.parent && (this._renderNode = e, this._renderNode.mapNode = this, this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode))
                    }
                }, {
                    key: "bdata",
                    get: function () {
                        return this._bdata
                    },
                    set: function (e) {
                        this._bdata = e
                    }
                }]), r
            }(h.default),
            v = m;
        t.default = v
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var o = r(n(385)),
            l = r(n(11)),
            s = r(n(16));
        n(13), n(8);
        var a, u, h = r(n(2)),
            c = r(n(3)),
            d = r(n(4)),
            f = r(n(5)),
            p = r(n(6)),
            g = r(n(7)),
            m = r(n(21)),
            v = r(n(20)),
            y = r(n(58)),
            _ = r(n(42)),
            A = r(n(49)),
            x = function (e) {
                function r(e, t) {
                    var n;
                    return (0, h.default)(this, r), n = (0, d.default)(this, (0, f.default)(r).call(this, t.eid, m.default.MODEL)), n._parseData = null, n._isInitMesh = !0, n._visible = !0, n._renderNode = null, n._data = null, n._geometry, n._shape, n.currHeight = 2, n._line = null, n._modelColor = null, n._modeAlpha = 1, n._lineColor = null, n._lineAlpha = 1, n._selected = !1, n._sgstat = !1, n._flashColor = null, n._card = {
                        top: null,
                        left: null,
                        right: null,
                        front: null,
                        back: null
                    }, n.precolor = {
                        useModel: !1,
                        useStroke: !1,
                        mcolor: null,
                        strokeColor: null,
                        malpha: 1,
                        strokeAlpha: 1
                    }, n.FID = t.fid, n.ID = t.eid, n.ename = t.ename, n.name = t.name, n.typeID = t.type, n.minlevel = t.minlevel, n.maxlevel = t.maxlevel, n.bdata = t, n.gdata = e, n.preSelect = !1, n
                }
                return (0, p.default)(r, e), (0, c.default)(r, [{
                    key: "initMesh",
                    value: function (e, t, n) {
                        this._geometry && (this._renderNode = new fm.Mesh(this._geometry.geometry, e), this._renderNode.mapNode = this, this._modelColor = e.color, this._modelAlpha = e.opacity, this._renderNode.scale.set(1, -1, 1), this._renderNode.rotation.set(Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.copy(t), this._renderNode.frustumCulled = !1, this._renderNode.parent = this.parent.scene, this._renderNode.castShadow = !0, this._renderNode.name = "oneModel", n && (this._renderNode.material.uniforms = {
                            maxPos: {
                                value: 10
                            },
                            minPos: {
                                value: 0
                            },
                            relativeModelMatrix: {
                                value: this._renderNode.matrixWorld
                            }
                        }), this.renderNodeInited = !0, this.precolor.useModel && (this.precolor.mcolor && (e.color = this.precolor.mcolor), "number" == typeof this.precolor.malpha && (e.opacity = this.precolor.malpha)), this.preSelect && (this.selected = !0, this.preSelect = !1))
                    }
                }, {
                    key: "releaseGpuMemory",
                    value: function () {
                        this.renderNode && (this._geometry = null, this._data = null, this.renderNodeInited = !1, this.renderNode.parent.remove(this.renderNode), this.dispose())
                    }
                }, {
                    key: "restoreGpuMemeory",
                    value: function () {}
                }, {
                    key: "getBbox",
                    value: function () {}
                }, {
                    key: "getRadius1",
                    value: function () {
                        return this._renderNode.geometry.boundingSphere.radius
                    }
                }, {
                    key: "getRadius",
                    value: function () {
                        for (var e = null, t = {
                                x: this._renderNode._x - this.parent.parent.parent.mapcenter.x,
                                y: this._renderNode._y - this.parent.parent.parent.mapcenter.y
                            }, n = [], r = this._renderNode.geometry.vertices, i = 0; i < r.length; i++) {
                            var a = {};
                            if (a.vertex = r[i], a.distance = Math.abs(Math.sqrt(Math.pow(r[i].x - t.x, 2) + Math.pow(r[i].y - t.y, 2))), n.length < 2) n.push(a);
                            else if (2 === n.length) {
                                if (n[0].distance > n[1].distance) {
                                    var o = null;
                                    o = n.shift(), n.push(o)
                                }
                            } else if (a.distance < n[1].distance)
                                if (a.distance < n[0].distance) {
                                    var s = null;
                                    n.pop(), s = n.shift(), n.push(a), n.push(s)
                                } else n.pop(), n.push(a)
                        }
                        var l = {
                                x: (n[0].vertex.x + n[1].vertex.x) / 2,
                                y: (n[0].vertex.y + n[1].vertex.y) / 2
                            },
                            u = Math.abs(Math.sqrt(Math.pow(l.x - t.x, 2) + Math.pow(l.y - t.y, 2)));
                        return e = n[0].distance < u ? n[0].distance : u, e
                    }
                }, {
                    key: "setByTheme",
                    value: function (e) {
                        if (this._renderNode) {
                            var t = this.findParent(v.default),
                                n = t.materialManager.createNormalMaterial(e),
                                r = t.materialManager.createLineMaterial(e);
                            if (this._lineColor = r.color, this._lineAlpha = r.opacity, this._modelColor = n.color, this._modeAlpha = n.opacity, this._renderNode.material.dispose(), this._renderNode.material = n, this._line && (this._line.material = r), this._geometry = null, this._card.top && this.removeStoreImage(), e.image && e.sizes) {
                                var i = e.sizes.split(","),
                                    a = [];
                                e.coords && (a = e.coords.split(",")), this.addStoreImage({
                                    image: e.image ? t._map.MapOptions.mapThemeURL + "/" + t._map.MapOptions.defaultThemeName + "/" + e.image : "",
                                    angle: e.angle ? e.angle : 0,
                                    size: [(0, s.default)(i[0]), (0, s.default)(i[1])],
                                    mapCoord: e.coords ? new fm.Vector2((0, s.default)(a[0]), (0, s.default)(a[1])) : void 0
                                })
                            }
                        }
                    }
                }, {
                    key: "initLine",
                    value: function (o, e) {
                        if (this._geometry) {
                            var t = (new fm.Geometry).setFromPoints(this._geometry.shape.getPoints());
                            t && 0 < t.vertices.length && t.vertices.push(t.vertices[0]);
                            for (var n = [], r = t.vertices.length, i = 0; i < r; i++) 0 == i || i == r - 1 ? n.push(t.vertices[i]) : n.push(t.vertices[i], t.vertices[i]);
                            t.vertices = n;
                            var a = new fm.LineSegments(t, o);
                            if (this._lineColor = o.color, this._lineAlpha = o.opacity, a.castShadow = !1, a.position.setZ(.005 * -e), a.geometry.computeBoundingSphere(), this.precolor.useStroke && (o.color = this.precolor.strokeColor, o.opacity = this.precolor.strokeAlpha), this._geometry.shape.holes)
                                for (var s = 0; s < this._geometry.shape.holes.length; s++) l(a, this._geometry.shape.holes[s].curves);
                            this._line = a, this._line.frustumCulled = !1, this._line.matrixAutoUpdate = !1, this._renderNode.add(a), this._shape = this._geometry.shape, this._geometry = null
                        }

                        function l(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = [];
                                r.push(new fm.Vector3(t[n].v1.x, t[n].v1.y, 0)), r.push(new fm.Vector3(t[n].v2.x, t[n].v2.y, 0));
                                var i = (new fm.BufferGeometry).setFromPoints(r),
                                    a = new fm.LineSegments(i, o);
                                e.add(a)
                            }
                        }
                    }
                }, {
                    key: "setHeight",
                    value: function (e) {
                        this.currHeight && (this._renderNode.scale.z *= e / this.currHeight, this._renderNode.position.y += e - this.currHeight), this.currHeight = e
                    }
                }, {
                    key: "checkByFrustum",
                    value: function (e) {
                        var t = !0;
                        this._renderNode && (this._renderNode.updateMatrixWorld(!0), t = e.intersectsObject(this._renderNode)), this.visible = t
                    }
                }, {
                    key: "setColor",
                    value: function (e, t) {
                        if (!this._renderNode) return this.precolor.mcolor = e ? new fm.Color(e) : e, this.precolor.malpha = t, void(this.precolor.useModel = !0);
                        e && (this._renderNode.material.color = new fm.Color(e)), "number" == typeof t && (this._renderNode.material.opacity = t, t !== this._renderNode.material.userData.opacity && (this._renderNode.material.userData.opacity = t))
                    }
                }, {
                    key: "setFlashColor",
                    value: function (e) {
                        this._flashColor = new fm.Color(e)
                    }
                }, {
                    key: "setStrokeColor",
                    value: function (e, t) {
                        if (!this._renderNode) return this.precolor.strokeColor = new fm.Color(e), this.precolor.strokeAlpha = t, void(this.precolor.useStroke = !0);
                        this._line.material.color = new fm.Color(e), this._line.material.opacity = t
                    }
                }, {
                    key: "setColorToDefault",
                    value: function () {
                        this._renderNode && (this._renderNode.material.color = this._modelColor, this._renderNode.material.opacity = this._modelAlpha)
                    }
                }, {
                    key: "setStrokeColorToDefault",
                    value: function () {
                        this._line.material.color = this._lineColor, this._line.material.opacity = this._lineAlpha
                    }
                }, {
                    key: "addStoreImage",
                    value: function (e) {
                        var t = this.findParent(v.default),
                            n = this.parent.parent.parent,
                            r = n.mapcenter,
                            i = e.mapCoord ? e.mapCoord : this.mapCoord;
                        if (this._renderNode && e.image) {
                            e = (0, l.default)({
                                size: [5, 5],
                                height: .1,
                                angle: 0,
                                offset: [0, 0]
                            }, e), this._card.top && this.removeStoreImage();
                            var a = new fm.PlaneBufferGeometry(1, 1, 1, 1),
                                o = new fm.MeshLambertMaterial({
                                    transparent: !0,
                                    depthWrite: !1,
                                    visible: !1
                                });
                            t.materialManager.loadTexture(e.image, function (e) {
                                e.anisotropy = 4, e.minFilter = fm.LinearFilter, o.map = e, o.needsUpdate = !0, o.visible = !0
                            });
                            var s = new fm.Mesh(a, o);
                            s.scale.set(e.size[0], e.size[1], -1), s.position.set(e.offset[0] + i.x - r.x, e.offset[1] + i.y - r.y, -e.height), s.rotation.z = -e.angle * fm.Math.DEG2RAD, s.renderOrder = 10, this._renderNode.add(s), this._card.top = s
                        }
                    }
                }, {
                    key: "getUvTransForm",
                    value: function () {
                        var e = this.parent.parent.parent,
                            t = (e.center, e.bbox);
                        t.max.x, t.min.x, t.max.y, t.min.y, this.renderNode
                    }
                }, {
                    key: "removeStoreImage",
                    value: function () {
                        this._card.top && (this._renderNode.remove(this._card.top), this._card.top.geometry.dispose(), this._card.top.material.map && this._card.top.material.map.dispose(), this._card.top.material.dispose(), this._card.top = null)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._line && (this._renderNode.remove(this._line), this._line.material.dispose(), this._line.geometry.dispose(), this._line = void 0), this.removeStoreImage(), this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._geometry = void 0, this._data = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "flash",
                    value: function () {
                        var t = this;
                        if (this._renderNode) {
                            this._renderNode.material.userData.color = this._renderNode.material.color;
                            var e = this.findParent(v.default),
                                n = e.map,
                                r = null;
                            r = null === this._flashColor ? n.modelSelectColor : this._flashColor;
                            var i = {
                                r: r.r / 2,
                                g: r.g / 2,
                                b: r.b / 2,
                                a: r.a / 2
                            };
                            a = function () {
                                var e = (Math.sin((new Date).getTime() / 180) + 1) / 2;
                                t._renderNode.material.color = new fm.Color(i.r * (1 + e), i.g * (1 + e), i.b * (1 + e))
                            }, n.on("frameLoop", a)
                        }
                    }
                }, {
                    key: "stopFlash",
                    value: function () {
                        if (this._renderNode) {
                            var e = this.findParent(v.default),
                                t = e.map;
                            t.off("frameLoop", a), this._renderNode.material.color = this._renderNode.material.userData.color
                        }
                    }
                }, {
                    key: "gradientColor",
                    value: function () {
                        var t = this;
                        if (this._renderNode) {
                            this._renderNode.material.userData.color = this._renderNode.material.color;
                            var e = this.findParent(v.default),
                                n = e.map,
                                r = n.modelSelectColor;
                            u = new y.default({
                                r: r.r / 2,
                                g: r.g / 2,
                                b: r.b / 2,
                                a: r.a / 2
                            }, r, 500, function () {
                                n.removeAnimater(u), u = void 0
                            }, function (e) {
                                t._renderNode.material.color = new fm.Color(e.r, e.g, e.b), t._renderNode.material.alpha = e.a, t._renderNode.material.update = !0
                            }).start(), n.addAnimater(u)
                        }
                    }
                }, {
                    key: "clearGradient",
                    value: function () {
                        if (this._renderNode) {
                            var e = this.findParent(v.default),
                                t = e.map;
                            u && t.removeAnimater(u), this._renderNode.material.color = this._renderNode.material.userData.color, this._renderNode.material.userData.color = void 0
                        }
                    }
                }, {
                    key: "distanceToPoint",
                    value: function (e) {
                        var t = this._shape.getPoints(),
                            n = A.default.isInPolygon(e, t);
                        if (n) return 0;
                        for (var r = o.default, i = 0; i < t.length - 1; i++) {
                            var a = A.default.pointDistanceToLine(e, t[i], t[i + 1], new fm.Vector2);
                            a < r && (r = a)
                        }
                        return r
                    }
                }, {
                    key: "selected",
                    set: function (e) {
                        if (e !== this._selected) {
                            if (this._selected = e, !this.renderNodeInited) return void(this.preSelect = !0);
                            e ? this.gradientColor() : this.clearGradient()
                        }
                    },
                    get: function () {
                        return this._selected
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : this._renderNode && (this.parent.scene.remove(this._renderNode), this._renderNode.parent = this.parent.scene), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this._renderNode = e
                    }
                }, {
                    key: "mapCoord",
                    get: function () {
                        var e = this.parent.parent.parent.parent.map.dataManager.file_ver,
                            t = this.parent.parent.layers.label[0].labels["" + this._eid];
                        if (t) {
                            if (t.renderNodeInited) return {
                                x: t.x,
                                y: t.y,
                                z: this.height
                            };
                            var n = null;
                            return n = 1 === e ? _.default.convertGeo2Points(t.gdata.geo) : _.default.convertArrayPoints(t.gdata.idxs, t.gdata.pts), {
                                x: n.vertices[0].x,
                                y: n.vertices[0].y,
                                z: this.height
                            }
                        }
                        return {
                            x: null,
                            y: null,
                            z: null
                        }
                    }
                }, {
                    key: "label",
                    get: function () {
                        return this.parent.parent.layers.label[0].labels["" + this._eid]
                    }
                }, {
                    key: "height",
                    set: function (e) {
                        this._height = e
                    },
                    get: function () {
                        return this.renderNodeInited ? this._height : this.gdata.height
                    }
                }, {
                    key: "line",
                    get: function () {
                        return this._line
                    }
                }]), r
            }(g.default),
            C = x;
        t.default = C
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(214)),
            d = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this)), n._scene = new fm.Scene, n._scene.userData.type = "label", n._scene.name = "label", n.alias = "label", n._labels = {}, n.initNode(e, t), n.needAvoid = !0, n._visible = !0, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._labels) e && e(this._labels[t])
                    }
                }, {
                    key: "getVideoMemoryAmount",
                    value: function () {
                        var n = null;
                        return this.traverse(function (e) {
                            if (e._renderNode && (n += e._renderNode.geometry.attributes.position.array.byteLength, n += e._renderNode.geometry.attributes.uv.array.byteLength, e._renderNode.material.map)) {
                                var t = null;
                                t = e._renderNode.material.map.image.width * e._renderNode.material.map.image.height * 32 / 8, n += t
                            }
                        }), n
                    }
                }, {
                    key: "initNode",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) this.createNode(e[n], t[n])
                    }
                }, {
                    key: "createNode",
                    value: function (e, t) {
                        var n = new c.default(e, t);
                        n.parent = this, this._labels["" + n.eid] = n
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._labels["" + e.eid] = e
                    }
                }, {
                    key: "allShow",
                    value: function () {
                        for (var e = 0; e < this._scene.children.length; e++) this._scene.children[e].visible = !0
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._labels["" + e]
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._labels) this._labels[e].visible && this._labels[e].renderNode && this._scene.add(this._labels[e].renderNode)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._labels) this._labels[e].dispose(), this._scene.remove(this._labels[e].renderNode), this._labels[e].parent = void 0, this._labels[e] = void 0;
                        this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.rushRenderNode()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }, {
                    key: "labels",
                    get: function () {
                        return this._labels
                    }
                }]), r
            }(h.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(68), n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(21)),
            d = r(n(20)),
            f = r(n(112)),
            p = r(n(80)),
            g = r(n(42)),
            m = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, t.eid, c.default.LABEL)), n._isInitSprite = !0, n._visible = !0, n._renderNode = null, n._geometry = void 0, n._size = 20, n._theme = void 0, n.bdata = t, n.ename = t.ename, n._text = t.name, n.gdata = e, n.FID = t.fid, n.ID = t.eid, n.name = t.name, n.typeID = t.type, n.minlevel = t.minlevel, n.maxlevel = t.maxlevel, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "checkByFrustum",
                    value: function (e) {
                        var t = !0;
                        this._renderNode && (this._renderNode.updateMatrixWorld(!0), t = e.intersectsSprite(this._renderNode)), this.visible = t
                    }
                }, {
                    key: "initSprite",
                    value: function (e, t) {
                        e && (this._renderNode = new f.default(e), this._renderNode.position.copy(t), this._renderNode.mapNode = this, this._renderNode.frustumCulled = !0, this.renderNodeInited = !0, this._renderNode.parent = this.parent.scene, this._renderNode.visible = this.show, this._renderNode.name = "spirit")
                    }
                }, {
                    key: "setText",
                    value: function (e) {
                        if (this._renderNode && this._theme) {
                            var t = this.findParent(d.default);
                            this._renderNode.material.map && this._renderNode.material.map.dispose(), this._renderNode.material && this._renderNode.material.dispose(), this._renderNode.material = t.materialManager.createLabelMaterial(e, this._theme), this._text = e, this.setSize()
                        }
                    }
                }, {
                    key: "releaseGpuMemory",
                    value: function () {
                        this.renderNode && (this.renderNodeInited = !1, this._isInitSprite = !1, this.tryInit = !1, this.renderNode.parent.remove(this.renderNode), this.dispose())
                    }
                }, {
                    key: "setByLanguage",
                    value: function (e) {
                        var t;
                        if (t = e === p.default.EN ? this.bdata.ename : this.bdata.name, !t) return this.visible = !1, void this.dispose();
                        if (this._renderNode) this.setText(t);
                        else if (this.tryInit && !this.renderNodeInited) {
                            var n = this.findParent(d.default),
                                r = this.parent.parent.parent.theme.getLabelTheme(this.bdata);
                            this._theme = r;
                            var i = n.materialManager.createLabelMaterial(t, r);
                            this.initSprite(i, this.pos), this.setSize()
                        }
                        this.visible = !0
                    }
                }, {
                    key: "setByTheme",
                    value: function (e) {
                        if (this._text) {
                            var t = this.findParent(d.default);
                            this._theme = e, this._size = 1.4 * e.fontsize, this._renderNode.material.map && this._renderNode.material.map.dispose(), this._renderNode.material && this._renderNode.material.dispose(), this._renderNode && (this._renderNode.material = t.materialManager.createLabelMaterial(this._text, this._theme)), this.setSize()
                        }
                    }
                }, {
                    key: "setSize",
                    value: function () {
                        var e = this.findParent(d.default);
                        e.map.renderer.setLabelSize(this._renderNode, this._size)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0, this.renderNodeInited = !1)
                    }
                }, {
                    key: "mapCoord",
                    get: function () {
                        var e = this.parent.parent.parent.parent.map.dataManager.file_ver,
                            t = this;
                        if (t) {
                            if (t.renderNodeInited) return {
                                x: t.x,
                                y: t.y,
                                z: this.height
                            };
                            var n = null;
                            return n = 1 === e ? g.default.convertGeo2Points(t.gdata.geo) : g.default.convertArrayPoints(t.gdata.idxs, t.gdata.pts), {
                                x: n.vertices[0].x,
                                y: n.vertices[0].y,
                                z: this.height
                            }
                        }
                        return {
                            x: null,
                            y: null,
                            z: null
                        }
                    }
                }, {
                    key: "model",
                    get: function () {
                        return this.parent.parent.layers.model[0].models["" + this._eid]
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        this._renderNode && (e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : (this.parent.scene.remove(this._renderNode), this._renderNode.parent = this.parent.scene)), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this._renderNode = e
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this._size
                    },
                    set: function (e) {
                        this._size = e
                    }
                }, {
                    key: "theme",
                    set: function (e) {
                        this._theme = e
                    }
                }]), r
            }(h.default),
            v = m;
        t.default = v
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(216)),
            d = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this)), n._scene = new fm.Scene, n._scene.userData.type = "facility", n.alias = "facility", n._facility = {}, n.needAvoid = !0, n.initNode(e, t), n._visible = !0, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "initNode",
                    value: function (e, t) {
                        if (e)
                            for (var n = 0; n < e.length; n++) this.createNode(e[n], t[n])
                    }
                }, {
                    key: "createNode",
                    value: function (e, t) {
                        var n = new c.default(e, t);
                        n.parent = this, this._facility["" + n.eid] = n
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._facility["" + e.eid] = e
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._facility) e && e(this._facility[t])
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._facility["" + e]
                    }
                }, {
                    key: "getVideoMemoryAmount",
                    value: function () {
                        var n = null;
                        return this.traverse(function (e) {
                            if (e._renderNode && (n += e._renderNode.geometry.attributes.position.array.byteLength, n += e._renderNode.geometry.attributes.uv.array.byteLength, e._renderNode.material.map)) {
                                var t = null;
                                t = e._renderNode.material.map.image.width * e._renderNode.material.map.image.height * 32 / 8, n += t
                            }
                        }), n
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._facility) this._facility[e].visible && this._facility[e].renderNode && this._scene.add(this._facility[e].renderNode)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._facility) this._facility[e].dispose(), this._scene.remove(this._facility[e].renderNode), this._facility[e].parent = void 0, this._facility[e] = void 0;
                        this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), r
            }(h.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(16)),
            s = r(n(11));
        n(8);
        var o = r(n(2)),
            l = r(n(3)),
            u = r(n(4)),
            h = r(n(5)),
            c = r(n(6)),
            d = r(n(7)),
            f = r(n(21)),
            p = r(n(20)),
            g = r(n(112)),
            m = r(n(42)),
            v = function (e) {
                function r(e, t) {
                    var n;
                    return (0, o.default)(this, r), n = (0, u.default)(this, (0, h.default)(r).call(this, t.eid, f.default.FACILITY)), n._isInitSprite = !0, n._visible = !0, n._renderNode = null, n._geometry = void 0, n._size = 20, n.bdata = t, n.gdata = e, n.FID = t.fid, n.ID = t.eid, n.ename = t.ename, n.name = t.name, n.typeID = t.type, n.minlevel = t.minlevel, n.maxlevel = t.maxlevel, n
                }
                return (0, c.default)(r, e), (0, l.default)(r, [{
                    key: "checkByFrustum",
                    value: function (e) {
                        var t = !0;
                        this._renderNode && (this._renderNode.updateMatrixWorld(!0), t = e.intersectsObject(this._renderNode)), this.visible = t
                    }
                }, {
                    key: "jump",
                    value: function (e) {
                        var n = this;
                        if (this._renderNode && !this._isJumping) {
                            this._isJumping = !0;
                            var r = (0, s.default)({
                                height: 8,
                                times: 0,
                                duration: 1,
                                delay: 0
                            }, e);
                            if ("number" == typeof r.height && "number" == typeof r.times && "number" == typeof r.duration && "number" == typeof r.delay) {
                                r.duration *= 1e3, r.delay *= 1e3, r.all = r.duration + r.delay, r.halfDuration = r.duration / 2;
                                var i = r.height - this._height;
                                this._origonY = this._renderNode.position.y;
                                var a = (new Date).getTime(),
                                    t = this.findParent(p.default),
                                    o = t.map;
                                this.jumpEvent = function () {
                                    if (n._renderNode) {
                                        var e = (new Date).getTime() - a;
                                        if (0 != r.times && e / r.all > r.times) n.stopJump();
                                        else if (e %= r.all, e > r.duration) n._renderNode.position.y != n._origonY && (n._renderNode.position.y = n._origonY);
                                        else {
                                            var t = e / r.halfDuration - 1;
                                            t = 1 - t * t, n._renderNode.position.y = n._origonY + i * t
                                        }
                                    } else o.off("frameLoop", n.jumpEvent)
                                }, o.on("frameLoop", this.jumpEvent)
                            }
                        }
                    }
                }, {
                    key: "stopJump",
                    value: function () {
                        if (this._renderNode && this.jumpEvent) {
                            this._renderNode.position.y = this._origonY, this._isJumping = !1;
                            var e = this.findParent(p.default),
                                t = e.map;
                            t.off("frameLoop", this.jumpEvent)
                        }
                    }
                }, {
                    key: "boost",
                    value: function (e) {
                        var n = this;
                        if (this._renderNode && !this._isBoosting) {
                            this._isBoosting = !0;
                            var r = (0, s.default)({
                                size: 8,
                                ratio: 0,
                                duration: 1,
                                delay: 0
                            }, e);
                            if ("number" == typeof r.size && "number" == typeof r.ratio && "number" == typeof r.duration && "number" == typeof r.delay) {
                                r.duration *= 1e3, r.delay *= 1e3, r.all = r.duration + r.delay, r.halfDuration = r.duration / 2;
                                var i = r.size - this._size;
                                this._origonSize = this._size;
                                var t = this.findParent(p.default),
                                    a = t.map;
                                this.boostEvent = function () {
                                    if (n._renderNode) {
                                        var e = (new Date).getTime(),
                                            t = Math.sin(e * r.ratio) / 2 + .5;
                                        n._size = n._origonSize + t * i, n.setSize()
                                    } else a.off("frameLoop", n.boostEvent)
                                }, a.on("frameLoop", this.boostEvent)
                            }
                        }
                    }
                }, {
                    key: "stopBoost",
                    value: function () {
                        if (this._renderNode && this.boostEvent) {
                            this._size = this._origonSize, this._isBoosting = !1;
                            var e = this.findParent(p.default),
                                t = e.map;
                            t.off("frameLoop", this.boostEvent), this.setSize()
                        }
                    }
                }, {
                    key: "initSprite",
                    value: function (e, t) {
                        this._renderNode = new g.default(e), this._renderNode.mapNode = this, this._renderNode.frustumCulled = !1, this._renderNode.position.copy(t), this._renderNode.parent = this.parent.scene, this.renderNodeInited = !0, this._renderNode.visible = this.show, this._renderNode.name = "spirit"
                    }
                }, {
                    key: "releaseGpuMemory",
                    value: function () {
                        this.renderNode && (this.renderNodeInited = !1, this.renderNode.parent.remove(this.renderNode), this.dispose())
                    }
                }, {
                    key: "setByTheme",
                    value: function (e) {
                        if (this._renderNode) {
                            var t = this.findParent(p.default),
                                n = t.materialManager.createPoiMaterial(e);
                            this._renderNode.material.dispose(), this._renderNode.material = n
                        }
                    }
                }, {
                    key: "setSize",
                    value: function () {
                        var e = this.findParent(p.default);
                        e.map.renderer.setFacilitySize(this._renderNode, this._size)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && (this._renderNode && this.parent.scene.add(this._renderNode), this.setSize()) : (this._renderNode && this.parent.scene.remove(this._renderNode), this._renderNode && (this._renderNode.parent = this.parent.scene)), this._visible = e, this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this._renderNode = e
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this._size
                    },
                    set: function (e) {
                        this._size = (0, a.default)(e)
                    }
                }, {
                    key: "mapCoord",
                    get: function () {
                        var e = this.parent.parent.parent.parent.map.dataManager.file_ver,
                            t = this;
                        if (t) {
                            if (t.renderNodeInited) return {
                                x: t.x,
                                y: t.y,
                                z: this.height
                            };
                            var n = null;
                            return n = 1 === e ? m.default.convertGeo2Points(t.gdata.geo) : m.default.convertArrayPoints(t.gdata.idxs, t.gdata.pts), {
                                x: n.vertices[0].x,
                                y: n.vertices[0].y,
                                z: this.height
                            }
                        }
                        return {
                            x: null,
                            y: null,
                            z: null
                        }
                    }
                }]), r
            }(d.default),
            y = v,
            _ = y;
        t.default = _
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(41)),
            s = r(n(12)),
            o = r(n(2)),
            l = r(n(3)),
            u = r(n(4)),
            h = r(n(5)),
            c = r(n(6)),
            d = r(n(7)),
            f = function (e) {
                function t() {
                    var e;
                    return (0, o.default)(this, t), e = (0, u.default)(this, (0, h.default)(t).call(this)), e._scene = new fm.Scene, e._scene.userData.type = "imageMarker", e.alias = "imageMarker", e.imageMarkers = [], e._visible = !0, e.needAvoid = !0, e.prepareInitObjects = [], e
                }
                return (0, c.default)(t, e), (0, l.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.isInitSprite || e.initSprite() ? this.pushImageMarker(e) : this.prepareInitObjects.push(e)
                    }
                }, {
                    key: "initPrepare",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.prepareInitObjects); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                if (a.initSprite()) {
                                    var o = this.prepareInitObjects.indexOf(a); - 1 < o && this.prepareInitObjects.splice(o, 1), this.pushImageMarker(a)
                                }
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "pushImageMarker",
                    value: function (e) {
                        this.imageMarkers.push(e), e.renderNode && this._scene.add(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.imageMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                this.removeNode(a, !0)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.imageMarkers.length = 0
                    }
                }, {
                    key: "untiedMarker",
                    value: function (e) {
                        e.parent = void 0, this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "removeNode",
                    value: function (e, t) {
                        if (e.parent = void 0, this._scene.remove(e.renderNode), e.isAlwaysShow && (this.parent.removeAlwaysShowMarker(e.renderNode), e.show = !1), e.dispose(), !t) {
                            var n = this.imageMarkers.indexOf(e); - 1 < n && this.imageMarkers.splice(n, 1)
                        }
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        this.removeNode(e)
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        this._scene.children.length = 0;
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.imageMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.visible && a.renderNode && this._scene.add(a.renderNode)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, s.default)(this.imageMarkers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e && e(o)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.imageMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose(), this._scene.remove(a.renderNode), a.parent = void 0
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.imageMarkers.length = 0, this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }, {
                    key: "markers",
                    get: function () {
                        var e = [];
                        return e.push.apply(e, (0, a.default)(this.imageMarkers)), e
                    }
                }]), t
            }(d.default),
            p = f;
        t.default = p
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var s = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(7)),
            d = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, l.default)(this, (0, u.default)(t).call(this)), e._scene = new fm.Scene, e._scene.userData.type = "polygonMarker", e.alias = "polygonMarker", e.polygonMarkers = [], e._visible = !0, e.prepareInitObjects = [], e
                }
                return (0, h.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.isInitPolygon || e.initPolygon() ? this.pushPolygonMarker(e) : this.prepareInitObjects.push(e)
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, s.default)(this.polygonMarkers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e && e(o)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "initPrepare",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.prepareInitObjects); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                if (a.initPolygon()) {
                                    var o = this.prepareInitObjects.indexOf(a); - 1 < o && this.prepareInitObjects.splice(o, 1), this.pushPolygonMarker(a)
                                }
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "pushPolygonMarker",
                    value: function (e) {
                        this.polygonMarkers.push(e), e.renderNode && this._scene.add(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.polygonMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.parent = void 0, this._scene.remove(a.renderNode), a.dispose()
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.polygonMarkers.length = 0
                    }
                }, {
                    key: "removeNode",
                    value: function (e) {
                        this.removeMarker(e)
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        e.parent = void 0, this._scene.remove(e.renderNode), e.dispose();
                        var t = this.polygonMarkers.indexOf(e); - 1 < t && this.polygonMarkers.splice(t, 1)
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        this._scene.children.length = 0;
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.polygonMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.visible && a.renderNode && this._scene.add(a.renderNode)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.polygonMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose(), this._scene.remove(a.renderNode), a.parent = void 0
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.polygonMarkers.length = 0, this._scene = void 0
                    }
                }, {
                    key: "markers",
                    get: function () {
                        return this.polygonMarkers
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), t
            }(c.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(220)),
            h = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, o.default)(this, (0, s.default)(t).call(this)), e._scene.userData.type = "gradientPolygonMarker", e.alias = "gradientPolygonMarker", e
                }
                return (0, l.default)(t, e), t
            }(u.default),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var s = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(388)),
            d = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, l.default)(this, (0, u.default)(t).call(this)), e._markers = [], e.prepareInitMarkers = [], e
                }
                return (0, h.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.isInit || e.init() ? this.pushMarker(e) : this.prepareInitMarkers.push(e)
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, s.default)(this._markers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e && e(o)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "initPrepare",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.prepareInitMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                if (a.init()) {
                                    var o = this.prepareInitMarkers.indexOf(a); - 1 < o && this.prepareInitMarkers.splice(o, 1), this.pushMarker(a)
                                }
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "pushMarker",
                    value: function (e) {
                        this._markers.push(e), e.renderNode && this._scene.add(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this._markers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.parent = void 0, this._scene.remove(a.renderNode), a.dispose()
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this._markers.length = 0
                    }
                }, {
                    key: "removeNode",
                    value: function (e) {
                        this.removeMarker(e)
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        e.parent = void 0, this._scene.remove(e.renderNode), e.dispose();
                        var t = this._markers.indexOf(e); - 1 < t && this._markers.splice(t, 1)
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        this._scene.children.length = 0;
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this._markers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.visible && a.renderNode && this._scene.add(a.renderNode)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this._markers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose(), this._scene.remove(a.renderNode), a.parent = void 0
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this._markers.length = 0, this._scene = void 0
                    }
                }, {
                    key: "markers",
                    get: function () {
                        return this._markers
                    }
                }]), t
            }(c.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var s = r(n(12));
        n(8);
        var a = r(n(2)),
            o = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(7)),
            d = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, l.default)(this, (0, u.default)(t).call(this)), e._scene = new fm.Scene, e._scene.userData.type = "textMarker", e._scene.name = "textMarker", e.alias = "textMarker", e.textMarkers = [], e._visible = !0, e.prepareInitObjects = [], e
                }
                return (0, h.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.isInitSprite || e.initSprite() ? this.pushImageMarker(e) : this.prepareInitObjects.push(e)
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        var t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, s.default)(this.textMarkers); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                e && e(o)
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "initPrepare",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.prepareInitObjects); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                if (a.initSprite()) {
                                    var o = this.prepareInitObjects.indexOf(a); - 1 < o && this.prepareInitObjects.splice(o, 1), this.pushImageMarker(a)
                                }
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "pushImageMarker",
                    value: function (e) {
                        this.textMarkers.push(e), e.renderNode && this._scene.add(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.textMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                this.removeNode(a, !0)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.textMarkers.length = 0
                    }
                }, {
                    key: "untiedMarker",
                    value: function (e) {
                        e.parent = void 0, this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "removeNode",
                    value: function (e, t) {
                        if (e.parent = void 0, this._scene.remove(e.renderNode), e.isAlwaysShow && (this.parent.removeAlwaysShowMarker(e.renderNode), e.show = !1), e.dispose(), !t) {
                            var n = this.textMarkers.indexOf(e); - 1 < n && this.textMarkers.splice(n, 1)
                        }
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        this.removeNode(e)
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        this._scene.children.length = 0;
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.textMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.visible && a.renderNode && this._scene.add(a.renderNode)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, s.default)(this.textMarkers); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose(), this._scene.remove(a.renderNode), a.parent = void 0
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        this.textMarkers.length = 0, this._scene = void 0
                    }
                }, {
                    key: "markers",
                    get: function () {
                        return this.textMarkers
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), t
            }(c.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var p = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            g = r(n(20)),
            m = r(n(390)),
            c = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this)), t._scene = new fm.Scene, t._scene.userData.type = "heatmap", t.alias = "heatmap", t._prepareInited = !1, t._randomInited = !0, t._randomNum = 0, t._gradient = null == e.gradient ? {
                        .45: "rgb(0,0,255)",
                        .55: "rgb(0,255,255)",
                        .65: "rgb(0,255,0)",
                        .95: "yellow",
                        1: "rgb(255,0,0)"
                    } : e.gradient, t._points = null, t._opacity = "number" == typeof e.opacity ? e.opacity : .5, t._prepareInitObjects = [], t._visible = !0, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "init",
                    value: function () {
                        var e = this.findParent(g.default);
                        if (e && this._points) {
                            var t = this.parent.parent,
                                n = this.parent.getHeight(),
                                r = t.center,
                                i = e.materialManager,
                                a = i.getHeatMapGradient(this._gradient),
                                o = new m.default({}, {}, a);
                            o.material.opacity = this._opacity;
                            var s = !0,
                                l = !1,
                                u = void 0;
                            try {
                                for (var h, c = (0, p.default)(this._points); !(s = (h = c.next()).done); s = !0) {
                                    var d = h.value,
                                        f = o.clone();
                                    f.position.set(d.x, r.y + 3 + n, d.y - r.y), f.mapNode = this, this._scene.add(f)
                                }
                            } catch (e) {
                                l = !0, u = e
                            } finally {
                                try {
                                    s || null == c.return || c.return()
                                } finally {
                                    if (l) throw u
                                }
                            }
                            this._prepareInited = !1
                        } else this._prepareInited = !0
                    }
                }, {
                    key: "initPrepare",
                    value: function () {
                        this._randomInited || (this.randomPoints(this._randomNum, !0), this._randomInited = !0, this._randomNum = 0), this._points, this.init()
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        var e = this._scene;
                        if (e) {
                            for (var t = e.children.length - 1; - 1 < t; t--) {
                                var n = e.children[t];
                                e.remove(n), n.mapNode = void 0, n.geometry.dispose(), n.material.dispose(), n.material.map.dispose()
                            }
                            e.children.length = 0
                        }
                        this._points.length = 0
                    }
                }, {
                    key: "clearPoints",
                    value: function () {
                        this.removeAll()
                    }
                }, {
                    key: "addPoints",
                    value: function (e) {
                        this._points = e, this.init()
                    }
                }, {
                    key: "randomPoints",
                    value: function (e, t) {
                        var n = this.findParent(g.default);
                        if (!n) return this._prepareInited = !0, this._randomInited = !1, void(this._randomNum = e);
                        for (var r = this.parent.parent, i = r.bbox, a = i.max.x - i.min.x, o = i.max.y - i.min.y, s = [], l = 0; l < e; l++) s.push({
                            x: Math.random() * a + i.min.x,
                            y: Math.random() * o + i.min.y
                        });
                        this._points = s, t || this.init()
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.removeAll(), this._scene = void 0, this._gradient = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "prepareInited",
                    get: function () {
                        return this._prepareInited
                    }
                }, {
                    key: "prepareInitObjects",
                    get: function () {
                        return this._prepareInitObjects
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    }
                }]), n
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(55), n(144), n(25);
        var a = r(n(2)),
            o = r(n(3)),
            s = (r(n(206)), function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, [{
                    key: "createGeometry",
                    value: function (e, t, n, r) {
                        for (var i = new Float32Array((t + 1) * n * 3), a = new Float32Array((t + 1) * n * 2), o = new Uint16Array(t * n * 2 * 3), s = 0; s < t + 1; s++)
                            for (var l = s / t * e, u = 4 / Math.sqrt(2 * Math.PI) * Math.exp(-l * l / 2 / r) / Math.sqrt(r), h = 0; h < n; h++) {
                                var c = h / n * Math.PI * 2,
                                    d = l * Math.sin(c),
                                    f = l * Math.cos(c),
                                    p = s * n * 3 + 3 * h;
                                i[p] = f, i[p + 1] = u, i[p + 2] = d;
                                var g = s * n * 2 + 2 * h;
                                if (a[g] = h / n, a[g + 1] = s / t, s < t) {
                                    var m = void 0,
                                        v = void 0,
                                        y = void 0,
                                        _ = void 0,
                                        A = s * n * 6 + 6 * h;
                                    m = s * n + h, v = h + 1 === n ? s * n : m + 1, y = m + n, _ = v + n, o[A] = m, o[A + 1] = v, o[A + 2] = y, o[A + 3] = v, o[A + 4] = _, o[A + 5] = y
                                }
                            }
                        return {
                            index: o,
                            uv: a,
                            vertice: i
                        }
                    }
                }, {
                    key: "computerArcLineByPoints",
                    value: function (e, t, n, r, i) {
                        var a = (new fm.Vector3).copy(e).distanceTo(t),
                            o = (new fm.Vector3).copy(n).distanceTo(t),
                            s = (new fm.Vector3).copy(e),
                            l = (new fm.Vector3).copy(e),
                            u = [];
                        r < a && (s = (new fm.Vector3).copy(t).add((new fm.Vector3).copy(e).sub(t).normalize().multiplyScalar(r)), u.push(s)), r < o && (l = (new fm.Vector3).copy(t).add((new fm.Vector3).copy(n).sub(t).normalize().multiplyScalar(r)));
                        for (var h = new fm.QuadraticBezierCurve3(s, t, l), c = 0; c < i - 1; c++) {
                            var d = (c + 1) / i,
                                f = h.getPoint(d);
                            u.push(f)
                        }
                        return r < o && u.push(l), u
                    }
                }]), e
            }()),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(113);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(20)),
            d = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e._scene = new fm.Scene, e._scene.userData.type = "domMarker", e.alias = "domMarker", e._visible = !0, e.domMarkers = [], e.anchor = 9, e.temp = [], e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, this.domMarkers.push(e);
                        var t = new Date,
                            n = t.getTime(),
                            r = Math.random();
                        e._param.id = "domMarker" + n + r, e.initDom(e._param);
                        var i = this.findParent(c.default);
                        i && (this._displayMarker(), i._map.on("update", this._moveMarker.bind(this)), i._map.on("focusGroupIDChanged", this._displayMarker.bind(this)), i._map.on("visibleGroupIDsChanged", this._displayMarker.bind(this)))
                    }
                }, {
                    key: "_moveMarker",
                    value: function () {
                        var e = this.findParent(c.default);
                        if (e)
                            for (var t = 0; t < this.domMarkers.length; t++) {
                                var n = this.domMarkers[t],
                                    r = n.domNode;
                                if (r) {
                                    var i = null;
                                    i = n.gid ? n.height ? n.height + e._map.groupSpace * n.gid : e._map.groupSpace * n.gid : n.height ? n.height + this.height : this.height;
                                    var a = e._map.coordMapToScreen(n.x, n.y, i);
                                    r.style.left = this._anchor(n, a).left, r.style.top = this._anchor(n, a).top, a.domvisible ? n._show && (r.style.display = "block") : r.style.display = "none"
                                }
                            }
                    }
                }, {
                    key: "_anchor",
                    value: function (e, t) {
                        var n = null,
                            r = null;
                        switch (e.anchor) {
                            case 9:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 5:
                                n = t.x - e.domWidth + "px", r = t.y - e.domHeight + "px";
                                break;
                            case 6:
                                n = t.x + "px", r = t.y - e.domHeight + "px";
                                break;
                            case 7:
                                n = t.x - e.domWidth + "px", r = t.y + "px";
                                break;
                            case 8:
                                n = t.x + "px", r = t.y + "px";
                                break;
                            case 1:
                                n = t.x - e.domWidth + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 2:
                                n = t.x + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 3:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight + "px";
                                break;
                            case 4:
                                n = t.x - e.domWidth / 2 + "px", r = t.y + "px";
                                break;
                            default:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight / 2 + "px"
                        }
                        return {
                            left: n,
                            top: r
                        }
                    }
                }, {
                    key: "_displayMarker",
                    value: function () {
                        var e = this.findParent(c.default);
                        if (e)
                            if (1 === e._map._visibleGroups.length)
                                if (this.parent.eid === e._map.focusGroupID)
                                    for (var t = 0; t < this.domMarkers.length; t++) this.domMarkers[t].show && (this.domMarkers[t].domNode.style.display = "block", this.domMarkers[t].domNode.style.opacity = 1);
                                else
                                    for (var n = 0; n < this.domMarkers.length; n++) this.domMarkers[n].domNode.style.display = "none", this.domMarkers[n].domNode.style.opacity = e._map.MapOptions.focusAlpha;
                        else if (this.parent.eid === e._map.focusGroupID)
                            for (var r = 0; r < this.domMarkers.length; r++) this.domMarkers[r].show && (this.domMarkers[r].domNode.style.display = "block", this.domMarkers[r].domNode.style.opacity = 1);
                        else
                            for (var i = 0; i < this.domMarkers.length; i++) this.domMarkers[i].show && (this.domMarkers[i].domNode.style.display = "block", this.domMarkers[i].domNode.style.opacity = e._map.MapOptions.focusAlpha)
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        if (void 0 === e) return null;
                        e.parent = null;
                        var t = document.getElementById(e._param.id);
                        t && (t.parentNode.removeChild(t), t = null);
                        var n = this.domMarkers.indexOf(e); - 1 < n && this.domMarkers.splice(n, 1)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        if (void 0 === this.domMarkers.length) return null;
                        for (var e = 0; e < this.domMarkers.length; e++) {
                            var t = document.getElementById(this.domMarkers[e]._param.id);
                            t && (t.parentNode.removeChild(t), t = null)
                        }
                        this.domMarkers.length = 0
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.removeAll()
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "height",
                    get: function () {
                        return this.parent._height
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.show
                    },
                    set: function (e) {
                        if (void 0 === this.domMarkers.length) return null;
                        for (var t = 0; t < this.domMarkers.length; t++) {
                            var n = document.getElementById(this.domMarkers[t]._param.id);
                            n && (n.style.display = e ? "block" : "none")
                        }
                    }
                }]), t
            }(h.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this, "dynmodel")), e._scene = new fm.Scene, e._scene.userData.type = "dynmodel", e._scene.name = "dynmodel", e.alias = "dynmodel", e._models = {}, e.prepareInitObjects = [], e._visible = !0, e.initLight(), e.putLight(), e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "initLight",
                    value: function () {
                        this._ambientLight = new fm.AmbientLight(7631988), this._target = new fm.Object3D, this._mainLight = new fm.DirectionalLight(8947848, 1.2), this._mainLight.position.set(-1, 1, 1).normalize(), this._mainLight.target = this._target, this._secondLight = new fm.DirectionalLight(3355443), this._secondLight.position.set(-.5, 1, -1).normalize(), this._secondLight.target = this._target
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._models["" + e.eid] = e
                    }
                }, {
                    key: "removeNode",
                    value: function (e) {
                        this.removeMarker(e)
                    }
                }, {
                    key: "removeMarker",
                    value: function (n) {
                        n.parent = void 0;
                        var r = this;
                        void 0 !== n.renderNode && null !== n.renderNode && (n.renderNode.traverse(function (e) {
                            if (e instanceof fm.Mesh)
                                if (e.material.transparent = !0, n._fadeOut) var t = setInterval(function () {
                                    .05 < e.material.opacity ? e.material.opacity -= .05 : (clearInterval(t), r._scene.remove(n.renderNode))
                                }, 200);
                                else r._scene.remove(n.renderNode)
                        }), n.dispose())
                    }
                }, {
                    key: "untiedMarker",
                    value: function (e) {
                        e.parent = void 0, this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "putLight",
                    value: function () {
                        var e = this;
                        this.scene.add(this._mainLight), this.scene.add(this._ambientLight), this.scene.add(this._secondLight), this.scene.add(this._target), this.scene.removeLight = function () {
                            e.removeLight()
                        }
                    }
                }, {
                    key: "removeLight",
                    value: function () {
                        this.scene.remove(this._mainLight), this.scene.remove(this._ambientLight), this.scene.remove(this._secondLight)
                    }
                }, {
                    key: "disposeLight",
                    value: function () {
                        this._mainLight = void 0, this._ambientLight = void 0, this._secondLight = void 0
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._models["" + e]
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._models) e && e(this._models[t])
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._models) this._models[e].visible && this._models[e].renderNode && this._scene.add(this._models[e].renderNode);
                        this.putLight()
                    }
                }, {
                    key: "getAllMesh",
                    value: function () {
                        var e = [];
                        for (var t in this._models) this._models[t].renderNode && e.push(this._models[t].renderNode);
                        return e
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._models) this._models[e].dispose(), this._scene.remove(this._models[e].renderNode), this._models[e].parent = void 0, this._models[e] = void 0;
                        this.removeLight(), this.disposeLight(), this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "models",
                    get: function () {
                        return this._models
                    },
                    set: function (e) {
                        this._models = e
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e._scene = new fm.Scene, e._scene.userData.type = "flmMarker", e._scene.name = "flmMarker", e.alias = "flmMarker", e.lines = [], e._visible = !0, e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.initLine(), e.renderNode && this._scene.add(e.renderNode), this.lines.push(e)
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        if (!e.renderNode) return !1;
                        for (var t = 0; t < this.lines.length; t++)
                            if (this.lines[t].renderNode.uuid === e.renderNode.uuid) {
                                this.lines.splice(t, 1);
                                break
                            } this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        for (var e = 0; e < this.lines.length; e++) this._scene.remove(this.lines[e].renderNode);
                        this.lines = []
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e = 0; e < this.lines.length; e++) this._scene.remove(this.lines[e].renderNode), this.lines[e].parent = void 0, this.lines[e] = void 0;
                        this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(220)),
            h = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, o.default)(this, (0, s.default)(t).call(this)), e._scene.userData.type = "extrudeMarker", e.alias = "extrudeMarker", e
                }
                return (0, l.default)(t, e), t
            }(u.default),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(25);
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = function (e) {
                function r() {
                    var e;
                    (0, a.default)(this, r), e = (0, o.default)(this, (0, s.default)(r).call(this));
                    var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        n = new fm.InterleavedBuffer(t, 5);
                    return e.setIndex([0, 1, 2, 0, 2, 3]), e.setAttribute("position", new fm.InterleavedBufferAttribute(n, 3, 0, !1)), e.setAttribute("uv", new fm.InterleavedBufferAttribute(n, 2, 3, !1)), e
                }
                return (0, l.default)(r, e), r
            }(fm.BufferGeometry),
            h = u;
        t.default = h
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var p = r(n(54));
        n(53);
        var a = r(n(11)),
            o = r(n(47));
        n(25), n(195), n(144), n(196), n(197);
        var s = r(n(31));
        n(48), n(147), n(99), n(62), n(67), n(402);
        var g = r(n(35)),
            v = r(n(403));

        function l(e) {
            this.manager = void 0 !== e ? e : fm.DefaultLoadingManager, this.dracoLoader = null, this.ddsLoader = null
        }

        function u() {
            var n = {};
            return {
                get: function (e) {
                    return n[e]
                },
                add: function (e, t) {
                    n[e] = t
                },
                remove: function (e) {
                    delete n[e]
                },
                removeAll: function () {
                    n = {}
                }
            }
        }
        n(8), n(145), l.prototype = {
            constructor: l,
            crossOrigin: "anonymous",
            load: function (n, r, e, t) {
                var i, a = this;
                i = void 0 !== this.resourcePath ? this.resourcePath : void 0 !== this.path ? this.path : fm.LoaderUtils.extractUrlBase(n), a.manager.itemStart(n);
                var o = function (e) {
                        t ? t(e) : console.error(e), a.manager.itemError(n), a.manager.itemEnd(n)
                    },
                    s = new fm.FileLoader(a.manager);
                s.setPath(this.path), s.setResponseType("arraybuffer"), "use-credentials" === a.crossOrigin && s.setWithCredentials(!0), s.load(n, function (t) {
                    try {
                        a.parse(t, i, function (e) {
                            r(e, t), a.manager.itemEnd(n)
                        }, o)
                    } catch (e) {
                        o(e)
                    }
                }, e, o)
            },
            setCrossOrigin: function (e) {
                return this.crossOrigin = e, this
            },
            setPath: function (e) {
                return this.path = e, this
            },
            setResourcePath: function (e) {
                return this.resourcePath = e, this
            },
            setDRACOLoader: function (e) {
                return this.dracoLoader = e, this
            },
            setDDSLoader: function (e) {
                return this.ddsLoader = e, this
            },
            parse: function (e, t, n, r) {
                var i, a = {};
                if ("string" == typeof e) i = e;
                else {
                    var o = fm.LoaderUtils.decodeText(new Uint8Array(e, 0, 4));
                    if (o === _) {
                        try {
                            a[m.KHR_BINARY_GLTF] = new A(e)
                        } catch (e) {
                            return void(r && r(e))
                        }
                        i = a[m.KHR_BINARY_GLTF].content
                    } else i = fm.LoaderUtils.decodeText(new Uint8Array(e))
                }
                var s = JSON.parse(i);
                if (void 0 === s.asset || s.asset.version[0] < 2) r && r(new Error("fm.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                else {
                    if (s.extensionsUsed)
                        for (var l = 0; l < s.extensionsUsed.length; ++l) {
                            var u = s.extensionsUsed[l],
                                h = s.extensionsRequired || [];
                            switch (u) {
                                case m.KHR_LIGHTS_PUNCTUAL:
                                    a[u] = new f(s);
                                    break;
                                case m.KHR_MATERIALS_UNLIT:
                                    a[u] = new y;
                                    break;
                                case m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                    a[u] = new I;
                                    break;
                                case m.KHR_DRACO_MESH_COMPRESSION:
                                    a[u] = new x(s, this.dracoLoader);
                                    break;
                                case m.MSFT_TEXTURE_DDS:
                                    a[m.MSFT_TEXTURE_DDS] = new d(this.ddsLoader);
                                    break;
                                case m.KHR_TEXTURE_TRANSFORM:
                                    a[m.KHR_TEXTURE_TRANSFORM] = new C;
                                    break;
                                default:
                                    0 <= h.indexOf(u) && console.warn('fm.GLTFLoader: Unknown extension "' + u + '".')
                            }
                        }
                    var c = new j(s, a, {
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        manager: this.manager
                    });
                    c.parse(n, r)
                }
            }
        };
        var m = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            MSFT_TEXTURE_DDS: "MSFT_texture_dds"
        };

        function d(e) {
            if (!e) throw new Error("fm.GLTFLoader: Attempting to load .dds texture without importing fm.DDSLoader");
            this.name = m.MSFT_TEXTURE_DDS, this.ddsLoader = e
        }

        function f(e) {
            this.name = m.KHR_LIGHTS_PUNCTUAL;
            var t = e.extensions && e.extensions[m.KHR_LIGHTS_PUNCTUAL] || {};
            this.lightDefs = t.lights || []
        }

        function y() {
            this.name = m.KHR_MATERIALS_UNLIT
        }
        f.prototype.loadLight = function (e) {
            var t, n = this.lightDefs[e],
                r = new fm.Color(16777215);
            void 0 !== n.color && r.fromArray(n.color);
            var i = void 0 !== n.range ? n.range : 0;
            switch (n.type) {
                case "directional":
                    t = new fm.DirectionalLight(r), t.target.position.set(0, 0, -1), t.add(t.target);
                    break;
                case "point":
                    t = new fm.PointLight(r), t.distance = i;
                    break;
                case "spot":
                    t = new fm.SpotLight(r), t.distance = i, n.spot = n.spot || {}, n.spot.innerConeAngle = void 0 !== n.spot.innerConeAngle ? n.spot.innerConeAngle : 0, n.spot.outerConeAngle = void 0 !== n.spot.outerConeAngle ? n.spot.outerConeAngle : Math.PI / 4, t.angle = n.spot.outerConeAngle, t.penumbra = 1 - n.spot.innerConeAngle / n.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target);
                    break;
                default:
                    throw new Error('fm.GLTFLoader: Unexpected light type, "' + n.type + '".')
            }
            return t.position.set(0, 0, 0), t.decay = 2, void 0 !== n.intensity && (t.intensity = n.intensity), t.name = n.name || "light_" + e, v.default.resolve(t)
        }, y.prototype.getMaterialType = function () {
            return fm.MeshBasicMaterial
        }, y.prototype.extendParams = function (e, t, n) {
            var r = [];
            e.color = new fm.Color(1, 1, 1), e.opacity = 1;
            var i = t.pbrMetallicRoughness;
            if (i) {
                if ((0, g.default)(i.baseColorFactor)) {
                    var a = i.baseColorFactor;
                    e.color.fromArray(a), e.opacity = a[3]
                }
                void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture))
            }
            return v.default.all(r)
        };
        var _ = "glTF",
            h = 12,
            c = {
                JSON: 1313821514,
                BIN: 5130562
            };

        function A(e) {
            this.name = m.KHR_BINARY_GLTF, this.content = null, this.body = null;
            var t = new DataView(e, 0, h);
            if (this.header = {
                    magic: fm.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== _) throw new Error("fm.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("fm.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.");
            for (var n = new DataView(e, h), r = 0; r < n.byteLength;) {
                var i = n.getUint32(r, !0);
                r += 4;
                var a = n.getUint32(r, !0);
                if (r += 4, a === c.JSON) {
                    var o = new Uint8Array(e, h + r, i);
                    this.content = fm.LoaderUtils.decodeText(o)
                } else if (a === c.BIN) {
                    var s = h + r;
                    this.body = e.slice(s, s + i)
                }
                r += i
            }
            if (null === this.content) throw new Error("fm.GLTFLoader: JSON content not found.")
        }

        function x(e, t) {
            if (!t) throw new Error("fm.GLTFLoader: No DRACOLoader instance provided.");
            this.name = m.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t
        }

        function C() {
            this.name = m.KHR_TEXTURE_TRANSFORM
        }

        function I() {
            return {
                name: m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                getMaterialType: function () {
                    return fm.ShaderMaterial
                },
                extendParams: function (e, t, n) {
                    var r = t.extensions[this.name],
                        i = fm.ShaderLib.standard,
                        a = fm.UniformsUtils.clone(i.uniforms),
                        o = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                        s = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                        l = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                        u = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                        h = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"),
                        c = i.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", o).replace("#include <metalnessmap_pars_fragment>", s).replace("#include <roughnessmap_fragment>", l).replace("#include <metalnessmap_fragment>", u).replace("#include <lights_physical_fragment>", h);
                    delete a.roughness, delete a.metalness, delete a.roughnessMap, delete a.metalnessMap, a.specular = {
                        value: (new fm.Color).setHex(1118481)
                    }, a.glossiness = {
                        value: .5
                    }, a.specularMap = {
                        value: null
                    }, a.glossinessMap = {
                        value: null
                    }, e.vertexShader = i.vertexShader, e.fragmentShader = c, e.uniforms = a, e.defines = {
                        STANDARD: ""
                    }, e.color = new fm.Color(1, 1, 1), e.opacity = 1;
                    var d = [];
                    if ((0, g.default)(r.diffuseFactor)) {
                        var f = r.diffuseFactor;
                        e.color.fromArray(f), e.opacity = f[3]
                    }
                    if (void 0 !== r.diffuseTexture && d.push(n.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new fm.Color(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new fm.Color(1, 1, 1), (0, g.default)(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                        var p = r.specularGlossinessTexture;
                        d.push(n.assignTexture(e, "glossinessMap", p)), d.push(n.assignTexture(e, "specularMap", p))
                    }
                    return v.default.all(d)
                },
                createMaterial: function (e) {
                    var t = new fm.ShaderMaterial({
                        defines: e.defines,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader,
                        uniforms: e.uniforms,
                        fog: !0,
                        lights: !0,
                        opacity: e.opacity,
                        transparent: e.transparent
                    });
                    return t.isGLTFSpecularGlossinessMaterial = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t.extensions.derivatives = !0, t
                },
                cloneMaterial: function (e) {
                    var t = e.clone();
                    t.isGLTFSpecularGlossinessMaterial = !0;
                    for (var n = this.specularGlossinessParams, r = 0, i = n.length; r < i; r++) {
                        var a = e[n[r]];
                        t[n[r]] = a && a.isColor ? a.clone() : a
                    }
                    return t
                },
                refreshUniforms: function (e, t, n, r, i) {
                    if (!0 === i.isGLTFSpecularGlossinessMaterial) {
                        var a, o = i.uniforms,
                            s = i.defines;
                        o.opacity.value = i.opacity, o.diffuse.value.copy(i.color), o.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), o.map.value = i.map, o.specularMap.value = i.specularMap, o.alphaMap.value = i.alphaMap, o.lightMap.value = i.lightMap, o.lightMapIntensity.value = i.lightMapIntensity, o.aoMap.value = i.aoMap, o.aoMapIntensity.value = i.aoMapIntensity, i.map ? a = i.map : i.specularMap ? a = i.specularMap : i.displacementMap ? a = i.displacementMap : i.normalMap ? a = i.normalMap : i.bumpMap ? a = i.bumpMap : i.glossinessMap ? a = i.glossinessMap : i.alphaMap ? a = i.alphaMap : i.emissiveMap && (a = i.emissiveMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), o.uvTransform.value.copy(a.matrix)), i.envMap && (o.envMap.value = i.envMap, o.envMapIntensity.value = i.envMapIntensity, o.flipEnvMap.value = i.envMap.isCubeTexture ? -1 : 1, o.reflectivity.value = i.reflectivity, o.refractionRatio.value = i.refractionRatio, o.maxMipLevel.value = e.properties.get(i.envMap).__maxMipLevel), o.specular.value.copy(i.specular), o.glossiness.value = i.glossiness, o.glossinessMap.value = i.glossinessMap, o.emissiveMap.value = i.emissiveMap, o.bumpMap.value = i.bumpMap, o.normalMap.value = i.normalMap, o.displacementMap.value = i.displacementMap, o.displacementScale.value = i.displacementScale, o.displacementBias.value = i.displacementBias, null !== o.glossinessMap.value && void 0 === s.USE_GLOSSINESSMAP && (s.USE_GLOSSINESSMAP = "", s.USE_ROUGHNESSMAP = ""), null === o.glossinessMap.value && void 0 !== s.USE_GLOSSINESSMAP && (delete s.USE_GLOSSINESSMAP, delete s.USE_ROUGHNESSMAP)
                    }
                }
            }
        }

        function S(e, t, n, r) {
            fm.Interpolant.call(this, e, t, n, r)
        }
        x.prototype.decodePrimitive = function (e, t) {
            var n = this.json,
                r = this.dracoLoader,
                i = e.extensions[this.name].bufferView,
                a = e.extensions[this.name].attributes,
                o = {},
                s = {},
                l = {};
            for (var u in a) {
                var h = N[u] || u.toLowerCase();
                o[h] = a[u]
            }
            for (u in e.attributes)
                if (h = N[u] || u.toLowerCase(), void 0 !== a[u]) {
                    var c = n.accessors[e.attributes[u]],
                        d = b[c.componentType];
                    l[h] = d, s[h] = !0 === c.normalized
                } return t.getDependency("bufferView", i).then(function (e) {
                return new v.default(function (i) {
                    r.decodeDracoFile(e, function (e) {
                        for (var t in e.attributes) {
                            var n = e.attributes[t],
                                r = s[t];
                            void 0 !== r && (n.normalized = r)
                        }
                        i(e)
                    }, o, l)
                })
            })
        }, C.prototype.extendTexture = function (e, t) {
            return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('fm.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e
        }, S.prototype = (0, s.default)(fm.Interpolant.prototype), S.prototype.constructor = S, S.prototype.copySampleValue_ = function (e) {
            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r, a = 0; a !== r; a++) t[a] = n[i + a];
            return t
        }, S.prototype.beforeStart_ = S.prototype.copySampleValue_, S.prototype.afterEnd_ = S.prototype.copySampleValue_, S.prototype.interpolate_ = function (e, t, n, r) {
            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, u = r - t, h = (n - t) / u, c = h * h, d = c * h, f = e * l, p = f - l, g = -2 * d + 3 * c, m = d - c, v = 1 - g, y = m - c + h, _ = 0; _ !== o; _++) {
                var A = a[p + _ + o],
                    x = a[p + _ + s] * u,
                    C = a[f + _ + o],
                    I = a[f + _] * u;
                i[_] = v * A + y * x + g * C + m * I
            }
            return i
        };
        var w, M = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            b = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            E = {
                9728: fm.NearestFilter,
                9729: fm.LinearFilter,
                9984: fm.NearestMipmapNearestFilter,
                9985: fm.LinearMipmapNearestFilter,
                9986: fm.NearestMipmapLinearFilter,
                9987: fm.LinearMipmapLinearFilter
            },
            T = {
                33071: fm.ClampToEdgeWrapping,
                33648: fm.MirroredRepeatWrapping,
                10497: fm.RepeatWrapping
            },
            L = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            N = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv2",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            R = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            k = {
                CUBICSPLINE: void 0,
                LINEAR: fm.InterpolateLinear,
                STEP: fm.InterpolateDiscrete
            },
            P = {
                OPAQUE: "OPAQUE",
                MASK: "MASK",
                BLEND: "BLEND"
            },
            D = {
                "image/png": fm.RGBAFormat,
                "image/jpeg": fm.RGBFormat
            };

        function O(e, t) {
            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
        }

        function F() {
            return w = w || new fm.MeshStandardMaterial({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: fm.FrontSide
            }), w
        }

        function B(e, t, n) {
            for (var r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
        }

        function G(e, t) {
            void 0 !== t.extras && ("object" === (0, o.default)(t.extras) ? (0, a.default)(e.userData, t.extras) : console.warn("fm.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }

        function U(f, p, e) {
            for (var g = !1, m = !1, t = 0, n = p.length; t < n; t++) {
                var r = p[t];
                if (void 0 !== r.POSITION && (g = !0), void 0 !== r.NORMAL && (m = !0), g && m) break
            }
            if (!g && !m) return v.default.resolve(f);
            var i = [],
                a = [];
            for (t = 0, n = p.length; t < n; t++) {
                if (r = p[t], g) {
                    var o = void 0 !== r.POSITION ? e.getDependency("accessor", r.POSITION) : f.attributes.position;
                    i.push(o)
                }
                m && (o = void 0 !== r.NORMAL ? e.getDependency("accessor", r.NORMAL) : f.attributes.normal, a.push(o))
            }
            return v.default.all([v.default.all(i), v.default.all(a)]).then(function (e) {
                for (var t = e[0], n = e[1], r = 0, i = t.length; r < i; r++) f.attributes.position !== t[r] && (t[r] = W(t[r]));
                for (r = 0, i = n.length; r < i; r++) f.attributes.normal !== n[r] && (n[r] = W(n[r]));
                for (r = 0, i = p.length; r < i; r++) {
                    var a = p[r],
                        o = "morphTarget" + r;
                    if (g && void 0 !== a.POSITION) {
                        var s = t[r];
                        s.name = o;
                        for (var l = f.attributes.position, u = 0, h = s.count; u < h; u++) s.setXYZ(u, s.getX(u) + l.getX(u), s.getY(u) + l.getY(u), s.getZ(u) + l.getZ(u))
                    }
                    if (m && void 0 !== a.NORMAL) {
                        var c = n[r];
                        c.name = o;
                        var d = f.attributes.normal;
                        for (u = 0, h = c.count; u < h; u++) c.setXYZ(u, c.getX(u) + d.getX(u), c.getY(u) + d.getY(u), c.getZ(u) + d.getZ(u))
                    }
                }
                return g && (f.morphAttributes.position = t), m && (f.morphAttributes.normal = n), f
            })
        }

        function z(e, t) {
            if (e.updateMorphTargets(), void 0 !== t.weights)
                for (var n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && (0, g.default)(t.extras.targetNames)) {
                var i = t.extras.targetNames;
                if (e.morphTargetInfluences.length === i.length)
                    for (e.morphTargetDictionary = {}, n = 0, r = i.length; n < r; n++) e.morphTargetDictionary[i[n]] = n;
                else console.warn("fm.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function V(e) {
            var t, n = e.extensions && e.extensions[m.KHR_DRACO_MESH_COMPRESSION];
            return t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + H(n.attributes) : e.indices + ":" + H(e.attributes) + ":" + e.mode, t
        }

        function H(e) {
            for (var t = "", n = (0, p.default)(e).sort(), r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
            return t
        }

        function W(e) {
            if (e.isInterleavedBufferAttribute) {
                for (var t = e.count, n = e.itemSize, r = e.array.slice(0, t * n), i = 0, a = 0; i < t; ++i) r[a++] = e.getX(i), 2 <= n && (r[a++] = e.getY(i)), 3 <= n && (r[a++] = e.getZ(i)), 4 <= n && (r[a++] = e.getW(i));
                return new fm.BufferAttribute(r, n, e.normalized)
            }
            return e.clone()
        }

        function j(e, t, n) {
            this.json = e || {}, this.extensions = t || {}, this.options = n || {}, this.cache = new u, this.primitiveCache = {}, this.textureLoader = new fm.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new fm.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }

        function Y(n, e, r) {
            var t = e.attributes,
                i = [];

            function a(e, t) {
                return r.getDependency("accessor", e).then(function (e) {
                    n.setAttribute(t, e)
                })
            }
            for (var o in t) {
                var s = N[o] || o.toLowerCase();
                s in n.attributes || i.push(a(t[o], s))
            }
            if (void 0 !== e.indices && !n.index) {
                var l = r.getDependency("accessor", e.indices).then(function (e) {
                    n.setIndex(e)
                });
                i.push(l)
            }
            return G(n, e), v.default.all(i).then(function () {
                return void 0 !== e.targets ? U(n, e.targets, r) : n
            })
        }

        function q(e, o, s, u) {
            var h = s.nodes[e];
            return u.getDependency("node", e).then(function (e) {
                return void 0 === h.skin ? e : u.getDependency("skin", h.skin).then(function (e) {
                    l = e;
                    for (var t = [], n = 0, r = l.joints.length; n < r; n++) t.push(u.getDependency("node", l.joints[n]));
                    return v.default.all(t)
                }).then(function (s) {
                    return e.traverse(function (e) {
                        if (e.isMesh) {
                            for (var t = [], n = [], r = 0, i = s.length; r < i; r++) {
                                var a = s[r];
                                if (a) {
                                    t.push(a);
                                    var o = new fm.Matrix4;
                                    void 0 !== l.inverseBindMatrices && o.fromArray(l.inverseBindMatrices.array, 16 * r), n.push(o)
                                } else console.warn('fm.GLTFLoader: Joint "%s" could not be found.', l.joints[r])
                            }
                            e.bind(new fm.Skeleton(t, n), e.matrixWorld)
                        }
                    }), e
                });
                var l
            }).then(function (e) {
                o.add(e);
                var t = [];
                if (h.children)
                    for (var n = h.children, r = 0, i = n.length; r < i; r++) {
                        var a = n[r];
                        t.push(q(a, e, s, u))
                    }
                return v.default.all(t)
            })
        }
        j.prototype.parse = function (n, e) {
            var r = this,
                i = this.json,
                a = this.extensions;
            this.cache.removeAll(), this.markDefs(), v.default.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function (e) {
                var t = {
                    scene: e[0][i.scene || 0],
                    scenes: e[0],
                    animations: e[1],
                    cameras: e[2],
                    asset: i.asset,
                    parser: r,
                    userData: {}
                };
                B(a, t, i), G(t, i), n(t)
            }).catch(e)
        }, j.prototype.markDefs = function () {
            for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], r = {}, i = {}, a = 0, o = t.length; a < o; a++)
                for (var s = t[a].joints, l = 0, u = s.length; l < u; l++) e[s[l]].isBone = !0;
            for (var h = 0, c = e.length; h < c; h++) {
                var d = e[h];
                void 0 !== d.mesh && (void 0 === r[d.mesh] && (r[d.mesh] = i[d.mesh] = 0), r[d.mesh]++, void 0 !== d.skin && (n[d.mesh].isSkinnedMesh = !0))
            }
            this.json.meshReferences = r, this.json.meshUses = i
        }, j.prototype.getDependency = function (e, t) {
            var n = e + ":" + t,
                r = this.cache.get(n);
            if (!r) {
                switch (e) {
                    case "scene":
                        r = this.loadScene(t);
                        break;
                    case "node":
                        r = this.loadNode(t);
                        break;
                    case "mesh":
                        r = this.loadMesh(t);
                        break;
                    case "accessor":
                        r = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        r = this.loadBufferView(t);
                        break;
                    case "buffer":
                        r = this.loadBuffer(t);
                        break;
                    case "material":
                        r = this.loadMaterial(t);
                        break;
                    case "texture":
                        r = this.loadTexture(t);
                        break;
                    case "skin":
                        r = this.loadSkin(t);
                        break;
                    case "animation":
                        r = this.loadAnimation(t);
                        break;
                    case "camera":
                        r = this.loadCamera(t);
                        break;
                    case "light":
                        r = this.extensions[m.KHR_LIGHTS_PUNCTUAL].loadLight(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(n, r)
            }
            return r
        }, j.prototype.getDependencies = function (n) {
            var e = this.cache.get(n);
            if (!e) {
                var r = this,
                    t = this.json[n + ("mesh" === n ? "es" : "s")] || [];
                e = v.default.all(t.map(function (e, t) {
                    return r.getDependency(n, t)
                })), this.cache.add(n, e)
            }
            return e
        }, j.prototype.loadBuffer = function (e) {
            var n = this.json.buffers[e],
                r = this.fileLoader;
            if (n.type && "arraybuffer" !== n.type) throw new Error("fm.GLTFLoader: " + n.type + " buffer type is not supported.");
            if (void 0 === n.uri && 0 === e) return v.default.resolve(this.extensions[m.KHR_BINARY_GLTF].body);
            var i = this.options;
            return new v.default(function (e, t) {
                r.load(O(n.uri, i.path), e, void 0, function () {
                    t(new Error('fm.GLTFLoader: Failed to load buffer "' + n.uri + '".'))
                })
            })
        }, j.prototype.loadBufferView = function (e) {
            var r = this.json.bufferViews[e];
            return this.getDependency("buffer", r.buffer).then(function (e) {
                var t = r.byteLength || 0,
                    n = r.byteOffset || 0;
                return e.slice(n, n + t)
            })
        }, j.prototype.loadAccessor = function (e) {
            var I = this,
                w = this.json,
                M = this.json.accessors[e];
            if (void 0 === M.bufferView && void 0 === M.sparse) return v.default.resolve(null);
            var t = [];
            return void 0 !== M.bufferView ? t.push(this.getDependency("bufferView", M.bufferView)) : t.push(null), void 0 !== M.sparse && (t.push(this.getDependency("bufferView", M.sparse.indices.bufferView)), t.push(this.getDependency("bufferView", M.sparse.values.bufferView))), v.default.all(t).then(function (e) {
                var t, n, r = e[0],
                    i = L[M.type],
                    a = b[M.componentType],
                    o = a.BYTES_PER_ELEMENT,
                    s = o * i,
                    l = M.byteOffset || 0,
                    u = void 0 !== M.bufferView ? w.bufferViews[M.bufferView].byteStride : void 0,
                    h = !0 === M.normalized;
                if (u && u !== s) {
                    var c = Math.floor(l / u),
                        d = "InterleavedBuffer:" + M.bufferView + ":" + M.componentType + ":" + c + ":" + M.count,
                        f = I.cache.get(d);
                    f || (t = new a(r, c * u, M.count * u / o), f = new fm.InterleavedBuffer(t, u / o), I.cache.add(d, f)), n = new fm.InterleavedBufferAttribute(f, i, l % u / o, h)
                } else t = null === r ? new a(M.count * i) : new a(r, l, M.count * i), n = new fm.BufferAttribute(t, i, h);
                if (void 0 !== M.sparse) {
                    var p = L.SCALAR,
                        g = b[M.sparse.indices.componentType],
                        m = M.sparse.indices.byteOffset || 0,
                        v = M.sparse.values.byteOffset || 0,
                        y = new g(e[1], m, M.sparse.count * p),
                        _ = new a(e[2], v, M.sparse.count * i);
                    null !== r && n.setArray(n.array.slice());
                    for (var A = 0, x = y.length; A < x; A++) {
                        var C = y[A];
                        if (n.setX(C, _[A * i]), 2 <= i && n.setY(C, _[A * i + 1]), 3 <= i && n.setZ(C, _[A * i + 2]), 4 <= i && n.setW(C, _[A * i + 3]), 5 <= i) throw new Error("fm.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return n
            })
        }, j.prototype.loadTexture = function (e) {
            var r, t = this,
                i = this.json,
                a = this.options,
                o = this.textureLoader,
                s = window.URL || window.webkitURL,
                l = i.textures[e],
                u = l.extensions || {};
            r = u[m.MSFT_TEXTURE_DDS] ? i.images[u[m.MSFT_TEXTURE_DDS].source] : i.images[l.source];
            var h = r.uri,
                c = !1;
            return void 0 !== r.bufferView && (h = t.getDependency("bufferView", r.bufferView).then(function (e) {
                c = !0;
                var t = new Blob([e], {
                    type: r.mimeType
                });
                return h = s.createObjectURL(t), h
            })), v.default.resolve(h).then(function (n) {
                var e = new fm.LoadingManager,
                    r = e.getHandler(n);
                return r = r || (u[m.MSFT_TEXTURE_DDS] ? t.extensions[m.MSFT_TEXTURE_DDS].ddsLoader : o), new v.default(function (e, t) {
                    r.load(O(n, a.path), e, void 0, t)
                })
            }).then(function (e) {
                !0 === c && s.revokeObjectURL(h), e.flipY = !1, void 0 !== l.name && (e.name = l.name), r.mimeType in D && (e.format = D[r.mimeType]);
                var t = i.samplers || {},
                    n = t[l.sampler] || {};
                return e.magFilter = E[n.magFilter] || fm.LinearFilter, e.minFilter = E[n.minFilter] || fm.LinearMipmapLinearFilter, e.wrapS = T[n.wrapS] || fm.RepeatWrapping, e.wrapT = T[n.wrapT] || fm.RepeatWrapping, e
            })
        }, j.prototype.assignTexture = function (n, r, i) {
            var a = this;
            return this.getDependency("texture", i.index).then(function (e) {
                if (!e.isCompressedTexture) switch (r) {
                    case "aoMap":
                    case "emissiveMap":
                    case "metalnessMap":
                    case "normalMap":
                    case "roughnessMap":
                        e.format = fm.RGBFormat
                }
                if (a.extensions[m.KHR_TEXTURE_TRANSFORM]) {
                    var t = void 0 !== i.extensions ? i.extensions[m.KHR_TEXTURE_TRANSFORM] : void 0;
                    t && (e = a.extensions[m.KHR_TEXTURE_TRANSFORM].extendTexture(e, t))
                }
                n[r] = e
            })
        }, j.prototype.assignFinalMaterial = function (e) {
            var t = e.geometry,
                n = e.material,
                r = this.extensions,
                i = void 0 !== t.attributes.tangent,
                a = void 0 !== t.attributes.color,
                o = void 0 === t.attributes.normal,
                s = !0 === e.isSkinnedMesh,
                l = 0 < (0, p.default)(t.morphAttributes).length,
                u = l && void 0 !== t.morphAttributes.normal;
            if (e.isPoints) {
                var h = "PointsMaterial:" + n.uuid,
                    c = this.cache.get(h);
                c || (c = new fm.PointsMaterial, fm.Material.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.lights = !1, this.cache.add(h, c)), n = c
            } else if (e.isLine) {
                h = "LineBasicMaterial:" + n.uuid;
                var d = this.cache.get(h);
                d || (d = new fm.LineBasicMaterial, fm.Material.prototype.copy.call(d, n), d.color.copy(n.color), d.lights = !1, this.cache.add(h, d)), n = d
            }
            if (i || a || o || s || l) {
                h = "ClonedMaterial:" + n.uuid + ":", n.isGLTFSpecularGlossinessMaterial && (h += "specular-glossiness:"), s && (h += "skinning:"), i && (h += "vertex-tangents:"), a && (h += "vertex-colors:"), o && (h += "flat-shading:"), l && (h += "morph-targets:"), u && (h += "morph-normals:");
                var f = this.cache.get(h);
                f || (f = n.isGLTFSpecularGlossinessMaterial ? r[m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(n) : n.clone(), s && (f.skinning = !0), i && (f.vertexTangents = !0), a && (f.vertexColors = fm.VertexColors), o && (f.flatShading = !0), l && (f.morphTargets = !0), u && (f.morphNormals = !0), this.cache.add(h, f)), n = f
            }
            n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.addAttribute("uv2", new fm.BufferAttribute(t.attributes.uv.array, 2)), n.isGLTFSpecularGlossinessMaterial && (e.onBeforeRender = r[m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms), e.material = n
        }, j.prototype.loadMaterial = function (e) {
            var t, n = this,
                r = this.json,
                i = this.extensions,
                a = r.materials[e],
                o = {},
                s = a.extensions || {},
                l = [];
            if (s[m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                var u = i[m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                t = u.getMaterialType(), l.push(u.extendParams(o, a, n))
            } else if (s[m.KHR_MATERIALS_UNLIT]) {
                var h = i[m.KHR_MATERIALS_UNLIT];
                t = h.getMaterialType(), l.push(h.extendParams(o, a, n))
            } else {
                t = fm.MeshStandardMaterial;
                var c = a.pbrMetallicRoughness || {};
                if (o.color = new fm.Color(1, 1, 1), o.opacity = 1, (0, g.default)(c.baseColorFactor)) {
                    var d = c.baseColorFactor;
                    o.color.fromArray(d), o.opacity = d[3]
                }
                void 0 !== c.baseColorTexture && l.push(n.assignTexture(o, "map", c.baseColorTexture)), o.metalness = void 0 !== c.metallicFactor ? c.metallicFactor : 1, o.roughness = void 0 !== c.roughnessFactor ? c.roughnessFactor : 1, void 0 !== c.metallicRoughnessTexture && (l.push(n.assignTexture(o, "metalnessMap", c.metallicRoughnessTexture)), l.push(n.assignTexture(o, "roughnessMap", c.metallicRoughnessTexture)))
            }!0 === a.doubleSided && (o.side = fm.DoubleSide);
            var f = a.alphaMode || P.OPAQUE;
            return f === P.BLEND ? o.transparent = !0 : (o.transparent = !1, f === P.MASK && (o.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)), void 0 !== a.normalTexture && t !== fm.MeshBasicMaterial && (l.push(n.assignTexture(o, "normalMap", a.normalTexture)), o.normalScale = new fm.Vector2(1, 1), void 0 !== a.normalTexture.scale && o.normalScale.set(a.normalTexture.scale, a.normalTexture.scale)), void 0 !== a.occlusionTexture && t !== fm.MeshBasicMaterial && (l.push(n.assignTexture(o, "aoMap", a.occlusionTexture)), void 0 !== a.occlusionTexture.strength && (o.aoMapIntensity = a.occlusionTexture.strength)), void 0 !== a.emissiveFactor && t !== fm.MeshBasicMaterial && (o.emissive = (new fm.Color).fromArray(a.emissiveFactor)), void 0 !== a.emissiveTexture && t !== fm.MeshBasicMaterial && l.push(n.assignTexture(o, "emissiveMap", a.emissiveTexture)), v.default.all(l).then(function () {
                var e;
                return e = t === fm.ShaderMaterial ? i[m.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new t(o), void 0 !== a.name && (e.name = a.name), e.map && (e.map.encoding = fm.sRGBEncoding), e.emissiveMap && (e.emissiveMap.encoding = fm.sRGBEncoding), e.specularMap && (e.specularMap.encoding = fm.sRGBEncoding), G(e, a), a.extensions && B(i, e, a), e
            })
        }, j.prototype.loadGeometries = function (e) {
            var n = this,
                r = this.extensions,
                t = this.primitiveCache;

            function i(t) {
                return r[m.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, n).then(function (e) {
                    return Y(e, t, n)
                })
            }
            for (var a = [], o = 0, s = e.length; o < s; o++) {
                var l, u = e[o],
                    h = V(u),
                    c = t[h];
                c ? a.push(c.promise) : (l = u.extensions && u.extensions[m.KHR_DRACO_MESH_COMPRESSION] ? i(u) : Y(new fm.BufferGeometry, u, n), t[h] = {
                    primitive: u,
                    promise: l
                }, a.push(l))
            }
            return v.default.all(a)
        }, j.prototype.loadMesh = function (h) {
            for (var c = this, e = this.json, d = e.meshes[h], f = d.primitives, t = [], n = 0, r = f.length; n < r; n++) {
                var i = void 0 === f[n].material ? F() : this.getDependency("material", f[n].material);
                t.push(i)
            }
            return v.default.all(t).then(function (u) {
                return c.loadGeometries(f).then(function (e) {
                    for (var t = [], n = 0, r = e.length; n < r; n++) {
                        var i, a = e[n],
                            o = f[n],
                            s = u[n];
                        if (o.mode === M.TRIANGLES || o.mode === M.TRIANGLE_STRIP || o.mode === M.TRIANGLE_FAN || void 0 === o.mode) i = !0 === d.isSkinnedMesh ? new fm.SkinnedMesh(a, s) : new fm.Mesh(a, s), !0 !== i.isSkinnedMesh || i.geometry.attributes.skinWeight.normalized || i.normalizeSkinWeights(), o.mode === M.TRIANGLE_STRIP ? i.drawMode = fm.TriangleStripDrawMode : o.mode === M.TRIANGLE_FAN && (i.drawMode = fm.TriangleFanDrawMode);
                        else if (o.mode === M.LINES) i = new fm.LineSegments(a, s);
                        else if (o.mode === M.LINE_STRIP) i = new fm.Line(a, s);
                        else if (o.mode === M.LINE_LOOP) i = new fm.LineLoop(a, s);
                        else {
                            if (o.mode !== M.POINTS) throw new Error("fm.GLTFLoader: Primitive mode unsupported: " + o.mode);
                            i = new fm.Points(a, s)
                        }
                        0 < (0, p.default)(i.geometry.morphAttributes).length && z(i, d), i.name = d.name || "mesh_" + h, 1 < e.length && (i.name += "_" + n), G(i, d), c.assignFinalMaterial(i), t.push(i)
                    }
                    if (1 === t.length) return t[0];
                    var l = new fm.Group;
                    for (n = 0, r = t.length; n < r; n++) l.add(t[n]);
                    return l
                })
            })
        }, j.prototype.loadCamera = function (e) {
            var t, n = this.json.cameras[e],
                r = n[n.type];
            if (r) return "perspective" === n.type ? t = new fm.PerspectiveCamera(fm.Math.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new fm.OrthographicCamera(r.xmag / -2, r.xmag / 2, r.ymag / 2, r.ymag / -2, r.znear, r.zfar)), void 0 !== n.name && (t.name = n.name), G(t, n), v.default.resolve(t);
            console.warn("fm.GLTFLoader: Missing camera parameters.")
        }, j.prototype.loadSkin = function (e) {
            var t = this.json.skins[e],
                n = {
                    joints: t.joints
                };
            return void 0 === t.inverseBindMatrices ? v.default.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) {
                return n.inverseBindMatrices = e, n
            })
        }, j.prototype.loadAnimation = function (M) {
            for (var e = this.json, b = e.animations[M], t = [], n = [], r = [], i = [], a = [], o = 0, s = b.channels.length; o < s; o++) {
                var l = b.channels[o],
                    u = b.samplers[l.sampler],
                    h = l.target,
                    c = void 0 !== h.node ? h.node : h.id,
                    d = void 0 !== b.parameters ? b.parameters[u.input] : u.input,
                    f = void 0 !== b.parameters ? b.parameters[u.output] : u.output;
                t.push(this.getDependency("node", c)), n.push(this.getDependency("accessor", d)), r.push(this.getDependency("accessor", f)), i.push(u), a.push(h)
            }
            return v.default.all([v.default.all(t), v.default.all(n), v.default.all(r), v.default.all(i), v.default.all(a)]).then(function (e) {
                for (var t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = [], s = 0, l = t.length; s < l; s++) {
                    var u = t[s],
                        h = n[s],
                        c = r[s],
                        d = i[s],
                        f = a[s];
                    if (void 0 !== u) {
                        var p;
                        switch (u.updateMatrix(), u.matrixAutoUpdate = !0, R[f.path]) {
                            case R.weights:
                                p = fm.NumberKeyframeTrack;
                                break;
                            case R.rotation:
                                p = fm.QuaternionKeyframeTrack;
                                break;
                            case R.position:
                            case R.scale:
                            default:
                                p = fm.VectorKeyframeTrack
                        }
                        var g = u.name ? u.name : u.uuid,
                            m = void 0 !== d.interpolation ? k[d.interpolation] : fm.InterpolateLinear,
                            v = [];
                        R[f.path] === R.weights ? u.traverse(function (e) {
                            !0 === e.isMesh && e.morphTargetInfluences && v.push(e.name ? e.name : e.uuid)
                        }) : v.push(g);
                        var y = c.array;
                        if (c.normalized) {
                            var _;
                            if (y.constructor === Int8Array) _ = 1 / 127;
                            else if (y.constructor === Uint8Array) _ = 1 / 255;
                            else if (y.constructor == Int16Array) _ = 1 / 32767;
                            else {
                                if (y.constructor !== Uint16Array) throw new Error("fm.GLTFLoader: Unsupported output accessor component type.");
                                _ = 1 / 65535
                            }
                            for (var A = new Float32Array(y.length), x = 0, C = y.length; x < C; x++) A[x] = y[x] * _;
                            y = A
                        }
                        for (x = 0, C = v.length; x < C; x++) {
                            var I = new p(v[x] + "." + R[f.path], h.array, y, m);
                            "CUBICSPLINE" === d.interpolation && (I.createInterpolant = function (e) {
                                return new S(this.times, this.values, this.getValueSize() / 3, e)
                            }, I.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), o.push(I)
                        }
                    }
                }
                var w = void 0 !== b.name ? b.name : "animation_" + M;
                return new fm.AnimationClip(w, void 0, o)
            })
        }, j.prototype.loadNode = function (e) {
            var t, n = this.json,
                a = this.extensions,
                r = this,
                o = n.meshReferences,
                s = n.meshUses,
                l = n.nodes[e];
            return (t = [], void 0 !== l.mesh && t.push(r.getDependency("mesh", l.mesh).then(function (e) {
                var t;
                if (1 < o[l.mesh]) {
                    var n = s[l.mesh]++;
                    t = e.clone(), t.name += "_instance_" + n, t.onBeforeRender = e.onBeforeRender;
                    for (var r = 0, i = t.children.length; r < i; r++) t.children[r].name += "_instance_" + n, t.children[r].onBeforeRender = e.children[r].onBeforeRender
                } else t = e;
                return void 0 !== l.weights && t.traverse(function (e) {
                    if (e.isMesh)
                        for (var t = 0, n = l.weights.length; t < n; t++) e.morphTargetInfluences[t] = l.weights[t]
                }), t
            })), void 0 !== l.camera && t.push(r.getDependency("camera", l.camera)), l.extensions && l.extensions[m.KHR_LIGHTS_PUNCTUAL] && void 0 !== l.extensions[m.KHR_LIGHTS_PUNCTUAL].light && t.push(r.getDependency("light", l.extensions[m.KHR_LIGHTS_PUNCTUAL].light)), v.default.all(t)).then(function (e) {
                var t;
                if (t = !0 === l.isBone ? new fm.Bone : 1 < e.length ? new fm.Group : 1 === e.length ? e[0] : new fm.Object3D, t !== e[0])
                    for (var n = 0, r = e.length; n < r; n++) t.add(e[n]);
                if (void 0 !== l.name && (t.userData.name = l.name, t.name = fm.PropertyBinding.sanitizeNodeName(l.name)), G(t, l), l.extensions && B(a, t, l), void 0 !== l.matrix) {
                    var i = new fm.Matrix4;
                    i.fromArray(l.matrix), t.applyMatrix(i)
                } else void 0 !== l.translation && t.position.fromArray(l.translation), void 0 !== l.rotation && t.quaternion.fromArray(l.rotation), void 0 !== l.scale && t.scale.fromArray(l.scale);
                return t
            })
        }, j.prototype.loadScene = function (e) {
            var t = this.json,
                n = this.extensions,
                r = this.json.scenes[e],
                i = this,
                a = new fm.Scene;
            void 0 !== r.name && (a.name = r.name), G(a, r), r.extensions && B(n, a, r);
            for (var o = r.nodes || [], s = [], l = 0, u = o.length; l < u; l++) s.push(q(o[l], a, t, i));
            return v.default.all(s).then(function () {
                return a
            })
        };
        var X = l;
        t.default = X
    }, function (e, t, n) {
        var i = n(29),
            a = n(70),
            o = n(19)("species");
        e.exports = function (e, t) {
            var n, r = i(e).constructor;
            return void 0 === r || null == (n = i(r)[o]) ? t : a(n)
        }
    }, function (e, t, n) {
        var r, i, a, o = n(36),
            s = n(406),
            l = n(169),
            u = n(116),
            h = n(14),
            c = h.process,
            d = h.setImmediate,
            f = h.clearImmediate,
            p = h.MessageChannel,
            g = h.Dispatch,
            m = 0,
            v = {},
            y = "onreadystatechange",
            _ = function () {
                var e = +this;
                if (v.hasOwnProperty(e)) {
                    var t = v[e];
                    delete v[e], t()
                }
            },
            A = function (e) {
                _.call(e.data)
            };
        d && f || (d = function (e) {
            for (var t = [], n = 1; n < arguments.length;) t.push(arguments[n++]);
            return v[++m] = function () {
                s("function" == typeof e ? e : Function(e), t)
            }, r(m), m
        }, f = function (e) {
            delete v[e]
        }, "process" == n(77)(c) ? r = function (e) {
            c.nextTick(o(_, e, 1))
        } : g && g.now ? r = function (e) {
            g.now(o(_, e, 1))
        } : p ? (i = new p, a = i.port2, i.port1.onmessage = A, r = o(a.postMessage, a, 1)) : h.addEventListener && "function" == typeof postMessage && !h.importScripts ? (r = function (e) {
            h.postMessage(e + "", "*")
        }, h.addEventListener("message", A, !1)) : r = y in u("script") ? function (e) {
            l.appendChild(u("script"))[y] = function () {
                l.removeChild(this), _.call(e)
            }
        } : function (e) {
            setTimeout(o(_, e, 1), 0)
        }), e.exports = {
            set: d,
            clear: f
        }
    }, function (e) {
        e.exports = function (e) {
            try {
                return {
                    e: !1,
                    v: e()
                }
            } catch (e) {
                return {
                    e: !0,
                    v: e
                }
            }
        }
    }, function (e, t, n) {
        var i = n(29),
            a = n(17),
            o = n(151);
        e.exports = function (e, t) {
            if (i(e), a(t) && t.constructor === e) return t;
            var n = o.f(e),
                r = n.resolve;
            return r(t), n.promise
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                VERSION: "2.7.2",
                BUILD: 22
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, [{
                    key: "addEventListener",
                    value: function (e, t) {
                        void 0 === this._listeners && (this._listeners = {});
                        var n = this._listeners;
                        void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                    }
                }, {
                    key: "hasEventListener",
                    value: function (e, t) {
                        if (void 0 === this._listeners) return !1;
                        var n = this._listeners;
                        return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                    }
                }, {
                    key: "removeEventListener",
                    value: function (e, t) {
                        if (void 0 !== this._listeners) {
                            var n = this._listeners,
                                r = n[e];
                            if (void 0 !== r) {
                                var i = r.indexOf(t); - 1 !== i && r.splice(i, 1)
                            }
                        }
                    }
                }, {
                    key: "dispatchEvent",
                    value: function (e) {
                        if (void 0 !== this._listeners) {
                            var t = this._listeners,
                                n = t[e.type];
                            if (void 0 !== n)
                                for (var r = n.slice(0), i = 0, a = r.length; i < a; i++) r[i].call(this, e)
                        }
                    }
                }]), e
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(53);
        var a = r(n(54)),
            c = r(n(12));
        n(8);
        var o = r(n(2)),
            s = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            d = r(n(7)),
            f = r(n(20)),
            p = r(n(58)),
            g = r(n(21)),
            m = function (e) {
                function r(e, t) {
                    var n;
                    return (0, o.default)(this, r), n = (0, l.default)(this, (0, u.default)(r).call(this, t.id ? t.id : fm.Math.generateUUID(), g.default.DYNMODEL)), n._url = t.url, n._loader = e.nodeManager.getDynLoader(), n._mixer = null, n._renderNode = null, n._gltf = null, n._visible = !0, n._actions = {}, n._color = t.color, n._scale = t.scale, n._rotation = t.rotation, n._moveAnimater = null, n._isMoving = !1, n._map = e, n._mapCenter = (new fm.Vector2).copy(e.center), n._meshes = [], n._fadeIn = t.fadeIn, n._fadeOut = t.fadeOut, n.init(e, t.coord, t.callback), n
                }
                return (0, h.default)(r, e), (0, s.default)(r, [{
                    key: "init",
                    value: function (s, l, u) {
                        var h = this;
                        this._loader ? (this._height = "number" == typeof l.z ? l.z : 5, this._loader.load(this._url, function (e) {
                            h._fadeIn && h.fadeIn(e.scene), h._gltf = e, h._renderNode = e.scene, h._renderNode.name = "oneModel", h._getMeshes(h._renderNode, h._meshes), h._color && h.setColor(h._color), h._scale && h.setScale(h._scale), h._rotation && h.setRotate(h._rotation), h._renderNode.scale.z *= -1, h._renderNode.mapNode = h, h._mixer = new fm.AnimationMixer(h._renderNode), s.addAnimationMixer(h._mixer);
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = (0, c.default)(e.animations); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    h._actions[o.name] = h._mixer.clipAction(o)
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                            h.setPosition(l.x, l.y, 0, h._height), h.renderNodeInited = !0, h.visible = !0, u && u(h)
                        })) : console.error("")
                    }
                }, {
                    key: "lookAt",
                    value: function (e) {
                        if (this.parent && this.parent.parent) {
                            var t = this._map.center,
                                n = this.parent.parent.height,
                                r = new fm.Vector3(e.x - t.x, n + e.z, -e.y + t.y);
                            this._renderNode.lookAt(r)
                        } else console.warn("")
                    }
                }, {
                    key: "setPosition",
                    value: function (e, t, n, r) {
                        "number" == typeof n && 0 < n && this.moveToGroup(n);
                        var i = this._mapCenter;
                        this._height = r, this._x = e, this._y = t, this._renderNode.position.set(this._x - i.x, this._height, i.y - this._y)
                    }
                }, {
                    key: "rotateTo",
                    value: function (t) {
                        var n = this,
                            e = this._renderNode.rotation.y,
                            r = t.to % 360 * fm.Math.DEG2RAD;
                        this.rotateAnimater && (this.rotateAnimater.stop(), this._map.removeAnimater(this.rotateAnimater));
                        var i = new p.default({
                            angle: e
                        }, {
                            angle: r
                        }, t.duration ? 1e3 * t.duration : 500, function () {
                            n._map.removeAnimater(i), n.rotateAnimater = null, t.callback && t.callback()
                        }, function (e) {
                            n._renderNode.rotation.y = e.angle, t.update && t.update()
                        }).start();
                        this._map.addAnimater(i), this.rotateAnimater = i
                    }
                }, {
                    key: "setRotate",
                    value: function (e) {
                        this._renderNode.rotation.y = e % 360 * fm.Math.DEG2RAD
                    }
                }, {
                    key: "setScale",
                    value: function (e) {
                        for (var t = this._renderNode.children, n = 0; n < t.length; n++) t[n].scale.x = e, t[n].scale.y = e, t[n].scale.z = e
                    }
                }, {
                    key: "setColor",
                    value: function (e) {
                        for (var t = new fm.Color(e), n = this._meshes, r = 0; r < n.length; r++) {
                            var i = n[r];
                            i.material.color.r = t.r, i.material.color.g = t.g, i.material.color.b = t.b
                        }
                    }
                }, {
                    key: "fadeIn",
                    value: function (e) {
                        e.traverse(function (e) {
                            if (e instanceof fm.Mesh) {
                                e.material.transparent = !0, e.material.opacity = 0;
                                var t = setInterval(function () {
                                    e.material.opacity < 1 ? e.material.opacity += .05 : clearInterval(t)
                                }, 200)
                            }
                        })
                    }
                }, {
                    key: "setHeight",
                    value: function (e) {
                        this.setPosition(this._x, this._y, 0, e)
                    }
                }, {
                    key: "setAngle",
                    value: function (e) {
                        this._renderNode && (this._renderNode.rotation.y = e * fm.Math.DEG2RAD)
                    }
                }, {
                    key: "startAction",
                    value: function (e, t, n) {
                        var r = 1 < arguments.length && void 0 !== t ? arguments[1] : .2,
                            i = 2 < arguments.length ? n : void 0,
                            a = this._actions[e];
                        a && (i && (a.clampWhenFinished = !0, a.loop = fm.LoopOnce), a.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(r).play())
                    }
                }, {
                    key: "stopAction",
                    value: function (e, t) {
                        var n = 1 < arguments.length && void 0 !== t ? arguments[1] : .2,
                            r = this._actions[e];
                        r && r.fadeOut(n)
                    }
                }, {
                    key: "getActionList",
                    value: function () {
                        return (0, a.default)(this._actions)
                    }
                }, {
                    key: "moveTo",
                    value: function (t) {
                        var n = this;
                        if (!this._isMoving) {
                            var e = this.findParent(f.default),
                                r = t.x,
                                i = t.y;
                            t.time || (t.time = .5);
                            var a = new p.default({
                                x: this.x,
                                y: this.y
                            }, {
                                x: r,
                                y: i
                            }, 1e3 * t.time, function () {
                                e.map.removeAnimater(a), n._moveAnimater = null, n._isMoving = !1, t.callback && t.callback()
                            }, function (e) {
                                n.setPosition(e.x, e.y, 0, n._height), t.update && t.update(e)
                            }).start();
                            this._isMoving = !0, e.map.addAnimater(a), this._moveAnimater = a
                        }
                    }
                }, {
                    key: "stopMoveTo",
                    value: function () {
                        var e = this.findParent(f.default);
                        this._moveAnimater && this._moveAnimater.stop(), e.map.removeAnimater(this._moveAnimater), this._isMoving = !1, this._moveAnimater = null
                    }
                }, {
                    key: "moveToGroup",
                    value: function (e) {
                        this.findParent(f.default);
                        var t = this.parent.parent.groupID;
                        if (t !== e)
                            if (this.parent.parent.parent.groups["" + e]) {
                                this._groupId = e;
                                var n = this.parent.parent.parent.groups["" + e].getOrCreateLayer("dynmodel");
                                this.parent.untiedMarker(this), n.addNodes(this)
                            } else console.warn(tileMessage.noGroup)
                    }
                }, {
                    key: "_getMeshes",
                    value: function (e, t) {
                        if (e instanceof fm.Mesh) e.material = e.material.clone(), t.push(e);
                        else if (e.children)
                            for (var n = 0; n < e.children.length; n++) this._getMeshes(e.children[n], t)
                    }
                }, {
                    key: "getRandomNumber",
                    value: function () {
                        for (var e = 100, t = new Array, n = 0; n < e; n++) t[n] = n + 1;
                        return t.sort(function () {
                            return .5 - Math.random()
                        }), t[Math.floor(Math.random() * e)]
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode.mapNode = null
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent && this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : (this._renderNode && this.parent.scene.remove(this._renderNode), this._renderNode.parent = this.parent.scene), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this._renderNode = e, this._renderNode.mapNode = this, this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode)
                    }
                }, {
                    key: "mapCoord",
                    get: function () {
                        if (this.parent && this.parent.parent) {
                            var e = this._map.center,
                                t = this.parent.parent.height,
                                n = this._renderNode.position;
                            return new fm.Vector3(n.x + e.x, e.y - n.z, -t + n.y)
                        }
                        console.warn("")
                    }
                }]), r
            }(d.default),
            v = m;
        t.default = v
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = function e() {
                (0, a.default)(this, e), this.enableMapPan = !0, this.enableMapRotate = !0, this.enableMapIncline = !0, this.enableMapPinch = !0, this.enableMapSingleTap = !0, this.enableMapHover = !1
            },
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(13);
        var a = r(n(2)),
            o = r(n(3)),
            l = r(n(202)),
            s = r(n(207)),
            u = r(n(208)),
            h = function () {
                function t(e) {
                    (0, a.default)(this, t), this._options = e, this._staticNaviScene = null, this._wktReader = new s.default, this._scene = null
                }
                return (0, o.default)(t, [{
                    key: "setScene",
                    value: function (e) {
                        this._scene = e
                    }
                }, {
                    key: "queryScene",
                    value: function (e, n) {
                        var t, r = this;
                        this._options.useStatic ? (t = this._options.naviServerURL + "/" + e + ".fmap", new l.default(t, function (e) {
                            var t = r._convertStatic1(e);
                            n(t.scene_data)
                        }, !0)) : (t = this._options.naviServerURL + "/" + e, new l.default(t, function (e) {
                            var t = r._convertSite1(e);
                            n(t.scene_data)
                        }, !0))
                    }
                }, {
                    key: "queryNaviData",
                    value: function (e, n, r) {
                        var i = this;
                        if (this._options.useStatic) {
                            var t = i._convertStatic2(n);
                            r(t)
                        } else {
                            var a = null,
                                o = null,
                                s = null;
                            i = this, new l.default(this._options.naviServerURL + "/group_v2/" + e + "/" + n + "/geo", function (e) {
                                if (a = e, null != a && null != o && null != s) {
                                    var t = i._convertSite2(n, a, o, s);
                                    r(t)
                                }
                            }, !0), new l.default(this._options.naviServerURL + "/group_v2/" + e + "/" + n + "/biz", function (e) {
                                if (o = e, null != a && null != o && null != s) {
                                    var t = i._convertSite2(n, a, o, s);
                                    r(t)
                                }
                            }, !0), new l.default(this._options.naviServerURL + "/group_v2/" + e + "/" + n + "/navi", function (e) {
                                if (s = e, null != a && null != o && null != s) {
                                    var t = i._convertSite2(n, a, o, s);
                                    r(t)
                                }
                            }, !0)
                        }
                    }
                }, {
                    key: "convertToGroup",
                    value: function (e, t, n, r) {
                        return this._convertToGroup(e, t, n, r)
                    }
                }, {
                    key: "convertGeo2Geometry",
                    value: function (e, t) {
                        return this._convertGeo2Geometry(e, t)
                    }
                }, {
                    key: "convertArray2Geometry",
                    value: function (e, t) {
                        return this._convertArray2Geometry(e, t)
                    }
                }, {
                    key: "_convertSite1",
                    value: function (e) {
                        var t = fmSceneDecode(e);
                        return e = {
                            scene_data: t
                        }, e
                    }
                }, {
                    key: "_convertSite2",
                    value: function (e, t, n, r) {
                        var i = fmFloorGeoDecode(t),
                            a = fmFloorBizDecode(n),
                            o = fmFloorNaviDecode(r);
                        return this._convertToGroup(e, i, a, o)
                    }
                }, {
                    key: "_convertGeo2Geometry",
                    value: function (e) {
                        var t = this._wktReader.parse(e);
                        return {
                            points: t._points,
                            holes: t._holes
                        }
                    }
                }, {
                    key: "_convertArray2Geometry",
                    value: function (e, t) {
                        var n = (new u.default).parseGeometry(e, t);
                        return {
                            points: n._points,
                            holes: n._holes
                        }
                    }
                }, {
                    key: "_tempFlipX",
                    value: function (e) {
                        if (e && "string" != typeof e)
                            for (var t in e) {
                                var n = e[t];
                                if ("vertices" == t || "vertex" == t)
                                    for (var r in n) r % 2 == 0 && (n[r] = -n[r]);
                                else "scene_data" == t ? (n.x = -n.x, n.defCenX = -n.defCenX) : this._tempFlipX(n)
                            }
                    }
                }, {
                    key: "_convertStringToArray",
                    value: function (e) {
                        if ("" == e || !e) return [];
                        var t = [],
                            n = e,
                            r = [];
                        return 0 <= n.indexOf("|") || 0 <= n.indexOf("-") || 0 <= n.indexOf(",") ? (r = n.split(/[|,-]/), t.push.apply(t, r)) : t.push(n), t
                    }
                }, {
                    key: "_convertStatic1",
                    value: function (e) {
                        return this._staticNaviScene = fmMapDecode(e, !1), e = {
                            scene_data: this._staticNaviScene.scene
                        }, e
                    }
                }, {
                    key: "_convertStatic2",
                    value: function (e) {
                        for (var t = this._staticNaviScene.floors, n = 0; n < t.length; n++) {
                            var r = t[n];
                            if (r.gid == e) return this._convertToGroup(e, r.geo[0], r.biz[0], r.navi[0])
                        }
                        return null
                    }
                }, {
                    key: "_convertToGroup",
                    value: function (e, t, n, r) {
                        for (var i = {}, a = [], o = [], s = [], l = [], u = [], h = this._scene.scene.file_ver, c = 0, d = t.extentLayer.length; c < d; c++) {
                            var f = t.extentLayer[c],
                                p = null;
                            p = 1 === h ? this._convertGeo2Geometry(f.geo) : this._convertArray2Geometry(f.idxs, f.pts), f.geoArr = p.points, f.holes = p.holes, o.push(f)
                        }
                        for (var g = 0, m = t.labelLayer.length; g < m; g++) i[t.labelLayer[g].eid] = t.labelLayer[g];
                        for (var v = 0, y = t.modelLayer.length; v < y; v++) {
                            var _ = t.modelLayer[v],
                                A = n.modelLayer[v],
                                x = {};
                            x.fid = A.fid, x.eid = _.eid, x.pass = A.pass, x.center = 1 === h ? this._convertGeo2Geometry(i[_.eid].geo).points[0] : this._convertArray2Geometry(i[_.eid].idxs, i[_.eid].pts).points[0];
                            var C = null;
                            C = 1 === h ? this._convertGeo2Geometry(_.geo) : this._convertArray2Geometry(_.idxs, _.pts), x.geoArr = C.points, x.holes = C.holes, a.push(x)
                        }
                        for (var I = 0, w = r.naviNodes.length; I < w; I++) {
                            var M = r.naviNodes[I];
                            M.geoArr = 1 === h ? this._convertGeo2Geometry(M.geo).points[0] : this._convertArray2Geometry(M.idxs, M.pts).points[0], M.linkSegArr = this._convertStringToArray(M.linkSeg), M.liftFloorArr = this._convertStringToArray(M.liftFloor), s.push(M)
                        }
                        for (var b = 0, S = r.naviSegments.length; b < S; b++) {
                            var E = r.naviSegments[b];
                            E.geoArr = 1 === h ? this._convertGeo2Geometry(E.geo).points : this._convertArray2Geometry(E.idxs, E.pts).points, E.m_Id = r.mid, l.push(E)
                        }
                        if (r.naviZones) {
                            var T = 0;
                            for (S = r.naviZones.length; T < S; T++) {
                                var L = r.naviZones[T],
                                    N = null;
                                N = 1 === h ? this._convertGeo2Geometry(L.geo) : this._convertArray2Geometry(L.idxs, L.pts), L.geoArr = N.points, L.holes = N.holes, L.m_Id = r.mid, u.push(L)
                            }
                        }
                        var R = {
                            gid: e,
                            extentLayer: o,
                            modelLayer: a,
                            naviSegments: l,
                            naviNodes: s,
                            naviZones: u
                        };
                        return R
                    }
                }]), t
            }(),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(48);
        var a = r(n(27));
        n(53), n(8);
        var N = r(n(12)),
            o = r(n(2)),
            s = r(n(3)),
            y = n(111),
            h = r(n(228)),
            c = r(n(417)),
            C = r(n(81));

        function l(e, t) {
            if (C.default.d) {
                var n = C.default.d();
                n.minFilter = fm.LinearFilter, n.generateMipmaps = !1;
                var r = .4,
                    i = new fm.Vector2(r, .12 * r / .5),
                    a = new c.default;
                a.transparent = !0, a.uniforms.scale = {
                    value: i
                };
                var o = -1 * (.5 * i.x / e - 1),
                    s = -1 * (1 - .5 * i.y);
                a.uniforms.offset = {
                    value: new fm.Vector2(o, s)
                }, a.uniforms.mmap = {
                    value: n
                }, a.needsUpdate = !0;
                var l = new h.default,
                    u = new fm.Mesh(l, a);
                u.frustumCulled = !1, C.default[t.uuid].f = u
            }
        }
        var u = function () {
                function n(e, t) {
                    (0, o.default)(this, n), this.container = e.container, this.renderer = null, this._map = t, this._clearColor = 16777215, this._clearAlpha = 1, this._viewMode = t._viewMode, this._w = this.container.clientWidth, this._h = this.container.clientHeight, this._spriteRenderHeight = 15, this._poiSpriteHeight = 15, this._logarithmicDepthBuffer = "boolean" == typeof e.logarithmicDepthBuffer && e.logarithmicDepthBuffer, this.init(), this._envMap = null, this._renderList = [], this._showCompass = !1, this._compassNode = null, this._lineMarkerScene = new fm.Scene, this._backrenderScene = new fm.Scene, this.background = new fm.Scene, this._backrenderScene.userData.type = "lastScene", this._firstRender = !1, this.particleEffect = null, this.isParticleEffect = !1, this.isSkyEffect = !1, this.SkyEffect = null, this.autoTime = !1, this._time = (new Date).getTime(), this._delTime = (new Date).getTime(), this._sweep = {}, this._sweep.startPoint = null, this._sweep.length = 0, this._sweep.min = 0, this._sweep.maxR = 10, this._sweep.minR = 0, this.reflectEffect = null, l(this._w / this._h, t)
                }
                return (0, s.default)(n, [{
                    key: "getFrustumByViewMode",
                    value: function (e) {
                        var t = "3d" === e ? this.perspectiveCamera : this.orthographicCamera;
                        return t.updateMatrixWorld(!0), (new fm.Frustum).setFromProjectionMatrix((new fm.Matrix4).multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse))
                    }
                }, {
                    key: "getScaleByPixels",
                    value: function (e, t) {
                        return t / (e / 2 * this.domElementHeight)
                    }
                }, {
                    key: "setBackground",
                    value: function (e) {
                        this.background.background = (new fm.TextureLoader).load(e)
                    }
                }, {
                    key: "setParticleEffect",
                    value: function (e) {
                        this.particleEffect = e
                    }
                }, {
                    key: "setSkyEffect",
                    value: function (e) {
                        this.skyEffect = e
                    }
                }, {
                    key: "setReflectEffect",
                    value: function (e) {
                        this.reflectEffect = e
                    }
                }, {
                    key: "resetCompass",
                    value: function () {
                        if (this.compassNode) {
                            var e = this.getAspect(),
                                t = this.getScaleByPixels(1, this._map.MapOptions.compassSize),
                                n = -this.getScaleByPixels(1, this._map.MapOptions.compassOffset[1]),
                                r = this.getScaleByPixels(1, this._map.MapOptions.compassOffset[0]) / e,
                                i = this.getCompassOffset(this._map.MapOptions.compassPosition, t, e, r, n);
                            this.compassNode.material.uniforms.scale = {
                                value: t
                            }, this.compassNode.material.uniforms.offset = {
                                value: new fm.Vector2(i.ox, i.oy)
                            }, this.compassNode.userData.coord = {
                                x: i.ox,
                                y: i.oy
                            }, this.compassNode.userData.width = .5 * t
                        }
                    }
                }, {
                    key: "getCompassOffset",
                    value: function (e, t, n, r, i) {
                        var a = 1,
                            o = 1;
                        switch (e) {
                            case 3:
                                a = -1;
                                break;
                            case 2:
                                o = -1;
                                break;
                            case 4:
                                o = -1, a = -1
                        }
                        var s = a * (.5 * t / n - 1),
                            l = o * (1 - .5 * t);
                        return {
                            ox: s + r,
                            oy: l + i
                        }
                    }
                }, {
                    key: "resetLocationsSize",
                    value: function () {
                        var e = this.renderList,
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, N.default)(e); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                if ("location" === o.userData.type) {
                                    var s = !0,
                                        l = !1,
                                        u = void 0;
                                    try {
                                        for (var h, c = (0, N.default)(o.children); !(s = (h = c.next()).done); s = !0) {
                                            var d = h.value;
                                            this.setLocationSize(d, d.mapNode.size)
                                        }
                                    } catch (e) {
                                        l = !0, u = e
                                    } finally {
                                        try {
                                            s || null == c.return || c.return()
                                        } finally {
                                            if (l) throw u
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "setLocationSize",
                    value: function (e, t) {
                        if ("3d" === this._viewMode) {
                            var n = new fm.Matrix4;
                            n.multiplyMatrices(this.perspectiveCamera.matrixWorldInverse, e.matrixWorld);
                            var r = (new fm.Vector3).applyMatrix4(n),
                                i = t / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2))) * Math.abs(r.z);
                            e.scale.set(i, i, i)
                        } else {
                            var a = t * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight;
                            e.scale.set(a, a, a)
                        }
                    }
                }, {
                    key: "setLabelSize",
                    value: function (e, t) {
                        if ("3d" === this._viewMode) {
                            var n = t / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2)));
                            isNaN(n) && (n = 1), e.scale.set(n, n, n), e.scale.multiplyScalar(e.material.userData.mspriteScale), e.scale.setX(e.scale.x / e.material.userData.scaleRatio)
                        } else {
                            var r = t * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight;
                            isNaN(r) && (r = 1), e.scale.set(r, r, r), e.scale.multiplyScalar(e.material.userData.mspriteScale), e.scale.setX(e.scale.x / e.material.userData.scaleRatio)
                        }
                    }
                }, {
                    key: "setFacilitySize",
                    value: function (e, t) {
                        var n, r = 1;
                        n = "3d" === this._viewMode ? t / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2))) : t * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight, e.material.userData.scaleRatio && (r = e.material.userData.scaleRatio), e.scale.set(n, n / r, n)
                    }
                }, {
                    key: "setImageMarkerSize",
                    value: function (e) {
                        var t, n = 1;
                        t = "3d" === this._viewMode ? e.material.userData.size / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2))) : e.material.userData.size * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight, e.material && (n = e.material.userData.scaleRatio), isNaN(n) && (n = 1), e.scale.set(t, t / n, t)
                    }
                }, {
                    key: "parseGroup",
                    value: function (e) {
                        var t = [],
                            n = e._getLayers(!1);
                        this.getShadowScene();
                        var r = this.shadowscene.children;
                        for (var i in n) {
                            var a = n[i];
                            if (!this.needshadow || "model" !== i && "extent" !== i) {
                                var o = !0,
                                    s = !1,
                                    l = void 0;
                                try {
                                    for (var u, h = (0, N.default)(a); !(o = (u = h.next()).done); o = !0) {
                                        var c = u.value;
                                        c.renderOrder = y.LayerOrder[i], c.e_id = e.eid, t.push(c)
                                    }
                                } catch (e) {
                                    s = !0, l = e
                                } finally {
                                    try {
                                        o || null == h.return || h.return()
                                    } finally {
                                        if (s) throw l
                                    }
                                }
                            } else {
                                var d = !0,
                                    f = !1,
                                    p = void 0;
                                try {
                                    for (var g, m = (0, N.default)(a[0].children); !(d = (g = m.next()).done); d = !0) {
                                        var v = g.value;
                                        v instanceof fm.Mesh && r.push(v)
                                    }
                                } catch (e) {
                                    f = !0, p = e
                                } finally {
                                    try {
                                        d || null == m.return || m.return()
                                    } finally {
                                        if (f) throw p
                                    }
                                }
                            }
                        }
                        return this.needshadow && (this.shadowscene.renderOrder = y.LayerOrder.model, t.push(this.shadowscene)), e.locationScene.renderOrder = y.LayerOrder.location, t.push(e.locationScene), e.lineScene.renderOrder = y.LayerOrder.line, t.push(e.lineScene), t
                    }
                }, {
                    key: "getShadowScene",
                    value: function () {
                        this.shadowscene = new fm.Scene;
                        var e = new fm.AmbientLight(7631988),
                            t = new fm.Object3D,
                            n = new fm.DirectionalLight(8947848, 1.2);
                        n.position.set(-1, 1, 1), n.target = t, n.castShadow = !0, n.shadow.camera = new fm.OrthographicCamera(-100, 100, 100, -100, .5, 1e3), n.shadow.mapSize.width = 720 * window.devicePixelRatio, n.shadow.mapSize.height = 610 * window.devicePixelRatio;
                        var r = new fm.DirectionalLight(3355443);
                        r.position.set(-.5, 1, -1).normalize(), r.target = t, this.shadowscene.add(n), this.shadowscene.add(e), this.shadowscene.add(r), this.shadowscene.add(t)
                    }
                }, {
                    key: "parseList",
                    value: function (e) {
                        var s = this,
                            l = [];
                        if (e) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = (0, N.default)(e); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value,
                                        u = !0,
                                        h = !1,
                                        c = void 0;
                                    try {
                                        for (var d, f = function () {
                                                for (var e = d.value, t = s.parseGroup(e), n = [], r = 0; r < t.length; r++) "model" === t[r].name ? t[r].traverse(function (e) {
                                                    "oneModel" === e.name && n.push(e)
                                                }) : "dynmodel" === t[r].name ? t[r].traverse(function (e) {
                                                    "oneModel" === e.name && n.push(e)
                                                }) : "extent" === t[r].name && t[r].traverse(function (e) {
                                                    "oneExtent" === e.name && n.push(e)
                                                });
                                                for (var i = 0; i < t.length; i++)
                                                    if ("waterMarker" === t[i].name) {
                                                        var a = !1;
                                                        if (t[i].traverse(function (e) {
                                                                if (e instanceof fm.Mesh && "water" === e.name) return a = !0
                                                            }), a)
                                                            for (var o = 0; o < n.length; o++) t[i].add(n[o])
                                                    } t.sort(function (e, t) {
                                                    return e.renderOrder - t.renderOrder
                                                }), l = l.concat(t)
                                            }, p = (0, N.default)(o); !(u = (d = p.next()).done); u = !0) f()
                                    } catch (e) {
                                        h = !0, c = e
                                    } finally {
                                        try {
                                            u || null == p.return || p.return()
                                        } finally {
                                            if (h) throw c
                                        }
                                    }
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                        return l
                    }
                }, {
                    key: "setBackRender",
                    value: function (e) {
                        this._backrenderScene.children = e
                    }
                }, {
                    key: "init",
                    value: function () {
                        this.renderer = this._map.render, this.renderer.setClearColor(this._clearColor, this._clearAlpha);
                        var e = this.container.clientWidth,
                            t = this.container.clientHeight;
                        return this.renderer.setSize(e, t), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = fm.PCFSoftShadowMap, this.renderer.autoClear = !1, this.canvas = this._map.canvas, this.container.appendChild(this.canvas), this.orthographicCamera = this._map.orthographicCamera, this.perspectiveCamera = this._map.perspectiveCamera, !0
                    }
                }, {
                    key: "getCameraByViewMode",
                    value: function (e) {
                        return "3d" === e ? this.perspectiveCamera : this.orthographicCamera
                    }
                }, {
                    key: "getCurrentCamera",
                    value: function () {
                        return this.getCameraByViewMode(this._viewMode)
                    }
                }, {
                    key: "resetSpriteSize",
                    value: function () {
                        var e = this.renderList,
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, N.default)(e); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                if ("facility" === o.userData.type) {
                                    var s = !0,
                                        l = !1,
                                        u = void 0;
                                    try {
                                        for (var h, c = (0, N.default)(o.children); !(s = (h = c.next()).done); s = !0) {
                                            var d = h.value;
                                            this.setFacilitySize(d, d.mapNode.size)
                                        }
                                    } catch (e) {
                                        l = !0, u = e
                                    } finally {
                                        try {
                                            s || null == c.return || c.return()
                                        } finally {
                                            if (l) throw u
                                        }
                                    }
                                } else if ("label" === o.userData.type) {
                                    var f = !0,
                                        p = !1,
                                        g = void 0;
                                    try {
                                        for (var m, v = (0, N.default)(o.children); !(f = (m = v.next()).done); f = !0) {
                                            var y = m.value;
                                            this.setLabelSize(y, y.mapNode.size)
                                        }
                                    } catch (e) {
                                        p = !0, g = e
                                    } finally {
                                        try {
                                            f || null == v.return || v.return()
                                        } finally {
                                            if (p) throw g
                                        }
                                    }
                                } else if ("imageMarker" === o.userData.type) {
                                    var _ = !0,
                                        A = !1,
                                        x = void 0;
                                    try {
                                        for (var C, I = (0, N.default)(o.children); !(_ = (C = I.next()).done); _ = !0) {
                                            var w = C.value;
                                            this.setImageMarkerSize(w)
                                        }
                                    } catch (e) {
                                        A = !0, x = e
                                    } finally {
                                        try {
                                            _ || null == I.return || I.return()
                                        } finally {
                                            if (A) throw x
                                        }
                                    }
                                } else if ("textMarker" === o.userData.type) {
                                    var M = !0,
                                        b = !1,
                                        S = void 0;
                                    try {
                                        for (var E, T = (0, N.default)(o.children); !(M = (E = T.next()).done); M = !0) {
                                            var L = E.value;
                                            this.setLabelSize(L, L.mapNode.size)
                                        }
                                    } catch (e) {
                                        b = !0, S = e
                                    } finally {
                                        try {
                                            M || null == T.return || T.return()
                                        } finally {
                                            if (b) throw S
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "getAspect",
                    value: function () {
                        return this._w / this._h
                    }
                }, {
                    key: "resize",
                    value: function () {
                        this.renderer.setSize(this._w, this._h), this.perspectiveCamera.aspect = this._w / this._h, this.resizeWater(this._w / this._h), this.perspectiveCamera.updateProjectionMatrix(), this.orthographicCamera.left = -this._w / 2, this.orthographicCamera.right = this._w / 2, this.orthographicCamera.top = this._h / 2, this.orthographicCamera.bottom = -this._h / 2, this.orthographicCamera.updateProjectionMatrix()
                    }
                }, {
                    key: "resizeWater",
                    value: function (e) {
                        if (C.default[this._map.uuid].f) {
                            var t = .4,
                                n = new fm.Vector2(t, .12 * t / .5);
                            C.default[this._map.uuid].f.material.uniforms.scale = {
                                value: n
                            }, isNaN(e);
                            var r = -1 * (.5 * n.x / e - 1),
                                i = -1 * (1 - .5 * n.y);
                            C.default[this._map.uuid].f.material.uniforms.offset = {
                                value: new fm.Vector2(r, i)
                            }
                        }
                    }
                }, {
                    key: "resizeLine",
                    value: function () {
                        var e = this.renderList,
                            t = !0,
                            n = !1,
                            r = void 0;
                        try {
                            for (var i, a = (0, N.default)(e); !(t = (i = a.next()).done); t = !0) {
                                var o = i.value;
                                if ("line" === o.userData.type) {
                                    var s = !0,
                                        l = !1,
                                        u = void 0;
                                    try {
                                        for (var h, c = (0, N.default)(o.children); !(s = (h = c.next()).done); s = !0) {
                                            var d = h.value;
                                            d.material.resolution.set(this.domElementWidth, this.domElementHeight)
                                        }
                                    } catch (e) {
                                        l = !0, u = e
                                    } finally {
                                        try {
                                            s || null == c.return || c.return()
                                        } finally {
                                            if (l) throw u
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            n = !0, r = e
                        } finally {
                            try {
                                t || null == a.return || a.return()
                            } finally {
                                if (n) throw r
                            }
                        }
                    }
                }, {
                    key: "update",
                    value: function () {
                        var r = this;
                        this._firstRender || (this._map.dispatchEvent({
                            type: "firstRender"
                        }), this._firstRender = !0), (5 < Math.abs(this._w - this.container.clientWidth) || 5 < Math.abs(this._h - this.container.clientHeight)) && (this._w = this.container.clientWidth, this._h = this.container.clientHeight, this.resize(), this.resetSpriteSize(), this.resetLocationsSize(), this._map.updatePopsPosition(), this.resizeLine(), this.resetCompass());
                        var e = "3d" === this._viewMode ? this.perspectiveCamera : this.orthographicCamera,
                            i = this.renderList;
                        if (i && this.renderer) {
                            for (var a = 0; a < i.length; a++) {
                                if ("waterMarker" === i[a].name && i[a].traverse(function (e) {
                                        "water" === e.name && (e.material.uniforms.time.value += 1 / 60)
                                    }), "flmMarker" === i[a].name)
                                    for (var t = 0; t < i[a].children.length; t++)
                                        if (i[a].children[t].userData.frustumUpdate && (this._map.nodeManager.checkNodeByFrustum(this._map.dataManager.getDecodeScene(this._map._currentSceneId), this._map.renderer.getFrustumByViewMode(this._map._viewMode), this._map.getVisibleGroups(), this._map.mapScaleLevel, this._map._currentSceneId), i[a].children[t].userData.frustumUpdate = !1), (new Date).getTime() - i[a].children[t].userData.time > 20 / i[a].children[t].userData.speed) {
                                            var n = i[a].children[t].userData.colors,
                                                o = n.pop(),
                                                s = n.pop(),
                                                l = n.pop();
                                            n.splice(0, 0, o), n.splice(0, 0, s), n.splice(0, 0, l), i[a].children[t].geometry.setColors(n), i[a].children[t].userData.time = (new Date).getTime()
                                        } var u = 1;
                                this._map._sweep.speed && (u = this._map._sweep.speed), this._map.MapOptions.isNeedSweep && (this._map._sweep.se2N && function () {
                                    var e = ((new Date).getTime() - r._time) / 40 * u,
                                        t = r._map._sweep.se2N.clone().multiplyScalar(e),
                                        n = void 0;
                                    r._sweep.startPoint || (r._sweep.startPoint = r._map._sweep.startPoint.clone()), r._sweep.length <= r._map._sweep.length ? (n = r._sweep.startPoint.add(t), r._sweep.length += t.length()) : (r._sweep.startPoint = r._map._sweep.startPoint.clone(), n = r._map._sweep.startPoint, r._sweep.length = 0), i[a].traverse(function (e) {
                                        "isNeedSweep" === e.name && (e.material.uniforms.moveP.value = n, e.material.uniforms.sweepW.value = r._map._sweep.width, e.material.uniforms.sweepH.value = r._map._sweep.height, e.material.uniforms.se2N.value = r._map._sweep.se2N, e.material.uniforms.se2RN.value = r._map._sweep.se2RN)
                                    })
                                }(), this._sweep.maxR < this._map._sweep.maxRadius ? (this._sweep.maxR += ((new Date).getTime() - this._time) / 40, this._sweep.minR += ((new Date).getTime() - this._time) / 40) : (this._sweep.maxR = this._map._sweep.minRadius + this._map._sweep.widthR, this._sweep.minR = this._map._sweep.minRadius), i[a].traverse(function (e) {
                                    "isNeedSweep" === e.name && (e.material.uniforms.maxR.value = r._sweep.maxR, e.material.uniforms.minR.value = r._sweep.minR)
                                }))
                            }
                            if (this.renderer.clear(), this.renderer.clearDepth(), this._envMap && this.renderer.render(this._envMap, e), null !== this.skyEffect && this.isSkyEffect && (this.skyEffect.render(e), this.autoTime)) {
                                var h = new Date,
                                    c = 864e5,
                                    d = 60 * h.getHours() * 60 * 1e3 + 60 * h.getMinutes() * 1e3 + 1e3 * h.getSeconds() + h.getMilliseconds(),
                                    f = 2 / c,
                                    p = d - 216e5;
                                this.skyEffect._inclination = f * p, this.skyEffect._setPosition(this.skyEffect._inclination)
                            }
                            if (this.lightEffects) this.effectRender(e);
                            else {
                                void 0 !== this.background.background && this.renderer.render(this.background, e);
                                var g = null;
                                try {
                                    g = this._map.nodeManager._scenes[this._map._currentSceneId].groups[this._map.focusGroupID]._layers.extent[0]._scene.rotation.y
                                } catch (e) {}
                                var m = !0,
                                    v = !1,
                                    y = void 0;
                                try {
                                    for (var _, A = (0, N.default)(i); !(m = (_ = A.next()).done); m = !0) {
                                        var x = _.value;
                                        null !== g && this.rotateLeft(g, x), this.renderer.render(x, e)
                                    }
                                } catch (e) {
                                    v = !0, y = e
                                } finally {
                                    try {
                                        m || null == A.return || A.return()
                                    } finally {
                                        if (v) throw y
                                    }
                                }
                                this.isHeatMap && this.renderer.render(this.heatMapEffect._scene, e), e.layers.set(0), this._showCompass && this._compassNode && this.renderer.render(this._compassNode, e)
                            }
                            C.default[this._map.uuid].f && this.renderer.render(C.default[this._map.uuid].f, e), null !== this.particleEffect && this.isParticleEffect && this.particleEffect.render(e), null !== this.reflectEffect && this.reflectEffect.render(), this._time = (new Date).getTime()
                        }
                    }
                }, {
                    key: "rotateLeft",
                    value: function (e, t) {
                        this._map.autoRotateBymodel && !this._map.autoRotateBymodelPause && (t.rotation.y = e, t.rotation.y -= 2 * Math.PI / 60 / 60 * this._map.autoRotateBymodelSpeed)
                    }
                }, {
                    key: "setSceneNodeLayers",
                    value: function (e, t) {
                        var n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, N.default)(e.children); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value;
                                s.mapNode && !s.mapNode.picLoading && s.layers.set(t)
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                    }
                }, {
                    key: "setClearColor",
                    value: function (e, t) {
                        "string" == typeof e && 0 <= e.indexOf("#") ? this._clearColor = (0, a.default)(e.replace("#", "0x")) : this._clearColor = e, this._clearAlpha = "number" == typeof t ? t : 1, this.renderer.setClearColor(this._clearColor, this._clearAlpha)
                    }
                }, {
                    key: "setEnvMap",
                    value: function (e) {
                        if (e && e.path && e.format) {
                            var t = e.path,
                                n = e.format,
                                r = (new fm.CubeTextureLoader).load([t + "px" + n, t + "nx" + n, t + "py" + n, t + "ny" + n, t + "pz" + n, t + "nz" + n]);
                            this._envMap || (this._envMap = new fm.Scene), this._envMap.background = r
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._envMap && (this._envMap = void 0);
                        var e = this.renderList;
                        if (e) {
                            var t = !0,
                                n = !1,
                                r = void 0;
                            try {
                                for (var i, a = (0, N.default)(e); !(t = (i = a.next()).done); t = !0) {
                                    var o = i.value;
                                    if (o) {
                                        for (var s = o.children.length - 1; - 1 < s; s--) o.remove(o.children[s]);
                                        o.children.length = 0, o = void 0
                                    }
                                }
                            } catch (e) {
                                n = !0, r = e
                            } finally {
                                try {
                                    t || null == a.return || a.return()
                                } finally {
                                    if (n) throw r
                                }
                            }
                        }
                        this._compassNode && (this._compassNode.material.dispose(), this._compassNode.geometry.dispose());
                        for (var l = this._lineMarkerScene.children.length - 1; - 1 < l; l--) this._lineMarkerScene.remove(this._lineMarkerScene.children[l]);
                        this._map = void 0, this.renderer.dispose(), this.renderer.forceContextLoss(), this.container.removeChild(this.canvas), this.canvas = void 0, this.renderer = void 0, this.container = void 0
                    }
                }, {
                    key: "renderList",
                    set: function (e) {
                        this._renderList = this.parseList(e, void 0)
                    },
                    get: function () {
                        return this._renderList
                    }
                }, {
                    key: "domElementHeight",
                    get: function () {
                        return this.container.clientHeight
                    }
                }, {
                    key: "domElementWidth",
                    get: function () {
                        return this.container.clientWidth
                    }
                }, {
                    key: "viewMode",
                    set: function (e) {
                        this._viewMode = e
                    }
                }, {
                    key: "showCompass",
                    set: function (e) {
                        this._showCompass = e
                    },
                    get: function () {
                        return this._showCompass
                    }
                }, {
                    key: "compassNode",
                    get: function () {
                        return this._compassNode
                    },
                    set: function (e) {
                        this._compassNode = e
                    }
                }, {
                    key: "lineMarkerScene",
                    get: function () {
                        return this._lineMarkerScene
                    }
                }]), n
            }(),
            d = u;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                LEFT_TOP: 1,
                LEFT_BOTTOM: 2,
                RIGHT_TOP: 3,
                RIGHT_BOTTOM: 4
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.LineGeometry = void 0, n(25);
        var a = r(n(31)),
            o = r(n(11)),
            s = n(242),
            l = function () {
                s.LineSegmentsGeometry.call(this), this.type = "LineGeometry"
            };
        t.LineGeometry = l, l.prototype = (0, o.default)((0, a.default)(s.LineSegmentsGeometry.prototype), {
            constructor: l,
            isLineGeometry: !0,
            setPositions: function (e) {
                for (var t = e.length - 3, n = new Float32Array(2 * t), r = 0; r < t; r += 3) n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
                return s.LineSegmentsGeometry.prototype.setPositions.call(this, n), this
            },
            setColors: function (e) {
                for (var t = e.length - 3, n = new Float32Array(2 * t), r = 0; r < t; r += 3) n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
                return s.LineSegmentsGeometry.prototype.setColors.call(this, n), this
            },
            fromLine: function (e) {
                var t = e.geometry;
                return t.isGeometry ? this.setPositions(t.vertices) : t.isBufferGeometry && this.setPositions(t.position.array), this
            },
            copy: function () {
                return this
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.LineSegmentsGeometry = void 0;
        var a = r(n(35));
        n(25);
        var o, s, l = r(n(31)),
            u = r(n(11)),
            h = n(82),
            c = function () {
                h.InstancedBufferGeometry.call(this), this.type = "LineSegmentsGeometry";
                var e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],
                    t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
                    n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
                this.setIndex(n), this.setAttribute("position", new h.Float32BufferAttribute(e, 3)), this.setAttribute("uv", new h.Float32BufferAttribute(t, 2))
            };
        t.LineSegmentsGeometry = c, c.prototype = (0, u.default)((0, l.default)(h.InstancedBufferGeometry.prototype), {
            constructor: c,
            isLineSegmentsGeometry: !0,
            applyMatrix: function (e) {
                var t = this.attributes.instanceStart,
                    n = this.attributes.instanceEnd;
                return void 0 !== t && (t.applyMatrix4(e), n.applyMatrix4(e), t.data.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            setPositions: function (e) {
                var t;
                e instanceof Float32Array ? t = e : (0, a.default)(e) && (t = new Float32Array(e));
                var n = new h.InstancedInterleavedBuffer(t, 6, 1);
                return this.setAttribute("instanceStart", new h.InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new h.InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
            },
            setColors: function (e) {
                var t;
                e instanceof Float32Array ? t = e : (0, a.default)(e) && (t = new Float32Array(e));
                var n = new h.InstancedInterleavedBuffer(t, 6, 1);
                return this.setAttribute("instanceColorStart", new h.InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceColorEnd", new h.InterleavedBufferAttribute(n, 3, 3)), this
            },
            fromWireframeGeometry: function (e) {
                return this.setPositions(e.attributes.position.array), this
            },
            fromEdgesGeometry: function (e) {
                return this.setPositions(e.attributes.position.array), this
            },
            fromMesh: function (e) {
                return this.fromWireframeGeometry(new h.WireframeGeometry(e.geometry)), this
            },
            fromLineSegements: function (e) {
                var t = e.geometry;
                return t.isGeometry ? this.setPositions(t.vertices) : t.isBufferGeometry && this.setPositions(t.position.array), this
            },
            computeBoundingBox: (s = new h.Box3, function () {
                null === this.boundingBox && (this.boundingBox = new h.Box3);
                var e = this.attributes.instanceStart,
                    t = this.attributes.instanceEnd;
                void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), s.setFromBufferAttribute(t), this.boundingBox.union(s))
            }),
            computeBoundingSphere: (o = new h.Vector3, function () {
                null === this.boundingSphere && (this.boundingSphere = new h.Sphere), null === this.boundingBox && this.computeBoundingBox();
                var e = this.attributes.instanceStart,
                    t = this.attributes.instanceEnd;
                if (void 0 !== e && void 0 !== t) {
                    var n = this.boundingSphere.center;
                    this.boundingBox.getCenter(n);
                    for (var r = 0, i = 0, a = e.count; i < a; i++) o.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(o)), o.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(o));
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
                }
            }),
            toJSON: function () {}
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                FULL: "full",
                DOTTED: "dotted",
                DOT_DASH: "dotDash",
                CENTER: "center",
                DASH: "dash",
                DOUBLE_DOT_DASH: "doubleDotDash",
                TRI_DOT_DASH: "triDotDash",
                NORMAL: "normal",
                ARROW: "arrow",
                RAW: "raw",
                FMARROW: "fmarrow",
                TEXTURE: "texture"
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(31)),
            o = r(n(107));
        fm.UniformsLib.line = {
            linewidth: {
                value: 1
            },
            resolution: {
                value: new fm.Vector2(1, 1)
            },
            dashScale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            gapSize: {
                value: 1
            },
            mmap: {
                value: null
            },
            offset: {
                value: new fm.Vector2(0, 0)
            },
            repeat: {
                value: new fm.Vector2(1, 1)
            },
            miny: {
                value: 0
            },
            pcolor: {
                value: new fm.Color(11447982)
            }
        }, fm.ShaderLib.line = {
            uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.fog, fm.UniformsLib.line]),
            vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute float uvyStart;\n\t\tattribute float uvyEnd;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\t\tattribute vec2 uv2;\n\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vUv2;\n\t\tvarying float uvScale;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\t\t\t\n\t\t\tfloat duvy = uvyEnd - uvyStart;\n\t\t\tfloat uvy = uvyStart + duvy * uv2.y;\n\t\t\t// vUv2 = vec2(uv2.x ,uvy);\n\t\t\tvUv2 = ( position.y < 0.5 ) ? vec2(uv2.x ,uvyStart) : vec2(uv2.x ,uvyEnd);\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tfloat scaleDir = length(dir);\n\t\t\tuvScale = 0.05/scaleDir;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
            fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform vec2 repeat;\n\t\tuniform vec2 offset;\n\t\tuniform float miny;\n\t\tuniform vec3 pcolor;\n\t\t\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\t\t\n\t\t\n\n\t\t\tuniform sampler2D mmap;\n\n\t\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying float uvScale;\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vUv2;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\t// if ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t// \tfloat a = vUv.x;\n\t\t\t// \tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t// \tfloat len2 = a * a + b * b;\n\n\t\t\t// \tif ( len2 > 1.0 ) discard;\n\n\t\t\t// }\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\n\t\t\t#ifdef USE_MMAP\n\t\t\t\n\t\t\t\tif(vUv2.y>miny){\t\t\t\t\n\t\t\t\t\tdiffuseColor = texture2D( mmap, vUv2 * repeat + offset );\n\t\t\t\t}else{\n\t\t\t\t\tdiffuseColor = vec4(pcolor,1.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t#endif\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
        }, fm.LineMaterial = function (e) {
            fm.ShaderMaterial.call(this, {
                type: "LineMaterial",
                uniforms: fm.UniformsUtils.clone(fm.ShaderLib.line.uniforms),
                vertexShader: fm.ShaderLib.line.vertexShader,
                fragmentShader: fm.ShaderLib.line.fragmentShader
            }), this.dashed = !1, (0, o.default)(this, {
                color: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.diffuse.value
                    },
                    set: function (e) {
                        this.uniforms.diffuse.value = e
                    }
                },
                linewidth: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.linewidth.value
                    },
                    set: function (e) {
                        this.uniforms.linewidth.value = e
                    }
                },
                dashScale: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.dashScale.value
                    },
                    set: function (e) {
                        this.uniforms.dashScale.value = e
                    }
                },
                dashSize: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.dashSize.value
                    },
                    set: function (e) {
                        this.uniforms.dashSize.value = e
                    }
                },
                gapSize: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.gapSize.value
                    },
                    set: function (e) {
                        this.uniforms.gapSize.value = e
                    }
                },
                resolution: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.resolution.value
                    },
                    set: function (e) {
                        this.uniforms.resolution.value.copy(e)
                    }
                }
            }), this.setValues(e)
        }, fm.LineMaterial.prototype = (0, a.default)(fm.ShaderMaterial.prototype), fm.LineMaterial.prototype.constructor = fm.LineMaterial, fm.LineMaterial.prototype.isLineMaterial = !0, fm.LineMaterial.prototype.copy = function (e) {
            return fm.ShaderMaterial.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.resolution = e.resolution, this
        };
        var s = fm.LineMaterial;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(25);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(246)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e.type = "LineGeometry", e.isLineGeometry = !0, e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "setPositions",
                    value: function (e) {
                        for (var t = e.length - 3, n = new Float32Array(2 * t), r = 0; r < t; r += 3) n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
                        return this.test = "ddd", (new h.default).setPositions.call(this, n), this
                    }
                }, {
                    key: "setColors",
                    value: function (e) {
                        for (var t = e.length - 3, n = new Float32Array(2 * t), r = 0; r < t; r += 3) n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
                        return (new h.default).setColors.call(this, n), this
                    }
                }, {
                    key: "fromLine",
                    value: function (e) {
                        var t = e.geometry;
                        return t.isGeometry ? this.setPositions(t.vertices) : t.isBufferGeometry && this.setPositions(t.position.array), this
                    }
                }, {
                    key: "copy",
                    value: function () {
                        return this
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var o = r(n(35));
        n(25);
        var s = r(n(2)),
            l = r(n(3)),
            u = r(n(4)),
            h = r(n(5)),
            c = r(n(6)),
            a = function (e) {
                function a() {
                    var e;
                    (0, s.default)(this, a), e = (0, u.default)(this, (0, h.default)(a).call(this)), e.type = "LineSegmentsGeometry", new fm.BufferGeometry;
                    var t = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],
                        n = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
                        r = [0, 0, 1, 0, 0, 1 / 3, 1, 1 / 3, 0, 2 / 3, 1, 2 / 3, 0, 1, 1, 1],
                        i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
                    return e.isLineSegmentsGeometry = !0, e.setIndex(i), e.setAttribute("position", new fm.Float32BufferAttribute(t, 3)), e.setAttribute("uv", new fm.Float32BufferAttribute(n, 2)), e.setAttribute("uv2", new fm.Float32BufferAttribute(r, 2)), e
                }
                return (0, c.default)(a, e), (0, l.default)(a, [{
                    key: "applyMatrix",
                    value: function (e) {
                        var t = this.attributes.instanceStart,
                            n = this.attributes.instanceEnd;
                        return void 0 !== t && (e.applyToBufferAttribute(t), e.applyToBufferAttribute(n), t.data.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                }, {
                    key: "setPositions",
                    value: function (e) {
                        var t;
                        e instanceof Float32Array ? t = e : (0, o.default)(e) && (t = new Float32Array(e));
                        var n = new fm.InstancedInterleavedBuffer(t, 6, 1);
                        return this.setAttribute("instanceStart", new fm.InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new fm.InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
                    }
                }, {
                    key: "setColors",
                    value: function (e) {
                        var t;
                        e instanceof Float32Array ? t = e : (0, o.default)(e) && (t = new Float32Array(e));
                        var n = new fm.InstancedInterleavedBuffer(t, 6, 1);
                        return this.addAttribute("instanceColorStart", new fm.InterleavedBufferAttribute(n, 3, 0)), this.addAttribute("instanceColorEnd", new fm.InterleavedBufferAttribute(n, 3, 3)), this
                    }
                }, {
                    key: "setUvys",
                    value: function (e) {
                        var t;
                        e instanceof Float32Array ? t = e : (0, o.default)(e) && (t = new Float32Array(e));
                        var n = new fm.InstancedInterleavedBuffer(t, 2, 1);
                        return this.setAttribute("uvyStart", new fm.InterleavedBufferAttribute(n, 1, 0)), this.setAttribute("uvyEnd", new fm.InterleavedBufferAttribute(n, 1, 1)), this
                    }
                }, {
                    key: "fromWireframeGeometry",
                    value: function (e) {
                        return this.setPositions(e.attributes.position.array), this
                    }
                }, {
                    key: "fromEdgesGeometry",
                    value: function (e) {
                        return this.setPositions(e.attributes.position.array), this
                    }
                }, {
                    key: "fromMesh",
                    value: function (e) {
                        return this.fromWireframeGeometry(new fm.WireframeGeometry(e.geometry)), this
                    }
                }, {
                    key: "fromLineSegements",
                    value: function (e) {
                        var t = e.geometry;
                        return t.isGeometry ? this.setPositions(t.vertices) : t.isBufferGeometry && this.setPositions(t.position.array), this
                    }
                }, {
                    key: "computeBoundingBox",
                    value: function () {
                        var e = new fm.Box3;
                        null === this.boundingBox && (this.boundingBox = new fm.Box3);
                        var t = this.attributes.instanceStart,
                            n = this.attributes.instanceEnd;
                        void 0 !== t && void 0 !== n && (this.boundingBox.setFromBufferAttribute(t), e.setFromBufferAttribute(n), this.boundingBox.union(e))
                    }
                }, {
                    key: "computeBoundingSphere",
                    value: function () {
                        var e = new fm.Vector3;
                        null === this.boundingSphere && (this.boundingSphere = new fm.Sphere), null === this.boundingBox && this.computeBoundingBox();
                        var t = this.attributes.instanceStart,
                            n = this.attributes.instanceEnd;
                        if (void 0 !== t && void 0 !== n) {
                            var r = this.boundingSphere.center;
                            this.boundingBox.getCenter(r);
                            for (var i = 0, a = 0, o = t.count; a < o; a++) e.fromBufferAttribute(t, a), i = Math.max(i, r.distanceToSquared(e)), e.fromBufferAttribute(n, a), i = Math.max(i, r.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("fm.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
                        }
                    }
                }, {
                    key: "toJSON",
                    value: function () {}
                }, {
                    key: "clone",
                    value: function () {}
                }, {
                    key: "copy",
                    value: function () {
                        return this
                    }
                }]), a
            }(fm.InstancedBufferGeometry),
            d = a;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var h = r(n(41)),
            a = r(n(2)),
            o = r(n(3)),
            l = r(n(223)),
            u = r(n(49)),
            s = function () {
                function t(e) {
                    (0, a.default)(this, t), this._points = e || null, this._groupId = 0, this._lineDis = [], this._linePoints = null, this._screenPoints = [], this._screenDis = [], this._radiusPoint = [], this._radiuInit = !1, this._uvys = null, this._minRadius = 1, this.needSmooth = !0
                }
                return (0, o.default)(t, [{
                    key: "initSegement",
                    value: function (e, t) {
                        "number" != typeof t && (t = this._minRadius), this._linePoints = this.pointsToLinePnts(e, t), this._uvys = this.computerUVY()
                    }
                }, {
                    key: "pointsToRadius",
                    value: function (e) {
                        for (var t = [], n = new l.default, r = 0; r < this._points.length; r++)
                            if (0 < r && r < this._points.length - 1) {
                                var i = u.default.distanceOfTwoPoints(t[t.length - 1], this._points[r]),
                                    a = u.default.distanceOfTwoPoints(this._points[r], this._points[r + 1]),
                                    o = .5 * (a < i ? a : i),
                                    s = e;
                                o < s && (s = o), t.push.apply(t, (0, h.default)(n.computerArcLineByPoints(t[t.length - 1], this._points[r], this._points[r + 1], s || 1, 12)))
                            } else t.push(this._points[r]);
                        this._radiusPoint = t, this._radiuInit = !0
                    }
                }, {
                    key: "pointsToLinePnts",
                    value: function (e, t) {
                        if (this.needSmooth) this._radiuInit || this.pointsToRadius(t);
                        else {
                            var n = [];
                            n.push.apply(n, (0, h.default)(this._points)), this._radiusPoint = n
                        }
                        for (var r = [], i = 0; i < this._radiusPoint.length; i++) {
                            var a = this._radiusPoint[i].x - e.x,
                                o = this._radiusPoint[i].z,
                                s = -this._radiusPoint[i].y + e.y;
                            if (r.push(a, o, s), 0 !== i) {
                                var l = new fm.Vector3(this._radiusPoint[i].x, this._radiusPoint[i].y, this._radiusPoint[i].z),
                                    u = new fm.Vector3(this._radiusPoint[i - 1].x, this._radiusPoint[i - 1].y, this._radiusPoint[i - 1].z);
                                this._lineDis.push(l.distanceTo(u))
                            }
                        }
                        return r
                    }
                }, {
                    key: "getIndexDis",
                    value: function (e) {
                        for (var t = 0, n = 0; n < this._lineDis.length; n++) n < e && (t += this._lineDis[n]);
                        return t
                    }
                }, {
                    key: "computerUVY",
                    value: function () {
                        for (var e = [], t = this.getIndexDis(this._lineDis.length), n = 0; n < this._radiusPoint.length; n++)
                            if (0 === n) e.push(0);
                            else if (n === this._radiusPoint.length - 1) e.push(1);
                        else {
                            var r = this.getIndexDis(n) / t;
                            e.push(r), e.push(r)
                        }
                        return e
                    }
                }, {
                    key: "computeScreenCoord",
                    value: function (e, t, n, r) {
                        for (var i = [], a = 0, o = [], s = e.matrixWorldInverse, l = 0; l < this._linePoints.length; l += 3) {
                            var u = this._linePoints[l],
                                h = this._linePoints[l + 1],
                                c = this._linePoints[l + 2],
                                d = new fm.Vector3(u + r.x, h + r.y, c + r.z),
                                f = d.applyMatrix4(s);
                            f.z, e.near;
                            var p = f.applyMatrix4(e.projectionMatrix),
                                g = new fm.Vector2(t / 2 + t / 2 * p.x, n / 2 - n / 2 * p.y);
                            if (i.push(g), 2 < l) {
                                var m = g.distanceTo(i[Math.round(l / 3) - 1]);
                                a += m, o.push(m)
                            }
                        }
                        return this._screenPoints = i, this._screenDis = o, a
                    }
                }, {
                    key: "_calcMinRadius",
                    value: function () {
                        if (this.points) {
                            this._minRadius = 1;
                            for (var e = 0; e < this._points.length - 1; e++) {
                                var t = this._points[e],
                                    n = this._points[e + 1],
                                    r = .368 * u.default.distanceOfTwoPoints(t, n);
                                this._minRadius > r && (this._minRadius = r)
                            }
                        }
                    }
                }, {
                    key: "points",
                    get: function () {
                        return this._points
                    },
                    set: function (e) {
                        this._points = e
                    }
                }, {
                    key: "groupId",
                    get: function () {
                        return this._groupId
                    },
                    set: function (e) {
                        this._groupId = e
                    }
                }, {
                    key: "allLength",
                    get: function () {
                        return this.getIndexDis(this._lineDis.length)
                    }
                }, {
                    key: "linePoints",
                    get: function () {
                        return this._linePoints
                    }
                }, {
                    key: "uvys",
                    get: function () {
                        return this._uvys
                    }
                }]), t
            }(),
            c = s;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(56);
        var a = r(n(433)),
            y = a.default;

        function o(e, t) {
            t = t || 1;
            for (var n = Number.MAX_VALUE, r = Number.MAX_VALUE, i = Number.MIN_VALUE, a = Number.MIN_VALUE, o = 0; o < e[0].length; o++) {
                var s = e[0][o];
                s[0] < n && (n = s[0]), s[1] < r && (r = s[1]), s[0] > i && (i = s[0]), s[1] > a && (a = s[1])
            }
            var l = i - n,
                u = a - r,
                h = Math.min(l, u),
                c = h / 2;
            if (0 === h) return [n, r];
            for (var d = new y(void 0, _), f = n; f < i; f += h)
                for (var p = r; p < a; p += h) d.push(new A(f + c, p + c, c, e));
            var g = x(e),
                m = new A(n + l / 2, r + u / 2, 0, e);
            for (m.d > g.d && (g = m), d.length; 0 < d.length;) {
                var v = d.pop();
                v.d > g.d && (g = v), v.max - g.d <= t || (c = v.h / 2, d.push(new A(v.x - c, v.y - c, c, e)), d.push(new A(v.x + c, v.y - c, c, e)), d.push(new A(v.x - c, v.y + c, c, e)), d.push(new A(v.x + c, v.y + c, c, e)))
            }
            return [g.x, g.y]
        }

        function _(e, t) {
            return t.max - e.max
        }

        function A(e, t, n, r) {
            this.x = e, this.y = t, this.h = n, this.d = s(e, t, r), this.max = this.d + this.h * Math.SQRT2
        }

        function s(e, t, n) {
            for (var r = !1, i = Infinity, a = 0; a < n.length; a++)
                for (var o = n[a], s = 0, l = o.length, u = l - 1; s < l; u = s++) {
                    var h = o[s],
                        c = o[u];
                    h[1] > t != c[1] > t && e < (c[0] - h[0]) * (t - h[1]) / (c[1] - h[1]) + h[0] && (r = !r), i = Math.min(i, d(e, t, h, c))
                }
            return (r ? 1 : -1) * Math.sqrt(i)
        }

        function x(e) {
            for (var t = 0, n = 0, r = 0, i = e[0], a = 0, o = i.length, s = o - 1; a < o; s = a++) {
                var l = i[a],
                    u = i[s],
                    h = l[0] * u[1] - u[0] * l[1];
                n += (l[0] + u[0]) * h, r += (l[1] + u[1]) * h, t += 3 * h
            }
            return 0 === t ? new A(i[0][0], i[0][1], 0, e) : new A(n / t, r / t, 0, e)
        }

        function d(e, t, n, r) {
            var i = n[0],
                a = n[1],
                o = r[0] - i,
                s = r[1] - a,
                l = i,
                u = a;
            if (0 !== o || 0 !== s) {
                var h = ((e - i) * o + (t - a) * s) / (o * o + s * s);
                1 < h ? (l = r[0], u = r[1]) : 0 < h && (l += o * h, u += s * h)
            }
            return o = e - l, s = t - u, o * o + s * s
        }
        var l = o;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, e, t)), n._renderNode = null, n._isInit = !1, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "init",
                    value: function () {}
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "isInit",
                    get: function () {
                        return this._isInit
                    }
                }]), r
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11)),
            o = r(n(2)),
            s = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(49)),
            d = r(n(248)),
            f = r(n(249)),
            p = r(n(437)),
            g = r(n(115)),
            m = function (e) {
                function i(e, t, n) {
                    var r;
                    return (0, o.default)(this, i), r = (0, l.default)(this, (0, u.default)(i).call(this, e, t)), r._alpha = void 0 !== n.alpha ? n.alpha : 1, r._color = void 0 !== n.color ? n.color : "#FF0000", r._height = void 0 !== n.height ? n.height : 1, r._lineColor = n.lineColor || n.color || "#FF0000", r._points = [], r.position = {
                        x: 0,
                        y: 0
                    }, r._points.type ? (r._points = void 0 !== n.points ? (0, a.default)(n.points) : [], "rectangle" === r._points.type && r._points.startPoint && r._points.startPoint.x && r._points.startPoint.y ? (r.position.x = r._points.startPoint.x + r._points.width / 2, r.position.y = r._points.startPoint.y - r._points.height / 2) : (r.position.x = r._points.center.x, r.position.y = r._points.center.y)) : r._points.constructor === Array && (void 0 !== n.points && (0, a.default)(r._points, n.points), g.default.closedPoints(r._points), p.default.polygonArea(r._points) < 0 && r._points.reverse()), r._edgesLine = null, r
                }
                return (0, h.default)(i, e), (0, s.default)(i, [{
                    key: "contain",
                    value: function (e) {
                        if (!this._points) return !1;
                        if (!this.parent) return !1;
                        if (!this.parent.parent) return !1;
                        if ("circle" === this._points.type) {
                            var t = Math.sqrt((e.x - this.position.x) * (e.x - this.position.x) + (e.y - this.position.y) * (e.y - this.position.y));
                            if (t < this._points.r) return !0
                        } else {
                            if ("rectangle" !== this._points.type) return c.default.pointInPolygon2d(this._points, e, this._points.length);
                            if (Math.abs(e.x - this.position.x) < this._points.width / 2 && Math.abs(e.y - this.position.y) < this._points.height / 2) return !0
                        }
                        return !1
                    }
                }, {
                    key: "setColor",
                    value: function (e) {
                        this._renderNode.material.color = new fm.Color(e), this._color = e
                    }
                }, {
                    key: "setAlpha",
                    value: function (e) {
                        this._renderNode.material.opacity = e, this._alpha = e
                    }
                }, {
                    key: "setLineColor",
                    value: function (e) {
                        this._edgesLine.material.color = new fm.Color(e)
                    }
                }, {
                    key: "center",
                    get: function () {
                        for (var e = this.parent.parent, t = (e.parent.mapcenter, []), n = 0; n < this._linePoints.length; n += 3) t.push([this._linePoints[n], this._linePoints[n + 1]]);
                        var r = null;
                        return r = (0, d.default)([t], .01), "circle" != this._points.type && "rectangle" != this._points.type ? {
                            x: this.position.x + r[0],
                            y: this.position.y - r[1],
                            z: this._height
                        } : {
                            x: this.position.x + r[0],
                            y: this.position.y + r[1],
                            z: this._height
                        }
                    }
                }]), i
            }(f.default),
            v = m;
        t.default = v
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = function e() {
                (0, a.default)(this, e), this.circle, this.polygon, this.eName, this.FID, this.groupID, this.ID, this.keyword, this.name, this.typeID, this.nodeType, this.startPoint, this.pathPoints, this.bufferRadius
            },
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var U = r(n(16));
        n(13), n(108), n(67);
        var z = r(n(35)),
            V = r(n(27));
        n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function t(e) {
                    (0, a.default)(this, t), this._data = e, this.Graphics = new fengmap.inner.Graphics
                }
                return (0, o.default)(t, [{
                    key: "check2",
                    value: function (e, t, n, r, i, a, o) {
                        var s, l, u = "",
                            h = "",
                            c = "";
                        n.name && (u = n.name), n.eName && (h = n.eName), n.keyword && (c = n.keyword), n.circle && (s = n.circle), n.polygon && (l = 2 < n.polygon.length ? new SearchPolygon(n.polygon, !0) : null);
                        var d, f, p = e.name,
                            g = e.ename,
                            m = e.type;
                        d = void 0 === n.typeID || !(!n.typeID || !m) && (f = "number" == typeof n.typeID ? [n.typeID] : n.typeID, -1 < f.indexOf((0, V.default)(m)));
                        var v, y, _ = !1;
                        if (g && h && -1 < g.toLowerCase().indexOf(h.toLowerCase()) && (_ = !0), g && c && -1 < g.toLowerCase().indexOf(c.toLowerCase()) && (_ = !0), p && c && -1 < p.toLowerCase().indexOf(c.toLowerCase()) && (_ = !0), p && u && -1 < p.toLowerCase().indexOf(u.toLowerCase()) && (_ = !0), c || h || u || (_ = !0), void 0 !== n.FID)
                            if (e.fid && n.FID) {
                                var A = n.FID;
                                A = (0, z.default)(A) ? A.map(function (e) {
                                    return e.toString()
                                }) : [A.toString()], v = -1 < A.indexOf(e.fid.toString())
                            } else v = !1;
                        else v = !0;
                        if (void 0 !== n.ID)
                            if (e.eid && n.ID) {
                                var x = n.ID;
                                (0, z.default)(x) ? fids = fids.map(function (e) {
                                    return e.toString()
                                }): x = [x.toString()], y = -1 < x.indexOf(e.eid.toString())
                            } else y = !1;
                        else y = !0;
                        var C = _ && d && v && y;
                        if (C) {
                            if (s) {
                                var I = t.geo;
                                "model" === r && i && (I = i);
                                var w = I.substring(6, I.length - 1).split(" "),
                                    M = (0, U.default)(w[0]),
                                    b = (0, U.default)(w[1]),
                                    S = s.center,
                                    E = Math.sqrt((M - S.x) * (M - S.x) + (b - S.y) * (b - S.y));
                                if (E < s.radius) return o && (o.distance = E), !0;
                                if ("model" == r) {
                                    var T = 0,
                                        L = null,
                                        N = this._map.getFMGroup(a).getNodeByLayerId("model", e.eid);
                                    o.target = N, N && N._data && (L = N._data.vertices), null == L && (L = DataManager.convertGeo2Geometry(t.geo).vertices);
                                    for (var R = L.length / 2, k = 0; k < R - 1; k++) {
                                        var P = 2 * k;
                                        if (T = Graphics.pointDistanceToLine(S, {
                                                x: L[P],
                                                y: L[P + 1]
                                            }, {
                                                x: L[P + 2],
                                                y: L[P + 3]
                                            }, {}), T < s.radius) return o && (o.distance = E), !0
                                    }
                                    if (Graphics.pointInPolygonVector2d(L, S, L.length)) return o.distance = E, !0
                                }
                                return !1
                            }
                            if (!l) return !0;
                            var D = t.geo;
                            "model" === r && i && (D = i);
                            var O = D.substring(6, D.length - 1).split(" "),
                                F = {
                                    x: (0, U.default)(O[0]),
                                    y: (0, U.default)(O[1])
                                };
                            if (l.contain(F)) return o.distance = l.distanceToPoint(F), !0;
                            if ("model" == r) {
                                var B = null,
                                    G = this._map.getFMGroup(a).getNodeByLayerId("model", e.eid);
                                if (o.target = G, G && G._data && (B = G._data.vertices), null == B && (B = DataManager.convertGeo2Geometry(t.geo).vertices), l.containXYArray(B)) return o.distance = l.distanceToPoint(F), !0
                            }
                        }
                        return !1
                    }
                }, {
                    key: "check",
                    value: function (e, t, n, r, i, a) {
                        if (void 0 !== n.FID && n.FID !== e.fid) return !1;
                        if (void 0 !== n.groupID && "" + n.groupID != "" + a) return !1;
                        if (void 0 !== n.ID && n.ID !== e.eid) return !1;
                        if (void 0 !== n.name && n.name !== e.name) return !1;
                        if (void 0 !== n.eName && n.eName !== e.ename) return !1;
                        if (void 0 !== n.typeID && n.typeID !== e.type) return !1;
                        if (void 0 !== n.keyword)
                            if (e.name && e.ename) {
                                if (e.name.toLowerCase().indexOf(n.keyword.toLowerCase()) < 0 && e.ename && e.ename.toLowerCase().indexOf(n.keyword.toLowerCase()) < 0) return !1
                            } else if (e.name && !e.ename) {
                            if (e.name.toLowerCase().indexOf(n.keyword.toLowerCase()) < 0) return !1
                        } else if (!e.name && e.ename) {
                            if (e.ename.toLowerCase().indexOf(n.keyword.toLowerCase()) < 0) return !1
                        } else if (!e.name && !e.ename) return !1;
                        return !0
                    }
                }, {
                    key: "everyModel",
                    value: function (e, t) {
                        for (var n = e.biz[0].modelLayer.length, r = 0; r < n; r++) t(e.biz[0].modelLayer[r], e.geo[0].modelLayer[r], "model", e.geo[0].labelLayer[r])
                    }
                }, {
                    key: "everyExternalModel",
                    value: function (e, t) {
                        var n = e.biz[0].externalModelLayer.length,
                            r = e.geo[0].externalModelLayer.length;
                        e.geo[0].labelLayer.length, r < n && (n = r);
                        for (var i = 0; i < n; i++) e.gid, t(e.biz[0].externalModelLayer[i], e.geo[0].externalModelLayer[i], "externalModel", e.geo[0].externalModelLayer[i])
                    }
                }, {
                    key: "everyFacility",
                    value: function (e, t) {
                        for (var n = e.biz[0].poiLayer.length, r = 0; r < n; r++) t(e.biz[0].poiLayer[r], e.geo[0].poiLayer[r], "poi")
                    }
                }, {
                    key: "everyLabel",
                    value: function (e, t) {
                        for (var n = e.biz[0].labelLayer.length, r = 0; r < n; r++) t(e.biz[0].labelLayer[r], e.geo[0].labelLayer[r], "label")
                    }
                }]), t
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = function e(t) {
                (0, a.default)(this, e), this._data = t
            },
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(253)),
            h = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, o.default)(this, (0, s.default)(r).call(this, e)), n._map = t, n.Graphics = fengmap.inner.Graphics, n
                }
                return (0, l.default)(r, e), r
            }(u.default),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(258), n(363), n(365), n(366);
        var a = r(n(200)),
            o = r(n(114)),
            s = r(n(210)),
            l = r(n(240)),
            u = (r(n(420)), r(n(21))),
            h = (r(n(152)), r(n(423))),
            c = r(n(217)),
            d = r(n(213)),
            f = r(n(215)),
            p = r(n(424)),
            g = (r(n(425)), r(n(226)), r(n(428))),
            m = r(n(243)),
            v = r(n(155)),
            y = r(n(247)),
            _ = r(n(432)),
            A = r(n(434)),
            x = r(n(438)),
            C = r(n(218)),
            I = r(n(219)),
            w = r(n(227)),
            M = r(n(236)),
            b = r(n(225)),
            S = r(n(222)),
            E = r(n(221)),
            T = r(n(224)),
            L = r(n(440)),
            N = r(n(441)),
            R = r(n(442)),
            k = r(n(251)),
            P = r(n(452)),
            D = r(n(453)),
            O = r(n(454)),
            F = r(n(455)),
            B = r(n(80)),
            G = r(n(203)),
            U = r(n(456)),
            z = r(n(457)),
            V = r(n(214)),
            H = r(n(212)),
            W = r(n(216)),
            j = r(n(211)),
            Y = r(n(209)),
            q = r(n(7)),
            X = r(n(458)),
            Z = r(n(237)),
            J = r(n(459)),
            K = r(n(234)),
            Q = r(n(153)),
            $ = r(n(239)),
            ee = r(n(49)),
            te = r(n(235)),
            ne = r(n(42)),
            re = r(n(57)),
            ie = r(n(155)),
            ae = r(n(460)),
            oe = r(n(238)),
            se = r(n(461)),
            le = n(111),
            ue = r(n(462));
        n(463);
        var he = {
            VERSION: K.default.VERSION,
            BUILD: K.default.BUILD,
            Map: a.default,
            FMMap: a.default,
            MapUtil: o.default,
            controlPositon: l.default,
            FMControlPosition: l.default,
            FMViewMode: F.default,
            FMDynamicModel: M.default,
            FMDynamicModelLayer: b.default,
            FMLanguageType: B.default,
            FMNodeType: u.default,
            FMImageMarker: h.default,
            FMTextMarker: p.default,
            FMLocationMarker: g.default,
            FMLineMarker: v.default,
            FMExtentLayer: s.default,
            FMSegment: y.default,
            FMPolygonMarker: _.default,
            FMGradientPolygonMarker: A.default,
            FMExtrudeMarker: x.default,
            FMPolygonMarkerLayer: C.default,
            FMGradientPolygonMarkerLayer: I.default,
            FMExtrudeMarkerLayer: w.default,
            FMImageMarkerLayer: c.default,
            FMLabelLayer: d.default,
            FMFacilityLayer: f.default,
            FMHeatMapLayer: S.default,
            FMHeatMap: N.default,
            FMSearchRequest: k.default,
            FMSearchAnalyser: R.default,
            FMLineType: m.default,
            FMNaviModule: P.default,
            FMNaviMode: P.default,
            FMTextAlign: D.default,
            FMNaviPriority: O.default,
            FMRouteCalcuResult: U.default,
            FMMapCoord: z.default,
            FMGroup: Y.default,
            FMLabel: V.default,
            FMStoreModel: H.default,
            FMElement: j.default,
            FMExternalModel: j.default,
            FMFacility: W.default,
            FMNode: q.default,
            FMDirection: G.default,
            FMScreenCoord: X.default,
            FMMapGestureEnableController: Z.default,
            FMTextMarkerLayer: E.default,
            FMDomMarkerLayer: T.default,
            FMDomMarker: L.default,
            FMMapCoordTransformer: J.default,
            MapCoordTransform: J.default,
            FMMarkerAnchor: Q.default,
            FMLayerOrder: le.LayerOrder,
            FMRenderer: $.default,
            FMCalculator: ue.default,
            inner: {
                Graphics: ee.default,
                FMSegment: y.default,
                FMNaviMode: P.default,
                FMNaviPriority: O.default,
                FMRouteCalcuResult: U.default,
                EventDispatcher: te.default,
                DataManager: ne.default,
                FMUtil: re.default,
                FMImageMarker: h.default,
                FMLineMarker: ie.default,
                FMLocationMarker: g.default,
                FMLanguageType: B.default,
                NaviDataType: ae.default,
                NaviService: oe.default,
                FMMapCoord: z.default,
                BoundingBox: se.default
            }
        };
        window.fm = fm, window.fengmap = he;
        var ce = he;
        t.default = ce
    }, function (e, t, n) {
        n(257);
        var r = n(9).Object;
        e.exports = function (e, t, n) {
            return r.defineProperty(e, t, n)
        }
    }, function (e, t, n) {
        var r = n(10);
        r(r.S + r.F * !n(26), "Object", {
            defineProperty: n(28).f
        })
    }, function (t, e, n) {
        (function (e) {
            t.exports = e.fm = n(82)
        }).call(this, n(157))
    }, function (e, t, n) {
        var r = n(22);
        r(r.S, "Math", {
            log2: function (e) {
                return Math.log(e) / Math.LN2
            }
        })
    }, function (e, t, n) {
        e.exports = n(118)("native-function-to-string", Function.toString)
    }, function (e, t, n) {
        var r = n(24),
            a = n(160),
            i = n(33).f,
            o = n(88).f,
            s = n(164),
            l = n(90),
            u = r.RegExp,
            h = u,
            c = u.prototype,
            d = /a/g,
            f = /a/g,
            p = new u(d) !== d;
        if (n(23) && (!p || n(18)(function () {
                return f[n(15)("match")] = !1, u(d) != d || u(f) == f || "/a/i" != u(d, "i")
            }))) {
            u = function (e, t) {
                var n = this instanceof u,
                    r = s(e),
                    i = void 0 === t;
                return !n && r && e.constructor === u && i ? e : a(p ? new h(r && !i ? e.source : e, t) : h((r = e instanceof u) ? e.source : e, r && i ? l.call(e) : t), n ? this : c, u)
            };
            for (var g = function (t) {
                    t in u || i(u, t, {
                        configurable: !0,
                        get: function () {
                            return h[t]
                        },
                        set: function (e) {
                            h[t] = e
                        }
                    })
                }, m = o(h), v = 0; m.length > v;) g(m[v++]);
            c.constructor = u, u.prototype = c, n(38)(r, "RegExp", u)
        }
        n(165)("RegExp")
    }, function (e, t, i) {
        var n = i(37),
            r = i(30),
            a = function (e, t) {
                if (r(e), !n(t) && null !== t) throw TypeError(t + ": can't set as prototype!")
            };
        e.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function (e, n, r) {
                try {
                    r = i(86)(Function.call, i(120).f(Object.prototype, "__proto__").set, 2), r(e, []), n = !(e instanceof Array)
                } catch (e) {
                    n = !0
                }
                return function (e, t) {
                    return a(e, t), n ? e.__proto__ = t : r(e, t), e
                }
            }({}, !1) : void 0),
            check: a
        }
    }, function (e, t, n) {
        n(59), n(268), e.exports = n(9).Array.from
    }, function (e, t, n) {
        var l = n(124),
            u = n(91);
        e.exports = function (s) {
            return function (e, t) {
                var n, r, i = String(u(e)),
                    a = l(t),
                    o = i.length;
                return a < 0 || o <= a ? s ? "" : void 0 : (n = i.charCodeAt(a), n < 55296 || 56319 < n || a + 1 === o || (r = i.charCodeAt(a + 1)) < 56320 || 57343 < r ? s ? i.charAt(a) : n : s ? i.slice(a, a + 2) : r - 56320 + (n - 55296 << 10) + 65536)
            }
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(92),
            i = n(71),
            a = n(78),
            o = {};
        n(43)(o, n(19)("iterator"), function () {
            return this
        }), e.exports = function (e, t, n) {
            e.prototype = r(o, {
                next: i(1, n)
            }), a(e, t + " Iterator")
        }
    }, function (e, t, n) {
        var l = n(61),
            u = n(93),
            h = n(267);
        e.exports = function (s) {
            return function (e, t, n) {
                var r, i = l(e),
                    a = u(i.length),
                    o = h(n, a);
                if (s && t != t) {
                    for (; o < a;)
                        if (r = i[o++], r != r) return !0
                } else
                    for (; o < a; o++)
                        if ((s || o in i) && i[o] === t) return s || o || 0;
                return !s && -1
            }
        }
    }, function (e, t, n) {
        var r = n(124),
            i = Math.max,
            a = Math.min;
        e.exports = function (e, t) {
            return e = r(e), e < 0 ? i(e + t, 0) : a(e, t)
        }
    }, function (e, t, n) {
        "use strict";
        var p = n(36),
            r = n(10),
            g = n(52),
            m = n(171),
            v = n(172),
            y = n(93),
            _ = n(269),
            A = n(131);
        r(r.S + r.F * !n(173)(function (e) {
            Array.from(e)
        }), "Array", {
            from: function (e, t, n) {
                var r, i, a, o, s = g(e),
                    l = "function" == typeof this ? this : Array,
                    u = arguments.length,
                    h = 1 < u ? t : void 0,
                    c = void 0 !== h,
                    d = 0,
                    f = A(s);
                if (c && (h = p(h, 2 < u ? n : void 0, 2)), null == f || l == Array && v(f))
                    for (r = y(s.length), i = new l(r); d < r; d++) _(i, d, c ? h(s[d], d) : s[d]);
                else
                    for (o = f.call(s), i = new l; !(a = o.next()).done; d++) _(i, d, c ? m(o, h, [a.value, d], !0) : a.value);
                return i.length = d, i
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(28),
            i = n(71);
        e.exports = function (e, t, n) {
            t in e ? r.f(e, t, i(0, n)) : e[t] = n
        }
    }, function (e) {
        e.exports = Object.is || function (e, t) {
            return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(132);
        n(22)({
            target: "RegExp",
            proto: !0,
            forced: r !== /./.exec
        }, {
            exec: r
        })
    }, function (e) {
        e.exports = function (e, t) {
            return {
                value: t,
                done: !!e
            }
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(133),
            i = n(84),
            a = n(135),
            o = {};
        n(32)(o, n(15)("iterator"), function () {
            return this
        }), e.exports = function (e, t, n) {
            e.prototype = r(o, {
                next: i(1, n)
            }), a(e, t + " Iterator")
        }
    }, function (e, t, n) {
        var o = n(33),
            s = n(30),
            l = n(134);
        e.exports = n(23) ? Object.defineProperties : function (e, t) {
            s(e);
            for (var n, r = l(t), i = r.length, a = 0; a < i;) o.f(e, n = r[a++], t[n]);
            return e
        }
    }, function (e, t, n) {
        var r = n(24).document;
        e.exports = r && r.documentElement
    }, function (e, t, n) {
        e.exports = n(277)
    }, function (e, t, n) {
        n(278), e.exports = n(9).Object.freeze
    }, function (e, t, n) {
        var r = n(17),
            i = n(64).onFreeze;
        n(136)("freeze", function (t) {
            return function (e) {
                return t && r(e) ? t(i(e)) : e
            }
        })
    }, function (e, t, n) {
        e.exports = n(280)
    }, function (e, t, n) {
        n(59), n(65), e.exports = n(137).f("iterator")
    }, function (e, t, n) {
        "use strict";
        var r = n(282),
            i = n(178),
            a = n(60),
            o = n(61);
        e.exports = n(125)(Array, "Array", function (e, t) {
            this._t = o(e), this._i = 0, this._k = t
        }, function () {
            var e = this._t,
                t = this._k,
                n = this._i++;
            return !e || n >= e.length ? (this._t = void 0, i(1)) : i(0, "keys" == t ? n : "values" == t ? e[n] : [n, e[n]])
        }, "values"), a.Arguments = a.Array, r("keys"), r("values"), r("entries")
    }, function (e) {
        e.exports = function () {}
    }, function (e, t, n) {
        e.exports = n(284)
    }, function (e, t, n) {
        n(285), n(101), n(288), n(289), e.exports = n(9).Symbol
    }, function (e, t, n) {
        "use strict";
        var r = n(14),
            o = n(45),
            i = n(26),
            a = n(10),
            s = n(126),
            l = n(64).KEY,
            u = n(44),
            h = n(129),
            c = n(78),
            d = n(94),
            f = n(19),
            p = n(137),
            g = n(138),
            m = n(286),
            v = n(140),
            y = n(29),
            _ = n(17),
            A = n(52),
            x = n(61),
            C = n(117),
            I = n(71),
            w = n(92),
            M = n(287),
            b = n(180),
            S = n(139),
            E = n(28),
            T = n(76),
            L = b.f,
            N = E.f,
            R = M.f,
            k = r.Symbol,
            P = r.JSON,
            D = P && P.stringify,
            O = "prototype",
            F = f("_hidden"),
            B = f("toPrimitive"),
            G = {}.propertyIsEnumerable,
            U = h("symbol-registry"),
            z = h("symbols"),
            V = h("op-symbols"),
            H = Object[O],
            W = "function" == typeof k && !!S.f,
            j = r.QObject,
            Y = !j || !j[O] || !j[O].findChild,
            q = i && u(function () {
                return 7 != w(N({}, "a", {
                    get: function () {
                        return N(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
            }) ? function (e, t, n) {
                var r = L(H, t);
                r && delete H[t], N(e, t, n), r && e !== H && N(H, t, r)
            } : N,
            X = function (e) {
                var t = z[e] = w(k[O]);
                return t._k = e, t
            },
            Z = W && "symbol" == typeof k.iterator ? function (e) {
                return "symbol" == typeof e
            } : function (e) {
                return e instanceof k
            },
            J = function (e, t, n) {
                return e === H && J(V, t, n), y(e), t = C(t, !0), y(n), o(z, t) ? (n.enumerable ? (o(e, F) && e[F][t] && (e[F][t] = !1), n = w(n, {
                    enumerable: I(0, !1)
                })) : (o(e, F) || N(e, F, I(1, {})), e[F][t] = !0), q(e, t, n)) : N(e, t, n)
            },
            K = function (e, t) {
                y(e);
                for (var n, r = m(t = x(t)), i = 0, a = r.length; i < a;) J(e, n = r[i++], t[n]);
                return e
            },
            Q = function (e, t) {
                return void 0 === t ? w(e) : K(w(e), t)
            },
            $ = function (e) {
                var t = G.call(this, e = C(e, !0));
                return !(this === H && o(z, e) && !o(V, e)) && (!(t || !o(this, e) || !o(z, e) || o(this, F) && this[F][e]) || t)
            },
            ee = function (e, t) {
                if (e = x(e), t = C(t, !0), e !== H || !o(z, t) || o(V, t)) {
                    var n = L(e, t);
                    return !n || !o(z, t) || o(e, F) && e[F][t] || (n.enumerable = !0), n
                }
            },
            te = function (e) {
                for (var t, n = R(x(e)), r = [], i = 0; n.length > i;) o(z, t = n[i++]) || t == F || t == l || r.push(t);
                return r
            },
            ne = function (e) {
                for (var t, n = e === H, r = R(n ? V : x(e)), i = [], a = 0; r.length > a;) !o(z, t = r[a++]) || n && !o(H, t) || i.push(z[t]);
                return i
            };
        W || (k = function (e) {
            if (this instanceof k) throw TypeError("Symbol is not a constructor!");
            var t = d(0 < arguments.length ? e : void 0),
                n = function (e) {
                    this === H && n.call(V, e), o(this, F) && o(this[F], t) && (this[F][t] = !1), q(this, t, I(1, e))
                };
            return i && Y && q(H, t, {
                configurable: !0,
                set: n
            }), X(t)
        }, s(k[O], "toString", function () {
            return this._k
        }), b.f = ee, E.f = J, n(179).f = M.f = te, n(100).f = $, S.f = ne, i && !n(75) && s(H, "propertyIsEnumerable", $, !0), p.f = function (e) {
            return X(f(e))
        }), a(a.G + a.W + a.F * !W, {
            Symbol: k
        });
        for (var re = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ie = 0; re.length > ie;) f(re[ie++]);
        for (var ae = T(f.store), oe = 0; ae.length > oe;) g(ae[oe++]);
        a(a.S + a.F * !W, "Symbol", {
            for: function (e) {
                return o(U, e += "") ? U[e] : U[e] = k(e)
            },
            keyFor: function (e) {
                if (!Z(e)) throw TypeError(e + " is not a symbol!");
                for (var t in U)
                    if (U[t] === e) return t
            },
            useSetter: function () {
                Y = !0
            },
            useSimple: function () {
                Y = !1
            }
        }), a(a.S + a.F * !W, "Object", {
            create: Q,
            defineProperty: J,
            defineProperties: K,
            getOwnPropertyDescriptor: ee,
            getOwnPropertyNames: te,
            getOwnPropertySymbols: ne
        });
        var se = u(function () {
            S.f(1)
        });
        a(a.S + a.F * se, "Object", {
            getOwnPropertySymbols: function (e) {
                return S.f(A(e))
            }
        }), P && a(a.S + a.F * (!W || u(function () {
            var e = k();
            return "[null]" != D([e]) || "{}" != D({
                a: e
            }) || "{}" != D(Object(e))
        })), "JSON", {
            stringify: function (e) {
                for (var t, n, r = [e], i = 1; i < arguments.length;) r.push(arguments[i++]);
                if (n = t = r[1], (_(t) || void 0 !== e) && !Z(e)) return v(t) || (t = function (e, t) {
                    if ("function" == typeof n && (t = n.call(this, e, t)), !Z(t)) return t
                }), r[1] = t, D.apply(P, r)
            }
        }), k[O][B] || n(43)(k[O], B, k[O].valueOf), c(k, "Symbol"), c(Math, "Math", !0), c(r.JSON, "JSON", !0)
    }, function (e, t, n) {
        var s = n(76),
            l = n(139),
            u = n(100);
        e.exports = function (e) {
            var t = s(e),
                n = l.f;
            if (n)
                for (var r, i = n(e), a = u.f, o = 0; i.length > o;) a.call(e, r = i[o++]) && t.push(r);
            return t
        }
    }, function (e, t, n) {
        var r = n(61),
            i = n(179).f,
            a = {}.toString,
            o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
            s = function (e) {
                try {
                    return i(e)
                } catch (e) {
                    return o.slice()
                }
            };
        e.exports.f = function (e) {
            return o && "[object Window]" == a.call(e) ? s(e) : i(r(e))
        }
    }, function (e, t, n) {
        n(138)("asyncIterator")
    }, function (e, t, n) {
        n(138)("observable")
    }, function (e, t, n) {
        n(101), n(59), n(65), n(291), n(295), n(298), n(299), e.exports = n(9).Map
    }, function (e, t, n) {
        "use strict";
        var r = n(292),
            i = n(79),
            a = "Map";
        e.exports = n(183)(a, function (t) {
            return function (e) {
                return t(this, 0 < arguments.length ? e : void 0)
            }
        }, {
            get: function (e) {
                var t = r.getEntry(i(this, a), e);
                return t && t.v
            },
            set: function (e, t) {
                return r.def(i(this, a), 0 === e ? 0 : e, t)
            }
        }, r, !0)
    }, function (e, t, n) {
        "use strict";
        var o = n(28).f,
            s = n(92),
            l = n(102),
            u = n(36),
            h = n(103),
            c = n(66),
            r = n(125),
            i = n(178),
            a = n(182),
            d = n(26),
            f = n(64).fastKey,
            p = n(79),
            g = d ? "_s" : "size",
            m = function (e, t) {
                var n, r = f(t);
                if ("F" !== r) return e._i[r];
                for (n = e._f; n; n = n.n)
                    if (n.k == t) return n
            };
        e.exports = {
            getConstructor: function (e, a, n, r) {
                var i = e(function (e, t) {
                    h(e, i, a, "_i"), e._t = a, e._i = s(null), e._f = void 0, e._l = void 0, e[g] = 0, null != t && c(t, n, e[r], e)
                });
                return l(i.prototype, {
                    clear: function () {
                        for (var e = p(this, a), t = e._i, n = e._f; n; n = n.n) n.r = !0, n.p && (n.p = n.p.n = void 0), delete t[n.i];
                        e._f = e._l = void 0, e[g] = 0
                    },
                    delete: function (e) {
                        var t = p(this, a),
                            n = m(t, e);
                        if (n) {
                            var r = n.n,
                                i = n.p;
                            delete t._i[n.i], n.r = !0, i && (i.n = r), r && (r.p = i), t._f == n && (t._f = r), t._l == n && (t._l = i), t[g]--
                        }
                        return !!n
                    },
                    forEach: function (e, t) {
                        p(this, a);
                        for (var n, r = u(e, 1 < arguments.length ? t : void 0, 3); n = n ? n.n : this._f;)
                            for (r(n.v, n.k, this); n && n.r;) n = n.p
                    },
                    has: function (e) {
                        return !!m(p(this, a), e)
                    }
                }), d && o(i.prototype, "size", {
                    get: function () {
                        return p(this, a)[g]
                    }
                }), i
            },
            def: function (e, t, n) {
                var r, i, a = m(e, t);
                return a ? a.v = n : (e._l = a = {
                    i: i = f(t, !0),
                    k: t,
                    v: n,
                    p: r = e._l,
                    n: void 0,
                    r: !1
                }, e._f || (e._f = a), r && (r.n = a), e[g]++, "F" !== i && (e._i[i] = a)), e
            },
            getEntry: m,
            setStrong: function (e, n, t) {
                r(e, n, function (e, t) {
                    this._t = p(e, n), this._k = t, this._l = void 0
                }, function () {
                    for (var e = this, t = e._k, n = e._l; n && n.r;) n = n.p;
                    return e._t && (e._l = n = n ? n.n : e._t._f) ? i(0, "keys" == t ? n.k : "values" == t ? n.v : [n.k, n.v]) : (e._t = void 0, i(1))
                }, t ? "entries" : "values", !t, !0), a(n)
            }
        }
    }, function (e, t, n) {
        var r = n(294);
        e.exports = function (e, t) {
            return new(r(e))(t)
        }
    }, function (e, t, n) {
        var r = n(17),
            i = n(140),
            a = n(19)("species");
        e.exports = function (e) {
            var t;
            return i(e) && (t = e.constructor, "function" != typeof t || t !== Array && !i(t.prototype) || (t = void 0), r(t) && (t = t[a], null === t && (t = void 0))), void 0 === t ? Array : t
        }
    }, function (e, t, n) {
        var r = n(10);
        r(r.P + r.R, "Map", {
            toJSON: n(296)("Map")
        })
    }, function (e, t, n) {
        var r = n(95),
            i = n(297);
        e.exports = function (e) {
            return function () {
                if (r(this) != e) throw TypeError(e + "#toJSON isn't generic");
                return i(this)
            }
        }
    }, function (e, t, n) {
        var r = n(66);
        e.exports = function (e, t) {
            var n = [];
            return r(e, !1, n.push, n, t), n
        }
    }, function (e, t, n) {
        n(184)("Map")
    }, function (e, t, n) {
        n(185)("Map")
    }, function (e, t, n) {
        e.exports = n(301)
    }, function (e, t, n) {
        n(101), n(65), n(302), n(304), n(305), e.exports = n(9).WeakMap
    }, function (e, t, n) {
        "use strict";
        var a, r = n(14),
            i = n(141)(0),
            o = n(126),
            s = n(64),
            l = n(189),
            u = n(303),
            h = n(17),
            c = n(79),
            d = n(79),
            f = !r.ActiveXObject && "ActiveXObject" in r,
            p = "WeakMap",
            g = s.getWeak,
            m = Object.isExtensible,
            v = u.ufstore,
            y = function (t) {
                return function (e) {
                    return t(this, 0 < arguments.length ? e : void 0)
                }
            },
            _ = {
                get: function (e) {
                    if (h(e)) {
                        var t = g(e);
                        return !0 === t ? v(c(this, p)).get(e) : t ? t[this._i] : void 0
                    }
                },
                set: function (e, t) {
                    return u.def(c(this, p), e, t)
                }
            },
            A = e.exports = n(183)(p, y, _, u, !0, !0);
        d && f && (a = u.getConstructor(y, p), l(a.prototype, _), s.NEED = !0, i(["delete", "has", "get", "set"], function (r) {
            var e = A.prototype,
                i = e[r];
            o(e, r, function (e, t) {
                if (!h(e) || m(e)) return i.call(this, e, t);
                this._f || (this._f = new a);
                var n = this._f[r](e, t);
                return "set" == r ? this : n
            })
        }))
    }, function (e, t, n) {
        "use strict";
        var o = n(102),
            s = n(64).getWeak,
            i = n(29),
            l = n(17),
            u = n(103),
            h = n(66),
            r = n(141),
            c = n(45),
            d = n(79),
            a = r(5),
            f = r(6),
            p = 0,
            g = function (e) {
                return e._l || (e._l = new m)
            },
            m = function () {
                this.a = []
            },
            v = function (e, t) {
                return a(e.a, function (e) {
                    return e[0] === t
                })
            };
        m.prototype = {
            get: function (e) {
                var t = v(this, e);
                if (t) return t[1]
            },
            has: function (e) {
                return !!v(this, e)
            },
            set: function (e, t) {
                var n = v(this, e);
                n ? n[1] = t : this.a.push([e, t])
            },
            delete: function (t) {
                var e = f(this.a, function (e) {
                    return e[0] === t
                });
                return ~e && this.a.splice(e, 1), !!~e
            }
        }, e.exports = {
            getConstructor: function (e, n, r, i) {
                var a = e(function (e, t) {
                    u(e, a, n, "_i"), e._t = n, e._i = p++, e._l = void 0, null != t && h(t, r, e[i], e)
                });
                return o(a.prototype, {
                    delete: function (e) {
                        if (!l(e)) return !1;
                        var t = s(e);
                        return !0 === t ? g(d(this, n)).delete(e) : t && c(t, this._i) && delete t[this._i]
                    },
                    has: function (e) {
                        if (!l(e)) return !1;
                        var t = s(e);
                        return !0 === t ? g(d(this, n)).has(e) : t && c(t, this._i)
                    }
                }), a
            },
            def: function (e, t, n) {
                var r = s(i(t), !0);
                return !0 === r ? g(e).set(t, n) : r[e._i] = n, e
            },
            ufstore: g
        }
    }, function (e, t, n) {
        n(184)("WeakMap")
    }, function (e, t, n) {
        n(185)("WeakMap")
    }, function (e, t, n) {
        e.exports = n(307)
    }, function (e, t, n) {
        n(308), e.exports = n(9).Object.getPrototypeOf
    }, function (e, t, n) {
        var r = n(52),
            i = n(170);
        n(136)("getPrototypeOf", function () {
            return function (e) {
                return i(r(e))
            }
        })
    }, function (e, t, n) {
        n(310), e.exports = n(9).Object.setPrototypeOf
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Object", {
            setPrototypeOf: n(311).set
        })
    }, function (e, t, i) {
        var n = i(17),
            r = i(29),
            a = function (e, t) {
                if (r(e), !n(t) && null !== t) throw TypeError(t + ": can't set as prototype!")
            };
        e.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function (e, n, r) {
                try {
                    r = i(36)(Function.call, i(180).f(Object.prototype, "__proto__").set, 2), r(e, []), n = !(e instanceof Array)
                } catch (e) {
                    n = !0
                }
                return function (e, t) {
                    return a(e, t), n ? e.__proto__ = t : r(e, t), e
                }
            }({}, !1) : void 0),
            check: a
        }
    }, function (e, t, n) {
        n(313);
        var r = n(9).Object;
        e.exports = function (e, t) {
            return r.create(e, t)
        }
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Object", {
            create: n(92)
        })
    }, function (n, e, t) {
        var r = t(190);

        function i(e, t) {
            return n.exports = i = r || function (e, t) {
                return e.__proto__ = t, e
            }, i(e, t)
        }
        n.exports = i
    }, function (e, t, n) {
        "use strict";
        var r = n(18);
        e.exports = function (e, t) {
            return !!e && r(function () {
                t ? e.call(null, function () {}, 1) : e.call(null)
            })
        }
    }, function (e, t, n) {
        n(317), e.exports = n(9).Object.keys
    }, function (e, t, n) {
        var r = n(52),
            i = n(76);
        n(136)("keys", function () {
            return function (e) {
                return i(r(e))
            }
        })
    }, function (e, t, n) {
        n(40)("Float64", 8, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(24),
            i = n(23),
            a = n(85),
            o = n(191),
            s = n(32),
            l = n(192),
            u = n(18),
            h = n(193),
            c = n(46),
            d = n(34),
            f = n(194),
            p = n(88).f,
            g = n(33).f,
            m = n(143),
            v = n(135),
            y = "ArrayBuffer",
            _ = "DataView",
            A = "prototype",
            x = "Wrong length!",
            C = "Wrong index!",
            I = r[y],
            w = r[_],
            M = r.Math,
            b = r.RangeError,
            S = r.Infinity,
            E = I,
            T = M.abs,
            L = M.pow,
            N = M.floor,
            R = M.log,
            k = M.LN2,
            P = "buffer",
            D = "byteLength",
            O = "byteOffset",
            F = i ? "_b" : P,
            B = i ? "_l" : D,
            G = i ? "_o" : O;

        function U(e, t, n) {
            var r, i, a, o = new Array(n),
                s = 8 * n - t - 1,
                l = (1 << s) - 1,
                u = l >> 1,
                h = 23 === t ? L(2, -24) - L(2, -77) : 0,
                c = 0,
                d = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = T(e), e != e || e === S ? (i = e != e ? 1 : 0, r = l) : (r = N(R(e) / k), e * (a = L(2, -r)) < 1 && (r--, a *= 2), e += 1 <= r + u ? h / a : h * L(2, 1 - u), 2 <= e * a && (r++, a /= 2), l <= r + u ? (i = 0, r = l) : 1 <= r + u ? (i = (e * a - 1) * L(2, t), r += u) : (i = e * L(2, u - 1) * L(2, t), r = 0)); 8 <= t; o[c++] = 255 & i, i /= 256, t -= 8);
            for (r = r << t | i, s += t; 0 < s; o[c++] = 255 & r, r /= 256, s -= 8);
            return o[--c] |= 128 * d, o
        }

        function z(e, t, n) {
            var r, i = 8 * n - t - 1,
                a = (1 << i) - 1,
                o = a >> 1,
                s = i - 7,
                l = n - 1,
                u = e[l--],
                h = 127 & u;
            for (u >>= 7; 0 < s; h = 256 * h + e[l], l--, s -= 8);
            for (r = h & (1 << -s) - 1, h >>= -s, s += t; 0 < s; r = 256 * r + e[l], l--, s -= 8);
            if (0 === h) h = 1 - o;
            else {
                if (h === a) return r ? NaN : u ? -S : S;
                r += L(2, t), h -= o
            }
            return (u ? -1 : 1) * r * L(2, h - t)
        }

        function V(e) {
            return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
        }

        function H(e) {
            return [255 & e]
        }

        function W(e) {
            return [255 & e, e >> 8 & 255]
        }

        function j(e) {
            return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
        }

        function Y(e) {
            return U(e, 52, 8)
        }

        function q(e) {
            return U(e, 23, 4)
        }

        function X(e, t, n) {
            g(e[A], t, {
                get: function () {
                    return this[n]
                }
            })
        }

        function Z(e, t, n, r) {
            var i = +n,
                a = f(i);
            if (a + t > e[B]) throw b(C);
            var o = e[F]._b,
                s = a + e[G],
                l = o.slice(s, s + t);
            return r ? l : l.reverse()
        }

        function J(e, t, n, r, i, a) {
            var o = +n,
                s = f(o);
            if (s + t > e[B]) throw b(C);
            for (var l = e[F]._b, u = s + e[G], h = r(+i), c = 0; c < t; c++) l[u + c] = h[a ? c : t - c - 1]
        }
        if (o.ABV) {
            if (!u(function () {
                    I(1)
                }) || !u(function () {
                    new I(-1)
                }) || u(function () {
                    return new I, new I(1.5), new I(NaN), I.name != y
                })) {
                I = function (e) {
                    return h(this, I), new E(f(e))
                };
                for (var K, Q = I[A] = E[A], $ = p(E), ee = 0; $.length > ee;)(K = $[ee++]) in I || s(I, K, E[K]);
                a || (Q.constructor = I)
            }
            var te = new w(new I(2)),
                ne = w[A].setInt8;
            te.setInt8(0, 2147483648), te.setInt8(1, 2147483649), !te.getInt8(0) && te.getInt8(1) || l(w[A], {
                setInt8: function (e, t) {
                    ne.call(this, e, t << 24 >> 24)
                },
                setUint8: function (e, t) {
                    ne.call(this, e, t << 24 >> 24)
                }
            }, !0)
        } else I = function (e) {
            h(this, I, y);
            var t = f(e);
            this._b = m.call(new Array(t), 0), this[B] = t
        }, w = function (e, t, n) {
            h(this, w, _), h(e, I, _);
            var r = e[B],
                i = c(t);
            if (i < 0 || r < i) throw b("Wrong offset!");
            if (n = void 0 === n ? r - i : d(n), r < i + n) throw b(x);
            this[F] = e, this[G] = i, this[B] = n
        }, i && (X(I, D, "_l"), X(w, P, "_b"), X(w, D, "_l"), X(w, O, "_o")), l(w[A], {
            getInt8: function (e) {
                return Z(this, 1, e)[0] << 24 >> 24
            },
            getUint8: function (e) {
                return Z(this, 1, e)[0]
            },
            getInt16: function (e, t) {
                var n = Z(this, 2, e, t);
                return (n[1] << 8 | n[0]) << 16 >> 16
            },
            getUint16: function (e, t) {
                var n = Z(this, 2, e, t);
                return n[1] << 8 | n[0]
            },
            getInt32: function (e, t) {
                return V(Z(this, 4, e, t))
            },
            getUint32: function (e, t) {
                return V(Z(this, 4, e, t)) >>> 0
            },
            getFloat32: function (e, t) {
                return z(Z(this, 4, e, t), 23, 4)
            },
            getFloat64: function (e, t) {
                return z(Z(this, 8, e, t), 52, 8)
            },
            setInt8: function (e, t) {
                J(this, 1, e, H, t)
            },
            setUint8: function (e, t) {
                J(this, 1, e, H, t)
            },
            setInt16: function (e, t, n) {
                J(this, 2, e, W, t, n)
            },
            setUint16: function (e, t, n) {
                J(this, 2, e, W, t, n)
            },
            setInt32: function (e, t, n) {
                J(this, 4, e, j, t, n)
            },
            setUint32: function (e, t, n) {
                J(this, 4, e, j, t, n)
            },
            setFloat32: function (e, t, n) {
                J(this, 4, e, q, t, n)
            },
            setFloat64: function (e, t, n) {
                J(this, 8, e, Y, t, n)
            }
        });
        v(I, y), v(w, _), s(w[A], o.VIEW, !0), t[y] = I, t[_] = w
    }, function (e, t, n) {
        var r = n(63),
            i = n(15)("iterator"),
            a = Array.prototype;
        e.exports = function (e) {
            return void 0 !== e && (r.Array === e || a[i] === e)
        }
    }, function (e, t, n) {
        var r = n(97),
            i = n(15)("iterator"),
            a = n(63);
        e.exports = n(83).getIteratorMethod = function (e) {
            if (null != e) return e[i] || e["@@iterator"] || a[r(e)]
        }
    }, function (e, t, n) {
        var _ = n(86),
            A = n(121),
            x = n(39),
            C = n(34),
            r = n(323);
        e.exports = function (c, e) {
            var d = 1 == c,
                f = 2 == c,
                p = 3 == c,
                g = 4 == c,
                m = 6 == c,
                v = 5 == c || m,
                y = e || r;
            return function (e, t, n) {
                for (var r, i, a = x(e), o = A(a), s = _(t, n, 3), l = C(o.length), u = 0, h = d ? y(e, l) : f ? y(e, 0) : void 0; u < l; u++)
                    if ((v || u in o) && (r = o[u], i = s(r, u, a), c))
                        if (d) h[u] = i;
                        else if (i) switch (c) {
                    case 3:
                        return !0;
                    case 5:
                        return r;
                    case 6:
                        return u;
                    case 2:
                        h.push(r)
                } else if (g) return !1;
                return m ? -1 : p || g ? g : h
            }
        }
    }, function (e, t, n) {
        var r = n(324);
        e.exports = function (e, t) {
            return new(r(e))(t)
        }
    }, function (e, t, n) {
        var r = n(37),
            i = n(325),
            a = n(15)("species");
        e.exports = function (e) {
            var t;
            return i(e) && (t = e.constructor, "function" != typeof t || t !== Array && !i(t.prototype) || (t = void 0), r(t) && (t = t[a], null === t && (t = void 0))), void 0 === t ? Array : t
        }
    }, function (e, t, n) {
        var r = n(74);
        e.exports = Array.isArray || function (e) {
            return "Array" == r(e)
        }
    }, function (e, t, n) {
        var a = n(15)("iterator"),
            o = !1;
        try {
            var r = [7][a]();
            r.return = function () {
                o = !0
            }, Array.from(r, function () {
                throw 2
            })
        } catch (e) {}
        e.exports = function (e, t) {
            if (!t && !o) return !1;
            var n = !1;
            try {
                var r = [7],
                    i = r[a]();
                i.next = function () {
                    return {
                        done: n = !0
                    }
                }, r[a] = function () {
                    return i
                }, e(r)
            } catch (e) {}
            return n
        }
    }, function (e, t, n) {
        "use strict";
        var h = n(39),
            c = n(89),
            d = n(34);
        e.exports = [].copyWithin || function (e, t, n) {
            var r = h(this),
                i = d(r.length),
                a = c(e, i),
                o = c(t, i),
                s = 2 < arguments.length ? n : void 0,
                l = Math.min((void 0 === s ? i : c(s, i)) - o, i - a),
                u = 1;
            for (o < a && a < o + l && (u = -1, o += l - 1, a += l - 1); 0 < l--;) o in r ? r[a] = r[o] : delete r[a], a += u, o += u;
            return r
        }
    }, function (e, t, n) {
        n(40)("Int32", 4, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        })
    }, function (e, t, n) {
        n(40)("Uint8", 1, function (r) {
            return function (e, t, n) {
                return r(this, e, t, n)
            }
        }, !0)
    }, function (e, t, n) {
        n(331), e.exports = n(9).parseInt
    }, function (e, t, n) {
        var r = n(10),
            i = n(332);
        r(r.G + r.F * (parseInt != i), {
            parseInt: i
        })
    }, function (e, t, n) {
        var r = n(14).parseInt,
            i = n(198).trim,
            a = n(146),
            o = /^[-+]?0[xX]/;
        e.exports = 8 !== r(a + "08") || 22 !== r(a + "0x16") ? function (e, t) {
            var n = i(String(e), 3);
            return r(n, t >>> 0 || (o.test(n) ? 16 : 10))
        } : r
    }, function (e, t, n) {
        n(334), e.exports = n(9).parseFloat
    }, function (e, t, n) {
        var r = n(10),
            i = n(335);
        r(r.G + r.F * (parseFloat != i), {
            parseFloat: i
        })
    }, function (e, t, n) {
        var r = n(14).parseFloat,
            i = n(198).trim;
        e.exports = 1 / r(n(146) + "-0") != -Infinity ? function (e) {
            var t = i(String(e), 3),
                n = r(t);
            return 0 === n && "-" == t.charAt(0) ? -0 : n
        } : r
    }, function (e, t, n) {
        "use strict";
        var r = n(22),
            i = n(39),
            a = n(72);
        r(r.P + r.F * n(18)(function () {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                toISOString: function () {
                    return 1
                }
            })
        }), "Date", {
            toJSON: function () {
                var e = i(this),
                    t = a(e);
                return "number" != typeof t || isFinite(t) ? e.toISOString() : null
            }
        })
    }, function (e, t, n) {
        var r = n(9),
            i = r.JSON || (r.JSON = {
                stringify: JSON.stringify
            });
        e.exports = function (e) {
            return i.stringify.apply(i, arguments)
        }
    }, function (e, t, n) {
        n(339), e.exports = n(9).Array.isArray
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Array", {
            isArray: n(140)
        })
    }, function (e, t, n) {
        "use strict";
        var i = n(46),
            a = n(51);
        e.exports = function (e) {
            var t = String(a(this)),
                n = "",
                r = i(e);
            if (r < 0 || Infinity == r) throw RangeError("Count can't be negative");
            for (; 0 < r;
                (r >>>= 1) && (t += t)) 1 & r && (n += t);
            return n
        }
    }, function (e, t, n) {
        n(342);
        var r = n(9).Object;
        e.exports = function (e, t) {
            return r.defineProperties(e, t)
        }
    }, function (e, t, n) {
        var r = n(10);
        r(r.S + r.F * !n(26), "Object", {
            defineProperties: n(167)
        })
    }, function (e, t, n) {
        var r = n(22);
        r(r.S + r.F, "Object", {
            assign: n(344)
        })
    }, function (e, t, n) {
        "use strict";
        var c = n(23),
            d = n(134),
            f = n(345),
            p = n(161),
            g = n(39),
            m = n(121),
            i = Object.assign;
        e.exports = !i || n(18)(function () {
            var e = {},
                t = {},
                n = Symbol(),
                r = "abcdefghijklmnopqrst";
            return e[n] = 7, r.split("").forEach(function (e) {
                t[e] = e
            }), 7 != i({}, e)[n] || Object.keys(i({}, t)).join("") != r
        }) ? function (e) {
            for (var t = g(e), n = arguments.length, r = 1, i = f.f, a = p.f; r < n;)
                for (var o, s = m(arguments[r++]), l = i ? d(s).concat(i(s)) : d(s), u = l.length, h = 0; h < u;) o = l[h++], c && !a.call(s, o) || (t[o] = s[o]);
            return t
        } : i
    }, function (e, t) {
        t.f = Object.getOwnPropertySymbols
    }, function (e, t, n) {
        n(347), e.exports = n(9).Object.assign
    }, function (e, t, n) {
        var r = n(10);
        r(r.S + r.F, "Object", {
            assign: n(189)
        })
    }, function (e, t, n) {
        n(23) && "g" != /./g.flags && n(33).f(RegExp.prototype, "flags", {
            configurable: !0,
            get: n(90)
        })
    }, function (e, t, n) {
        var r = n(22);
        r(r.S, "Math", {
            sign: n(350)
        })
    }, function (e) {
        e.exports = Math.sign || function (e) {
            return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1
        }
    }, function (e, t, n) {
        var r = n(22);
        r(r.S, "Number", {
            isInteger: n(352)
        })
    }, function (e, t, n) {
        var r = n(37),
            i = Math.floor;
        e.exports = function (e) {
            return !r(e) && isFinite(e) && i(e) === e
        }
    }, function (e, t, n) {
        e.exports = n(354)
    }, function (e, t, n) {
        n(355), e.exports = n(9).Number.isInteger
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Number", {
            isInteger: n(356)
        })
    }, function (e, t, n) {
        var r = n(17),
            i = Math.floor;
        e.exports = function (e) {
            return !r(e) && isFinite(e) && i(e) === e
        }
    }, function (e, t, n) {
        var o = n(22),
            r = n(51),
            s = n(18),
            l = n(358),
            i = "[" + l + "]",
            u = "",
            a = RegExp("^" + i + i + "*"),
            h = RegExp(i + i + "*$"),
            c = function (e, t, n) {
                var r = {},
                    i = s(function () {
                        return !!l[e]() || u[e]() != u
                    }),
                    a = r[e] = i ? t(d) : l[e];
                n && (r[n] = a), o(o.P + o.F * i, "String", r)
            },
            d = c.trim = function (e, t) {
                return e = String(r(e)), 1 & t && (e = e.replace(a, "")), 2 & t && (e = e.replace(h, "")), e
            };
        e.exports = c
    }, function (e) {
        e.exports = "\t\n\v\f\r  \u2028\u2029\ufeff"
    }, function (e, t, n) {
        var r = n(22);
        r(r.S, "Number", {
            EPSILON: Math.pow(2, -52)
        })
    }, function (e, t, n) {
        e.exports = n(361)
    }, function (e, t, n) {
        n(362), e.exports = Math.pow(2, -52)
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Number", {
            EPSILON: Math.pow(2, -52)
        })
    }, function (t, e, n) {
        (function (e) {
            t.exports = e.TWEEN = n(364)
        }).call(this, n(157))
    }, function (a, o, e) {
        (function (t) {
            var e, n, r = function () {
                this._tweens = {}, this._tweensAddedDuringUpdate = {}
            };
            r.prototype = {
                getAll: function () {
                    return Object.keys(this._tweens).map(function (e) {
                        return this._tweens[e]
                    }.bind(this))
                },
                removeAll: function () {
                    this._tweens = {}
                },
                add: function (e) {
                    this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
                },
                remove: function (e) {
                    delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
                },
                update: function (e, t) {
                    var n = Object.keys(this._tweens);
                    if (0 === n.length) return !1;
                    for (e = void 0 !== e ? e : s.now(); 0 < n.length;) {
                        this._tweensAddedDuringUpdate = {};
                        for (var r = 0; r < n.length; r++) {
                            var i = this._tweens[n[r]];
                            i && !1 === i.update(e) && (i._isPlaying = !1, t || delete this._tweens[n[r]])
                        }
                        n = Object.keys(this._tweensAddedDuringUpdate)
                    }
                    return !0
                }
            };
            var i, s = new r;
            s.Group = r, s._nextId = 0, s.nextId = function () {
                return s._nextId++
            }, "undefined" == typeof self && void 0 !== t && t.hrtime ? s.now = function () {
                var e = t.hrtime();
                return 1e3 * e[0] + e[1] / 1e6
            } : void 0 !== self.performance && void 0 !== self.performance.now ? s.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? s.now = Date.now : s.now = function () {
                return (new Date).getTime()
            }, s.Tween = function (e, t) {
                this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = s.Easing.Linear.None, this._interpolationFunction = s.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = t || s, this._id = s.nextId()
            }, s.Tween.prototype = {
                getId: function () {
                    return this._id
                },
                isPlaying: function () {
                    return this._isPlaying
                },
                to: function (e, t) {
                    return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
                },
                duration: function (e) {
                    return this._duration = e, this
                },
                start: function (e) {
                    for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" == typeof e ? s.now() + parseFloat(e) : e : s.now(), this._startTime += this._delayTime, this._valuesEnd) {
                        if (this._valuesEnd[t] instanceof Array) {
                            if (0 === this._valuesEnd[t].length) continue;
                            this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                        }
                        void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], this._valuesStart[t] instanceof Array == 0 && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
                    }
                    return this
                },
                stop: function () {
                    return this._isPlaying && (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens()), this
                },
                end: function () {
                    return this.update(Infinity), this
                },
                stopChainedTweens: function () {
                    for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop()
                },
                group: function (e) {
                    return this._group = e, this
                },
                delay: function (e) {
                    return this._delayTime = e, this
                },
                repeat: function (e) {
                    return this._repeat = e, this
                },
                repeatDelay: function (e) {
                    return this._repeatDelayTime = e, this
                },
                yoyo: function (e) {
                    return this._yoyo = e, this
                },
                easing: function (e) {
                    return this._easingFunction = e, this
                },
                interpolation: function (e) {
                    return this._interpolationFunction = e, this
                },
                chain: function () {
                    return this._chainedTweens = arguments, this
                },
                onStart: function (e) {
                    return this._onStartCallback = e, this
                },
                onUpdate: function (e) {
                    return this._onUpdateCallback = e, this
                },
                onRepeat: function (e) {
                    return this._onRepeatCallback = e, this
                },
                onComplete: function (e) {
                    return this._onCompleteCallback = e, this
                },
                onStop: function (e) {
                    return this._onStopCallback = e, this
                },
                update: function (e) {
                    var t, n, r;
                    if (e < this._startTime) return !0;
                    for (t in !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), n = (e - this._startTime) / this._duration, n = 0 === this._duration || 1 < n ? 1 : n, r = this._easingFunction(n), this._valuesEnd)
                        if (void 0 !== this._valuesStart[t]) {
                            var i = this._valuesStart[t] || 0,
                                a = this._valuesEnd[t];
                            a instanceof Array ? this._object[t] = this._interpolationFunction(a, r) : ("string" == typeof a && (a = "+" === a.charAt(0) || "-" === a.charAt(0) ? i + parseFloat(a) : parseFloat(a)), "number" == typeof a && (this._object[t] = i + (a - i) * r))
                        } if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, n), 1 !== n) return !0;
                    if (0 < this._repeat) {
                        for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                            if ("string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t])), this._yoyo) {
                                var o = this._valuesStartRepeat[t];
                                this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = o
                            }
                            this._valuesStart[t] = this._valuesStartRepeat[t]
                        }
                        return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object), !0
                    }
                    null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                    for (var s = 0, l = this._chainedTweens.length; s < l; s++) this._chainedTweens[s].start(this._startTime + this._duration);
                    return !1
                }
            }, s.Easing = {
                Linear: {
                    None: function (e) {
                        return e
                    }
                },
                Quadratic: {
                    In: function (e) {
                        return e * e
                    },
                    Out: function (e) {
                        return e * (2 - e)
                    },
                    InOut: function (e) {
                        return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                    }
                },
                Cubic: {
                    In: function (e) {
                        return e * e * e
                    },
                    Out: function (e) {
                        return --e * e * e + 1
                    },
                    InOut: function (e) {
                        return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                    }
                },
                Quartic: {
                    In: function (e) {
                        return e * e * e * e
                    },
                    Out: function (e) {
                        return 1 - --e * e * e * e
                    },
                    InOut: function (e) {
                        return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                    }
                },
                Quintic: {
                    In: function (e) {
                        return e * e * e * e * e
                    },
                    Out: function (e) {
                        return --e * e * e * e * e + 1
                    },
                    InOut: function (e) {
                        return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                    }
                },
                Sinusoidal: {
                    In: function (e) {
                        return 1 - Math.cos(e * Math.PI / 2)
                    },
                    Out: function (e) {
                        return Math.sin(e * Math.PI / 2)
                    },
                    InOut: function (e) {
                        return .5 * (1 - Math.cos(Math.PI * e))
                    }
                },
                Exponential: {
                    In: function (e) {
                        return 0 === e ? 0 : Math.pow(1024, e - 1)
                    },
                    Out: function (e) {
                        return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                    },
                    InOut: function (e) {
                        return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                    }
                },
                Circular: {
                    In: function (e) {
                        return 1 - Math.sqrt(1 - e * e)
                    },
                    Out: function (e) {
                        return Math.sqrt(1 - --e * e)
                    },
                    InOut: function (e) {
                        return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                    }
                },
                Elastic: {
                    In: function (e) {
                        return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                    },
                    Out: function (e) {
                        return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                    },
                    InOut: function (e) {
                        return 0 === e ? 0 : 1 === e ? 1 : (e *= 2, e < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1)
                    }
                },
                Back: {
                    In: function (e) {
                        var t = 1.70158;
                        return e * e * ((t + 1) * e - t)
                    },
                    Out: function (e) {
                        var t = 1.70158;
                        return --e * e * ((t + 1) * e + t) + 1
                    },
                    InOut: function (e) {
                        var t = 2.5949095;
                        return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                    }
                },
                Bounce: {
                    In: function (e) {
                        return 1 - s.Easing.Bounce.Out(1 - e)
                    },
                    Out: function (e) {
                        return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                    },
                    InOut: function (e) {
                        return e < .5 ? .5 * s.Easing.Bounce.In(2 * e) : .5 * s.Easing.Bounce.Out(2 * e - 1) + .5
                    }
                }
            }, s.Interpolation = {
                Linear: function (e, t) {
                    var n = e.length - 1,
                        r = n * t,
                        i = Math.floor(r),
                        a = s.Interpolation.Utils.Linear;
                    return t < 0 ? a(e[0], e[1], r) : 1 < t ? a(e[n], e[n - 1], n - r) : a(e[i], e[n < i + 1 ? n : i + 1], r - i)
                },
                Bezier: function (e, t) {
                    for (var n = 0, r = e.length - 1, i = Math.pow, a = s.Interpolation.Utils.Bernstein, o = 0; o <= r; o++) n += i(1 - t, r - o) * i(t, o) * e[o] * a(r, o);
                    return n
                },
                CatmullRom: function (e, t) {
                    var n = e.length - 1,
                        r = n * t,
                        i = Math.floor(r),
                        a = s.Interpolation.Utils.CatmullRom;
                    return e[0] === e[n] ? (t < 0 && (i = Math.floor(r = n * (1 + t))), a(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)) : t < 0 ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : 1 < t ? e[n] - (a(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : a(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
                },
                Utils: {
                    Linear: function (e, t, n) {
                        return (t - e) * n + e
                    },
                    Bernstein: function (e, t) {
                        var n = s.Interpolation.Utils.Factorial;
                        return n(e) / n(t) / n(e - t)
                    },
                    Factorial: (i = [1], function (e) {
                        var t = 1;
                        if (i[e]) return i[e];
                        for (var n = e; 1 < n; n--) t *= n;
                        return i[e] = t, t
                    }),
                    CatmullRom: function (e, t, n, r, i) {
                        var a = .5 * (n - e),
                            o = .5 * (r - t),
                            s = i * i,
                            l = i * s;
                        return (2 * t - 2 * n + a + o) * l + (-3 * t + 3 * n - 2 * a - o) * s + a * i + t
                    }
                }
            }, e = [], n = function () {
                return s
            }.apply(o, e), void 0 === n || (a.exports = n)
        }).call(this, e(148))
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = r(n(107)),
            a = r(n(31));
        n(55), n(99), n(62), n(67), r(n(2)), r(n(3)), fm.OrbitControls = function (e, t, n) {
            var h, c, d, f, p, g, m, v, y, _;
            this.object = e, this.map = n, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new fm.Vector3, this.minDistance = 0, this.maxDistance = Infinity, this.minZoom = 0, this.maxZoom = Infinity, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -Infinity, this.maxAzimuthAngle = Infinity, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !1, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {
                LEFT: fm.MOUSE.LEFT,
                MIDDLE: fm.MOUSE.MIDDLE,
                RIGHT: fm.MOUSE.RIGHT
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.rangeCenter = new fm.Vector3, this.rangeRadius = 500, this.useRange = !1, this.enterCtrl = null, this.setEnterCtrl = function (e) {
                this.enterCtrl = e
            }, this.getPolarAngle = function () {
                return M.phi
            }, this.getAzimuthalAngle = function () {
                return M.theta
            }, this.setPolarAngle = function (e) {
                M.phi = e
            }, this.setAzimuthalAngle = function (e) {
                M.theta = e
            }, this.addPolarAngle = function (e) {
                M.phi += e
            }, this.addAzimuthalAngle = function (e) {
                M.theta += e
            }, this.panAdd = function (e) {
                E.add(e)
            }, this.saveState = function () {
                A.target0.copy(A.target), A.position0.copy(A.object.position), A.zoom0 = A.object.zoom
            }, this.reset = function () {
                A.target.copy(A.target0), A.object.position.copy(A.position0), A.object.zoom = A.zoom0, A.object.updateProjectionMatrix(), A.dispatchEvent(x), A.update(), I = C.NONE
            }, this.setUpdate = function (e, t, n, r, i) {
                h = e, c = t, d = n, f = r, p = p || i
            }, this.update = (g = new fm.Vector3, m = (new fm.Quaternion).setFromUnitVectors(e.up, new fm.Vector3(0, 1, 0)), v = m.clone().inverse(), y = new fm.Vector3, _ = new fm.Quaternion, function () {
                var e = A.object.position;
                g.copy(e).sub(A.target), g.applyQuaternion(m);
                var t = M.theta;
                if (M.setFromVector3(g), M.theta = t, I !== C.NONE ? A.map.autoRotateBymodelPause = !0 : A.map.autoRotateBymodelPause = !1, A.autoRotate && I === C.NONE && V(z()), M.theta += b.theta, M.phi += b.phi, "number" == typeof f && (M.theta = f), "number" == typeof p && (M.phi = p), "number" == typeof h && (M.phi += h), c && "number" == typeof c && (M.theta += c), M.theta = Math.max(A.minAzimuthAngle, Math.min(A.maxAzimuthAngle, M.theta)), M.phi = Math.max(A.minPolarAngle, Math.min(A.maxPolarAngle, M.phi)), M.makeSafe(), M.radius *= S, M.radius = Math.max(A.minDistance, Math.min(A.maxDistance, M.radius)), this.useRange) {
                    var n = (new fm.Vector3).setFromMatrixPosition(A.object.matrixWorld);
                    n.add(E);
                    var r = (new fm.Matrix4).copy(A.object.matrixWorld).setPosition(n),
                        i = (new fm.Matrix4).getInverse(r),
                        a = (new fm.Frustum).setFromProjectionMatrix((new fm.Matrix4).multiplyMatrices(A.object.projectionMatrix, i));
                    a.intersectsBox(A.viewBox) && A.target.add(E)
                } else A.target.add(E);
                if (g.setFromSpherical(M), g.applyQuaternion(v), d && g.add(d), this.useRange) {
                    var o = (new fm.Vector3).setFromMatrixPosition(A.object.matrixWorld);
                    o.add(g);
                    var s = (new fm.Matrix4).copy(A.object.matrixWorld).setPosition(o),
                        l = (new fm.Matrix4).getInverse(s),
                        u = (new fm.Frustum).setFromProjectionMatrix((new fm.Matrix4).multiplyMatrices(A.object.projectionMatrix, l));
                    u.intersectsBox(A.viewBox) && e.copy(A.target).add(g)
                } else e.copy(A.target).add(g);
                return A.object.lookAt(A.target), !0 === A.enableDamping ? (b.theta *= 1 - A.dampingFactor, b.phi *= 1 - A.dampingFactor, E.multiplyScalar(1 - A.dampingFactor)) : (b.set(0, 0, 0), E.set(0, 0, 0)), h = void 0, c = void 0, d = void 0, f = void 0, p = void 0, S = 1, !!(T || y.distanceToSquared(A.object.position) > w || 8 * (1 - _.dot(A.object.quaternion)) > w) && (A.dispatchEvent(x), y.copy(A.object.position), _.copy(A.object.quaternion), T = !1, !0)
            }), this.dispose = function () {
                A.domElement.removeEventListener("contextmenu", ge, !1), A.domElement.removeEventListener("mousedown", ae, !1), A.domElement.removeEventListener("wheel", he, !1), A.domElement.removeEventListener("touchstart", de, !1), A.domElement.removeEventListener("touchend", pe, !1), A.domElement.removeEventListener("touchmove", fe, !1), A.domElement.removeEventListener("mouseup", se, !1), A.domElement.removeEventListener("mousemove", le, !1), window.PointerEvent && !window.TouchEvent && (A.domElement.removeEventListener("pointerdown", ye, !1), A.domElement.removeEventListener("pointermove", _e, !1), A.domElement.removeEventListener("pointerup", Ae, !1)), document.removeEventListener("mousemove", oe, !1), document.removeEventListener("mouseup", ue, !1), window.removeEventListener("keydown", ce, !1), this.enterCtrl = void 0, this.domElement = void 0, this.object = void 0
            };
            var A = this,
                x = {
                    type: "change"
                },
                l = {
                    type: "start"
                },
                r = {
                    type: "end"
                },
                C = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_DOLLY_PAN: 4,
                    TOUCH_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                },
                I = C.NONE,
                w = 1e-6,
                M = new fm.Spherical,
                b = new fm.Spherical,
                S = 1,
                E = new fm.Vector3,
                T = !1,
                L = new fm.Vector2,
                N = new fm.Vector2,
                R = new fm.Vector2,
                k = new fm.Vector2,
                P = new fm.Vector2,
                D = (new fm.Vector2, new fm.Vector2),
                O = new fm.Vector2,
                F = new fm.Vector2,
                B = new fm.Vector2,
                G = new fm.Vector2,
                U = new fm.Vector2,
                u = new fm.Vector2;

            function z() {
                return 2 * Math.PI / 60 / 60 * A.autoRotateSpeed
            }

            function i() {
                return Math.pow(.95, A.zoomSpeed)
            }

            function V(e) {
                A.enterCtrl && !A.enterCtrl.enableMapRotate || (b.theta -= e)
            }

            function H(e) {
                A.enterCtrl && !A.enterCtrl.enableMapIncline || (b.phi -= e)
            }
            this.rotateLeft = function (e) {
                V(e)
            };
            var a, o, s = (a = new fm.Vector3, function (e, t) {
                    a.setFromMatrixColumn(t, 0), a.multiplyScalar(-e), E.add(a)
                }),
                W = (o = new fm.Vector3, function (e, t) {
                    !0 === A.screenSpacePanning ? o.setFromMatrixColumn(t, 1) : (o.setFromMatrixColumn(t, 0), o.crossVectors(A.object.up, o)), o.multiplyScalar(e), E.add(o)
                });
            this.panUp = function (e) {
                var t = new fm.Vector3;
                t.y = 1, t.multiplyScalar(e), E.add(t)
            };
            var j, Y = (j = new fm.Vector3, function (e, t) {
                if (!A.enterCtrl || A.enterCtrl.enableMapPan) {
                    var n = A.domElement === document ? A.domElement.body : A.domElement;
                    if (A.object.isPerspectiveCamera) {
                        var r = A.object.position;
                        j.copy(r).sub(A.target);
                        var i = j.length();
                        i *= Math.tan(A.object.fov / 2 * Math.PI / 180), s(2 * e * i / n.clientHeight, A.object.matrix), W(2 * t * i / n.clientHeight, A.object.matrix)
                    } else A.object.isOrthographicCamera ? (s(e * (A.object.right - A.object.left) / A.object.zoom / n.clientWidth, A.object.matrix), W(t * (A.object.top - A.object.bottom) / A.object.zoom / n.clientHeight, A.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), A.enablePan = !1)
                }
            });

            function q(e) {
                A.enterCtrl && !A.enterCtrl.enableMapPinch || (A.object.isPerspectiveCamera ? S /= e : A.object.isOrthographicCamera ? (A.object.zoom = Math.max(A.minZoom, Math.min(A.maxZoom, A.object.zoom * e)), A.object.updateProjectionMatrix(), S /= e, T = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), A.enableZoom = !1))
            }

            function X(e) {
                A.enterCtrl && !A.enterCtrl.enableMapPinch || (A.object.isPerspectiveCamera ? S *= e : A.object.isOrthographicCamera ? (A.object.zoom = Math.max(A.minZoom, Math.min(A.maxZoom, A.object.zoom / e)), A.object.updateProjectionMatrix(), T = !0, S *= e) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), A.enableZoom = !1))
            }

            function Z(e) {
                L.set(e.clientX, e.clientY)
            }

            function J(e) {
                B.set(e.clientX, e.clientY)
            }

            function K(e) {
                D.set(e.clientX, e.clientY)
            }

            function Q(e) {
                N.set(e.clientX, e.clientY), R.subVectors(N, L).multiplyScalar(A.rotateSpeed);
                var t = A.domElement === document ? A.domElement.body : A.domElement;
                V(2 * Math.PI * R.x / t.clientHeight), H(2 * Math.PI * R.y / t.clientHeight), L.copy(N)
            }

            function $(e) {
                G.set(e.clientX, e.clientY), U.subVectors(G, B), 0 < U.y ? q(i()) : U.y < 0 && X(i()), B.copy(G)
            }

            function ee(e) {
                O.set(e.clientX, e.clientY), F.subVectors(O, D).multiplyScalar(A.panSpeed), Y(F.x, F.y), D.copy(O)
            }

            function te() {}

            function ne(e) {
                e.deltaY < 0 ? X(i()) : 0 < e.deltaY && q(i())
            }

            function re(e) {
                switch (e.keyCode) {
                    case A.keys.UP:
                        Y(0, A.keyPanSpeed), A.update();
                        break;
                    case A.keys.BOTTOM:
                        Y(0, -A.keyPanSpeed), A.update();
                        break;
                    case A.keys.LEFT:
                        Y(A.keyPanSpeed, 0), A.update();
                        break;
                    case A.keys.RIGHT:
                        Y(-A.keyPanSpeed, 0), A.update()
                }
            }

            function ie() {}

            function ae(e) {
                if (u.set(e.clientX, e.clientY, A.enabled), !1 !== A.enabled) {
                    switch (e.preventDefault(), e.button) {
                        case A.mouseButtons.LEFT:
                            if (!1 === A.enablePan) return;
                            K(e), I = C.PAN;
                            break;
                        case A.mouseButtons.MIDDLE:
                            if (!1 === A.enableZoom) return;
                            J(e), I = C.DOLLY;
                            break;
                        case A.mouseButtons.RIGHT:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === A.enablePan) return;
                                K(e), I = C.PAN
                            } else {
                                if (!1 === A.enableRotate) return;
                                Z(e), I = C.ROTATE
                            }
                    }
                    I !== C.NONE && (document.addEventListener("mousemove", oe, !1), document.addEventListener("mouseup", ue, !1), A.dispatchEvent(l))
                }
            }

            function oe(e) {
                if (!1 !== A.enabled) switch (e.preventDefault(), I) {
                    case C.ROTATE:
                        if (!1 === A.enableRotate) return;
                        Q(e);
                        break;
                    case C.DOLLY:
                        if (!1 === A.enableZoom) return;
                        $(e);
                        break;
                    case C.PAN:
                        if (!1 === A.enablePan) return;
                        ee(e)
                }
            }

            function se(e) {
                var t = u.distanceTo(new fm.Vector2(e.clientX, e.clientY));
                t < 5 && A.dispatchEvent({
                    type: "mouseup",
                    mousePoint: {
                        x: e.offsetX,
                        y: e.offsetY,
                        w: A.domElement.clientWidth,
                        h: A.domElement.clientHeight
                    },
                    event: e,
                    mouseButton: e.button
                })
            }

            function le(e) {
                A.dispatchEvent({
                    type: "mousemove",
                    mousePoint: {
                        x: e.offsetX,
                        y: e.offsetY,
                        w: A.domElement.clientWidth,
                        h: A.domElement.clientHeight
                    },
                    event: e
                })
            }

            function ue(e) {
                !1 !== A.enabled && (te(e), document.removeEventListener("mousemove", oe, !1), document.removeEventListener("mouseup", ue, !1), A.dispatchEvent(r), I = C.NONE)
            }

            function he(e) {
                !1 === A.enabled || !1 === A.enableZoom || I !== C.NONE && I !== C.ROTATE || (e.preventDefault(), e.stopPropagation(), A.dispatchEvent(l), ne(e), A.dispatchEvent(r))
            }

            function ce(e) {
                !1 !== A.enabled && !1 !== A.enableKeys && !1 !== A.enablePan && re(e)
            }

            function de(e) {
                if (!1 !== A.enabled) {
                    switch (e.preventDefault(), A.map && A.map.eventTransform && (e = A.map.eventTransform(e)), u.set(e.changedTouches[0].pageX, e.changedTouches[0].pageY), e.touches.length) {
                        case 1:
                            if (A.enablePan) {
                                var t = e.touches[0].pageX,
                                    n = e.touches[0].pageY;
                                D.set(t, n)
                            }
                            I = C.TOUCH_PAN;
                            break;
                        case 2:
                            if (!1 === A.enableZoom && !1 === A.enableRotate) return;
                            if (I = C.TOUCH_DOLLY_ROTATE, A.enableZoom) {
                                var r = e.touches[0].pageX - e.touches[1].pageX,
                                    i = e.touches[0].pageY - e.touches[1].pageY,
                                    a = Math.sqrt(r * r + i * i);
                                B.set(0, a)
                            }
                            if (A.enableRotate) {
                                t = .5 * (e.touches[0].pageX + e.touches[1].pageX), n = .5 * (e.touches[0].pageY + e.touches[1].pageY), L.set(t, n);
                                var o = e.touches[0].pageX - e.touches[1].pageX,
                                    s = e.touches[0].pageY - e.touches[1].pageY;
                                k.set(o, s)
                            }
                            break;
                        default:
                            I = C.NONE
                    }
                    I !== C.NONE && A.dispatchEvent(l)
                }
            }

            function fe(e) {
                if (!1 !== A.enabled) switch (e.preventDefault(), e.stopPropagation(), A.map && A.map.eventTransform && (e = A.map.eventTransform(e)), e.touches.length) {
                    case 1:
                        if (I !== C.TOUCH_PAN) return;
                        if (A.enablePan) {
                            var t = e.touches[0].pageX,
                                n = e.touches[0].pageY;
                            if (t < 0) break;
                            O.set(t, n), F.subVectors(O, D).multiplyScalar(A.panSpeed), Y(F.x, F.y), D.copy(O)
                        }
                        break;
                    case 2:
                        if (!1 === A.enableRotate && !1 === A.enableZoom) return;
                        if (I !== C.TOUCH_DOLLY_ROTATE) return;
                        if (A.enableZoom) {
                            var r = e.touches[0].pageX - e.touches[1].pageX,
                                i = e.touches[0].pageY - e.touches[1].pageY,
                                a = Math.sqrt(r * r + i * i);
                            G.set(0, a), U.set(0, Math.pow(G.y / B.y, A.zoomSpeed)), q(U.y), B.copy(G)
                        }
                        if (A.enableRotate) {
                            var o = e.touches[0].pageX - e.touches[1].pageX,
                                s = e.touches[0].pageY - e.touches[1].pageY;
                            P.set(o, s);
                            var l = k.angle(),
                                u = P.angle();
                            N.set(.5 * (e.touches[0].pageX + e.touches[1].pageX), .5 * (e.touches[0].pageY + e.touches[1].pageY)), R.subVectors(N, L).multiplyScalar(A.rotateSpeed);
                            var h = A.domElement === document ? A.domElement.body : A.domElement;
                            V((-u + l) * A.rotateSpeed), H(2 * Math.PI * R.y / h.clientHeight), L.copy(N), k.copy(P)
                        }
                        break;
                    default:
                        I = C.NONE
                }
            }

            function pe(e) {
                if (!1 !== A.enabled) {
                    A.map && A.map.eventTransform && (e = A.map.eventTransform(e));
                    var t = u.distanceTo(new fm.Vector2(e.changedTouches[0].pageX, e.changedTouches[0].pageY)),
                        n = A.domElement.getBoundingClientRect();
                    t < 5 && A.dispatchEvent({
                        type: "mouseup",
                        mousePoint: {
                            x: e.changedTouches[0].pageX - n.left,
                            y: e.changedTouches[0].pageY - n.top,
                            w: A.domElement.clientWidth,
                            h: A.domElement.clientHeight
                        },
                        event: e,
                        mouseButton: fm.MOUSE.LEFT
                    }), ie(e), A.dispatchEvent(r), I = C.NONE
                }
            }

            function ge(e) {
                !1 !== A.enabled && e.preventDefault()
            }
            this.dollyIn = function (e) {
                q(e)
            }, this.dollyOut = function (e) {
                X(e)
            }, this.mapMouseDown = ae, this.mapMouseUp = se, A.domElement.addEventListener("contextmenu", ge, !1), A.domElement.addEventListener("mouseup", se, !1), A.domElement.addEventListener("mousemove", le, !1), A.domElement.addEventListener("mousedown", ae, !1), A.domElement.addEventListener("wheel", he, !1);
            var me = {
                touches: [],
                changedTouches: [],
                preventDefault: function () {},
                stopPropagation: function () {}
            };

            function ve(e) {
                return {
                    pointerId: e.pointerId,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    pageX: e.clientX,
                    pageY: e.clientY
                }
            }

            function ye(e) {
                if ("touch" == e.pointerType) {
                    switch (me.touches.length) {
                        case 0:
                            var t = {
                                startClientX: e.clientX,
                                startClientY: e.clientY,
                                clientX: e.clientX,
                                clientY: e.clientY,
                                pageY: e.clientY,
                                pageX: e.clientX,
                                pointerId: e.pointerId
                            };
                            me.touches.push(ve(t)), me.changedTouches.push(ve(t)), I = C.TOUCH_PAN;
                            break;
                        case 1:
                            var n = {
                                startClientX: e.clientX,
                                startClientY: e.clientY,
                                clientX: e.clientX,
                                clientY: e.clientY,
                                pageY: e.clientY,
                                pageX: e.clientX,
                                pointerId: e.pointerId
                            };
                            me.touches.push(ve(n)), me.changedTouches.push(ve(n)), I = C.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            I = C.NONE
                    }
                    1 < me.touches.length && de(me, !0)
                } else me = {
                    touches: [],
                    changedTouches: [],
                    preventDefault: function () {},
                    stopPropagation: function () {}
                }
            }

            function _e(e) {
                if (!("touch" != e.pointerType && me.touches.length < 2)) {
                    for (var t = 0, n = me.touches.length; t < n; t++) me.touches[t].pointerId == e.pointerId && (me.touches[t].clientX = e.clientX, me.touches[t].clientY = e.clientY, me.touches[t].pageY = e.clientY, me.touches[t].pageX = e.clientX, me.changedTouches[t].clientX = e.clientX, me.changedTouches[t].clientY = e.clientY, me.changedTouches[t].pageY = e.clientY, me.changedTouches[t].pageX = e.clientX);
                    1 < me.touches.length && fe(me)
                }
            }

            function Ae(e) {
                if ("touch" == e.pointerType) {
                    1 < me.touches.length && pe(me);
                    for (var t = me.touches.length - 1; - 1 < t; t--) me.touches[t].pointerId == e.pointerId && (me.touches.splice(t, 1), me.changedTouches.splice(t, 1))
                } else me = {
                    touches: [],
                    changedTouches: [],
                    preventDefault: function () {},
                    stopPropagation: function () {}
                }
            }
            window.PointerEvent && !window.TouchEvent && (A.domElement.addEventListener("pointerdown", ye, !1), A.domElement.addEventListener("pointermove", _e, !1), A.domElement.addEventListener("pointerup", Ae, !1)), A.domElement.addEventListener("touchstart", de, !1), A.domElement.addEventListener("touchend", pe, !1), A.domElement.addEventListener("touchmove", fe, !1), window.addEventListener("keydown", ce, !1), this.update()
        }, fm.OrbitControls.prototype = (0, a.default)(fm.EventDispatcher.prototype), fm.OrbitControls.prototype.constructor = fm.OrbitControls, (0, i.default)(fm.OrbitControls.prototype, {
            center: {
                get: function () {
                    return console.warn("fm.OrbitControls: .center has been renamed to .target"), this.target
                }
            },
            noZoom: {
                get: function () {
                    return console.warn("fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
                }
            },
            noRotate: {
                get: function () {
                    return console.warn("fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
                }
            },
            noPan: {
                get: function () {
                    return console.warn("fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
                }
            },
            noKeys: {
                get: function () {
                    return console.warn("fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
                }
            },
            staticMoving: {
                get: function () {
                    return console.warn("fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
                }
            },
            dynamicDampingFactor: {
                get: function () {
                    return console.warn("fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
                },
                set: function (e) {
                    console.warn("fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e
                }
            }
        })
    }, function () {
        "use strict";
        fm.Evento = {
            convert: function (i, a) {
                return a = a || {}, i.on = function (e, t) {
                    return (a[e] = a[e] || []).push(t), i
                }, i.getHandlers = function (e) {
                    return a[e]
                }, i.once = function (e, t) {
                    function n() {
                        t.apply(i.off(e, n), arguments)
                    }
                    return n.h = t, i.on(e, n)
                }, i.off = function (e, t) {
                    for (var n = a[e], r = 0; t && n && n[r]; r++) n[r] != t && n[r].h != t || n.splice(r--, 1);
                    return t || delete a[e], i
                }, i.emit = function (e) {
                    for (var t = a[e], n = 0; t && t[n];) t[n++].apply(i, t.slice.call(arguments, 1));
                    return i
                }, i.offAll = function () {
                    for (var e in a) a[e] = [], delete a[e];
                    a = void 0
                }, i
            }
        }
    }, function (e, t, n) {
        var r = n(35);

        function i(e) {
            if (r(e)) {
                for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                return n
            }
        }
        e.exports = i
    }, function (e, t, n) {
        var r = n(166),
            i = n(369);

        function a(e) {
            if (i(Object(e)) || "[object Arguments]" === Object.prototype.toString.call(e)) return r(e)
        }
        e.exports = a
    }, function (e, t, n) {
        e.exports = n(370)
    }, function (e, t, n) {
        n(65), n(59), e.exports = n(371)
    }, function (e, t, n) {
        var r = n(95),
            i = n(19)("iterator"),
            a = n(60);
        e.exports = n(9).isIterable = function (e) {
            var t = Object(e);
            return void 0 !== t[i] || "@@iterator" in t || a.hasOwnProperty(r(t))
        }
    }, function (e) {
        function t() {
            throw new TypeError("Invalid attempt to spread non-iterable instance")
        }
        e.exports = t
    }, function (e, t, n) {
        n(65), n(59), e.exports = n(374)
    }, function (e, t, n) {
        var r = n(29),
            i = n(131);
        e.exports = n(9).getIterator = function (e) {
            var t = i(e);
            if ("function" != typeof t) throw TypeError(e + " is not iterable!");
            return r(t.call(e))
        }
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11));
        n(48);
        var o = r(n(2)),
            s = r(n(3)),
            l = r(n(80)),
            u = r(n(203)),
            h = r(n(109)),
            c = function () {
                function n(e) {
                    (0, o.default)(this, n), window.location.protocol;
                    var t = h.default.replace("FMCloud/", "").replace("www.fengmap.com", "source.fengmap.com") + "webtheme";
                    this._key = null, this._appName = null, this._mapServerURL = "fengmap", this._mapThemeURL = t, this._container = document.body, this._compassOffset = [28, 20], this._compassSize = 50, this._compassFg = null, this._compassBg = null, this.compassPosition = 1, this._defaultThemeName = "2001", this._focusAnimateMode = !0, this._focusAnimateTime = .3, this._focusAlphaMode = !0, this._focusAlpha = .1, this._viewModeAnimateMode = !0, this._viewModeAnimateTime = .3, this._moveToAnimateMode = !0, this._moveToAnimateTime = .3, this._scaleToAnimateMode = !0, this._modelSelectedEffect = !0, this._modelHoverEffect = !1, this._modelHoverTime = 1e3, this.minScaleLevel = 0, this.maxScaleLevel = 6, this.defaultScaleLevel = 3, this.mapScaleLevelRange = [16, 23], this.mapScaleRange = null, this.defaultMapScaleLevel = 20, this.defaultMapScale = null, this.minViewDistance = 2e3, this.defaultVisibleGroups = [1], this.defaultFocusGroup = 1, this.defaultViewMode = "3d", this.shadowEnabled = !1, this.lightAngleX = 45, this.lightAngleY = 45, this.shadowSize = 2048, this.shadowAlpha = .6, this.storeImageAngle = 0, this.naviLineAnimation = !0, this.controlsRotateThreshold = .03, this.controlsScaleThreshold = .03, this.defaultGroupSpace = 50, this.passiveMode = !1, this.themeVersion = null, this.themeFileType = null, this.cornerRoundLimit = 1, this.stairsConfig = {}, this.defaultControlsPose = -15, this.defaultTiltAngle = 30, this.defaultMaxTiltAngle = 90, this.defaultMinTiltAngle = 30, this.extentHeight = 0, this.poiLabelFadeMode = !1, this.poiLabelFadeSpeed = 5, this.defaultBackgroundColor = null, this.defaultBackgroundAlpha = null, this.storeImageDistanceEnabled = !1, this.storeImageDistance = 500, this.useStoreApply = !0, this.frameRate = 12, this.defaultViewCenter = null, this.pickCoordHeight = 1, this.modelFileSuffix = "js", this.enabledFXAA = !1, this.dynamicTextureScale = 1, this.enabledPanRange = !1, this.tile = !1, this.levelShowOffset = 0, this.lightEffects = !1, this.defaultLabelLanguage = l.default.ZH, this.font = {
                        family: '"Microsoft Yahei","",Tahoma,Arial'
                    }, (0, a.default)(this, e)
                }
                return (0, s.default)(n, [{
                    key: "computePoseToAngle",
                    value: function () {
                        if ("number" == typeof this.defaultControlsPose) return this.defaultControlsPose;
                        if (this.defaultControlsPose) {
                            var e = u.default[this.defaultControlsPose];
                            return e || -15
                        }
                    }
                }, {
                    key: "key",
                    set: function (e) {
                        this._key = e
                    },
                    get: function () {
                        return this._key
                    }
                }, {
                    key: "appName",
                    set: function (e) {
                        this._appName = e
                    },
                    get: function () {
                        return this._appName
                    }
                }, {
                    key: "mapServerURL",
                    get: function () {
                        return this._mapServerURL
                    },
                    set: function (e) {
                        this._mapServerURL = e
                    }
                }, {
                    key: "mapThemeURL",
                    get: function () {
                        return this._mapThemeURL
                    },
                    set: function (e) {
                        this._mapThemeURL = e
                    }
                }, {
                    key: "container",
                    get: function () {
                        return this._container
                    },
                    set: function (e) {
                        this._container = e
                    }
                }, {
                    key: "compassOffset",
                    get: function () {
                        return this._compassOffset
                    },
                    set: function (e) {
                        this._compassOffset = e
                    }
                }, {
                    key: "compassSize",
                    get: function () {
                        return this._compassSize
                    },
                    set: function (e) {
                        this._compassSize = e
                    }
                }, {
                    key: "compassFg",
                    set: function (e) {
                        this._compassFg = e
                    },
                    get: function () {
                        return this._compassFg
                    }
                }, {
                    key: "compassBg",
                    set: function (e) {
                        this._compassBg = e
                    },
                    get: function () {
                        return this._compassBg
                    }
                }, {
                    key: "defaultThemeName",
                    get: function () {
                        return this._defaultThemeName
                    },
                    set: function (e) {
                        this._defaultThemeName = e
                    }
                }, {
                    key: "focusAnimateMode",
                    get: function () {
                        return this._focusAnimateMode
                    },
                    set: function (e) {
                        this._focusAnimateMode = e
                    }
                }, {
                    key: "focusAnimateTime",
                    get: function () {
                        return this._focusAnimateTime
                    },
                    set: function (e) {
                        this._focusAnimateTime = e
                    }
                }, {
                    key: "focusAlphaMode",
                    get: function () {
                        this._focusAlphaMode
                    },
                    set: function (e) {
                        this._focusAlphaMode = e
                    }
                }, {
                    key: "focusAlpha",
                    set: function (e) {
                        this._focusAlpha = e
                    },
                    get: function () {
                        return this._focusAlpha
                    }
                }, {
                    key: "viewModeAnimateMode",
                    set: function (e) {
                        this._viewModeAnimateMode = e
                    },
                    get: function () {
                        return this._viewModeAnimateMode
                    }
                }, {
                    key: "moveToAnimateMode",
                    set: function (e) {
                        this._moveToAnimateMode = e
                    },
                    get: function () {
                        return this._moveToAnimateMode
                    }
                }, {
                    key: "scaleToAnimateMode",
                    set: function (e) {
                        this._scaleToAnimateMode = e
                    },
                    get: function () {
                        return this._scaleToAnimateMode
                    }
                }, {
                    key: "viewModeAnimateTime",
                    set: function (e) {
                        this._viewModeAnimateTime = e
                    },
                    get: function () {
                        return this._viewModeAnimateTime
                    }
                }, {
                    key: "modelHoverTime",
                    get: function () {
                        return this._modelHoverTime
                    },
                    set: function (e) {
                        e < 300 && (e = 300), this._modelHoverTime = e
                    }
                }, {
                    key: "modelHoverEffect",
                    get: function () {
                        return this._modelHoverEffect
                    },
                    set: function (e) {
                        this._modelHoverEffect = e
                    }
                }, {
                    key: "modelSelectedEffect",
                    get: function () {
                        return this._modelSelectedEffect
                    },
                    set: function (e) {
                        this._modelSelectedEffect = e
                    }
                }]), n
            }(),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var l = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            A = r(n(377)),
            x = r(n(379)),
            C = r(n(380)),
            I = r(n(205)),
            s = function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, [{
                    key: "mapDecode",
                    value: function (e, t, n) {
                        var r = A.default.build("Map").decode(e),
                            i = "%E8%AF%B7%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E7%9A%84license.";
                        if (I.default.ls && !I.default.checkLicense(r.key, t, n)) return console.warn(decodeURIComponent(i)), null;
                        for (var a = {
                                scene: null,
                                floors: []
                            }, o = 0, s = r.buffers.length; o < s; o++) {
                            var l = r.buffers[o],
                                u = l.len,
                                h = l.data.offset,
                                c = l.data.offset + u.low,
                                d = l.data.buffer;
                            if (1 == l.btype) {
                                var f = C.default.build("Scene").decode(d.slice(h, c));
                                a.scene = f
                            } else {
                                var p = l.gid,
                                    g = this.containsFloor(p, a.floors),
                                    m = g.floor;
                                if (g.index < 0 && (m.gid = p, m.biz = [], m.navi = [], m.geo = []), 2 == l.btype) {
                                    var v = x.default.build("FloorGeo").decode(d.slice(h, c));
                                    m.geo.push(v)
                                }
                                if (3 == l.btype) {
                                    var y = x.default.build("FloorBiz").decode(d.slice(h, c));
                                    m.biz.push(y)
                                }
                                if (4 == l.btype) {
                                    var _ = x.default.build("FloorNavi").decode(d.slice(h, c));
                                    m.navi.push(_)
                                }
                                g.index < 0 ? a.floors.push(m) : a.floors[g.index] = m
                            }
                        }
                        return a
                    }
                }, {
                    key: "containsFloor",
                    value: function (e, t) {
                        for (var n = 0, r = t.length; n < r; n++)
                            if (t[n].gid == e) return {
                                index: n,
                                floor: t[n]
                            };
                        return {
                            index: -1,
                            floor: {}
                        }
                    }
                }, {
                    key: "sceneDecode",
                    value: function (e, t, n) {
                        var r = C.default.build("Scene").decode(e),
                            i = "%E8%AF%B7%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E7%9A%84license.";
                        return I.default.ls && !I.default.checkLicense(r.key, t, n) ? (console.warn(decodeURIComponent(i)), null) : r
                    }
                }, {
                    key: "floorGeoDecode",
                    value: function (e) {
                        var t = x.default.build("FloorGeo").decode(e);
                        return t
                    }
                }, {
                    key: "floorBizDecode",
                    value: function (e) {
                        var t = x.default.build("FloorBiz").decode(e);
                        return t
                    }
                }, {
                    key: "floorNaviDecode",
                    value: function (e) {
                        var t = x.default.build("FloorNavi").decode(e);
                        return t
                    }
                }, {
                    key: "disposeRoot",
                    value: function (e) {
                        var t = e.ns,
                            n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, l.default)(t.children); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value;
                                s.builder = void 0, s.parent = void 0, s.children.length = 0, s._fields.length = 0, s._fieldsById = void 0, s._fieldsByName = void 0
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        t.children.length = 0, e.ns = void 0, e.ptr = void 0
                    }
                }, {
                    key: "dispose",
                    value: function () {}
                }]), e
            }(),
            u = s;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = n(149),
            a = i.ProtoBuf.newBuilder({}).import({
                messages: [{
                    name: "Map",
                    fields: [{
                        rule: "required",
                        type: "string",
                        name: "mid",
                        id: 1
                    }, {
                        rule: "required",
                        type: "int32",
                        name: "file_ver",
                        id: 2
                    }, {
                        rule: "required",
                        type: "uint64",
                        name: "date_ver",
                        id: 3
                    }, {
                        rule: "required",
                        type: "string",
                        name: "mname",
                        id: 4
                    }, {
                        rule: "required",
                        type: "string",
                        name: "hash_code",
                        id: 5
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "key",
                        id: 6
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "file_date",
                        id: 7
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "desc",
                        id: 8
                    }, {
                        rule: "optional",
                        type: "bool",
                        name: "read_only",
                        id: 9,
                        options: {
                            default: !1
                        }
                    }, {
                        rule: "repeated",
                        type: "Buffer",
                        name: "buffers",
                        id: 10
                    }],
                    messages: [{
                        name: "Buffer",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "gid",
                            id: 1
                        }, {
                            rule: "required",
                            type: "int32",
                            name: "file_ver",
                            id: 2
                        }, {
                            rule: "required",
                            type: "int32",
                            name: "btype",
                            id: 3
                        }, {
                            rule: "required",
                            type: "uint64",
                            name: "len",
                            id: 4
                        }, {
                            rule: "required",
                            type: "bytes",
                            name: "data",
                            id: 5
                        }]
                    }]
                }]
            });
        t.default = a
    }, function () {}, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = n(149),
            a = i.ProtoBuf.newBuilder({}).import({
                messages: [{
                    name: "FloorGeo",
                    syntax: "proto2",
                    fields: [{
                        rule: "required",
                        type: "string",
                        name: "mid",
                        id: 1
                    }, {
                        rule: "required",
                        type: "int32",
                        name: "gid",
                        id: 2
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "height",
                        id: 3
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "extentLayer",
                        id: 4
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "modelLayer",
                        id: 5
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "labelLayer",
                        id: 6
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "poiLayer",
                        id: 7
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "polygonLayer",
                        id: 8
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "polygonLabelLayer",
                        id: 9
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "liftLayer",
                        id: 10
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "stairLayer",
                        id: 11
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "escalatorLayer",
                        id: 12
                    }, {
                        rule: "repeated",
                        type: "GeneralGeoInfo",
                        name: "externalModelLayer",
                        id: 13
                    }],
                    messages: [{
                        name: "GeneralGeoInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "geo",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "height",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "area",
                            id: 4
                        }, {
                            rule: "repeated",
                            type: "Indexinfo",
                            name: "idxs",
                            id: 5
                        }, {
                            rule: "repeated",
                            type: "double",
                            name: "pts",
                            id: 6
                        }],
                        messages: [{
                            name: "Indexinfo",
                            syntax: "proto2",
                            fields: [{
                                rule: "repeated",
                                type: "int32",
                                name: "idxs",
                                id: 1
                            }]
                        }]
                    }]
                }, {
                    name: "FloorBiz",
                    syntax: "proto2",
                    fields: [{
                        rule: "required",
                        type: "string",
                        name: "mid",
                        id: 1
                    }, {
                        rule: "required",
                        type: "int32",
                        name: "gid",
                        id: 2
                    }, {
                        rule: "repeated",
                        type: "ExtentBizInfo",
                        name: "extentLayer",
                        id: 3
                    }, {
                        rule: "repeated",
                        type: "ModelBizInfo",
                        name: "modelLayer",
                        id: 4
                    }, {
                        rule: "repeated",
                        type: "LabelBizInfo",
                        name: "labelLayer",
                        id: 5
                    }, {
                        rule: "repeated",
                        type: "POIBizInfo",
                        name: "poiLayer",
                        id: 6
                    }, {
                        rule: "repeated",
                        type: "PolygonBizInfo",
                        name: "polygonLayer",
                        id: 7
                    }, {
                        rule: "repeated",
                        type: "LiftBizInfo",
                        name: "liftLayer",
                        id: 8
                    }, {
                        rule: "repeated",
                        type: "StairBizInfo",
                        name: "stairLayer",
                        id: 9
                    }, {
                        rule: "repeated",
                        type: "PolygonLabelBizInfo",
                        name: "polygonLabelLayer",
                        id: 10
                    }, {
                        rule: "repeated",
                        type: "ExternalModelBizInfo",
                        name: "externalModelLayer",
                        id: 11
                    }],
                    messages: [{
                        name: "ExtentBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }]
                    }, {
                        name: "ModelBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 7
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "pass",
                            id: 8
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "floorID",
                            id: 9
                        }]
                    }, {
                        name: "LabelBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 7
                        }]
                    }, {
                        name: "PolygonBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }]
                    }, {
                        name: "POIBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 7
                        }]
                    }, {
                        name: "LiftBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "flag",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "floor",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 7
                        }]
                    }, {
                        name: "StairBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "flag",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 6
                        }]
                    }, {
                        name: "PolygonLabelBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "width",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "angle",
                            id: 7
                        }]
                    }, {
                        name: "ExternalModelBizInfo",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "eid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "fid",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "type",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "ename",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "minlevel",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "maxlevel",
                            id: 7
                        }]
                    }]
                }, {
                    name: "FloorNavi",
                    syntax: "proto2",
                    fields: [{
                        rule: "required",
                        type: "string",
                        name: "mid",
                        id: 1
                    }, {
                        rule: "required",
                        type: "int32",
                        name: "gid",
                        id: 2
                    }, {
                        rule: "repeated",
                        type: "NaviNode",
                        name: "naviNodes",
                        id: 3
                    }, {
                        rule: "repeated",
                        type: "NaviSegment",
                        name: "naviSegments",
                        id: 4
                    }, {
                        rule: "repeated",
                        type: "NaviZone",
                        name: "naviZones",
                        id: 5
                    }, {
                        rule: "repeated",
                        type: "NaviModel",
                        name: "naviModels",
                        id: 6
                    }, {
                        rule: "repeated",
                        type: "int32",
                        name: "nextFloors",
                        id: 7
                    }],
                    messages: [{
                        name: "NaviNode",
                        syntax: "proto2",
                        fields: [{
                            rule: "optional",
                            type: "int32",
                            name: "nodeId",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "nodeType",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "liftType",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "liftFlag",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "liftEntry",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "liftFloor",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "linkSeg",
                            id: 7
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "geo",
                            id: 8
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "entranceType",
                            id: 9
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "entranceFloor",
                            id: 10
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "doortype",
                            id: 11
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "idxs",
                            id: 12
                        }, {
                            rule: "repeated",
                            type: "double",
                            name: "pts",
                            id: 13
                        }]
                    }, {
                        name: "NaviSegment",
                        syntax: "proto2",
                        fields: [{
                            rule: "optional",
                            type: "int32",
                            name: "segmentId",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "snode",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "enode",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "double",
                            name: "length",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "rank",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "name",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "entry",
                            id: 7
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "desc",
                            id: 8
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "geo",
                            id: 9
                        }, {
                            rule: "optional",
                            type: "int32",
                            name: "through",
                            id: 10
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "idxs",
                            id: 11
                        }, {
                            rule: "repeated",
                            type: "double",
                            name: "pts",
                            id: 12
                        }]
                    }, {
                        name: "NaviZone",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "id",
                            id: 1
                        }, {
                            rule: "required",
                            type: "int32",
                            name: "type",
                            id: 2,
                            options: {
                                default: 0
                            }
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "geo",
                            id: 3
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "rejects",
                            id: 4
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "idxs",
                            id: 5
                        }, {
                            rule: "repeated",
                            type: "double",
                            name: "pts",
                            id: 6
                        }]
                    }, {
                        name: "NaviModel",
                        syntax: "proto2",
                        fields: [{
                            rule: "required",
                            type: "int32",
                            name: "id",
                            id: 1
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "doorids",
                            id: 2
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "nodetypes",
                            id: 3
                        }, {
                            rule: "repeated",
                            type: "int32",
                            name: "entrytypes",
                            id: 4
                        }]
                    }]
                }]
            });
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = n(149),
            a = i.ProtoBuf.newBuilder({}).import({
                messages: [{
                    name: "Scene",
                    fields: [{
                        rule: "required",
                        type: "string",
                        name: "mid",
                        id: 19
                    }, {
                        rule: "required",
                        type: "int32",
                        name: "file_ver",
                        id: 20
                    }, {
                        rule: "required",
                        type: "uint64",
                        name: "date_ver",
                        id: 21
                    }, {
                        rule: "required",
                        type: "string",
                        name: "mname",
                        id: 22
                    }, {
                        rule: "required",
                        type: "string",
                        name: "hash_code",
                        id: 23
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "key",
                        id: 24
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "desc",
                        id: 25
                    }, {
                        rule: "optional",
                        type: "bool",
                        name: "read_only",
                        id: 26,
                        options: {
                            default: !1
                        }
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "x",
                        id: 1
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "y",
                        id: 2
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "z",
                        id: 3
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "minX",
                        id: 4
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "minY",
                        id: 5
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "maxX",
                        id: 6
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "maxY",
                        id: 7
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "defGid",
                        id: 8
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "defCenX",
                        id: 9
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "defCenY",
                        id: 10
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "defCenZ",
                        id: 11
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "height",
                        id: 12
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "rotateAngleX",
                        id: 13
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "rotateAngleY",
                        id: 14
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "rotateAngleZ",
                        id: 15
                    }, {
                        rule: "optional",
                        type: "float",
                        name: "scale",
                        id: 16
                    }, {
                        rule: "optional",
                        type: "string",
                        name: "scaleLevel",
                        id: 17
                    }, {
                        rule: "repeated",
                        type: "LayerGroup",
                        name: "layerGroups",
                        id: 18
                    }],
                    messages: [{
                        name: "Layer",
                        fields: [{
                            rule: "optional",
                            type: "int32",
                            name: "lid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "lname",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "alias",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "Type",
                            name: "ltype",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "offsetX",
                            id: 5
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "offsetY",
                            id: 6
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "height",
                            id: 7
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "rotateAngleX",
                            id: 8
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "rotateAngleY",
                            id: 9
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "rotateAngleZ",
                            id: 10
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "minScaleLevel",
                            id: 11
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "maxScaleLevel",
                            id: 12
                        }, {
                            rule: "optional",
                            type: "bool",
                            name: "isVisible",
                            id: 13
                        }, {
                            rule: "optional",
                            type: "bool",
                            name: "isSelectable",
                            id: 14
                        }, {
                            rule: "optional",
                            type: "bool",
                            name: "isEditable",
                            id: 15
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "desc",
                            id: 16
                        }],
                        enums: [{
                            name: "Type",
                            values: [{
                                name: "GEOPOINT",
                                id: 1
                            }, {
                                name: "GEOPOINT_ESCALATOR",
                                id: 2
                            }, {
                                name: "GEOPOINT_LIFT",
                                id: 3
                            }, {
                                name: "GEOPOINT_STAIR",
                                id: 4
                            }, {
                                name: "GEOPOINT_PANORAMA",
                                id: 5
                            }, {
                                name: "GEOPOINT_POI",
                                id: 6
                            }, {
                                name: "GEOPOINT_STORELABEL",
                                id: 7
                            }, {
                                name: "GEOPOINT_NAVINODE",
                                id: 8
                            }, {
                                name: "GEOPOINT_MODEL",
                                id: 9
                            }, {
                                name: "GEOLINE",
                                id: 20
                            }, {
                                name: "GEOLINE_NAVISEGMENT",
                                id: 21
                            }, {
                                name: "GEOLINE_BORDER",
                                id: 22
                            }, {
                                name: "GEOPOLYGON",
                                id: 30
                            }, {
                                name: "GEOPOLYGON_EXTENT",
                                id: 31
                            }, {
                                name: "GEOPOLYGON_STORE",
                                id: 32
                            }, {
                                name: "GEOPOLYGON_LABEL",
                                id: 33
                            }, {
                                name: "RASTERATA",
                                id: 40
                            }, {
                                name: "OVERLAYDATA",
                                id: 50
                            }]
                        }]
                    }, {
                        name: "LayerGroup",
                        fields: [{
                            rule: "optional",
                            type: "int32",
                            name: "gid",
                            id: 1
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "gname",
                            id: 2
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "alias",
                            id: 3
                        }, {
                            rule: "optional",
                            type: "float",
                            name: "height",
                            id: 4
                        }, {
                            rule: "optional",
                            type: "string",
                            name: "desc",
                            id: 5
                        }, {
                            rule: "repeated",
                            type: "Layer",
                            name: "layers",
                            id: 6
                        }]
                    }]
                }]
            });
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i, a = (i = function (e) {
            return w(e)
        }, {
            encryption: function (e) {
                return i(e)
            }
        });

        function c(e, t) {
            var n = (65535 & e) + (65535 & t),
                r = (e >> 16) + (t >> 16) + (n >> 16);
            return r << 16 | 65535 & n
        }

        function o(e, t) {
            return e << t | e >>> 32 - t
        }

        function s(e, t, n, r, i, a) {
            return c(o(c(c(t, e), c(r, a)), i), n)
        }

        function d(e, t, n, r, i, a, o) {
            return s(t & n | ~t & r, e, t, i, a, o)
        }

        function f(e, t, n, r, i, a, o) {
            return s(t & r | n & ~r, e, t, i, a, o)
        }

        function p(e, t, n, r, i, a, o) {
            return s(t ^ n ^ r, e, t, i, a, o)
        }

        function g(e, t, n, r, i, a, o) {
            return s(n ^ (t | ~r), e, t, i, a, o)
        }

        function l(e, t) {
            var n, r, i, a, o;
            e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
            var s = 1732584193,
                l = -271733879,
                u = -1732584194,
                h = 271733878;
            for (n = 0; n < e.length; n += 16) r = s, i = l, a = u, o = h, s = d(s, l, u, h, e[n], 7, -680876936), h = d(h, s, l, u, e[n + 1], 12, -389564586), u = d(u, h, s, l, e[n + 2], 17, 606105819), l = d(l, u, h, s, e[n + 3], 22, -1044525330), s = d(s, l, u, h, e[n + 4], 7, -176418897), h = d(h, s, l, u, e[n + 5], 12, 1200080426), u = d(u, h, s, l, e[n + 6], 17, -1473231341), l = d(l, u, h, s, e[n + 7], 22, -45705983), s = d(s, l, u, h, e[n + 8], 7, 1770035416), h = d(h, s, l, u, e[n + 9], 12, -1958414417), u = d(u, h, s, l, e[n + 10], 17, -42063), l = d(l, u, h, s, e[n + 11], 22, -1990404162), s = d(s, l, u, h, e[n + 12], 7, 1804603682), h = d(h, s, l, u, e[n + 13], 12, -40341101), u = d(u, h, s, l, e[n + 14], 17, -1502002290), l = d(l, u, h, s, e[n + 15], 22, 1236535329), s = f(s, l, u, h, e[n + 1], 5, -165796510), h = f(h, s, l, u, e[n + 6], 9, -1069501632), u = f(u, h, s, l, e[n + 11], 14, 643717713), l = f(l, u, h, s, e[n], 20, -373897302), s = f(s, l, u, h, e[n + 5], 5, -701558691), h = f(h, s, l, u, e[n + 10], 9, 38016083), u = f(u, h, s, l, e[n + 15], 14, -660478335), l = f(l, u, h, s, e[n + 4], 20, -405537848), s = f(s, l, u, h, e[n + 9], 5, 568446438), h = f(h, s, l, u, e[n + 14], 9, -1019803690), u = f(u, h, s, l, e[n + 3], 14, -187363961), l = f(l, u, h, s, e[n + 8], 20, 1163531501), s = f(s, l, u, h, e[n + 13], 5, -1444681467), h = f(h, s, l, u, e[n + 2], 9, -51403784), u = f(u, h, s, l, e[n + 7], 14, 1735328473), l = f(l, u, h, s, e[n + 12], 20, -1926607734), s = p(s, l, u, h, e[n + 5], 4, -378558), h = p(h, s, l, u, e[n + 8], 11, -2022574463), u = p(u, h, s, l, e[n + 11], 16, 1839030562), l = p(l, u, h, s, e[n + 14], 23, -35309556), s = p(s, l, u, h, e[n + 1], 4, -1530992060), h = p(h, s, l, u, e[n + 4], 11, 1272893353), u = p(u, h, s, l, e[n + 7], 16, -155497632), l = p(l, u, h, s, e[n + 10], 23, -1094730640), s = p(s, l, u, h, e[n + 13], 4, 681279174), h = p(h, s, l, u, e[n], 11, -358537222), u = p(u, h, s, l, e[n + 3], 16, -722521979), l = p(l, u, h, s, e[n + 6], 23, 76029189), s = p(s, l, u, h, e[n + 9], 4, -640364487), h = p(h, s, l, u, e[n + 12], 11, -421815835), u = p(u, h, s, l, e[n + 15], 16, 530742520), l = p(l, u, h, s, e[n + 2], 23, -995338651), s = g(s, l, u, h, e[n], 6, -198630844), h = g(h, s, l, u, e[n + 7], 10, 1126891415), u = g(u, h, s, l, e[n + 14], 15, -1416354905), l = g(l, u, h, s, e[n + 5], 21, -57434055), s = g(s, l, u, h, e[n + 12], 6, 1700485571), h = g(h, s, l, u, e[n + 3], 10, -1894986606), u = g(u, h, s, l, e[n + 10], 15, -1051523), l = g(l, u, h, s, e[n + 1], 21, -2054922799), s = g(s, l, u, h, e[n + 8], 6, 1873313359), h = g(h, s, l, u, e[n + 15], 10, -30611744), u = g(u, h, s, l, e[n + 6], 15, -1560198380), l = g(l, u, h, s, e[n + 13], 21, 1309151649), s = g(s, l, u, h, e[n + 4], 6, -145523070), h = g(h, s, l, u, e[n + 11], 10, -1120210379), u = g(u, h, s, l, e[n + 2], 15, 718787259), l = g(l, u, h, s, e[n + 9], 21, -343485551), s = c(s, r), l = c(l, i), u = c(u, a), h = c(h, o);
            return [s, l, u, h]
        }

        function u(e) {
            var t, n = "",
                r = 32 * e.length;
            for (t = 0; t < r; t += 8) n += String.fromCharCode(e[t >> 5] >>> t % 32 & 255);
            return n
        }

        function h(e) {
            var t, n = [];
            for (n[(e.length >> 2) - 1] = void 0, t = 0; t < n.length; t += 1) n[t] = 0;
            var r = 8 * e.length;
            for (t = 0; t < r; t += 8) n[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
            return n
        }

        function m(e) {
            return u(l(h(e), 8 * e.length))
        }

        function v(e, t) {
            var n, r, i = h(e),
                a = [],
                o = [];
            for (a[15] = o[15] = void 0, 16 < i.length && (i = l(i, 8 * e.length)), n = 0; n < 16; n += 1) a[n] = 909522486 ^ i[n], o[n] = 1549556828 ^ i[n];
            return r = l(a.concat(h(t)), 512 + 8 * t.length), u(l(o.concat(r), 640))
        }

        function y(e) {
            var t, n, r = "0123456789abcdef",
                i = "";
            for (n = 0; n < e.length; n += 1) t = e.charCodeAt(n), i += r.charAt(t >>> 4 & 15) + r.charAt(15 & t);
            return i
        }

        function _(e) {
            return unescape(encodeURIComponent(e))
        }

        function A(e) {
            return m(_(e))
        }

        function x(e) {
            return y(A(e))
        }

        function C(e, t) {
            return v(_(e), _(t))
        }

        function I(e, t) {
            return y(C(e, t))
        }

        function w(e, t, n) {
            return t ? (n ? C : I)(t, e) : (n ? A : x)(e)
        }
        var M = a;
        t.default = M
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(16)),
            o = r(n(2)),
            s = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(7)),
            d = r(n(21)),
            f = function (e) {
                function r(e, t) {
                    var n;
                    return (0, o.default)(this, r), n = (0, l.default)(this, (0, u.default)(r).call(this, t.eid, d.default.FLOOR)), n._parseData = null, n._isInitMesh = !0, n._visible = !0, n._renderNode = null, n._geometry = void 0, n.bdata = t, n.gdata = e, n
                }
                return (0, h.default)(r, e), (0, s.default)(r, [{
                    key: "initMesh",
                    value: function (e, t, n, r) {
                        this._geometry && (this._renderNode = new fm.Mesh(this._geometry.geometry, e), this._renderNode.mapNode = this, e.color = new fm.Color(n), r = (0, a.default)(r), e.opacity = r, e.userData.opacity = r, e.transparent = !0, this._renderNode.scale.set(1, -1, 1), this._renderNode.rotation.set(Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.copy(t), this._renderNode.frustumCulled = !1, this._renderNode.parent = this.parent.scene, this._renderNode.visible = this.show, this._renderNode.receiveShadow = !0, this.renderNodeInited = !0, this._renderNode.name = "oneExtent", this._geometry = null)
                    }
                }, {
                    key: "setByTheme",
                    value: function (e) {
                        this._renderNode && (this._renderNode.material.color = new fm.Color(e.floorColor), this._renderNode.material.alpha = e.floorOpacity, this._renderNode.material.userData.opacity = e.floorOpacity)
                    }
                }, {
                    key: "checkByFrustum",
                    value: function () {
                        var e = !0;
                        this._renderNode && this._renderNode.updateMatrixWorld(!0), this.visible = e
                    }
                }, {
                    key: "releaseGpuMemory",
                    value: function () {
                        this.renderNode && (this._geometry = null, this.renderNodeInited = !1, this.renderNode.parent.remove(this.renderNode), this.dispose())
                    }
                }, {
                    key: "restoreGpuMemeory",
                    value: function () {}
                }, {
                    key: "getBbox",
                    value: function () {}
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "isInitMesh",
                    set: function (e) {
                        this._isInitMesh = e
                    },
                    get: function () {
                        return this._isInitMesh
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : (this._renderNode && this.parent.scene.remove(this._renderNode), this._renderNode.parent = this.parent.scene), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    },
                    set: function (e) {
                        this._renderNode = e
                    }
                }]), r
            }(c.default),
            p = f;
        t.default = p
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(211)),
            d = r(n(81)),
            f = (r(n(20)), function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, "externalModelLayer")), n._scene = new fm.Scene, n._scene, n._scene.userData.type = "externalModel", n.alias = "externalModel", n._models = {}, n.initNode(e, t), n._visible = !0, n.initLight(), n.putLight(), n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "initNode",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) this.createNode(e[n], t[n])
                    }
                }, {
                    key: "createNode",
                    value: function (e, t) {
                        var n = new c.default(e, t);
                        n.parent = this, this._models["" + n.eid] = n
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._models["" + e.eid] = e
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._models) e && e(this._models[t])
                    }
                }, {
                    key: "initLight",
                    value: function () {
                        this._target = new fm.Object3D, this._mainLight = new fm.DirectionalLight(8947848, 1.2), this._mainLight.position.set(-1, 1, 1).normalize(), this._mainLight.target = this._target, this._secondLight = new fm.DirectionalLight(3355443), this._secondLight.position.set(-.5, 1, -1).normalize(), this._secondLight.target = this._target
                    }
                }, {
                    key: "putLight",
                    value: function () {
                        d.default.light ? this._ambientLight = new fm.AmbientLight(4210752) : (this._ambientLight = new fm.AmbientLight(16777215, .46), this.scene.add(this._mainLight), this.scene.add(this._secondLight), this.scene.add(this._target)), this.scene.add(this._ambientLight), this.scene.removeLight = function () {}
                    }
                }, {
                    key: "removeLight",
                    value: function () {
                        this.scene.remove(this._mainLight), this.scene.remove(this._ambientLight), this.scene.remove(this._secondLight), this.scene.add(this._target)
                    }
                }, {
                    key: "disposeLight",
                    value: function () {
                        this._mainLight = void 0, this._ambientLight = void 0
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._models["" + e]
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._models) this._models[e].visible && this._models[e].renderNode && this._scene.add(this._models[e].renderNode);
                        this.putLight()
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._models) this._models[e].dispose(), this._scene.remove(this._models[e].renderNode), this._models[e].parent = void 0, this._models[e] = void 0;
                        this.removeLight(), this.disposeLight(), this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), r
            }(h.default)),
            p = f;
        t.default = p
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(212)),
            d = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, "modelLayer")), n._scene = new fm.Scene, n._scene.name = "model", n._scene.userData.type = "model", n.alias = "model", n._models = {}, n.initNode(e, t), n._visible = !0, n.initLight(), n.putLight(), n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "initNode",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) this.createNode(e[n], t[n])
                    }
                }, {
                    key: "createNode",
                    value: function (e, t) {
                        var n = new c.default(e, t);
                        n.parent = this, this._models["" + n.eid] = n
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        e.parent = this, e.renderNode && this._scene.add(e.renderNode), this._models["" + e.eid] = e
                    }
                }, {
                    key: "removeNode",
                    value: function (e) {
                        e.renderNode && this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "traverse",
                    value: function (e) {
                        for (var t in this._models) e && e(this._models[t])
                    }
                }, {
                    key: "initLight",
                    value: function () {
                        this._ambientLight = new fm.AmbientLight(7631988), this._target = new fm.Object3D, this._mainLight = new fm.DirectionalLight(8947848, 1.2), this._mainLight.name = "directionalLight", this._mainLight.position.set(-1, 1, 1).normalize(), this._mainLight.target = this._target, this._secondLight = new fm.DirectionalLight(3355443), this._secondLight.position.set(-.5, 1, -1).normalize(), this._secondLight.target = this._target
                    }
                }, {
                    key: "putLight",
                    value: function () {
                        var e = this;
                        this.scene.add(this._mainLight), this.scene.add(this._secondLight), this.scene.add(this._ambientLight), this.scene.add(this._target), this.scene.removeLight = function () {
                            e.removeLight()
                        }
                    }
                }, {
                    key: "removeLight",
                    value: function () {
                        this.scene.remove(this._mainLight), this.scene.remove(this._ambientLight), this.scene.remove(this._secondLight)
                    }
                }, {
                    key: "disposeLight",
                    value: function () {
                        this._mainLight = void 0, this._ambientLight = void 0
                    }
                }, {
                    key: "getNodeById",
                    value: function (e) {
                        return this._models["" + e]
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        for (var e in this._scene.children.length = 0, this._models) this._models[e].visible && this._models[e].renderNode && this._scene.add(this._models[e].renderNode);
                        this.putLight()
                    }
                }, {
                    key: "getAllMesh",
                    value: function () {
                        var e = [];
                        for (var t in this._models) this._models[t].renderNode && e.push(this._models[t].renderNode);
                        return e
                    }
                }, {
                    key: "getVideoMemoryAmount",
                    value: function () {
                        var t = null;
                        return this.traverse(function (e) {
                            e._renderNode && e._renderNode.geometry && e._renderNode.geometry._bufferGeometry && (t += e._renderNode.geometry._bufferGeometry.attributes.position.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.color.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.normal.array.byteLength, t += e._renderNode.geometry._bufferGeometry.attributes.uv.array.byteLength)
                        }), t
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e in this._models) this._models[e].dispose(), this._scene.remove(this._models[e].renderNode), this._models[e].parent = void 0, this._models[e] = void 0;
                        this.removeLight(), this.disposeLight(), this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    },
                    set: function (e) {
                        this._visible = e, this.parent && this.parent.parent && this.parent.parent.parent && this.parent.parent.parent.map.setRenderList()
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), r
            }(h.default),
            f = d;
        t.default = f
    }, function (e, t, n) {
        e.exports = n(386)
    }, function (e, t, n) {
        n(387), e.exports = 9007199254740991
    }, function (e, t, n) {
        var r = n(10);
        r(r.S, "Number", {
            MAX_SAFE_INTEGER: 9007199254740991
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e._scene = new fm.Scene, e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this.visible
                    },
                    set: function (e) {
                        this.visible = e
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e._scene = new fm.Scene, e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "checkSceneNode",
                    value: function () {}
                }, {
                    key: "dispose",
                    value: function () {}
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var l = r(n(2)),
            u = r(n(4)),
            h = r(n(5)),
            a = r(n(6)),
            c = r(n(223)),
            o = function (e) {
                function s(e, t, n) {
                    var r;
                    if ((0, l.default)(this, s), r = (0, u.default)(this, (0, h.default)(s).call(this, e, t)), n) {
                        var i = new c.default,
                            a = i.createGeometry(1.5, 20, 24, .5),
                            o = new fm.BufferGeometry;
                        o.addAttribute("position", new fm.Float32BufferAttribute(a.vertice, 3)), o.addAttribute("uv", new fm.Float32BufferAttribute(a.uv, 2)), o.setIndex(new fm.Uint16BufferAttribute(a.index, 1)), r.geometry = o, r.material = new fm.MeshBasicMaterial({
                            map: n,
                            depthTest: !1
                        }), r.material.side = 2, r.material.transparent = !0
                    }
                    return r
                }
                return (0, a.default)(s, e), s
            }(fm.Mesh),
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(7)),
            h = function (e) {
                function t() {
                    return (0, a.default)(this, t), (0, o.default)(this, (0, s.default)(t).call(this))
                }
                return (0, l.default)(t, e), t
            }(u.default),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, s.default)(this, (0, l.default)(t).call(this)), e._scene = new fm.Scene, e._scene.name = "waterMarker", e._scene.userData.type = "waterMarker", e._visible = !0, e.waters = [], e.initLight(), e.putLight(), e
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "addMarker",
                    value: function (e) {
                        e.parent = this, e.isInitWater || (e.initWater(), e.renderNode && (this.waters.push(e), this._scene.add(e.renderNode), e.floorNode && this._scene.add(e.floorNode)))
                    }
                }, {
                    key: "removeMarker",
                    value: function (e) {
                        if (!e.renderNode) return !1;
                        for (var t = 0; t < this.waters.length; t++)
                            if (this.waters[t].renderNode.uuid === e.renderNode.uuid) {
                                this.waters.splice(t, 1);
                                break
                            } this._scene.remove(e.renderNode)
                    }
                }, {
                    key: "removeAll",
                    value: function () {
                        for (var e = 0; e < this.waters.length; e++) this._scene.remove(this.waters[e].renderNode);
                        this.waters = []
                    }
                }, {
                    key: "checkSceneNode",
                    value: function () {
                        this._scene.children.length = 0;
                        for (var e = 0; e < this.waters.length; e++) this.waters[e].visible && this.waters[e].renderNode && this._scene.add(this.waters[e].renderNode)
                    }
                }, {
                    key: "initLight",
                    value: function () {
                        this._ambientLight = new fm.AmbientLight(7631988), this._target = new fm.Object3D, this._mainLight = new fm.DirectionalLight(8947848, 1.2), this._mainLight.position.set(-1, 1, 1).normalize(), this._mainLight.target = this._target, this._secondLight = new fm.DirectionalLight(3355443), this._secondLight.position.set(-.5, 1, -1).normalize(), this._secondLight.target = this._target
                    }
                }, {
                    key: "putLight",
                    value: function () {
                        var e = this;
                        this.scene.add(this._mainLight), this.scene.add(this._ambientLight), this.scene.add(this._secondLight), this.scene.add(this._target), this.scene.removeLight = function () {
                            e.removeLight()
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        for (var e = 0; e < this.waters.length; e++) this._scene.remove(this.waters[e].renderNode), this.waters[e].parent = void 0, this.waters[e] = void 0;
                        this._scene.length = 0, this._scene = void 0
                    }
                }, {
                    key: "scene",
                    get: function () {
                        return this._scene
                    }
                }, {
                    key: "visible",
                    get: function () {
                        return this._visible
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(55);
        var h = r(n(47)),
            c = r(n(2)),
            o = r(n(3)),
            a = 1e-5,
            y = 0,
            _ = 1,
            A = 2,
            x = 3,
            s = function () {
                function u(e) {
                    (0, c.default)(this, u);
                    var t, n, r, i, a, o, s, l = [];
                    if (this.Polygon = d, this.Vertex = f, this.Node = p, e instanceof fm.Geometry) this.matrix = new fm.Matrix4;
                    else {
                        if (!(e instanceof fm.Mesh)) {
                            if (e instanceof p) return this.tree = e, this.matrix = new fm.Matrix4, this;
                            throw "ThreeBSP: Given geometry is unsupported"
                        }
                        e.updateMatrix(), this.matrix = e.matrix.clone(), e = e.geometry
                    }
                    for (t = 0, n = e.faces.length; t < n; t++) {
                        if (r = e.faces[t], a = e.faceVertexUvs[0][t], s = new d, r instanceof fm.Face3) i = e.vertices[r.a], o = a ? new fm.Vector2(a[0].x, a[0].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[0], o), i.applyMatrix4(this.matrix), s.vertices.push(i), i = e.vertices[r.b], o = a ? new fm.Vector2(a[1].x, a[1].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[1], o), i.applyMatrix4(this.matrix), s.vertices.push(i), i = e.vertices[r.c], o = a ? new fm.Vector2(a[2].x, a[2].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[2], o), i.applyMatrix4(this.matrix), s.vertices.push(i);
                        else {
                            if (!(0, h.default)(fm.Face4)) throw "Invalid face type at index " + t;
                            i = e.vertices[r.a], o = a ? new fm.Vector2(a[0].x, a[0].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[0], o), i.applyMatrix4(this.matrix), s.vertices.push(i), i = e.vertices[r.b], o = a ? new fm.Vector2(a[1].x, a[1].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[1], o), i.applyMatrix4(this.matrix), s.vertices.push(i), i = e.vertices[r.c], o = a ? new fm.Vector2(a[2].x, a[2].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[2], o), i.applyMatrix4(this.matrix), s.vertices.push(i), i = e.vertices[r.d], o = a ? new fm.Vector2(a[3].x, a[3].y) : null, i = new f(i.x, i.y, i.z, r.vertexNormals[3], o), i.applyMatrix4(this.matrix), s.vertices.push(i)
                        }
                        s.calculateProperties(), l.push(s)
                    }
                    this.tree = new p(l)
                }
                return (0, o.default)(u, [{
                    key: "subtract",
                    value: function (e) {
                        var t = this.tree.clone(),
                            n = e.tree.clone();
                        return t.invert(), t.clipTo(n), n.clipTo(t), n.invert(), n.clipTo(t), n.invert(), t.build(n.allPolygons()), t.invert(), t = new u(t), t.matrix = this.matrix, t
                    }
                }, {
                    key: "union",
                    value: function (e) {
                        var t = this.tree.clone(),
                            n = e.tree.clone();
                        return t.clipTo(n), n.clipTo(t), n.invert(), n.clipTo(t), n.invert(), t.build(n.allPolygons()), t = new u(t), t.matrix = this.matrix, t
                    }
                }, {
                    key: "intersect",
                    value: function (e) {
                        var t = this.tree.clone(),
                            n = e.tree.clone();
                        return t.invert(), n.clipTo(t), n.invert(), t.clipTo(n), n.clipTo(t), t.build(n.allPolygons()), t.invert(), t = new u(t), t.matrix = this.matrix, t
                    }
                }, {
                    key: "toGeometry",
                    value: function () {
                        var e, t, n, r, i, a, o, s, l, u, h = (new fm.Matrix4).getInverse(this.matrix),
                            c = new fm.Geometry,
                            d = this.tree.allPolygons(),
                            f = d.length,
                            p = {};
                        for (e = 0; e < f; e++)
                            for (n = d[e], r = n.vertices.length, t = 2; t < r; t++) u = [], s = n.vertices[0], u.push(new fm.Vector2(s.uv.x, s.uv.y)), s = new fm.Vector3(s.x, s.y, s.z), s.applyMatrix4(h), i = void 0 !== p[s.x + "," + s.y + "," + s.z] ? p[s.x + "," + s.y + "," + s.z] : (c.vertices.push(s), p[s.x + "," + s.y + "," + s.z] = c.vertices.length - 1), s = n.vertices[t - 1], u.push(new fm.Vector2(s.uv.x, s.uv.y)), s = new fm.Vector3(s.x, s.y, s.z), s.applyMatrix4(h), a = void 0 !== p[s.x + "," + s.y + "," + s.z] ? p[s.x + "," + s.y + "," + s.z] : (c.vertices.push(s), p[s.x + "," + s.y + "," + s.z] = c.vertices.length - 1), s = n.vertices[t], u.push(new fm.Vector2(s.uv.x, s.uv.y)), s = new fm.Vector3(s.x, s.y, s.z), s.applyMatrix4(h), o = void 0 !== p[s.x + "," + s.y + "," + s.z] ? p[s.x + "," + s.y + "," + s.z] : (c.vertices.push(s), p[s.x + "," + s.y + "," + s.z] = c.vertices.length - 1), l = new fm.Face3(i, a, o, new fm.Vector3(n.normal.x, n.normal.y, n.normal.z)), c.faces.push(l), c.faceVertexUvs[0].push(u);
                        return c
                    }
                }, {
                    key: "toMesh",
                    value: function (e) {
                        var t = this.toGeometry(),
                            n = new fm.Mesh(t, e);
                        return n.position.setFromMatrixPosition(this.matrix), n.rotation.setFromRotationMatrix(this.matrix), n
                    }
                }]), u
            }();
        t.default = s;
        var d = function () {
                function v(e) {
                    (0, c.default)(this, v), e instanceof Array || (e = []), this.vertices = e, 0 < e.length ? this.calculateProperties() : this.normal = this.w = void 0
                }
                return (0, o.default)(v, [{
                    key: "calculateProperties",
                    value: function () {
                        var e = this.vertices[0],
                            t = this.vertices[1],
                            n = this.vertices[2];
                        return this.normal = t.clone().subtract(e).cross(n.clone().subtract(e)).normalize(), this.w = this.normal.clone().dot(e), this
                    }
                }, {
                    key: "clone",
                    value: function () {
                        var e, t, n = new v;
                        for (e = 0, t = this.vertices.length; e < t; e++) n.vertices.push(this.vertices[e].clone());
                        return n.calculateProperties(), n
                    }
                }, {
                    key: "flip",
                    value: function () {
                        var e, t = [];
                        for (this.normal.multiplyScalar(-1), this.w *= -1, e = this.vertices.length - 1; 0 <= e; e--) t.push(this.vertices[e]);
                        return this.vertices = t, this
                    }
                }, {
                    key: "classifyVertex",
                    value: function (e) {
                        var t = this.normal.dot(e) - this.w;
                        return t < -a ? A : a < t ? _ : y
                    }
                }, {
                    key: "classifySide",
                    value: function (e) {
                        var t, n, r, i = 0,
                            a = 0,
                            o = e.vertices.length;
                        for (t = 0; t < o; t++) n = e.vertices[t], r = this.classifyVertex(n), r === _ ? i++ : r === A && a++;
                        return i === o && 0 === a ? _ : 0 === i && a === o ? A : 0 < i && 0 < a ? x : y
                    }
                }, {
                    key: "splitPolygon",
                    value: function (e, t, n, r, i) {
                        var a = this.classifySide(e);
                        if (a === y)(0 < this.normal.dot(e.normal) ? t : n).push(e);
                        else if (a === _) r.push(e);
                        else if (a === A) i.push(e);
                        else {
                            var o, s, l, u, h, c, d, f, p, g = [],
                                m = [];
                            for (s = 0, o = e.vertices.length; s < o; s++) l = (s + 1) % o, c = e.vertices[s], d = e.vertices[l], u = this.classifyVertex(c), h = this.classifyVertex(d), u != A && g.push(c), u != _ && m.push(c), (u | h) === x && (f = (this.w - this.normal.dot(c)) / this.normal.dot(d.clone().subtract(c)), p = c.interpolate(d, f), g.push(p), m.push(p));
                            3 <= g.length && r.push(new v(g).calculateProperties()), 3 <= m.length && i.push(new v(m).calculateProperties())
                        }
                    }
                }]), v
            }(),
            f = function () {
                function a(e, t, n, r, i) {
                    (0, c.default)(this, a), this.x = e, this.y = t, this.z = n, this.normal = r || new fm.Vector3, this.uv = i || new fm.Vector2
                }
                return (0, o.default)(a, [{
                    key: "clone",
                    value: function () {
                        return new a(this.x, this.y, this.z, this.normal.clone(), this.uv.clone())
                    }
                }, {
                    key: "add",
                    value: function (e) {
                        return this.x += e.x, this.y += e.y, this.z += e.z, this
                    }
                }, {
                    key: "subtract",
                    value: function (e) {
                        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                    }
                }, {
                    key: "multiplyScalar",
                    value: function (e) {
                        return this.x *= e, this.y *= e, this.z *= e, this
                    }
                }, {
                    key: "cross",
                    value: function (e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z;
                        return this.x = n * e.z - r * e.y, this.y = r * e.x - t * e.z, this.z = t * e.y - n * e.x, this
                    }
                }, {
                    key: "normalize",
                    value: function () {
                        var e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                        return this.x /= e, this.y /= e, this.z /= e, this
                    }
                }, {
                    key: "dot",
                    value: function (e) {
                        return this.x * e.x + this.y * e.y + this.z * e.z
                    }
                }, {
                    key: "lerp",
                    value: function (e, t) {
                        return this.add(e.clone().subtract(this).multiplyScalar(t)), this.normal.add(e.normal.clone().sub(this.normal).multiplyScalar(t)), this.uv.add(e.uv.clone().sub(this.uv).multiplyScalar(t)), this
                    }
                }, {
                    key: "interpolate",
                    value: function (e, t) {
                        return this.clone().lerp(e, t)
                    }
                }, {
                    key: "applyMatrix4",
                    value: function (e) {
                        var t = this.x,
                            n = this.y,
                            r = this.z,
                            i = e.elements;
                        return this.x = i[0] * t + i[4] * n + i[8] * r + i[12], this.y = i[1] * t + i[5] * n + i[9] * r + i[13], this.z = i[2] * t + i[6] * n + i[10] * r + i[14], this
                    }
                }]), a
            }(),
            p = function () {
                function a(e) {
                    (0, c.default)(this, a);
                    var t, n, r = [],
                        i = [];
                    if (this.polygons = [], this.front = this.back = void 0, e instanceof Array && 0 !== e.length) {
                        for (this.divider = e[0].clone(), t = 0, n = e.length; t < n; t++) this.divider.splitPolygon(e[t], this.polygons, this.polygons, r, i);
                        0 < r.length && (this.front = new a(r)), 0 < i.length && (this.back = new a(i))
                    }
                }
                return (0, o.default)(a, [{
                    key: "isConvex",
                    value: function (e) {
                        var t, n;
                        for (t = 0; t < e.length; t++)
                            for (n = 0; n < e.length; n++)
                                if (t !== n && e[t].classifySide(e[n]) !== A) return !1;
                        return !0
                    }
                }, {
                    key: "build",
                    value: function (e) {
                        var t, n, r = [],
                            i = [];
                        for (this.divider || (this.divider = e[0].clone()), t = 0, n = e.length; t < n; t++) this.divider.splitPolygon(e[t], this.polygons, this.polygons, r, i);
                        0 < r.length && (this.front || (this.front = new a), this.front.build(r)), 0 < i.length && (this.back || (this.back = new a), this.back.build(i))
                    }
                }, {
                    key: "allPolygons",
                    value: function () {
                        var e = this.polygons.slice();
                        return this.front && (e = e.concat(this.front.allPolygons())), this.back && (e = e.concat(this.back.allPolygons())), e
                    }
                }, {
                    key: "clone",
                    value: function () {
                        var e = new a;
                        return e.divider = this.divider.clone(), e.polygons = this.polygons.map(function (e) {
                            return e.clone()
                        }), e.front = this.front && this.front.clone(), e.back = this.back && this.back.clone(), e
                    }
                }, {
                    key: "invert",
                    value: function () {
                        var e, t, n;
                        for (e = 0, t = this.polygons.length; e < t; e++) this.polygons[e].flip();
                        return this.divider.flip(), this.front && this.front.invert(), this.back && this.back.invert(), n = this.front, this.front = this.back, this.back = n, this
                    }
                }, {
                    key: "clipPolygons",
                    value: function (e) {
                        var t, n, r, i;
                        if (!this.divider) return e.slice();
                        for (r = [], i = [], t = 0, n = e.length; t < n; t++) this.divider.splitPolygon(e[t], r, i, r, i);
                        return this.front && (r = this.front.clipPolygons(r)), i = this.back ? this.back.clipPolygons(i) : [], r.concat(i)
                    }
                }, {
                    key: "clipTo",
                    value: function (e) {
                        this.polygons = e.clipPolygons(this.polygons), this.front && this.front.clipTo(e), this.back && this.back.clipTo(e)
                    }
                }]), a
            }()
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(395), n(68);
        var Y = r(n(11));
        n(199), n(110);
        var H = r(n(27)),
            q = r(n(12));
        n(13);
        var X = r(n(16)),
            a = r(n(2)),
            o = r(n(3)),
            Z = r(n(57)),
            s = n(396),
            l = n(397),
            u = function () {
                function t(e) {
                    (0, a.default)(this, t), this._data = {}, this._textureData = {}, this._textureArray = [], this.font = e, this._textData = {}, this.extrudeMaterial = {}
                }
                return (0, o.default)(t, [{
                    key: "createBasicMaterial",
                    value: function (e) {
                        var t = new fm.MeshBasicMaterial;
                        return e ? (t.color = new fm.Color(e.color), t.transparent = !0, t.depthWrite = !0, t.opacity = (0, X.default)(e.alpha), t.userData.opacity = (0, X.default)(e.alpha)) : t.userData.opacity = 1, t
                    }
                }, {
                    key: "createNormalMaterial",
                    value: function (e) {
                        var t = new fm.MeshLambertMaterial;
                        return e ? (t.color = new fm.Color(e.color), t.transparent = !0, t.depthWrite = !0, t.opacity = (0, X.default)(e.alpha), t.userData.opacity = (0, X.default)(e.alpha)) : t.userData.opacity = 1, t
                    }
                }, {
                    key: "createPhysicMaterial",
                    value: function (e) {
                        var t = new fm.MeshStandardMaterial({
                            roughness: .5,
                            metalness: .5
                        });
                        return e ? (t.color = new fm.Color(e.color), t.transparent = !0, t.depthWrite = !0, t.opacity = (0, X.default)(e.alpha), t.userData.opacity = (0, X.default)(e.alpha)) : t.userData.opacity = 1, t
                    }
                }, {
                    key: "createMeshPhongMaterial",
                    value: function (e) {
                        var t = new fm.MeshPhongMaterial({
                            shininess: 50,
                            specular: 16777215
                        });
                        return e ? (t.color = new fm.Color(e.color), t.transparent = !0, t.depthWrite = !0, t.opacity = (0, X.default)(e.alpha), t.userData.opacity = (0, X.default)(e.alpha)) : t.userData.opacity = 1, t
                    }
                }, {
                    key: "createLineMaterial",
                    value: function (e) {
                        if (!e) return new fm.LineBasicMaterial({
                            color: "#ff0000",
                            linewidth: 1,
                            transparent: !0,
                            opacity: 1
                        });
                        var t = "#ff0000";
                        t = "number" == typeof e.strokeColor || e.strokeColor ? e.strokeColor : "#ff0000";
                        var n = {
                                color: t,
                                linewidth: 1,
                                transparent: !0,
                                opacity: (0, X.default)(e.alpha)
                            },
                            r = new fm.LineBasicMaterial(n);
                        return r.userData.opacity = (0, X.default)(e.alpha), r
                    }
                }, {
                    key: "createPoiMaterial",
                    value: function (t, n, e, r) {
                        var i = this,
                            a = new fm.SpriteMaterial;
                        if (a.sizeAttenuation = !1, a.opacity = 1, a.userData.opacity = 1, a.depthTest = !!e, a.depthWrite = !!e, a.transparent = !0, a.side = 2, a.priority = r, a.visible = !1, this._textureData[t.imageUrl]) {
                            var o = this._textureData[t.imageUrl];
                            o.minFilter = fm.LinearFilter, o.generateMipmaps = !1, o.needsUpdate = !0, a.map = o, a.needsUpdate = !0, a.userData.scaleRatio = o.scaleRatio, a.visible = !0, n && n()
                        } else {
                            var s = new Image;
                            s.crossOrigin = "Anonymous";
                            var l = navigator.userAgent,
                                u = /(msie\s|trident.*rv:)([\w.]+)/,
                                h = u.exec(l.toLowerCase());
                            s.onload = null !== h ? new function () {
                                var e = new fm.Texture(s);
                                e.minFilter = fm.LinearFilter, e.generateMipmaps = !1, e.needsUpdate = !0, e.scaleRatio = s.width / s.height, a.userData.scaleRatio = e.scaleRatio, a.map = e, a.needsUpdate = !0, a.visible = !0, i._textureData[t.imageUrl] = e, i._textureArray.push(e), n && n()
                            } : function () {
                                var e = new fm.Texture(s);
                                e.minFilter = fm.LinearFilter, e.generateMipmaps = !1, e.needsUpdate = !0, e.scaleRatio = s.width / s.height, a.userData.scaleRatio = e.scaleRatio, a.map = e, a.needsUpdate = !0, a.visible = !0, i._textureData[t.imageUrl] = e, i._textureArray.push(e), n && n()
                            }, s.src = t.imageSrc
                        }
                        return a
                    }
                }, {
                    key: "createLabelMaterial",
                    value: function (t, n, e) {
                        var r = this,
                            i = new fm.SpriteMaterial;
                        if (i.sizeAttenuation = !1, i.opacity = (0, X.default)(n.alpha), i.userData.opacity = (0, X.default)(n.alpha), i.depthTest = !!e, i.depthWrite = !!e, i.transparent = !0, i.side = 2, i.opacity = 1, i.visible = !1, n.imageSrc)
                            if (this._data[n.imageUrl]) {
                                var a = this._data[n.imageUrl],
                                    o = this.excuteLabelTexture(t, a, n);
                                i.map = o, this._textureArray.push(o), i.userData.scaleRatio = i.map.scaleRatio, i.userData.mspriteScale = i.map.mspriteScale, i.needsUpdate = !0, i.visible = !0
                            } else {
                                var s = new Image,
                                    l = r.excuteLabelTexture(t, !0, n, !0);
                                s.crossOrigin = "Anonymous", i.userData.scaleRatio = l.scaleRatio, i.userData.mspriteScale = l.mspriteScale;
                                var u = navigator.userAgent,
                                    h = /(msie\s|trident.*rv:)([\w.]+)/,
                                    c = h.exec(u.toLowerCase());
                                s.onload = null !== c ? new function () {
                                    var e = r.excuteLabelTexture(t, s, n);
                                    i.map = e, r._textureArray.push(e), i.needsUpdate = !0, i.visible = !0, r._data[n.imageUrl] = s
                                } : function () {
                                    var e = r.excuteLabelTexture(t, s, n);
                                    i.map = e, r._textureArray.push(e), i.needsUpdate = !0, i.visible = !0, r._data[n.imageUrl] = s
                                }, s.src = n.imageSrc
                            }
                        else {
                            var d = this.excuteLabelTexture(t, !1, n);
                            i.map = d, this._textureArray.push(d), i.userData.scaleRatio = i.map.scaleRatio, i.userData.mspriteScale = i.map.mspriteScale, i.needsUpdate = !0, i.visible = !0
                        }
                        return i
                    }
                }, {
                    key: "excuteSDFLabelTexture",
                    value: function (e, t, n, r) {
                        var i = 1,
                            a = 1.5 * i,
                            o = 12 * i,
                            s = 2 * i;
                        t || (o = 0, s = 0);
                        var l = 2 * i,
                            u = 3 * i,
                            h = 3 * i,
                            c = 14 * i,
                            d = 1,
                            f = 2 * i,
                            p = document.createElement("canvas"),
                            g = p.getContext("2d"),
                            m = this.font.family;
                        g.font = c + "px " + m;
                        var v, y, _, A = -1 < e.indexOf("%rn%");
                        if (A) {
                            _ = e.split("%rn%");
                            var x = 0,
                                C = 0,
                                I = !0,
                                w = !1,
                                M = void 0;
                            try {
                                for (var b, S = (0, q.default)(_); !(I = (b = S.next()).done); I = !0) {
                                    var E = b.value;
                                    x = Math.max(g.measureText(E).width, x), C += c
                                }
                            } catch (e) {
                                w = !0, M = e
                            } finally {
                                try {
                                    I || null == S.return || S.return()
                                } finally {
                                    if (w) throw M
                                }
                            }
                            C += (_.length - 1) * l, d = _.length, v = x + s + o + 2 * h, y = Math.max(C, o) + 2 * u
                        } else {
                            var T = g.measureText(e).width;
                            v = T + s + o + 2 * h, y = Math.max(c, o) + 2 * u
                        }
                        if (r) return {
                            scaleRatio: y / v,
                            mspriteScale: d
                        };
                        if (p.width = v, p.height = y, p.style.width = v + "px", p.style.height = y + "px", n.platecolor || n.platestrokecolor) {
                            var L = n.platecolor.split(",");
                            if (n.platecolor && (g.fillStyle = "rgb(".concat((0, H.default)(L[0]), ",").concat((0, H.default)(L[1]), ",").concat((0, H.default)(L[2]), ")")), g.lineWidth = i, this.drawRadiuRect(g, v, y, 5 * i, {
                                    x: 0,
                                    y: 0
                                }), n.platecolor && g.fill(), n.platestrokecolor) {
                                var N = n.platestrokecolor.split(",");
                                g.strokeStyle = "rgb(".concat((0, H.default)(N[0]), ",").concat((0, H.default)(N[1]), ",").concat((0, H.default)(N[2]), ")"), g.stroke()
                            }
                            g.beginPath()
                        }
                        var R = o + s,
                            k = (y - o) / 2,
                            P = (y - c) / 2;
                        g.font = c + "px " + m, g.textBaseline = "top", g.strokeStyle = Z.default.toRgba(n.strokecolor), g.lineWidth = f;
                        var D = 0,
                            O = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
                            F = navigator.vendor && -1 < navigator.vendor.indexOf("Apple") && navigator.userAgent && -1 == navigator.userAgent.indexOf("CriOS") && -1 == navigator.userAgent.indexOf("FxiOS");
                        if ((-1 < navigator.userAgent.indexOf("Edge") || O || F) && (D = -4), D *= i, A)
                            for (var B = u, G = 0; G < _.length; G++) G && (B += c + l), g.strokeText(_[G], R, B);
                        else g.strokeText(e, R, P + a + D);
                        if (g.fillStyle = Z.default.toRgba(n.fillcolor), A)
                            for (var U = u, z = 0; z < _.length; z++) z && (U += c + l), g.fillText(_[z], R, U);
                        else g.fillText(e, R, P + a + D);
                        t && g.drawImage(t, 0, k, o, o);
                        var V = new fm.CanvasTexture(p);
                        return V.minFilter = fm.LinearFilter, V.generateMipmaps = !1, V.scaleRatio = p.height / p.width, V.mspriteScale = d, V
                    }
                }, {
                    key: "excuteLabelTexture",
                    value: function (e, t, n, r) {
                        n = (0, Y.default)({}, n);
                        var i = 2,
                            a = 1.5 * i,
                            o = 1.2 * n.fontsize * i,
                            s = 2 * i;
                        t || (o = 0, s = 5 * i);
                        var l = 2 * i,
                            u = 3 * i,
                            h = 3 * i,
                            c = n.fontsize * i * 1.2,
                            d = 1,
                            f = 2 * i,
                            p = document.createElement("canvas"),
                            g = p.getContext("2d"),
                            m = this.font.family;
                        g.font = c + "px " + m;
                        var v, y, _, A = -1 < e.indexOf("%rn%");
                        if (A) {
                            _ = e.split("%rn%");
                            var x = 0,
                                C = 0,
                                I = !0,
                                w = !1,
                                M = void 0;
                            try {
                                for (var b, S = (0, q.default)(_); !(I = (b = S.next()).done); I = !0) {
                                    var E = b.value;
                                    x = Math.max(g.measureText(E).width, x), C += c
                                }
                            } catch (e) {
                                w = !0, M = e
                            } finally {
                                try {
                                    I || null == S.return || S.return()
                                } finally {
                                    if (w) throw M
                                }
                            }
                            C += (_.length - 1) * l, v = x + s + o + 2 * h, y = Math.max(C, o) + 2 * u, d = y / (c + 2 * u)
                        } else {
                            var T = g.measureText(e).width;
                            v = T + s + o + 2 * h, y = Math.max(c, o) + 2 * u
                        }
                        if (r) return {
                            scaleRatio: y / v,
                            mspriteScale: d
                        };
                        p.width = v, p.height = y, p.style.width = v + "px", p.style.height = y + "px", (n.platecolor || n.platestrokecolor) && (n.platecolor && (g.fillStyle = Z.default.toRgba(n.platecolor)), g.lineWidth = i, this.drawRadiuRect(g, v - o, y, 5 * i, {
                            x: 0 + o,
                            y: 0
                        }), n.platecolor && g.fill(), n.platestrokecolor && (g.strokeStyle = Z.default.toRgba(n.platestrokecolor), g.stroke()), g.beginPath());
                        var L = o + s,
                            N = (y - o) / 2,
                            R = (y - c) / 2;
                        g.font = c + "px " + m, g.textBaseline = "top", g.lineWidth = f * (n.strokewidth ? n.strokewidth : 1);
                        var k = 1;
                        n.strokewidth && (k = (0, X.default)(n.strokewidth));
                        var P = 0,
                            D = !1,
                            O = navigator.mimeTypes;
                        for (var F in O) "application/vnd.chromium.remoting-viewer" == O[F].type && (D = !0);
                        D && (P = -4 - (c - 28) / 6);
                        var B = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
                            G = navigator.vendor && -1 < navigator.vendor.indexOf("Apple") && navigator.userAgent && -1 == navigator.userAgent.indexOf("CriOS") && -1 == navigator.userAgent.indexOf("FxiOS");
                        (-1 < navigator.userAgent.indexOf("Edge") || B || G) && (P = -4 - (c - 28) / 6), (-1 < navigator.userAgent.indexOf("QQBrowser") || B || G) && (P = -4 - (c - 28) / 6), (-1 < navigator.userAgent.indexOf(".NET4.0C") || B || G) && (P = -4 - (c - 28) / 6), P *= i;
                        var U = 0;
                        if ("micromessenger" == navigator.userAgent.toLowerCase().match(/MicroMessenger/i) && (U = 10), n.strokecolor && 0 !== k)
                            if (g.strokeStyle = Z.default.toRgba(n.strokecolor), A)
                                for (var z = u, V = 0; V < _.length; V++) V && (z += c + l), t ? g.strokeText(_[V], L, z) : "left" == n.textAlign ? (g.textAlign = "left", g.strokeText(_[V], 0, z)) : "right" == n.textAlign ? (g.textAlign = "right", g.strokeText(_[V], v, z)) : (g.textAlign = "center", g.strokeText(_[V], v / 2, z));
                            else t ? g.strokeText(e, L, R + a + P + U) : "left" == n.textAlign ? g.strokeText(e, 0, R + a + P + U) : "right" == n.textAlign ? (g.textAlign = "right", g.strokeText(e, v, R + a + P + U)) : (g.textAlign = "center", g.strokeText(e, v / 2, R + a + P + U));
                        if (g.fillStyle = Z.default.toRgba(n.fillcolor), A)
                            for (var H = u, W = 0; W < _.length; W++) W && (H += c + l), t ? g.fillText(_[W], L, H) : "left" === n.textAlign ? (g.textAlign = "left", g.fillText(_[W], 0, H)) : "right" === n.textAlign ? (g.textAlign = "right", g.fillText(_[W], v, H)) : (g.textAlign = "center", g.fillText(_[W], v / 2, H));
                        else t ? g.fillText(e, L, R + a + P + U) : "left" == n.textAlign ? (g.textAlign = "left", g.fillText(e, 0, R + a + P + U)) : "right" == n.textAlign ? (g.textAlign = "right", g.fillText(e, v, R + a + P + U)) : (g.textAlign = "center", g.fillText(e, v / 2, R + a + P + U));
                        t && g.drawImage(t, 0, N, o, o);
                        var j = new fm.CanvasTexture(p);
                        return j.minFilter = fm.LinearFilter, j.generateMipmaps = !1, j.scaleRatio = p.height / p.width, j.mspriteScale = d, j
                    }
                }, {
                    key: "createTextMaterial",
                    value: function (e, t) {
                        var n = new fm.SpriteMaterial;
                        n.sizeAttenuation = !1, n.opacity = (0, X.default)(1), n.userData.opacity = (0, X.default)(1), n.depthTest = !1, n.depthWrite = !1, n.transparent = !0, n.side = 2;
                        var r = this.executeTexTexture(e, t);
                        return n.map = r, n.size = r.size, n.userData.scaleRatio = n.map.scaleRatio, n.userData.mspriteScale = n.map.mspriteScale, n.needsUpdate = !0, n
                    }
                }, {
                    key: "executeTexTexture",
                    value: function (e, t, n, r) {
                        this.parent;
                        var i = 2,
                            a = 12 * i,
                            o = 2 * i;
                        n || (a = 0, o = 0);
                        var s, l, u = 2 * i,
                            h = 3 * i,
                            c = 3 * i,
                            d = 1,
                            f = 2 * i,
                            p = document.createElement("canvas"),
                            g = p.getContext("2d"),
                            m = this.font.family,
                            v = 0,
                            y = 0,
                            _ = !0,
                            A = !1,
                            x = void 0;
                        try {
                            for (var C, I = (0, q.default)(e); !(_ = (C = I.next()).done); _ = !0) {
                                var w = C.value,
                                    M = w.fontsize * i;
                                g.font = M + "px " + m, v = Math.max(g.measureText(w.text).width, v), y += M
                            }
                        } catch (e) {
                            A = !0, x = e
                        } finally {
                            try {
                                _ || null == I.return || I.return()
                            } finally {
                                if (A) throw x
                            }
                        }
                        if (y += (e.length - 1) * u, d = e.length, s = v + o + a + 2 * c, l = Math.max(y, a) + 2 * h, r) return {
                            scaleRatio: l / s,
                            mspriteScale: d
                        };
                        p.width = s, p.height = l, p.style.width = s + "px", p.style.height = l + "px", t.platecolor && (g.fillStyle = Z.default.toRgba(t.platecolor), g.lineWidth = i, this.drawRadiuRect(g, s, l, 5 * i, {
                            x: 0,
                            y: 0
                        }), g.fill(), t.platestrokecolor && (g.strokeStyle = Z.default.toRgba(t.platestrokecolor), g.stroke()), g.beginPath());
                        var b = 4,
                            S = !1,
                            E = navigator.mimeTypes;
                        for (var T in E) "application/vnd.chromium.remoting-viewer" == E[T].type && (S = !0);
                        var L = -6;
                        L += 8 * (e.length - 1), S && (b = L - (y - 28) / 6);
                        var N = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),
                            R = navigator.vendor && -1 < navigator.vendor.indexOf("Apple") && navigator.userAgent && -1 == navigator.userAgent.indexOf("CriOS") && -1 == navigator.userAgent.indexOf("FxiOS");
                        (-1 < navigator.userAgent.indexOf("Edge") || N || R) && (b = L - (y - 28) / 6), (-1 < navigator.userAgent.indexOf("QQBrowser") || N || R) && (b = L - (y - 28) / 6), (-1 < navigator.userAgent.indexOf(".NET4.0C") || N || R) && (b = L - (y - 28) / 6), g.textBaseline = "top";
                        for (var k = h, P = 0; P < e.length; P++)
                            if (e[P].strokecolor) {
                                g.lineWidth = f;
                                var D = e[P].fontsize * i;
                                g.font = D + "px " + m, g.strokeStyle = Z.default.toRgba(e[P].strokecolor), P && (k += e[P - 1].fontsize * i + u), 0 == t.textAlign ? (g.textAlign = "left", g.strokeText(e[P].text, 0, k + b)) : 2 == t.textAlign ? (g.textAlign = "right", g.strokeText(e[P].text, s, k + b)) : (g.textAlign = "center", g.strokeText(e[P].text, s / 2, k + b))
                            } k = h;
                        for (var O = 0; O < e.length; O++) {
                            var F = e[O].fontsize * i;
                            g.font = F + "px " + m, g.fillStyle = Z.default.toRgba(e[O].fontcolor), O && (k += e[O - 1].fontsize * i + u), 0 == t.textAlign ? (g.textAlign = "left", g.fillText(e[O].text, 0, k + b)) : 2 == t.textAlign ? (g.textAlign = "right", g.fillText(e[O].text, s, k + b)) : (g.textAlign = "center", g.fillText(e[O].text, s / 2, k + b))
                        }
                        var B = new fm.CanvasTexture(p);
                        B.minFilter = fm.LinearFilter, B.generateMipmaps = !1, B.scaleRatio = p.height / p.width, B.mspriteScale = d;
                        for (var G = 0, U = null, z = 0; z < e.length; z++) G += e[z].fontsize;
                        return U = 1 < e.length ? (G + u * (e.length - 1) + h) / e.length : G + h, B.size = U, B
                    }
                }, {
                    key: "drawRadiuRect",
                    value: function (e, t, n, r, i) {
                        var a = i,
                            o = {
                                x: i.x + t,
                                y: i.y
                            },
                            s = {
                                x: i.x,
                                y: i.y + n
                            },
                            l = {
                                x: i.x + t,
                                y: i.y + n
                            },
                            u = {
                                x: a.x + r,
                                y: a.y
                            },
                            h = {
                                x: o.x - r,
                                y: o.y
                            },
                            c = {
                                x: o.x,
                                y: o.y + r
                            },
                            d = {
                                x: l.x,
                                y: l.y - r
                            },
                            f = {
                                x: l.x - r,
                                y: l.y
                            },
                            p = {
                                x: s.x + r,
                                y: s.y
                            },
                            g = {
                                x: s.x,
                                y: s.y - r
                            },
                            m = {
                                x: a.x,
                                y: a.y + r
                            };
                        e.beginPath(), e.moveTo(u.x, u.y), e.lineTo(h.x, h.y), e.arcTo(o.x, o.y, c.x, c.y, r), e.lineTo(d.x, d.y), e.arcTo(l.x, l.y, f.x, f.y, r), e.lineTo(p.x, p.y), e.arcTo(s.x, s.y, g.x, g.y, r), e.lineTo(m.x, m.y), e.arcTo(a.x, a.y, u.x, u.y, r), e.closePath()
                    }
                }, {
                    key: "measureText",
                    value: function (e, t, n) {
                        var r = document.createElement("div");
                        r.style.fontSize = n + "px", r.style.position = "absolute", r.style.fontStyle = e, r.style.whiteSpace = "nowrap", r.innerHTML = t;
                        var i = {
                            width: r.clientWidth,
                            height: r.clientHeight
                        };
                        return document.body.removeChild(r), i
                    }
                }, {
                    key: "loadTexture",
                    value: function (e, t) {
                        var n = this,
                            r = new fm.Texture;
                        if ("string" != typeof e) return r.image = e, r.needsUpdate = !0, t(r), r;
                        "data" !== e.substring(0, 4) && this._textureData[e] && t(this._textureData[e]);
                        var i = new Image;
                        return i.crossOrigin = "Anonymous", this._textureArray.push(r), i.onload = function () {
                            r.image = i, "data" !== e.substring(0, 4) && (n._textureData[e] = r), r.needsUpdate = !0, t(r)
                        }, i.src = e, r
                    }
                }, {
                    key: "getHeatMapGradient",
                    value: function (e) {
                        var t = document.createElement("canvas"),
                            n = t.getContext("2d"),
                            r = 8,
                            i = 128;
                        t.width = r, t.height = i, t.style.width = r + "px", t.style.height = i + "px";
                        var a = n.createLinearGradient(0, 0, 8, 128);
                        for (var o in e) a.addColorStop(o, e[o]);
                        n.fillStyle = a, n.fillRect(0, 0, 8, 128);
                        var s = new fm.CanvasTexture(t);
                        return this._textureArray.push(s), s
                    }
                }, {
                    key: "createNormalLineTexture",
                    value: function (n) {
                        var e = document.createElement("canvas"),
                            r = e.getContext("2d"),
                            t = n.width,
                            i = n.height;
                        e.width = t, e.height = i, e.style.width = t + "px", e.style.height = i + "px";
                        var a = 0,
                            o = n.dashArray,
                            s = o.reduce(function (e, t) {
                                return e + t
                            }),
                            l = new fm.Matrix3;
                        l.set(Math.cos(Math.PI / 2), -Math.sin(Math.PI / 2), t / 2, Math.sin(Math.PI / 2), Math.cos(Math.PI / 2), i / 2, 0, 0, 1);
                        var u = new fm.Matrix3;
                        u.set(1, 0, -t / 2, 0, 1, -i / 2, 0, 0, 1), l.multiply(u);
                        var h = l.elements;
                        r.transform(h[0], h[3], h[1], h[4], h[2], h[6]), o.forEach(function (e, t) {
                            t % 2 == 0 && (r.fillStyle = n.color, r.fillRect(a / s * n.width, 0, e / s * n.width, n.height)), a += e
                        });
                        var c = new fm.CanvasTexture(e);
                        return c
                    }
                }, {
                    key: "createArrowLineTexture",
                    value: function (e) {
                        var t = e,
                            n = document.createElement("canvas"),
                            r = n.getContext("2d"),
                            i = e.width,
                            a = e.height;
                        n.width = i, n.height = a, n.style.width = i + "px", n.style.height = a + "px";
                        var o = (1 - t.arrowHeightPercent) * t.height / 2,
                            s = t.height * t.arrowHeightPercent,
                            l = new fm.Matrix3;
                        l.set(Math.cos(Math.PI / 2), -Math.sin(Math.PI / 2), i / 2, Math.sin(Math.PI / 2), Math.cos(Math.PI / 2), a / 2, 0, 0, 1);
                        var u = new fm.Matrix3;
                        u.set(1, 0, -i / 2, 0, 1, -a / 2, 0, 0, 1), l.multiply(u);
                        var h = l.elements;
                        r.transform(h[0], h[3], h[1], h[4], h[2], h[6]), r.beginPath(), r.moveTo(0, o);
                        var c = t.width * (t.arrowWidthPercent - t.arrowPercent);
                        r.lineTo(c, o), r.lineTo(t.width * t.arrowWidthPercent, o + s / 2), r.lineTo(c, o + s), r.lineTo(0, o + s), r.lineTo(t.width * t.arrowPercent, o + s / 2), r.closePath(), r.fillStyle = t.color, r.fill();
                        var d = new fm.CanvasTexture(n);
                        return d
                    }
                }, {
                    key: "createArrowWidthBackTexture",
                    value: function (e) {
                        var t = e,
                            n = document.createElement("canvas"),
                            r = n.getContext("2d"),
                            i = e.width,
                            a = e.height;
                        n.width = i, n.height = a, n.style.width = i + "px", n.style.height = a + "px", r.fillStyle = t.godEdgeColor, r.fillRect(0, 0, t.width, t.height);
                        var o = t.width * (1 - t.godEdgePercent);
                        r.fillStyle = t.godColor, r.fillRect((t.width - o) / 2, 0, o, t.height), r.fillStyle = "#ffffff", r.shadowOffsetX = -2, r.shadowOffsetY = 2, r.shadowBlur = 4, r.shadowColor = "rgba(0,0,0,0.5)";
                        var s = {
                                x: t.width / 2,
                                y: t.height / 2
                            },
                            l = t.height * t.godArrowPercent,
                            u = o * t.godArrowWidthPercent,
                            h = t.arrawWidth || 10,
                            c = s.x - u / 2,
                            d = s.y + l / 2;
                        r.beginPath(), r.moveTo(c, d), r.lineTo(c, d + h), r.lineTo(c + u / 2, d - l + h), r.lineTo(c + u, d + h), r.lineTo(c + u, d), r.lineTo(c + u / 2, d - l), r.closePath(), r.fillStyle = t.godArrowColor, r.fill();
                        var f = new fm.CanvasTexture(n);
                        return f
                    }
                }, {
                    key: "rotateCanvas",
                    value: function (e, t, n, r) {
                        var i = document.createElement("canvas"),
                            a = i.getContext("2d");
                        i.width = n, i.height = r, i.style.width = n + "px", i.style.height = r + "px", a.drawImage(e, 0, 0, n, r)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, q.default)(this._textureArray); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.dispose()
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                        for (var o in this._textureArray.length = 0, this._textureData) this._textureData[o] = void 0;
                        for (var s in this.data) this._data[s] = void 0;
                        for (var l in this.extrudeMaterial) this.extrudeMaterial[l].dispose()
                    }
                }, {
                    key: "getExtrudeMaterial",
                    value: function (e, t) {
                        if (this.extrudeMaterial[e + t]) return this.extrudeMaterial[e + t];
                        var n = new fm.RawShaderMaterial({
                            uniforms: {
                                color: {
                                    value: new fm.Color(e)
                                },
                                alpha: {
                                    value: t
                                }
                            },
                            vertexShader: s.RawExtrudeVertShader,
                            fragmentShader: l.RawExtrudeFragShader
                        });
                        return n.transparent = !0, this.extrudeMaterial[e + t] = n, n
                    }
                }, {
                    key: "data",
                    get: function () {
                        return this._data
                    },
                    set: function (e) {
                        this._data = e
                    }
                }, {
                    key: "textureData",
                    get: function () {
                        return this._textureData
                    },
                    set: function (e) {
                        this._textureData = e
                    }
                }, {
                    key: "textureArray",
                    get: function () {
                        return this._textureArray
                    },
                    set: function (e) {
                        this._textureArray = e
                    }
                }]), t
            }(),
            h = u;
        t.default = h
    }, function (e, t, n) {
        "use strict";
        n(106)("fontcolor", function (t) {
            return function (e) {
                return t(this, "font", "color", e)
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.RawExtrudeVertShader = void 0;
        var i = "\nprecision mediump float;\nprecision mediump int;\n\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n ";
        t.RawExtrudeVertShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.RawExtrudeFragShader = void 0;
        var i = "\nprecision mediump float;\nprecision mediump int;\n\nuniform vec3 color;\nuniform float alpha;\n\nvoid main() {\n    gl_FragColor = vec4(color,alpha);\n}\n ";
        t.RawExtrudeFragShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(399)),
            h = function (e) {
                function t() {
                    var e;
                    return (0, a.default)(this, t), e = (0, o.default)(this, (0, s.default)(t).call(this, {
                        uniforms: {
                            diffuse: {
                                value: new fm.Vector3(1, 1, 1)
                            },
                            offset: {
                                value: new fm.Vector2
                            },
                            rotation: {
                                value: 0
                            },
                            scale: {
                                value: 1
                            }
                        },
                        vertexShader: u.default.vert,
                        fragmentShader: u.default.frag
                    })), e.depthTest = !1, e
                }
                return (0, l.default)(t, e), t
            }(fm.ShaderMaterial),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                vert: "     \nuniform vec2 offset;    // \nuniform float rotation; // \nuniform float scale;    // \n\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  vec2 rotatedPosition;\n  rotatedPosition.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n  rotatedPosition.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n\n  rotatedPosition.x *= scale * abs(projectionMatrix[0][0] / projectionMatrix[1][1]);\n  rotatedPosition.y *= scale;\n  \n  rotatedPosition.xy += offset;\n  gl_Position = vec4(rotatedPosition,0.0,1.0);\n}\n",
                frag: "\n\nuniform vec3 diffuse;\nuniform sampler2D mapBack;\nuniform sampler2D mapfront;\n\n#include <common>\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 diffuseColor = vec4( diffuse, 1.0 );\n    diffuseColor = texture2D( mapfront, vUv );\n   \n    vec4 backColor = vec4(1.0 , 0.0 ,0.0 ,1.0);\n    backColor = texture2D( mapBack, vUv );\n\n    float alphacomp = backColor.a + diffuseColor.a * (1.0 - backColor.a);\n    vec3 resultColor = diffuseColor.rgb *  diffuseColor.a + backColor.rgb * (1.0 - diffuseColor.a);\n    gl_FragColor = vec4(resultColor , alphacomp);\n}\n"
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(12));
        n(13);
        var o = r(n(2)),
            s = r(n(3)),
            l = r(n(401)),
            u = r(n(229)),
            h = r(n(109)),
            c = function () {
                function r(e, t, n) {
                    (0, o.default)(this, r), this.preLoadModels = {}, this.waitingBacks = {}, this.waitingNodes = [], this._path = e, this.isRemote = t, this.key = n, this.externalLoadingCount = 0
                }
                return (0, s.default)(r, [{
                    key: "load",
                    value: function (i) {
                        var e, t, n, a = this;
                        this.externalLoadingCount++, n = this.isRemote ? h.default+"webmodel/" : this._path;
                        var o = this.preLoadModels[i].modelUrl.split(".");
                        t = "js" === o[1] ? (e = new l.default, o[0] + ".js?keyValue=" + this.key) : "gltf" === o[1] ? (e = new u.default, o[0] + ".gltf?keyValue=" + this.key) : (e = new u.default, o[0] + ".glb?keyValue=" + this.key), this.isRemote && (t = o[0] + "/" + t), e.setPath(n), this.preLoadModels[i].isLoading = !0, e.load(t, function (e, t) {
                            for (var n in a.waitingBacks[i]) {
                                var r = a.waitingBacks[i][n];
                                r(e, t, o[1])
                            }
                            a.externalLoadingCount--, a.externalLoadingCount < 1 && a.loaded && a.loaded(), a.preLoadModels[i].isGltf = "js" !== o[1], a.preLoadModels[i].geometry = e, a.preLoadModels[i].material = t, a.waitingBacks[i].length = 0, a.preLoadModels[i].isLoading = !1, a.preLoadModels[i].loaded = !0
                        }, function () {}, function (e) {
                            console.error(e), a.externalLoadingCount--, a.externalLoadingCount < 1 && a.loaded && a.loaded(), a.preLoadModels[i].isLoading = !1
                        })
                    }
                }, {
                    key: "addWaitingBacks",
                    value: function (e, t, n) {
                        this.waitingBacks[e] || (this.waitingBacks[e] = {}), this.waitingBacks[e][n] || (this.waitingBacks[e][n] = t)
                    }
                }, {
                    key: "setLoadedBack",
                    value: function (e) {
                        this.loaded = e
                    }
                }, {
                    key: "checkAndLoadwaiting",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, a.default)(this.waitingNodes); !(e = (r = i.next()).done); e = !0) r.value
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }]), r
            }(),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(11));

        function o(e) {
            "boolean" == typeof e && (console.warn("fm.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : fm.DefaultLoadingManager, this.withCredentials = !1
        }

        function s(e, t) {
            function n(e, t) {
                return e & 1 << t
            }
            var r, i, a, o, s, l, u, h, c, d, f, p, g, m, v, y, _, A, x, C, I, w, M, b, S, E, T, L = e.faces,
                N = e.vertices,
                R = e.normals,
                k = e.colors,
                P = e.scale,
                D = 0;
            if (void 0 !== e.uvs) {
                for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && D++;
                for (r = 0; r < D; r++) t.faceVertexUvs[r] = []
            }
            for (o = 0, s = N.length; o < s;) A = new fm.Vector3, A.x = N[o++] * P, A.y = N[o++] * P, A.z = N[o++] * P, t.vertices.push(A);
            for (o = 0, s = L.length; o < s;)
                if (d = L[o++], f = n(d, 0), p = n(d, 1), g = n(d, 3), m = n(d, 4), v = n(d, 5), y = n(d, 6), _ = n(d, 7), f) {
                    if (C = new fm.Face3, C.a = L[o], C.b = L[o + 1], C.c = L[o + 3], I = new fm.Face3, I.a = L[o + 1], I.b = L[o + 2], I.c = L[o + 3], o += 4, p && (c = L[o++], C.materialIndex = c, I.materialIndex = c), a = t.faces.length, g)
                        for (r = 0; r < D; r++)
                            for (b = e.uvs[r], t.faceVertexUvs[r][a] = [], t.faceVertexUvs[r][a + 1] = [], i = 0; i < 4; i++) h = L[o++], E = b[2 * h], T = b[2 * h + 1], S = new fm.Vector2(E, T), 2 !== i && t.faceVertexUvs[r][a].push(S), 0 !== i && t.faceVertexUvs[r][a + 1].push(S);
                    if (m && (u = 3 * L[o++], C.normal.set(R[u++], R[u++], R[u]), I.normal.copy(C.normal)), v)
                        for (r = 0; r < 4; r++) u = 3 * L[o++], M = new fm.Vector3(R[u++], R[u++], R[u]), 2 !== r && C.vertexNormals.push(M), 0 !== r && I.vertexNormals.push(M);
                    if (y && (l = L[o++], w = k[l], C.color.setHex(w), I.color.setHex(w)), _)
                        for (r = 0; r < 4; r++) l = L[o++], w = k[l], 2 !== r && C.vertexColors.push(new fm.Color(w)), 0 !== r && I.vertexColors.push(new fm.Color(w));
                    t.faces.push(C), t.faces.push(I)
                } else {
                    if (x = new fm.Face3, x.a = L[o++], x.b = L[o++], x.c = L[o++], p && (c = L[o++], x.materialIndex = c), a = t.faces.length, g)
                        for (r = 0; r < D; r++)
                            for (b = e.uvs[r], t.faceVertexUvs[r][a] = [], i = 0; i < 3; i++) h = L[o++], E = b[2 * h], T = b[2 * h + 1], S = new fm.Vector2(E, T), t.faceVertexUvs[r][a].push(S);
                    if (m && (u = 3 * L[o++], x.normal.set(R[u++], R[u++], R[u])), v)
                        for (r = 0; r < 3; r++) u = 3 * L[o++], M = new fm.Vector3(R[u++], R[u++], R[u]), x.vertexNormals.push(M);
                    if (y && (l = L[o++], x.color.setHex(k[l])), _)
                        for (r = 0; r < 3; r++) l = L[o++], x.vertexColors.push(new fm.Color(k[l]));
                    t.faces.push(x)
                }
        }

        function l(e, t) {
            var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
            if (e.skinWeights)
                for (var r = 0, i = e.skinWeights.length; r < i; r += n) {
                    var a = e.skinWeights[r],
                        o = 1 < n ? e.skinWeights[r + 1] : 0,
                        s = 2 < n ? e.skinWeights[r + 2] : 0,
                        l = 3 < n ? e.skinWeights[r + 3] : 0;
                    t.skinWeights.push(new fm.Vector4(a, o, s, l))
                }
            if (e.skinIndices)
                for (r = 0, i = e.skinIndices.length; r < i; r += n) {
                    var u = e.skinIndices[r],
                        h = 1 < n ? e.skinIndices[r + 1] : 0,
                        c = 2 < n ? e.skinIndices[r + 2] : 0,
                        d = 3 < n ? e.skinIndices[r + 3] : 0;
                    t.skinIndices.push(new fm.Vector4(u, h, c, d))
                }
            t.bones = e.bones, t.bones && 0 < t.bones.length && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
        }

        function u(e, t) {
            var n = e.scale;
            if (void 0 !== e.morphTargets)
                for (var r = 0, i = e.morphTargets.length; r < i; r++) {
                    t.morphTargets[r] = {}, t.morphTargets[r].name = e.morphTargets[r].name, t.morphTargets[r].vertices = [];
                    for (var a = t.morphTargets[r].vertices, o = e.morphTargets[r].vertices, s = 0, l = o.length; s < l; s += 3) {
                        var u = new fm.Vector3;
                        u.x = o[s] * n, u.y = o[s + 1] * n, u.z = o[s + 2] * n, a.push(u)
                    }
                }
            if (void 0 !== e.morphColors && 0 < e.morphColors.length) {
                console.warn('fm.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                var h = t.faces,
                    c = e.morphColors[0].colors;
                for (r = 0, i = h.length; r < i; r++) h[r].color.fromArray(c, 3 * r)
            }
        }

        function h(e, t) {
            var n = [],
                r = [];
            void 0 !== e.animation && r.push(e.animation), void 0 !== e.animations && (e.animations.length ? r = r.concat(e.animations) : r.push(e.animations));
            for (var i = 0; i < r.length; i++) {
                var a = fm.AnimationClip.parseAnimation(r[i], t.bones);
                a && n.push(a)
            }
            if (t.morphTargets) {
                var o = fm.AnimationClip.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                n = n.concat(o)
            }
            0 < n.length && (t.animations = n)
        }(0, a.default)(o.prototype, {
            crossOrigin: "anonymous",
            load: function (a, o, e, t) {
                var s = this,
                    l = void 0 === this.path ? fm.LoaderUtils.extractUrlBase(a) : this.path;
                this.resourcePath = l + "maps/";
                var n = new fm.FileLoader(this.manager);
                n.setPath(this.path), n.setWithCredentials(this.withCredentials), n.load(a, function (e) {
                    var t = JSON.parse(e),
                        n = t.metadata;
                    if (void 0 !== n) {
                        var r = n.type;
                        if (void 0 !== r && "object" === r.toLowerCase()) return void console.error("fm.JSONLoader: " + a + " should be loaded with fm.ObjectLoader instead.")
                    }
                    var i = s.parse(t, l);
                    o(i.geometry, i.materials)
                }, e, t)
            },
            setPath: function (e) {
                return this.path = e, this
            },
            setResourcePath: function (e) {
                return this.resourcePath = e, this
            },
            setCrossOrigin: function (e) {
                return this.crossOrigin = e, this
            },
            parse: function (e, t) {
                void 0 !== e.data && (e = e.data), void 0 !== e.scale ? e.scale = 1 / e.scale : e.scale = 1;
                var n = new fm.Geometry;
                if (s(e, n), l(e, n), u(e, n), h(e, n), n.computeFaceNormals(), n.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length) return {
                    geometry: n
                };
                var r = fm.Loader.prototype.initMaterials(e.materials, this.resourcePath || t, this.crossOrigin);
                return {
                    geometry: n,
                    materials: r
                }
            }
        });
        var c = o;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(187)(!0);
        n(176)(String, "String", function (e) {
            this._t = String(e), this._i = 0
        }, function () {
            var e, t = this._t,
                n = this._i;
            return n >= t.length ? {
                value: void 0,
                done: !0
            } : (e = r(t, n), this._i += e.length, {
                value: e,
                done: !1
            })
        })
    }, function (e, t, n) {
        e.exports = n(404)
    }, function (e, t, n) {
        n(101), n(59), n(65), n(405), n(409), n(410), e.exports = n(9).Promise
    }, function (e, t, n) {
        "use strict";
        var r, i, a, o, s = n(75),
            l = n(14),
            u = n(36),
            h = n(95),
            c = n(10),
            d = n(17),
            f = n(70),
            p = n(103),
            g = n(66),
            m = n(230),
            v = n(231).set,
            y = n(407)(),
            _ = n(151),
            A = n(232),
            x = n(408),
            C = n(233),
            I = "Promise",
            w = l.TypeError,
            M = l.process,
            b = M && M.versions,
            S = b && b.v8 || "",
            E = l[I],
            T = "process" == h(M),
            L = function () {},
            N = i = _.f,
            R = !! function () {
                try {
                    var e = E.resolve(1),
                        t = (e.constructor = {})[n(19)("species")] = function (e) {
                            e(L, L)
                        };
                    return (T || "function" == typeof PromiseRejectionEvent) && e.then(L) instanceof t && 0 !== S.indexOf("6.6") && -1 === x.indexOf("Chrome/66")
                } catch (e) {}
            }(),
            k = function (e) {
                var t;
                return !(!d(e) || "function" != typeof (t = e.then)) && t
            },
            P = function (h, n) {
                if (!h._n) {
                    h._n = !0;
                    var r = h._c;
                    y(function () {
                        for (var l = h._v, u = 1 == h._s, e = 0, t = function (e) {
                                var t, n, r, i = u ? e.ok : e.fail,
                                    a = e.resolve,
                                    o = e.reject,
                                    s = e.domain;
                                try {
                                    i ? (u || (2 == h._h && F(h), h._h = 1), !0 === i ? t = l : (s && s.enter(), t = i(l), s && (s.exit(), r = !0)), t === e.promise ? o(w("Promise-chain cycle")) : (n = k(t)) ? n.call(t, a, o) : a(t)) : o(l)
                                } catch (e) {
                                    s && !r && s.exit(), o(e)
                                }
                            }; r.length > e;) t(r[e++]);
                        h._c = [], h._n = !1, n && !h._h && D(h)
                    })
                }
            },
            D = function (a) {
                v.call(l, function () {
                    var e, t, n, r = a._v,
                        i = O(a);
                    if (i && (e = A(function () {
                            T ? M.emit("unhandledRejection", r, a) : (t = l.onunhandledrejection) ? t({
                                promise: a,
                                reason: r
                            }) : (n = l.console) && n.error && n.error("Unhandled promise rejection", r)
                        }), a._h = T || O(a) ? 2 : 1), a._a = void 0, i && e.e) throw e.v
                })
            },
            O = function (e) {
                return 1 !== e._h && 0 === (e._a || e._c).length
            },
            F = function (t) {
                v.call(l, function () {
                    var e;
                    T ? M.emit("rejectionHandled", t) : (e = l.onrejectionhandled) && e({
                        promise: t,
                        reason: t._v
                    })
                })
            },
            B = function (e) {
                var t = this;
                t._d || (t._d = !0, t = t._w || t, t._v = e, t._s = 2, t._a || (t._a = t._c.slice()), P(t, !0))
            },
            G = function (e) {
                var n, r = this;
                if (!r._d) {
                    r._d = !0, r = r._w || r;
                    try {
                        if (r === e) throw w("Promise can't be resolved itself");
                        (n = k(e)) ? y(function () {
                            var t = {
                                _w: r,
                                _d: !1
                            };
                            try {
                                n.call(e, u(G, t, 1), u(B, t, 1))
                            } catch (e) {
                                B.call(t, e)
                            }
                        }): (r._v = e, r._s = 1, P(r, !1))
                    } catch (e) {
                        B.call({
                            _w: r,
                            _d: !1
                        }, e)
                    }
                }
            };
        R || (E = function (e) {
            p(this, E, I, "_h"), f(e), r.call(this);
            try {
                e(u(G, this, 1), u(B, this, 1))
            } catch (e) {
                B.call(this, e)
            }
        }, r = function () {
            this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
        }, r.prototype = n(102)(E.prototype, {
            then: function (e, t) {
                var n = N(m(this, E));
                return n.ok = "function" != typeof e || e, n.fail = "function" == typeof t && t, n.domain = T ? M.domain : void 0, this._c.push(n), this._a && this._a.push(n), this._s && P(this, !1), n.promise
            },
            catch: function (e) {
                return this.then(void 0, e)
            }
        }), a = function () {
            var e = new r;
            this.promise = e, this.resolve = u(G, e, 1), this.reject = u(B, e, 1)
        }, _.f = N = function (e) {
            return e === E || e === o ? new a(e) : i(e)
        }), c(c.G + c.W + c.F * !R, {
            Promise: E
        }), n(78)(E, I), n(182)(I), o = n(9)[I], c(c.S + c.F * !R, I, {
            reject: function (e) {
                var t = N(this),
                    n = t.reject;
                return n(e), t.promise
            }
        }), c(c.S + c.F * (s || !R), I, {
            resolve: function (e) {
                return C(s && this === o ? E : this, e)
            }
        }), c(c.S + c.F * !(R && n(173)(function (e) {
            E.all(e).catch(L)
        })), I, {
            all: function (e) {
                var o = this,
                    t = N(o),
                    s = t.resolve,
                    l = t.reject,
                    n = A(function () {
                        var r = [],
                            i = 0,
                            a = 1;
                        g(e, !1, function (e) {
                            var t = i++,
                                n = !1;
                            r.push(void 0), a++, o.resolve(e).then(function (e) {
                                n || (n = !0, r[t] = e, --a || s(r))
                            }, l)
                        }), --a || s(r)
                    });
                return n.e && l(n.v), t.promise
            },
            race: function (e) {
                var t = this,
                    n = N(t),
                    r = n.reject,
                    i = A(function () {
                        g(e, !1, function (e) {
                            t.resolve(e).then(n.resolve, r)
                        })
                    });
                return i.e && r(i.v), n.promise
            }
        })
    }, function (e) {
        e.exports = function (e, t, n) {
            var r = void 0 === n;
            switch (t.length) {
                case 0:
                    return r ? e() : e.call(n);
                case 1:
                    return r ? e(t[0]) : e.call(n, t[0]);
                case 2:
                    return r ? e(t[0], t[1]) : e.call(n, t[0], t[1]);
                case 3:
                    return r ? e(t[0], t[1], t[2]) : e.call(n, t[0], t[1], t[2]);
                case 4:
                    return r ? e(t[0], t[1], t[2], t[3]) : e.call(n, t[0], t[1], t[2], t[3])
            }
            return e.apply(n, t)
        }
    }, function (e, t, n) {
        var s = n(14),
            l = n(231).set,
            u = s.MutationObserver || s.WebKitMutationObserver,
            h = s.process,
            c = s.Promise,
            d = "process" == n(77)(h);
        e.exports = function () {
            var n, r, i, e = function () {
                var e, t;
                for (d && (e = h.domain) && e.exit(); n;) {
                    t = n.fn, n = n.next;
                    try {
                        t()
                    } catch (e) {
                        throw n ? i() : r = void 0, e
                    }
                }
                r = void 0, e && e.enter()
            };
            if (d) i = function () {
                h.nextTick(e)
            };
            else if (!u || s.navigator && s.navigator.standalone)
                if (c && c.resolve) {
                    var t = c.resolve(void 0);
                    i = function () {
                        t.then(e)
                    }
                } else i = function () {
                    l.call(s, e)
                };
            else {
                var a = !0,
                    o = document.createTextNode("");
                new u(e).observe(o, {
                    characterData: !0
                }), i = function () {
                    o.data = a = !a
                }
            }
            return function (e) {
                var t = {
                    fn: e,
                    next: void 0
                };
                r && (r.next = t), n || (n = t, i()), r = t
            }
        }
    }, function (e, t, n) {
        var r = n(14),
            i = r.navigator;
        e.exports = i && i.userAgent || ""
    }, function (e, t, n) {
        "use strict";
        var r = n(10),
            i = n(9),
            a = n(14),
            o = n(230),
            s = n(233);
        r(r.P + r.R, "Promise", {
            finally: function (t) {
                var n = o(this, i.Promise || a.Promise),
                    e = "function" == typeof t;
                return this.then(e ? function (e) {
                    return s(n, t()).then(function () {
                        return e
                    })
                } : t, e ? function (e) {
                    return s(n, t()).then(function () {
                        throw e
                    })
                } : t)
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(10),
            i = n(151),
            a = n(232);
        r(r.S, "Promise", {
            try: function (e) {
                var t = i.f(this),
                    n = a(e);
                return (n.e ? t.reject : t.resolve)(n.v), t.promise
            }
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(229)),
            l = function () {
                function e() {
                    (0, a.default)(this, e), this.dynamicModel = {}, this.loader = new s.default
                }
                return (0, o.default)(e, [{
                    key: "load",
                    value: function (a, t, e) {
                        var o = this;
                        this.dynamicModel[a] ? 0 == this.dynamicModel[a].loadComplete ? (this.dynamicModel[a].scbs.push(t), this.dynamicModel[a].fcbs.push(e)) : this.dynamicModel[a].error ? e && e(this.dynamicModel[a].error) : t && this.loader.parse(this.dynamicModel[a].data, fm.LoaderUtils.extractUrlBase(a), function (e) {
                            t(e)
                        }, function () {}) : (this.dynamicModel[a] = {
                            gltf: null,
                            loadComplete: !1,
                            error: null,
                            scbs: [],
                            fcbs: []
                        }, this.dynamicModel[a].scbs.push(t), this.dynamicModel[a].fcbs.push(e), this.loader.load(a, function (e, t) {
                            o.dynamicModel[a].gltf = e, o.dynamicModel[a].data = t, o.dynamicModel[a].loadComplete = !0;
                            for (var n = o.dynamicModel[a].scbs, r = function (t) {
                                    n[t] && o.loader.parse(o.dynamicModel[a].data, fm.LoaderUtils.extractUrlBase(a), function (e) {
                                        n[t](e)
                                    }, function () {})
                                }, i = 0; i < n.length; i++) r(i)
                        }, void 0, function (e) {
                            o.dynamicModel[a].error = e, o.dynamicModel[a].loadComplete = !0;
                            for (var t = o.dynamicModel[a].fcbs, n = 0; n < t.length; n++) t[n] && t[n](e)
                        }))
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.dynamicModel = {}, this.loader = null
                    }
                }]), e
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.vertexShader = void 0;
        var i = "\n varying vec4 v_position;\n//  varying vec3 vReflect;\n uniform mat4 relativeModelMatrix;\n//  uniform vec3 cameraPosition2;\n\n #define STANDARD\n varying vec3 vViewPosition;\n #ifndef FLAT_SHADED\n \tvarying vec3 vNormal;\n \t#ifdef USE_TANGENT\n \t\tvarying vec3 vTangent;\n \t\tvarying vec3 vBitangent;\n \t#endif\n #endif\n #define PI 3.14159265359\n #define PI2 6.28318530718\n #define PI_HALF 1.5707963267949\n #define RECIPROCAL_PI 0.31830988618\n #define RECIPROCAL_PI2 0.15915494\n #define LOG2 1.442695\n #define EPSILON 1e-6\n #ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n #endif\n #define whiteComplement(a) ( 1.0 - saturate( a ) )\n float pow2( const in float x ) { return x*x; }\n float pow3( const in float x ) { return x*x*x; }\n float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\n float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n highp float rand( const in vec2 uv ) {\n \tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n \thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n \treturn fract(sin(sn) * c);\n }\n #ifdef HIGH_PRECISION\n \tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n #else\n \tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n \tfloat precisionSafeLength( vec3 v ) {\n \t\tfloat maxComponent = max3( abs( v ) );\n \t\treturn length( v / maxComponent ) * maxComponent;\n \t}\n #endif\n struct IncidentLight {\n \tvec3 color;\n \tvec3 direction;\n \tbool visible;\n };\n struct ReflectedLight {\n \tvec3 directDiffuse;\n \tvec3 directSpecular;\n \tvec3 indirectDiffuse;\n \tvec3 indirectSpecular;\n };\n struct GeometricContext {\n \tvec3 position;\n \tvec3 normal;\n \tvec3 viewDir;\n #ifdef CLEARCOAT\n \tvec3 clearcoatNormal;\n #endif\n };\n vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n \treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n }\n vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n \treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n }\n vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \tfloat distance = dot( planeNormal, point - pointOnPlane );\n \treturn - distance * planeNormal + point;\n }\n float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \treturn sign( dot( point - pointOnPlane, planeNormal ) );\n }\n vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n }\n mat3 transposeMat3( const in mat3 m ) {\n \tmat3 tmp;\n \ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n \ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n \ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n \treturn tmp;\n }\n float linearToRelativeLuminance( const in vec3 color ) {\n \tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n \treturn dot( weights, color.rgb );\n }\n bool isPerspectiveMatrix( mat4 m ) {\n   return m[ 2 ][ 3 ] == - 1.0;\n }\n #ifdef USE_UV\n \t#ifdef UVS_VERTEX_ONLY\n \t\tvec2 vUv;\n \t#else\n \t\tvarying vec2 vUv;\n \t#endif\n \tuniform mat3 uvTransform;\n #endif\n #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n \tattribute vec2 uv2;\n \tvarying vec2 vUv2;\n \tuniform mat3 uv2Transform;\n #endif\n #ifdef USE_DISPLACEMENTMAP\n \tuniform sampler2D displacementMap;\n \tuniform float displacementScale;\n \tuniform float displacementBias;\n #endif\n #ifdef USE_COLOR\n \tvarying vec3 vColor;\n #endif\n #ifdef USE_FOG\n \tvarying float fogDepth;\n #endif\n #ifdef USE_MORPHTARGETS\n \tuniform float morphTargetBaseInfluence;\n \t#ifndef USE_MORPHNORMALS\n \tuniform float morphTargetInfluences[ 8 ];\n \t#else\n \tuniform float morphTargetInfluences[ 4 ];\n \t#endif\n #endif\n #ifdef USE_SKINNING\n \tuniform mat4 bindMatrix;\n \tuniform mat4 bindMatrixInverse;\n \t#ifdef BONE_TEXTURE\n \t\tuniform highp sampler2D boneTexture;\n \t\tuniform int boneTextureSize;\n \t\tmat4 getBoneMatrix( const in float i ) {\n \t\t\tfloat j = i * 4.0;\n \t\t\tfloat x = mod( j, float( boneTextureSize ) );\n \t\t\tfloat y = floor( j / float( boneTextureSize ) );\n \t\t\tfloat dx = 1.0 / float( boneTextureSize );\n \t\t\tfloat dy = 1.0 / float( boneTextureSize );\n \t\t\ty = dy * ( y + 0.5 );\n \t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n \t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n \t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n \t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n \t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n \t\t\treturn bone;\n \t\t}\n \t#else\n \t\tuniform mat4 boneMatrices[ MAX_BONES ];\n \t\tmat4 getBoneMatrix( const in float i ) {\n \t\t\tmat4 bone = boneMatrices[ int(i) ];\n \t\t\treturn bone;\n \t\t}\n \t#endif\n #endif\n #ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n #ifdef USE_LOGDEPTHBUF\n \t#ifdef USE_LOGDEPTHBUF_EXT\n \t\tvarying float vFragDepth;\n \t\tvarying float vIsPerspective;\n \t#else\n \t\tuniform float logDepthBufFC;\n \t#endif\n #endif\n #if 0 > 0\n \tvarying vec3 vClipPosition;\n #endif\n void main() {\n    // vec3 worldPosition2 = ( modelMatrix * vec4( position, 1.0 )).xyz;\n    // vec3 cameraToVertex = normalize( worldPosition2 - cameraPosition2 );\n    // vReflect = reflect( cameraToVertex, normal );\n \tvec4 pos = vec4(position, 1.0);\n \tv_position = relativeModelMatrix * pos;\n\n #ifdef USE_UV\n \tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n #endif\n #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n \tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n #endif\n #ifdef USE_COLOR\n \tvColor.xyz = color.xyz;\n #endif\n vec3 objectNormal = vec3( normal );\n #ifdef USE_TANGENT\n \tvec3 objectTangent = vec3( tangent.xyz );\n #endif\n #ifdef USE_MORPHNORMALS\n \tobjectNormal *= morphTargetBaseInfluence;\n \tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n \tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n \tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n \tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n #endif\n #ifdef USE_SKINNING\n \tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n \tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n \tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n \tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n #endif\n #ifdef USE_SKINNING\n \tmat4 skinMatrix = mat4( 0.0 );\n \tskinMatrix += skinWeight.x * boneMatX;\n \tskinMatrix += skinWeight.y * boneMatY;\n \tskinMatrix += skinWeight.z * boneMatZ;\n \tskinMatrix += skinWeight.w * boneMatW;\n \tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n \tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n \t#ifdef USE_TANGENT\n \t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n \t#endif\n #endif\n vec3 transformedNormal = objectNormal;\n #ifdef USE_INSTANCING\n \tmat3 m = mat3( instanceMatrix );\n \ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n \ttransformedNormal = m * transformedNormal;\n #endif\n transformedNormal = normalMatrix * transformedNormal;\n #ifdef FLIP_SIDED\n \ttransformedNormal = - transformedNormal;\n #endif\n #ifdef USE_TANGENT\n \tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n \t#ifdef FLIP_SIDED\n \t\ttransformedTangent = - transformedTangent;\n \t#endif\n #endif\n #ifndef FLAT_SHADED\n \tvNormal = normalize( transformedNormal );\n \t#ifdef USE_TANGENT\n \t\tvTangent = normalize( transformedTangent );\n \t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n \t#endif\n #endif\n vec3 transformed = vec3( position );\n #ifdef USE_MORPHTARGETS\n \ttransformed *= morphTargetBaseInfluence;\n \ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n \ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n \ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n \ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n \t#ifndef USE_MORPHNORMALS\n \ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n \ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n \ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n \ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n \t#endif\n #endif\n #ifdef USE_SKINNING\n \tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n \tvec4 skinned = vec4( 0.0 );\n \tskinned += boneMatX * skinVertex * skinWeight.x;\n \tskinned += boneMatY * skinVertex * skinWeight.y;\n \tskinned += boneMatZ * skinVertex * skinWeight.z;\n \tskinned += boneMatW * skinVertex * skinWeight.w;\n \ttransformed = ( bindMatrixInverse * skinned ).xyz;\n #endif\n #ifdef USE_DISPLACEMENTMAP\n \ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n #endif\n vec4 mvPosition = vec4( transformed, 1.0 );\n #ifdef USE_INSTANCING\n \tmvPosition = instanceMatrix * mvPosition;\n #endif\n mvPosition = modelViewMatrix * mvPosition;\n gl_Position = projectionMatrix * mvPosition;\n #ifdef USE_LOGDEPTHBUF\n \t#ifdef USE_LOGDEPTHBUF_EXT\n \t\tvFragDepth = 1.0 + gl_Position.w;\n \t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n \t#else\n \t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n \t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n \t\t\tgl_Position.z *= gl_Position.w;\n \t\t}\n \t#endif\n #endif\n #if 0 > 0\n \tvClipPosition = - mvPosition.xyz;\n #endif\n \tvViewPosition = - mvPosition.xyz;\n #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n \tvec4 worldPosition = vec4( transformed, 1.0 );\n \t#ifdef USE_INSTANCING\n \t\tworldPosition = instanceMatrix * worldPosition;\n \t#endif\n \tworldPosition = modelMatrix * worldPosition;\n #endif\n #ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n #ifdef USE_FOG\n \tfogDepth = -mvPosition.z;\n #endif\n }\n ";
        t.vertexShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.fragmentShader = void 0;
        var i = "\n    \nuniform bool isNeedSweep;\nuniform bool isRect;\nuniform bool isAnnulus;\n\nuniform float sweepW;\nuniform float sweepH;\nuniform vec2 se2N;\nuniform vec2 se2RN;\nuniform vec2 moveP;\n\nbool isInRectW(vec2 v, vec2 a, float w){\n    float a1 = abs(dot(v,a));\n    return a1 < w;\n}\nbool isInRectH(vec2 v, vec2 a, float h){\n    float a1 = abs(dot(v,a));\n    return a1 < h;\n}\n\nvarying vec2 v_Uv;\nvarying vec4 v_position;\n\n\nuniform vec2 circleC;\nuniform float maxR;\nuniform float minR;\nbool isMaxCircle(vec3 a, vec2 b, float r){\n    float c = sqrt(pow((a.x-b.x),2.0)+pow((a.z-b.y),2.0));\n    return c <= r;\n}\n\nbool isMinCircle(vec3 a, vec2 b, float r){\n    float c = sqrt(pow((a.x-b.x),2.0)+pow((a.z-b.y),2.0));\n    return c > r;\n}\n\n#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\n\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\n    if(isRect){\n            \n        vec2 v = vec2(v_position.x-moveP.x,v_position.z-moveP.y);\n        if(float(isInRectW(v,se2N,sweepW) && isInRectH(v,se2RN,sweepH)) != 0.0 && isNeedSweep){\n            gl_FragColor = vec4(mix(vec3(1.0, 1.0, 0.36)*0.8, gl_FragColor.rgb, 0.5), 1.0);\n            gl_FragColor.rgb = toneMapping( gl_FragColor.rgb ); \n        }\n        \n    }\n    \n    if(isAnnulus){\n    \n        if(float(isMaxCircle(v_position.xyz,circleC,maxR) && isMinCircle(v_position.xyz,circleC,minR) ) != 0.0 && isNeedSweep){\n            gl_FragColor = vec4(mix(vec3(0.3, 1.0, 0.86),gl_FragColor.rgb,0.91), 1.0);\n            gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n        }\n        // gl_FragColor = vec4(1.0,0.1,0.1,1.0);\n    }\n    \n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
        t.fragmentShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(68), n(8);
        var c = r(n(16)),
            A = r(n(11));
        n(13);
        var S = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            d = r(n(57)),
            s = (r(n(415)), function () {
                function n(e, t) {
                    (0, a.default)(this, n), this._themeName = t, this._themeUrl = e, this._data = null, this._type2theme = {}, this._poiimagetheme = {}, this._storePoiThemes = {}, this._storeLabelTypeDic = {}, this._storeLabelThemeDic = {}, this._storethemes = {}, this._externalModelTheme = {}, this._defaultTheme = {
                        color: 16777215,
                        alpha: 1,
                        strokeColor: 16777215,
                        strokeWidth: 2
                    }, this._labelDefaultTheme = {
                        alpha: "0.9",
                        fillcolor: "30,30,30",
                        fontsize: "14.0",
                        id: "109",
                        image: !1,
                        strokecolor: "255,255,255"
                    }, this.clearColor = 16777215, this.clearAlpha = 1, this._modelOpacity = .875, this._floorColor = 16776960, this._floorOpacity = .875, this._selectedColor = 16750950, this._labelStyle, this._labelSelectedStyle, this._facilitySize, this._poiMatClones = {}, this._storeApply = {}, this.navigateStyle_ = {
                        color: 16711680,
                        lineWidth: 8,
                        alpha: .8,
                        dash: {
                            size: 1,
                            gap: 1
                        }
                    }
                }
                return (0, o.default)(n, [{
                    key: "initExteralModelTheme",
                    value: function () {
                        if (this._data.externalmodelapply) {
                            var e = !0,
                                t = !1,
                                n = void 0;
                            try {
                                for (var r, i = (0, S.default)(this._data.externalmodelapply); !(e = (r = i.next()).done); e = !0) {
                                    var a = r.value,
                                        o = a.fids.split(","),
                                        s = !0,
                                        l = !1,
                                        u = void 0;
                                    try {
                                        for (var h, c = (0, S.default)(o); !(s = (h = c.next()).done); s = !0) {
                                            var d = h.value,
                                                f = void 0,
                                                p = !0,
                                                g = !1,
                                                m = void 0;
                                            try {
                                                for (var v, y = (0, S.default)(this._data.externalmodeltheme); !(p = (v = y.next()).done); p = !0) {
                                                    var _ = v.value;
                                                    if (_.id === a.normalid) {
                                                        f = _;
                                                        break
                                                    }
                                                }
                                            } catch (e) {
                                                g = !0, m = e
                                            } finally {
                                                try {
                                                    p || null == y.return || y.return()
                                                } finally {
                                                    if (g) throw m
                                                }
                                            }
                                            this._externalModelTheme[d] = (0, A.default)({
                                                color: f.color,
                                                model: f.model
                                            }, a), this._externalModelTheme[d].fids = void 0
                                        }
                                    } catch (e) {
                                        l = !0, u = e
                                    } finally {
                                        try {
                                            s || null == c.return || c.return()
                                        } finally {
                                            if (l) throw u
                                        }
                                    }
                                }
                            } catch (e) {
                                t = !0, n = e
                            } finally {
                                try {
                                    e || null == i.return || i.return()
                                } finally {
                                    if (t) throw n
                                }
                            }
                        }
                    }
                }, {
                    key: "initStoreTheme",
                    value: function () {
                        var e = {};
                        this._defaultTheme = this._data.storetheme[0], this.storeThemes = e;
                        for (var t = 0; t < this._data.storetheme.length; t++) {
                            var n = this._data.storetheme[t];
                            n.color = d.default.toColor(n.color), n.strokeColor = d.default.toColor(n.strokecolor), n.strokeWidth = n.strokewidth, n.alpha = n.alpha, e[n.id] = n
                        }
                        var r = this._data.floorapply;
                        for (var t in r) {
                            var i = r[t];
                            if (i.typeapply)
                                for (var a in i.typeapply) {
                                    var o = i.typeapply[a];
                                    if (o.normalid) {
                                        n = e[o.normalid];
                                        var s = e[o.selectedid];
                                        s && (this._selectedColor = d.default.toColor(s.color));
                                        var l = o.type.split(",");
                                        for (var u in l) this._type2theme[l[u]] = n
                                    }
                                }
                        }
                        var h = this._data.extenttheme;
                        this._floorColor = d.default.toColor(h[0].color), this._floorOpacity = (0, c.default)(h[0].alpha)
                    }
                }, {
                    key: "initLabelTheme",
                    value: function () {
                        var e = this._data.storelabeltheme;
                        if (this.storeLabelThemeDic = {}, this.storeLabelTypeDic = {}, e) {
                            0 < e.length && (this._labelStyle = e[0], 1 < e.length && (this._labelSelectedStyle = e[1]));
                            for (var t = 0; t < e.length; t++) this.storeLabelThemeDic[e[t].id] = e[t];
                            var n = this._data.floorstorelabelapply;
                            if (n)
                                for (t = 0; t < n.length; t++) {
                                    var r = n[t].typeapply;
                                    if ("0" == n[t].floorid)
                                        for (var i = 0; i < r.length; i++)
                                            for (var a = r[i], o = a.type.split(","), s = 0; s < o.length; s++) this.storeLabelTypeDic[o[s]] = a
                                }
                            var l = this.data.storelabelapply;
                            this._labelFidTheme = {};
                            var u = this._labelFidTheme,
                                h = !0,
                                c = !1,
                                d = void 0;
                            try {
                                for (var f, p = (0, S.default)(l); !(h = (f = p.next()).done); h = !0) {
                                    var g = f.value;
                                    if (g.fids) {
                                        var m = g.fids.split(","),
                                            v = !0,
                                            y = !1,
                                            _ = void 0;
                                        try {
                                            for (var A, x = (0, S.default)(m); !(v = (A = x.next()).done); v = !0) {
                                                var C = A.value;
                                                u[C] = this.storeLabelThemeDic[g.normalid]
                                            }
                                        } catch (e) {
                                            y = !0, _ = e
                                        } finally {
                                            try {
                                                v || null == x.return || x.return()
                                            } finally {
                                                if (y) throw _
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                c = !0, d = e
                            } finally {
                                try {
                                    h || null == p.return || p.return()
                                } finally {
                                    if (c) throw d
                                }
                            }
                        }
                    }
                }, {
                    key: "initPoiTheme",
                    value: function () {
                        this._poiimagetheme = {};
                        var e = this._data.poiimagetheme,
                            t = {};
                        for (var n in this.storePoiThemes = t, e) {
                            var r = e[n];
                            r.imagename && (t[r.id] = r)
                        }
                        var i = this.data.floorpoiimageapply;
                        for (var a in i) {
                            var o = i[a];
                            if (o.typeapply)
                                for (var s in o.typeapply) {
                                    var l = o.typeapply[s];
                                    if (l.normalid) {
                                        var u = t[l.normalid],
                                            h = l.type.split(",");
                                        for (var c in h) this._poiimagetheme[h[c]] = u
                                    }
                                }
                        }
                        var d = this.data.poiimageapply;
                        this._poiFidTheme = {};
                        var f = this._poiFidTheme,
                            p = !0,
                            g = !1,
                            m = void 0;
                        try {
                            for (var v, y = (0, S.default)(d); !(p = (v = y.next()).done); p = !0) {
                                var _ = v.value;
                                if (_.fids) {
                                    var A = _.fids.split(","),
                                        x = !0,
                                        C = !1,
                                        I = void 0;
                                    try {
                                        for (var w, M = (0, S.default)(A); !(x = (w = M.next()).done); x = !0) {
                                            var b = w.value;
                                            f[b] = t[_.normalid]
                                        }
                                    } catch (e) {
                                        C = !0, I = e
                                    } finally {
                                        try {
                                            x || null == M.return || M.return()
                                        } finally {
                                            if (C) throw I
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            g = !0, m = e
                        } finally {
                            try {
                                p || null == y.return || y.return()
                            } finally {
                                if (g) throw m
                            }
                        }
                    }
                }, {
                    key: "getStoreApplyTheme",
                    value: function (e) {
                        var t, n = !0,
                            r = !1,
                            i = void 0;
                        try {
                            for (var a, o = (0, S.default)(this._data.storeapply); !(n = (a = o.next()).done); n = !0) {
                                var s = a.value;
                                if (s.fids === e) {
                                    var l = !0,
                                        u = !1,
                                        h = void 0;
                                    try {
                                        for (var c, d = (0, S.default)(this._data.storetheme); !(l = (c = d.next()).done); l = !0) {
                                            var f = c.value;
                                            if (f.id == s.normalid) return t = (0, A.default)({}, f, s), t
                                        }
                                    } catch (e) {
                                        u = !0, h = e
                                    } finally {
                                        try {
                                            l || null == d.return || d.return()
                                        } finally {
                                            if (u) throw h
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            r = !0, i = e
                        } finally {
                            try {
                                n || null == o.return || o.return()
                            } finally {
                                if (r) throw i
                            }
                        }
                        return null
                    }
                }, {
                    key: "getRThemeTexture",
                    value: function (e) {
                        if (this.rtheme)
                            for (var t, n = 0; n < this.rtheme.fmis.length; n++)
                                if (t = this.rtheme.fmis[n], t.name == e) return t.content;
                        return null
                    }
                }, {
                    key: "getModelSelectColor",
                    value: function () {
                        var e = this._data.storetheme[1],
                            t = e.color,
                            n = (0, c.default)(e.alpha);
                        return {
                            r: (t >> 16 & 255) / 255,
                            g: (t >> 8 & 255) / 255,
                            b: (255 & t) / 255,
                            a: n
                        }
                    }
                }, {
                    key: "getModelTheme",
                    value: function (e) {
                        if (!e) return this._defaultTheme;
                        var t = this._type2theme[e.type];
                        return t || this._defaultTheme
                    }
                }, {
                    key: "getPoiTheme",
                    value: function (e) {
                        var t, n = e.type,
                            r = e.fid;
                        return t = this._poiFidTheme[r], t = t || this._poiimagetheme[n], t = (0, A.default)(t || this._poiimagetheme[0], {}), "rtheme" == this.fileType ? t.imageSrc = this.getRThemeTexture(t.imagename) : t.imageSrc = this._themeUrl + "/" + this.themeName + "/" + t.imagename, t.imageUrl = this._themeUrl + "/" + this.themeName + "/" + t.imagename, t.imagehead = this._themeUrl + "/" + this.themeName + "/", t
                    }
                }, {
                    key: "getLabelTheme",
                    value: function (e) {
                        var t, n = e.type,
                            r = e.fid,
                            i = this.storeLabelTypeDic[n];
                        if (r && (t = this._labelFidTheme[r]), i || t ? i && (t = t || (this.storeLabelThemeDic[i.normalid] ? this.storeLabelThemeDic[i.normalid] : this._labelStyle)) : t = this._labelStyle, t = t || this._labelDefaultTheme, !t.fillcolor || !t.alpha || !t.fontsize) {
                            var a = {
                                fillcolor: "0,0,0",
                                alpha: "1.0",
                                fontsize: "12.0"
                            };
                            t = (0, A.default)(t, a)
                        }
                        return t.image ? ("rtheme" == this.fileType ? t.imageSrc = this.getRThemeTexture(t.image) : t.imageSrc = this._themeUrl + "/" + this.themeName + "/" + t.image, t.imageUrl = this._themeUrl + "/" + this.themeName + "/" + t.image) : t.imageSrc = !1, t
                    }
                }, {
                    key: "getExteralModelTheme",
                    value: function (e) {
                        return this._externalModelTheme[e]
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._type2theme = void 0, this._poiimagetheme = void 0, this._storePoiThemes = void 0, this._storeLabelTypeDic = void 0, this._storeLabelThemeDic = void 0, this._storethemes = void 0, this._data = void 0
                    }
                }, {
                    key: "themeName",
                    get: function () {
                        return this._themeName
                    }
                }, {
                    key: "data",
                    set: function (e) {
                        this._data = e, this.initStoreTheme(), this.initLabelTheme(), this.initPoiTheme(), this.initExteralModelTheme(), this.clearColor = d.default.toColor(this._data.viewtheme.clearcolor), this.clearAlpha = (0, c.default)(this._data.viewtheme.clearalpha)
                    },
                    get: function () {
                        return this._data
                    }
                }, {
                    key: "storeLabelTypeDic",
                    get: function () {
                        return this._storeLabelTypeDic
                    },
                    set: function (e) {
                        this._storeLabelTypeDic = e
                    }
                }, {
                    key: "storeLabelThemeDic",
                    get: function () {
                        return this._storeLabelThemeDic
                    },
                    set: function (e) {
                        this._storeLabelThemeDic = e
                    }
                }, {
                    key: "storePoiThemes",
                    get: function () {
                        return this._storePoiThemes
                    },
                    set: function (e) {
                        this._storePoiThemes = e
                    }
                }, {
                    key: "storethemes",
                    get: function () {
                        return this._storethemes
                    },
                    set: function (e) {
                        this._storethemes = e
                    }
                }, {
                    key: "themeUrl",
                    get: function () {
                        return this._themeUrl
                    },
                    set: function (e) {
                        this.themeUrl = e
                    }
                }, {
                    key: "floorColor",
                    set: function (e) {
                        this._floorColor = e
                    },
                    get: function () {
                        return this._floorColor
                    }
                }, {
                    key: "floorOpacity",
                    set: function (e) {
                        this._floorOpacity = e
                    },
                    get: function () {
                        return this._floorOpacity
                    }
                }, {
                    key: "selectedColor",
                    get: function () {
                        return this._selectedColor
                    }
                }]), n
            }()),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11)),
            o = r(n(12)),
            s = r(n(2)),
            l = r(n(3)),
            u = function () {
                function t(e) {
                    (0, s.default)(this, t), this._data = e, this._Nodes = []
                }
                return (0, l.default)(t, [{
                    key: "updateNodes",
                    value: function () {
                        var e = !0,
                            t = !1,
                            n = void 0;
                        try {
                            for (var r, i = (0, o.default)(this._Nodes); !(e = (r = i.next()).done); e = !0) {
                                var a = r.value;
                                a.setByTheme(this._data)
                            }
                        } catch (e) {
                            t = !0, n = e
                        } finally {
                            try {
                                e || null == i.return || i.return()
                            } finally {
                                if (t) throw n
                            }
                        }
                    }
                }, {
                    key: "addNodes",
                    value: function (e) {
                        this._Nodes.push(e)
                    }
                }, {
                    key: "removeNodes",
                    value: function (e) {
                        var t = this._Nodes.indexOf(e); - 1 < t && this._Nodes.splice(t, 1)
                    }
                }, {
                    key: "changeData",
                    value: function (e) {
                        (0, a.default)(this._data, e)
                    }
                }]), t
            }(),
            h = u;
        t.default = h
    }, function (e, t, n) {
        "use strict";
        var r, i, a, o = n(1),
            s = o(n(47));
        a = function () {
            var e = function e() {
                var n = 0,
                    r = document.createElement("div");

                function t(e) {
                    return r.appendChild(e.dom), e
                }

                function i(e) {
                    for (var t = 0; t < r.children.length; t++) r.children[t].style.display = t === e ? "block" : "none";
                    n = e
                }
                r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function (e) {
                    e.preventDefault(), i(++n % r.children.length)
                }, !1);
                var a = (performance || Date).now(),
                    o = a,
                    s = 0,
                    l = t(new e.Panel("FPS", "#0ff", "#002")),
                    u = t(new e.Panel("MS", "#0f0", "#020"));
                if (self.performance && self.performance.memory) var h = t(new e.Panel("MB", "#f08", "#201"));
                return i(0), {
                    REVISION: 16,
                    dom: r,
                    addPanel: t,
                    showPanel: i,
                    begin: function () {
                        a = (performance || Date).now()
                    },
                    end: function () {
                        s++;
                        var e = (performance || Date).now();
                        if (u.update(e - a, 200), o + 1e3 <= e && (l.update(1e3 * s / (e - o), 100), o = e, s = 0, h)) {
                            var t = performance.memory;
                            h.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                        }
                        return e
                    },
                    update: function () {
                        a = this.end()
                    },
                    domElement: r,
                    setMode: i
                }
            };
            return e.Panel = function (n, r, i) {
                var a = Infinity,
                    o = 0,
                    s = Math.round,
                    l = s(window.devicePixelRatio || 1),
                    u = 80 * l,
                    e = 48 * l,
                    h = 3 * l,
                    c = 2 * l,
                    d = 3 * l,
                    f = 15 * l,
                    p = 74 * l,
                    g = 30 * l,
                    m = document.createElement("canvas");
                m.width = u, m.height = e, m.style.cssText = "width:80px;height:48px";
                var v = m.getContext("2d");
                return v.font = "bold " + 9 * l + "px Helvetica,Arial,sans-serif", v.textBaseline = "top", v.fillStyle = i, v.fillRect(0, 0, u, e), v.fillStyle = r, v.fillText(n, h, c), v.fillRect(d, f, p, g), v.fillStyle = i, v.globalAlpha = .9, v.fillRect(d, f, p, g), {
                    dom: m,
                    update: function (e, t) {
                        a = Math.min(a, e), o = Math.max(o, e), v.fillStyle = i, v.globalAlpha = 1, v.fillRect(0, 0, u, f), v.fillStyle = r, v.fillText(s(e) + " " + n + " (" + s(a) + "-" + s(o) + ")", h, c), v.drawImage(m, d + l, f, p - l, g, d, f, p - l, g), v.fillRect(d + p - l, f, l, g), v.fillStyle = i, v.globalAlpha = .9, v.fillRect(d + p - l, f, l, s((1 - e / t) * g))
                    }
                }
            }, e
        }, "object" === (0, s.default)(t) && void 0 !== e ? e.exports = a() : (r = a, i = "function" == typeof r ? r.call(t, n, t, e) : r, void 0 === i || (e.exports = i))
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(418)),
            h = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, o.default)(this, (0, s.default)(n).call(this, e)), t.uniforms.offset = {
                        value: new fm.Vector2
                    }, t.uniforms.rotation = {
                        value: 0
                    }, t.uniforms.scale = {
                        value: new fm.Vector2(1, 1)
                    }, t.depthTest = !1, t.vertexShader = u.default.vert, t.fragmentShader = u.default.frag, t
                }
                return (0, l.default)(n, e), n
            }(fm.ShaderMaterial),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                vert: "\n                      \n                        uniform vec2 offset;\n                        uniform float rotation;\n                        uniform vec2 scale;\n                        varying vec2 vUv;\n                        void main() {\n                          vUv = uv;\n                  \n                          \n                          vec2 rotatedPosition;\n                            rotatedPosition.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n                            rotatedPosition.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n                      \n        \n                            rotatedPosition.x *= scale.x * abs(projectionMatrix[0][0] / projectionMatrix[1][1]);\n                            rotatedPosition.y *= scale.y;\n                          \n                          rotatedPosition.xy += offset;\n                          gl_Position = vec4(rotatedPosition,0.0,1.0);\n                        }\n                        ",
                frag: "\n                    uniform vec3 diffuse;\n                    uniform sampler2D mmap;\n                    #include <common>\n                    varying vec2 vUv;\n               \n                    void main() {\n                \n                        // vec2 muv = vec2(vUv.x , 1.0 - vUv.y);\n                        vec4 diffuseColor = texture2D( mmap, vUv );\n                       \n                        \n                        gl_FragColor = diffuseColor;\n                    }\n                    "
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function t(e) {
                    (0, a.default)(this, t), this.videoMemoryAmount = null, this._map = e
                }
                return (0, o.default)(t, [{
                    key: "getVideoMemoryAmount",
                    value: function (e) {
                        if (this._map.nodeManager) {
                            var t = this._map.nodeManager._scenes["" + e].groups;
                            for (var n in t) this.videoMemoryAmount += t["" + n].layers.facility[0].getVideoMemoryAmount(), this.videoMemoryAmount += t["" + n].layers.model[0].getVideoMemoryAmount(), this.videoMemoryAmount += t["" + n].layers.extent[0].getVideoMemoryAmount(), this.videoMemoryAmount += t["" + n].layers.label[0].getVideoMemoryAmount();
                            return this.videoMemoryAmount
                        }
                    }
                }, {
                    key: "_addAmount",
                    value: function (e) {
                        this.videoMemoryAmount += e
                    }
                }, {
                    key: "_subtractAmount",
                    value: function (e) {
                        this.videoMemoryAmount -= e
                    }
                }]), t
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(41)),
            o = r(n(27));
        n(48);
        var s, l = r(n(2)),
            u = r(n(3)),
            h = r(n(57)),
            c = r(n(240)),
            d = r(n(421)),
            f = function () {
                function n(e, t) {
                    (0, l.default)(this, n), this._map = e, this._ctlOpt = new d.default(t), this._btnWidth = 42, this._showBtnCount = this._ctlOpt.showBtnCount || 5, this._foucusId = this._map.currentFocusGroup, this._scrollSpeed = 10, this._btnPanel = null, this._mainPanel = null, this._ctlOpt.offset || (this._ctlOpt.offset = {
                        x: 0,
                        y: 0
                    }), this._ctlOpt.needAllLayerBtn = null == this._ctlOpt.needAllLayerBtn || this._ctlOpt.needAllLayerBtn, this._allLayer = !!this._ctlOpt.allLayer && this._ctlOpt.allLayer, this._allLayer && this._map.showSingerOrMultiGroup(this._allLayer), this.uuid = null, this.init(), this.scrollTopAn_ = new h.default.scrollTopAnFun
                }
                return (0, u.default)(n, [{
                    key: "init",
                    value: function () {
                        var n = this,
                            e = new Date,
                            t = e.getFullYear(),
                            r = e.getMonth(),
                            i = e.getDate(),
                            a = e.getHours(),
                            o = e.getMinutes(),
                            s = e.getSeconds();
                        a < 10 && (a = "0" + a), o < 10 && (o = "0" + o), s < 10 && (s = "0" + s);
                        var l = t + "/" + r + "/" + i + "/" + a + ":" + o + ":" + s;
                        this.uuid = String(5 * Math.random()).replace(/^(.*\..{4}).*$/, "$1") + l;
                        var u = this.createPanel(this._btnWidth);
                        this._mainPanel = u, this.checkPosition(this._ctlOpt.position, this._ctlOpt.offset, u), this._map.getContainer().appendChild(u);
                        var h = this._map.listGroups.map(function (e) {
                                return e.gid
                            }),
                            c = h.length,
                            d = this._showBtnCount,
                            f = !0;
                        c <= this._showBtnCount && (d = c, f = !1);
                        var p = this.createMultiSwitchButton(this._ctlOpt.imgURL + (this._ctlOpt.allLayer ? "layers.png" : "layer.png"));
                        this._ctlOpt.needAllLayerBtn && u.appendChild(p), this._switchBtn = p, f && u.appendChild(this.createScrollButton(this._ctlOpt.imgURL + "arrow1.png", "top"));
                        var g = this.createGroupBtnPanel(d * this._btnWidth + 2 * (d - 1));
                        u.appendChild(g), this._btnPanel = g;
                        for (var m = this._map.listGroups, v = m.length - 1; - 1 < v; v--) g.appendChild(this.createGroupButton(m[v], this._btnWidth)), 0 < v && g.appendChild(this.createHr());
                        f && u.appendChild(this.createScrollButton(this._ctlOpt.imgURL + "arrow2.png", "buttom")), g.scrollTop = this.getCenterScrolltopById(this._foucusId, h.length), document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(30, 130, 250)", this.eventBtnPanelInit(g), this.eventPanelInit(u, g, h), this.eventSwitchBtn(p);
                        var y = function (e) {
                                var t = n._map.listGroups.map(function (e) {
                                    return e.gid
                                });
                                e.gid < t[0] || e.gid > t[t.length - 1] || (g.scrollTop = n.getCenterScrolltopById(e.gid, t.length), n.setFocusStaus(e.gid))
                            },
                            _ = function (e) {
                                1 < e.gids.length ? n.setLayerStatus(!0) : n.setLayerStatus(!1)
                            };
                        this._map.on("focusGroupIDChanged", y), this._map.on("visibleGroupIDsChanged", _), this._map.on("dispose", function () {
                            n._map.off("focusGroupIDChanged", y), n._map.off("visibleGroupIDsChanged", _), n._map.getContainer().removeChild(u)
                        }), this._$ = function (e) {
                            return n.map ? n.map.mapView.container_.querySelector(e) : document.querySelector(e)
                        }
                    }
                }, {
                    key: "eventSwitchBtn",
                    value: function (e) {
                        var t = this;
                        e.addEventListener("click", function () {
                            t._allLayer = !t._allLayer, t._allLayer ? e.firstElementChild.src = t._ctlOpt.imgURL + "layers.png" : e.firstElementChild.src = t._ctlOpt.imgURL + "layer.png", t._map.showSingerOrMultiGroup(t._allLayer)
                        })
                    }
                }, {
                    key: "eventBtnPanelInit",
                    value: function (n) {
                        var r = this,
                            i = this;
                        i.changeScrollBtnPic(), h.default.bindEvent(n, "label", "click", function () {
                            i.foucusId = (0, o.default)(this.dataset.gid), i.setFocusStaus(this.dataset.gid)
                        });
                        var e = function (e) {
                            i.changeScrollBtnPic();
                            var t = 0;
                            e.wheelDelta ? t += -e.wheelDelta : e.detail && (t += e.detail), r.scrollTopAn_({
                                el: n,
                                to: n.scrollTop,
                                form: n.scrollTop + t
                            })
                        };
                        n.addEventListener("mousewheel", e, {
                            passive: !0
                        }), n.addEventListener("MozMousePixelScroll", e, !1), n.addEventListener("touchstart", this.touchstart.bind(this), !1), n.addEventListener("touchmove", this.touchmove.bind(this), !1), n.addEventListener("touchend", this.touchend.bind(this), !0)
                    }
                }, {
                    key: "touchstart",
                    value: function (e) {
                        e.preventDefault(), this.touchStartPointY = e.touches[0].pageY, this.touchPointX = e.touches[0].pageX, this.touchPointY = e.touches[0].pageY
                    }
                }, {
                    key: "touchmove",
                    value: function (e) {
                        e.preventDefault(), this.touchEndPointX = e.touches[0].pageX, this.touchEndPointY = e.touches[0].pageY, this.handleTouchEnd(e)
                    }
                }, {
                    key: "handleTouchEnd",
                    value: function (e) {
                        e = e || window.event;
                        var t = this,
                            n = null,
                            r = 0;
                        0 < e.changedTouches.length && (t.touchEndPointX = e.changedTouches[0].pageX, t.touchEndPointY = e.changedTouches[0].pageY), n = e.target, n instanceof HTMLSpanElement == 1 && (n = n.parentElement);
                        var i = t.touchEndPointY - t.touchPointY;
                        if (r = -i, 0 != r) {
                            t.touchPointX = t.touchEndPointX, t.touchPointY = t.touchEndPointY;
                            var a = t._$(".fm-layer-list");
                            this.scrollTopAn_({
                                el: a,
                                to: a.scrollTop,
                                form: a.scrollTop + r
                            })
                        }
                    }
                }, {
                    key: "touchend",
                    value: function (e) {
                        e = e || window.event;
                        var t = this,
                            n = null;
                        0 < e.changedTouches.length && (t.touchEndPointX = e.changedTouches[0].pageX, t.touchEndPointY = e.changedTouches[0].pageY), n = e.target, n instanceof HTMLSpanElement == 1 && (n = n.parentElement);
                        var r = Math.abs(t.touchEndPointY - t.touchStartPointY);
                        if (r < 5 && 0 <= r && n) {
                            var i = (0, o.default)(n.dataset.gid);
                            isNaN(i) || (t.foucusId = i, t.setFocusStaus(i))
                        }
                    }
                }, {
                    key: "eventPanelInit",
                    value: function (e, o, s) {
                        var l = this;
                        e.onselectstart = function () {
                            return !1
                        }, e.style.MozUserSelect = "none", h.default.bindEvent(e, ".scroll", "click", function () {
                            var e = s.length - Math.floor(o.scrollTop / 44) - (l._showBtnCount - 1),
                                t = o.scrollTop % 44,
                                n = e + l._showBtnCount - 1 + (0 < t ? 1 : 0),
                                r = 0;
                            if (this.id === "scroll_top" + l.uuid) {
                                var i = l._foucusId + 1;
                                if (i = Math.min(s[s.length - 1], i), l.foucusId == i) return;
                                l.foucusId = i, i < e ? r -= 0 < t ? 44 - t : 0 : i <= n + 1 && i === n + 1 && (r -= 44 + (0 < t ? 44 - t : 0))
                            } else {
                                var a = l._foucusId - 1;
                                if (a = Math.max(s[0], a), l.foucusId == a) return;
                                l.foucusId = a, n < a ? r += 0 < t ? t : 0 : e - 1 <= a && a === e - 1 && (r += 44 + (0 < t ? t : 0))
                            }
                            0 != r && l.scrollTopAn_({
                                el: o,
                                to: o.scrollTop,
                                form: o.scrollTop + r
                            })
                        })
                    }
                }, {
                    key: "getCenterScrolltopById",
                    value: function (e, t) {
                        var n = t - e - Math.floor(this._showBtnCount / 2);
                        return n * (this._btnWidth + 2)
                    }
                }, {
                    key: "createPanel",
                    value: function () {
                        var e = document.createElement("div"),
                            t = '\n            <div class="fm-control-groups" style ="width: 42px; position: absolute; background-color: white; box-shadow: rgba(0, 0, 0, 0.3) 2px 2px 3px; border-radius: 2px; top: 30px; right: 30px;"></div>\n        ';
                        return e.innerHTML = t.trim(), e.firstChild
                    }
                }, {
                    key: "createGroupBtnPanel",
                    value: function (e) {
                        var t = document.createElement("div"),
                            n = '\n            <div style = "overflow: hidden; height: '.concat(e, 'px;" class="fm-layer-list"> </div\n        ');
                        return t.innerHTML = n.trim(), t.firstChild
                    }
                }, {
                    key: "createMultiSwitchButton",
                    value: function (e) {
                        var t = document.createElement("div"),
                            n = '\n            <div class="fm-control-groups-layer fm-btn-layer" style="padding: 10px; cursor: pointer;">\n                <img src="'.concat(e, '" style="width: 22px; height: 22px;">\n            </div>\n            ');
                        return t.innerHTML = n.trim(), t.firstChild
                    }
                }, {
                    key: "createHr",
                    value: function () {
                        var e = document.createElement("div"),
                            t = '\n            <hr style="height: 1px; border-top: 1px solid rgba(153, 153, 153, 0.45); border-right: none; border-bottom: none; border-left: none; border-image: initial; width: 60%; margin: 0px 20%;">\n        ';
                        return e.innerHTML = t.trim(), e.firstChild
                    }
                }, {
                    key: "createScrollButton",
                    value: function (e, t) {
                        var n = document.createElement("div"),
                            r = '\n            <div class="scroll" id="scroll_'.concat(t + this.uuid, '" style="height: 18px; background: url(&quot;').concat(e, '&quot;) 50% 50% no-repeat; cursor: pointer;"></div>\n        ');
                        return n.innerHTML = r.trim(), n.firstChild
                    }
                }, {
                    key: "createGroupButton",
                    value: function (e, t) {
                        var n = document.createElement("div"),
                            r = "<label  data-gid=".concat(e.gid, ' id="gid_').concat(e.gid + this.uuid, '" style="display: inline-block; text-align: center; width: ').concat(t, "px; height: ").concat(t, "px; line-height: ").concat(t, 'px; margin: 0px; cursor: pointer; font-size: 0.8em; font-weight: bold; color: rgb(102, 102, 102);">\n                        <span>').concat(e.alias && e.alias.toUpperCase() || e.gname.toUpperCase(), "</span>\n                    </label>");
                        return n.innerHTML = r.trim(), n.firstChild
                    }
                }, {
                    key: "changeScrollBtnPic",
                    value: function () {
                        var e = this._foucusId,
                            t = this._map.listGroups.map(function (e) {
                                return e.gid
                            }),
                            n = document.getElementById("scroll_buttom" + this.uuid),
                            r = document.getElementById("scroll_top" + this.uuid);
                        e == t[0] ? n && (n.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow4.png)") : n && (n.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow2.png)"), e == t[t.length - 1] ? r && (r.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow3.png)") : r && (r.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow1.png)")
                    }
                }, {
                    key: "changeFocusGroup",
                    value: function (e) {
                        this.foucusId = e
                    }
                }, {
                    key: "changeGroupsSelect",
                    value: function (e) {
                        this.setLayerStatus(e), this._map.showSingerOrMultiGroup(e)
                    }
                }, {
                    key: "setLayerStatus",
                    value: function (e) {
                        this._allLayer = e, this._allLayer ? this._switchBtn.firstElementChild.src = this._ctlOpt.imgURL + "layers.png" : this._switchBtn.firstElementChild.src = this._ctlOpt.imgURL + "layer.png"
                    }
                }, {
                    key: "checkPosition",
                    value: function (e, t, n) {
                        switch (n.style.left = "", n.style.right = "", n.style.top = "", n.style.bottom = "", e) {
                            case c.default.LEFT_TOP:
                                n.style.left = t.x + "px", n.style.top = t.y + "px";
                                break;
                            case c.default.RIGHT_TOP:
                                n.style.right = -t.x + "px", n.style.top = t.y + "px";
                                break;
                            case c.default.LEFT_BOTTOM:
                                n.style.left = t.x + "px", n.style.bottom = -t.y + "px";
                                break;
                            case c.default.RIGHT_BOTTOM:
                                n.style.right = -t.x + "px", n.style.bottom = -t.y + "px";
                                break;
                            default:
                                n.style.left = t.x + "px", n.style.top = t.y + "px"
                        }
                    }
                }, {
                    key: "onChange",
                    value: function (e) {
                        s = e
                    }
                }, {
                    key: "setFocusStaus",
                    value: function (e) {
                        document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(102, 102, 102)", this._foucusId = (0, o.default)(e), document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(30, 130, 250)", this.changeScrollBtnPic()
                    }
                }, {
                    key: "foucusId",
                    set: function (e) {
                        var t = [];
                        t.push.apply(t, (0, a.default)(this._map.visibleGroupIDs)), 1 == t.length ? this._map.visibleGroupIDs = [e] : -1 < this._map.visibleGroupIDs.indexOf(e) || (t.push(e), this._map.visibleGroupIDs = t), this._map.changeFocusToGroup({
                            gid: e
                        }), s && s([e], 1 < this._map.visibleGroupIDs.length)
                    },
                    get: function () {
                        return this._map.currentFocusGroup
                    }
                }, {
                    key: "allLayer",
                    get: function () {
                        return this._map.showAllGroup
                    }
                }]), n
            }(),
            p = f;
        t.default = p
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11)),
            o = r(n(2)),
            s = r(n(422)),
            l = function e(t) {
                (0, o.default)(this, e), this.size = s.default.FMMap_CONTROL_NORMAL, this.position = null, this.offset = new fm.Vector2(0, 0), this.imgURL = "resource/style/wedgets/img/", (0, a.default)(this, t)
            },
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                FMMap_CONTROL_SMALL: "small",
                FMMap_CONTROL_NORMAL: "normal"
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var s = r(n(11));
        n(8), n(113);
        var a = r(n(2)),
            o = r(n(3)),
            l = r(n(4)),
            u = r(n(5)),
            h = r(n(6)),
            c = r(n(7)),
            d = r(n(20)),
            f = r(n(150)),
            p = r(n(58)),
            g = r(n(21)),
            m = r(n(112)),
            v = r(n(153)),
            y = n(69),
            _ = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, l.default)(this, (0, u.default)(n).call(this, 0, g.default.IMAGE_MARKER)), t.isInitSprite = !1, t._url = e.url, t._size = e.size, t._height = 0, t._offsetHeight = e.height ? e.height : 0, t._renderNode = null, t._visible = !0, t._opx = e.x || 0, t._opy = e.y || 0, t._callBack = e.callback, t._moveAnimater = null, t._isMoving = !1, t._depth = e.depth, t._isJumping = !1, t._origonY = 0, t.center = t.getCenterByAnchor(e.anchor), t.picLoading = !1, t.needAvoid = !0, t.markername = e.name, t
                }
                return (0, h.default)(n, e), (0, o.default)(n, [{
                    key: "initSprite",
                    value: function () {
                        var e = this,
                            t = this.findParent(d.default);
                        if (!t) return !1;
                        var n = !0,
                            r = t.materialManager.createPoiMaterial({
                                imageUrl: this._url,
                                imageSrc: this._url,
                                alpha: 1
                            }, function () {
                                e._renderNode ? (e.picLoading = !1, e._renderNode.layers.set(0), e._renderNode.frustumCulled = !1, t.map.renderer.setImageMarkerSize(e._renderNode)) : n = !1
                            }, this._depth, this._priority);
                        r.userData.size = this._size, this._renderNode = new m.default(r), this._renderNode.markername = this.markername, n && (this.picLoading = !0, this._renderNode.layers.set(2)), this._renderNode.mapNode = this, this._renderNode.parent = this.parent.scene, this._renderNode.center.set(this.center.x, this.center.y), t.map.renderer.setImageMarkerSize(this._renderNode), this._renderNode.visible = this.show, this._renderNode.name = "spirit", this.isInitSprite = !0;
                        var i = this.parent.parent.groupID,
                            a = this.parent.parent.parent.mapcenter;
                        return this._opx && this._opy ? (this._x = this._opx, this._y = this._opy) : (this._x = a.x, this._y = a.y), this.setPosition(this.x, this.y, i, this._offsetHeight), this._callBack && this._callBack(this), !0
                    }
                }, {
                    key: "setPosition",
                    value: function (e, t, n, r) {
                        var i = this.findParent(f.default);
                        if (i) {
                            "number" == typeof n && 0 < n && this.moveToGroup(n);
                            var a = i.center,
                                o = i.mapcenter;
                            this._height = r, this._x = e, this._y = t, this._renderNode.position.set(this._x - o.x, a.y + this._height, a.y - this._y + o.y)
                        } else console.error("Can't change position before map init Marker")
                    }
                }, {
                    key: "getPosition",
                    value: function () {
                        return {
                            x: this._y,
                            y: this._y,
                            z: this._height,
                            groupID: this.parent.parent.groupID
                        }
                    }
                }, {
                    key: "moveTo",
                    value: function (t) {
                        var n = this;
                        if (!this._isMoving) {
                            var e = this.findParent(d.default),
                                r = t.x,
                                i = t.y,
                                a = null;
                            a = t.height ? t.height : this._height;
                            var o = new p.default({
                                x: this.x,
                                y: this.y,
                                height: this._height
                            }, {
                                x: r,
                                y: i,
                                height: a
                            }, 1e3 * t.time, function () {
                                e.map.removeAnimater(o), n._moveAnimater = null, n._isMoving = !1, t.callback()
                            }, function (e) {
                                n.setPosition(e.x, e.y, 0, e.height), t.update(e)
                            }).start();
                            this._isMoving = !0, e.map.addAnimater(o), this._moveAnimater = o
                        }
                    }
                }, {
                    key: "moveToGroup",
                    value: function (e) {
                        var t = this.findParent(d.default),
                            n = this.parent.parent.groupID;
                        if (n !== e)
                            if (this.parent.parent.parent.groups["" + e]) {
                                this._groupId = e;
                                var r = this.parent.parent.parent.groups["" + e].getOrCreateLayer("imageMarker");
                                this.parent.untiedMarker(this), r.addMarker(this), this._renderNode.material.opacity = .9, t.map.renderer.setImageMarkerSize(this._renderNode)
                            } else console.warn(y.tileMessage.noGroup)
                    }
                }, {
                    key: "stopMoveTo",
                    value: function () {
                        var e = this.findParent(d.default);
                        this._moveAnimater && this._moveAnimater.stop(), e.map.removeAnimater(this._moveAnimater), this._isMoving = !1, this._moveAnimater = null
                    }
                }, {
                    key: "jump",
                    value: function (e) {
                        var n = this;
                        if (this._renderNode && !this._isJumping) {
                            this._isJumping = !0;
                            var r = (0, s.default)({
                                height: 8,
                                times: 0,
                                duration: 1,
                                delay: 0
                            }, e);
                            if ("number" == typeof r.height && "number" == typeof r.times && "number" == typeof r.duration && "number" == typeof r.delay) {
                                r.duration *= 1e3, r.delay *= 1e3, r.all = r.duration + r.delay, r.halfDuration = r.duration / 2;
                                var i = r.height - this._height;
                                this._origonY = this._renderNode.position.y;
                                var a = (new Date).getTime(),
                                    t = this.findParent(d.default),
                                    o = t.map;
                                this.jumpEvent = function () {
                                    if (n._renderNode) {
                                        var e = (new Date).getTime() - a;
                                        if (0 != r.times && e / r.all > r.times) n.stopJump();
                                        else if (e %= r.all, e > r.duration) n._renderNode.position.y != n._origonY && (n._renderNode.position.y = n._origonY);
                                        else {
                                            var t = e / r.halfDuration - 1;
                                            t = 1 - t * t, n._renderNode.position.y = n._origonY + i * t
                                        }
                                    } else o.off("frameLoop", n.jumpEvent)
                                }, o.on("frameLoop", this.jumpEvent)
                            }
                        }
                    }
                }, {
                    key: "stopJump",
                    value: function () {
                        if (this._renderNode && this.jumpEvent) {
                            this._renderNode.position.y = this._origonY, this._isJumping = !1;
                            var e = this.findParent(d.default),
                                t = e.map;
                            t.off("frameLoop", this.jumpEvent)
                        }
                    }
                }, {
                    key: "setSize",
                    value: function () {
                        var e = this.findParent(d.default);
                        e.map.renderer.setFacilitySize(this._renderNode, this._size)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.parent && this.parent.removeMarker(this), this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "getCenterByAnchor",
                    value: function (e) {
                        var t = new fm.Vector2(.5, .5);
                        switch (e) {
                            case v.default.LEFT:
                                t.setX(0);
                                break;
                            case v.default.RIGHT:
                                t.setX(1);
                                break;
                            case v.default.TOP:
                                t.setY(1);
                                break;
                            case v.default.BOTTOM:
                                t.setY(0);
                                break;
                            case v.default.LEFT_TOP:
                                t.set(0, 1);
                                break;
                            case v.default.RIGHT_TOP:
                                t.set(1, 1);
                                break;
                            case v.default.LEFT_BOTTOM:
                                t.set(0, 0);
                                break;
                            case v.default.RIGHT_BOTTOM:
                                t.set(1, 0)
                        }
                        return t
                    }
                }, {
                    key: "url",
                    set: function (e) {
                        var t = this.findParent(d.default);
                        if (!t) return !1;
                        var n = t.materialManager.createPoiMaterial({
                            imageUrl: e,
                            imageSrc: e,
                            alpha: 1
                        });
                        n.userData.size = this._size, this._renderNode.material.dispose(), this._renderNode.material = n, this._url = e
                    },
                    get: function () {
                        return this._url
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : this._renderNode && this.parent.scene.remove(this._renderNode), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this._size
                    },
                    set: function (e) {
                        this._size = e
                    }
                }, {
                    key: "height",
                    set: function (e) {
                        this._height = e, this._renderNode.position.y = this._height
                    }
                }]), n
            }(c.default),
            A = _;
        t.default = A
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(11));
        n(113), n(13), n(68), n(8);
        var s = r(n(2)),
            l = r(n(3)),
            u = r(n(4)),
            h = r(n(5)),
            c = r(n(6)),
            o = r(n(7)),
            d = r(n(20)),
            f = r(n(112)),
            p = r(n(150)),
            g = r(n(58)),
            m = r(n(21)),
            v = r(n(153)),
            y = n(69),
            _ = function (e) {
                function o(e, t) {
                    var n;
                    if ((0, s.default)(this, o), n = (0, u.default)(this, (0, h.default)(o).call(this, 0, m.default.TEXT_MARKER)), n._text = e.name, n._param = e, n.isInitSprite = !1, n._opx = e.x || 0, n._opy = e.y || 0, n._height = e.height || 0, n._renderNode = null, n._visible = !0, n._isRuning = !1, n._size = 1.4 * e.fontsize, n._callBack = e.callback, n._fillcolor = e.fillcolor, n._platecolor = e.platecolor, n._platestrokecolor = e.platestrokecolor, n._fontsize = e.fontsize, n._strokecolor = e.strokecolor, n._content = e.content, n.needAvoid = !1, !n._content) {
                        n.needAvoid = !0;
                        for (var r = n._text.split("%rn%"), i = [], a = 0; a < r.length; a++) i.push({
                            text: r[a],
                            fontsize: n._fontsize,
                            fontcolor: n._fillcolor,
                            strokecolor: n._strokecolor
                        });
                        n._content = i
                    }
                    return n._scale = e.scale, n._target = t, n._moveAnimater = null, n.center = n.getCenterByAnchor(e.anchor), n.picLoading = !1, n
                }
                return (0, c.default)(o, e), (0, l.default)(o, [{
                    key: "getCenterByAnchor",
                    value: function (e) {
                        var t = new fm.Vector2(.5, .5);
                        switch (e) {
                            case v.default.LEFT:
                                t.setX(0);
                                break;
                            case v.default.RIGHT:
                                t.setX(1);
                                break;
                            case v.default.TOP:
                                t.setY(1);
                                break;
                            case v.default.BOTTOM:
                                t.setY(0);
                                break;
                            case v.default.LEFT_TOP:
                                t.set(0, 1);
                                break;
                            case v.default.RIGHT_TOP:
                                t.set(1, 1);
                                break;
                            case v.default.LEFT_BOTTOM:
                                t.set(0, 0);
                                break;
                            case v.default.RIGHT_BOTTOM:
                                t.set(1, 0)
                        }
                        return t
                    }
                }, {
                    key: "initSprite",
                    value: function () {
                        var e = this.findParent(d.default);
                        if (!e) return !1;
                        var t = e.materialManager.createTextMaterial(this._content, (0, a.default)({
                            alpha: 1
                        }, this._param), this._param.depth);
                        this._size = t.size, t.userData.size = t.size, this._renderNode = new f.default(t), this._renderNode.mapNode = this, this._renderNode.frustumCulled = !1, this._target ? this.setTsize() : e.map.renderer.setLabelSize(this._renderNode, t.size), this._renderNode.center.set(this.center.x, this.center.y), this.isInitSprite = !0;
                        var n = this.parent.parent.parent.mapcenter;
                        if (this._target) {
                            var r = this._target.mapCoord;
                            this._x = r.x, this._y = r.y
                        } else this._opx && this._opy ? (this._x = this._opx, this._y = this._opy) : (this._x = n.x, this._y = n.y);
                        return this._height, this.setPosition(this.x, this.y, 0, this._height), this._callBack && this._callBack(), this._renderNode.visible = this.show, this._renderNode.name = "spirit", !0
                    }
                }, {
                    key: "redraw",
                    value: function () {
                        var e = this.findParent(d.default);
                        if (!e) return !1;
                        if (this.renderNode) {
                            var t = e.materialManager.createTextMaterial(this._content, (0, a.default)({
                                alpha: 1
                            }, this._param));
                            this.renderNode.material.map.dispose(), this.renderNode.material.dispose(), this.renderNode.material = t
                        }
                    }
                }, {
                    key: "setTsize",
                    value: function () {
                        var e = this._target,
                            t = e.getNearestDis();
                        this.renderNode && (this.setSize(t * this._scale), this.renderNode.material.sizeAttenuation = !0)
                    }
                }, {
                    key: "setSize",
                    value: function (e) {
                        var t = this.findParent(d.default);
                        this._size = e, t.map.renderer.setLabelSize(this._renderNode, e || this._size, !!e)
                    }
                }, {
                    key: "setPosition",
                    value: function (e, t, n, r) {
                        var i = this.findParent(p.default);
                        if (i) {
                            "number" == typeof n && 0 < n && this.moveToGroup(n);
                            var a = i.mapcenter;
                            this._height = r, this._x = e, this._y = t, this._renderNode.position.set(this._x - a.x, this._height, -this._y + a.y)
                        } else console.error("Can't change position before map init Marker")
                    }
                }, {
                    key: "getPosition",
                    value: function () {
                        return {
                            x: this._x,
                            y: this._y,
                            z: this._height,
                            groupID: this.parent.parent.groupID
                        }
                    }
                }, {
                    key: "moveTo",
                    value: function (t) {
                        var n = this;
                        if (!this._isRuning) {
                            var e = this.findParent(d.default),
                                r = t.x,
                                i = t.y,
                                a = new g.default({
                                    x: this.x,
                                    y: this.y
                                }, {
                                    x: r,
                                    y: i
                                }, 1e3 * t.time, function () {
                                    e.map.removeAnimater(a), n._moveAnimater = null, n._isRuning = !1, t.callback()
                                }, function (e) {
                                    n.setPosition(e.x, e.y, 0, 0), t.update(e)
                                }).start();
                            this._isRuning = !0, e.map.addAnimater(a), this._moveAnimater = a
                        }
                    }
                }, {
                    key: "moveToGroup",
                    value: function (e) {
                        var t = this.findParent(d.default),
                            n = this.parent.parent.groupID;
                        if (n !== e)
                            if (this.parent.parent.parent.groups["" + e]) {
                                var r = this.parent.parent.parent.groups["" + e].getOrCreateLayer("textMarker");
                                this._groupId = e, this.parent.untiedMarker(this), this._renderNode.material.opacity = .9, r.addMarker(this), t.map.renderer.setLabelSize(this._renderNode, this._renderNode.material.userData.size)
                            } else console.warn(y.tileMessage.noGroup)
                    }
                }, {
                    key: "stopMoveTo",
                    value: function () {
                        var e = this.findParent(d.default);
                        this._moveAnimater && this._moveAnimater.stop(), e.map.removeAnimater(this._moveAnimater)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.material.texture && this._renderNode.material.texture.dispose(), this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "reDraw",
                    value: function () {
                        var e = this.findParent(d.default);
                        if (!e) return !1;
                        var t = e.materialManager.createLabelMaterial(this._text, (0, a.default)({
                            alpha: 1
                        }, this._param));
                        t.userData.size = this._size, this._renderNode.material.dispose(), this._renderNode.material = void 0, this._renderNode.material = t, e.map.renderer.setLabelSize(this._renderNode, this._size)
                    }
                }, {
                    key: "name",
                    set: function (e) {
                        this._text = e, this.reDraw()
                    },
                    get: function () {
                        return this._text
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "visible",
                    set: function (e) {
                        e ? this.parent.scene.children.indexOf(this._renderNode) < 0 && this._renderNode && this.parent.scene.add(this._renderNode) : this._renderNode && this.parent.scene.remove(this._renderNode), this._visible = e
                    },
                    get: function () {
                        return this._visible
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this._size
                    }
                }, {
                    key: "fillcolor",
                    get: function () {
                        return this._fillcolor
                    },
                    set: function (e) {
                        this._fillcolor = e, this._param.fillcolor = e, this.reDraw()
                    }
                }, {
                    key: "fontsize",
                    get: function () {
                        return this._fontsize
                    }
                }, {
                    key: "strokecolor",
                    get: function () {
                        return this._strokecolor
                    },
                    set: function (e) {
                        this._strokecolor = e, this._param.strokecolor = e, this.reDraw()
                    }
                }, {
                    key: "content",
                    set: function (e) {
                        this._content = e
                    }
                }, {
                    key: "height",
                    set: function (e) {
                        this._height = e, this._renderNode.position.y = this._height
                    }
                }]), o
            }(o.default),
            A = _;
        t.default = A
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = n(241),
            d = n(154),
            f = n(426),
            p = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, e)), t._renderNode = null, t._lineLength = void 0 !== e.lineLength ? e.lineLength : 5, t._center = e.center, t._minDistance = t._getMinDistance(e.points), t._points = t._getPoints(e.points), t._backgroundColor = e.backgroundColor, t._color = e.color, t._colors = t._getColor(), t._opacity = e.opacity, t._lineWidth = e.lineWidth, t._speed = e.speed, t._show = !0, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "initLine",
                    value: function () {
                        var e = new c.LineGeometry;
                        e.setPositions(this._points), e.setColors(this._colors);
                        var t = new d.LineMaterial({
                            lineWidth: this._lineWidth,
                            vertexColors: fm.VertexColors
                        });
                        t.uniforms.opacity.value = this._opacity, t.resolution.set(this.parent.parent.parent.parent._map.renderer._w, this.parent.parent.parent.parent._map.renderer._h), this._renderNode = new f.Line2(e, t), this._renderNode.mapNode = this, this._renderNode.name = "line", this._renderNode.userData.colors = this._colors, this._renderNode.userData.speed = this._speed, this._renderNode.userData.frustumUpdate = !0, this._renderNode.userData.time = (new Date).getTime();
                        var n = this.parent.parent.parent.mapcenter;
                        this._x = n.x, this._y = n.y
                    }
                }, {
                    key: "_getMinDistance",
                    value: function (e) {
                        for (var t = 0, n = 0, r = 0; r < e.length; r += 3) {
                            var i = new fm.Vector3(e[r], e[r + 2], -e[r + 1]),
                                a = new fm.Vector3(e[r + 3], e[r + 5], -e[r + 4]);
                            n = i.distanceToSquared(a), 0 === r ? t = i.distanceToSquared(a) : n < t && (t = n)
                        }
                        return Math.sqrt(t)
                    }
                }, {
                    key: "_getPoints",
                    value: function (e) {
                        for (var t = [], n = 0; n < e.length - 3; n += 3)
                            for (var r = new fm.Vector3(e[n] - this._center.x, e[n + 2], -e[n + 1] + this._center.y), i = new fm.Vector3(e[n + 3] - this._center.x, e[n + 5], -e[n + 4] + this._center.y), a = new fm.LineCurve3(r, i), o = r.distanceTo(i), s = Math.ceil(o / (this._minDistance * this._lineLength)), l = a.getPoints(s), u = 0; u < l.length; u++) t.push(l[u].x, l[u].y, l[u].z);
                        return t
                    }
                }, {
                    key: "_getColor",
                    value: function () {
                        for (var e = [], t = new fm.Color(this._color), n = new fm.Color(this._backgroundColor), r = 0; r < this._points.length / 3; r++) 3 * r < 3 * this._lineLength ? e.push(t.r, t.g, t.b) : e.push(n.r, n.g, n.b);
                        return e
                    }
                }, {
                    key: "setColor",
                    value: function (e) {
                        this._color = e, this._colors = this._getColor(), this._renderNode.userData.colors = this._colors
                    }
                }, {
                    key: "setBackgroundColor",
                    value: function (e) {
                        this._backgroundColor = e, this._colors = this._getColor(), this._renderNode.userData.colors = this._colors
                    }
                }, {
                    key: "setOpacity",
                    value: function (e) {
                        this._renderNode.material.uniforms.opacity.vaule = e
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "show",
                    get: function () {
                        return this._show
                    },
                    set: function (e) {
                        this._renderNode.visible = e, this._show = e, this._renderNode.userData.frustumUpdate = !0
                    }
                }]), n
            }(h.default),
            g = p;
        t.default = g
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.Line2 = void 0;
        var a = r(n(31)),
            o = r(n(11)),
            s = n(427),
            l = n(241),
            u = n(154),
            h = function (e, t) {
                s.LineSegments2.call(this), this.type = "Line2", this.geometry = void 0 !== e ? e : new l.LineGeometry, this.material = void 0 !== t ? t : new u.LineMaterial({
                    color: 16777215 * Math.random()
                })
            };
        t.Line2 = h, h.prototype = (0, o.default)((0, a.default)(s.LineSegments2.prototype), {
            constructor: h,
            isLine2: !0
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.LineSegments2 = void 0, n(25);
        var C, I, w, M, b, S, E, l, u, a = r(n(31)),
            o = r(n(11)),
            T = n(82),
            s = n(242),
            h = n(154),
            c = function (e, t) {
                T.Mesh.call(this), this.type = "LineSegments2", this.geometry = void 0 !== e ? e : new s.LineSegmentsGeometry, this.material = void 0 !== t ? t : new h.LineMaterial({
                    color: 16777215 * Math.random()
                })
            };
        t.LineSegments2 = c, c.prototype = (0, o.default)((0, a.default)(T.Mesh.prototype), {
            constructor: c,
            isLineSegments2: !0,
            computeLineDistances: (l = new T.Vector3, u = new T.Vector3, function () {
                for (var e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, r = new Float32Array(2 * t.data.count), i = 0, a = 0, o = t.data.count; i < o; i++, a += 2) l.fromBufferAttribute(t, i), u.fromBufferAttribute(n, i), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + l.distanceTo(u);
                var s = new T.InstancedInterleavedBuffer(r, 2, 1);
                return e.setAttribute("instanceDistanceStart", new T.InterleavedBufferAttribute(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new T.InterleavedBufferAttribute(s, 1, 1)), this
            }),
            raycast: (C = new T.Vector4, I = new T.Vector4, w = new T.Vector4, M = new T.Vector3, b = new T.Matrix4, S = new T.Line3, E = new T.Vector3, function (e, t) {
                null === e.camera && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
                var n = e.ray,
                    r = e.camera,
                    i = r.projectionMatrix,
                    a = this.geometry,
                    o = this.material,
                    s = o.resolution,
                    l = o.linewidth,
                    u = a.attributes.instanceStart,
                    h = a.attributes.instanceEnd;
                n.at(1, w), w.w = 1, w.applyMatrix4(r.matrixWorldInverse), w.applyMatrix4(i), w.multiplyScalar(1 / w.w), w.x *= s.x / 2, w.y *= s.y / 2, w.z = 0, M.copy(w);
                var c = this.matrixWorld;
                b.multiplyMatrices(r.matrixWorldInverse, c);
                for (var d = 0, f = u.count; d < f; d++) {
                    C.fromBufferAttribute(u, d), I.fromBufferAttribute(h, d), C.w = 1, I.w = 1, C.applyMatrix4(b), I.applyMatrix4(b), C.applyMatrix4(i), I.applyMatrix4(i), C.multiplyScalar(1 / C.w), I.multiplyScalar(1 / I.w);
                    var p = C.z < -1 && I.z < -1,
                        g = 1 < C.z && 1 < I.z;
                    if (!p && !g) {
                        C.x *= s.x / 2, C.y *= s.y / 2, I.x *= s.x / 2, I.y *= s.y / 2, S.start.copy(C), S.start.z = 0, S.end.copy(I), S.end.z = 0;
                        var m = S.closestPointToPointParameter(M, !0);
                        S.at(m, E);
                        var v = T.Math.lerp(C.z, I.z, m),
                            y = -1 <= v && v <= 1,
                            _ = M.distanceTo(E) < .5 * l;
                        if (y && _) {
                            S.start.fromBufferAttribute(u, d), S.end.fromBufferAttribute(h, d), S.start.applyMatrix4(c), S.end.applyMatrix4(c);
                            var A = new T.Vector3,
                                x = new T.Vector3;
                            n.distanceSqToSegment(S.start, S.end, x, A), t.push({
                                point: x,
                                pointOnLine: A,
                                distance: n.origin.distanceTo(x),
                                object: this,
                                face: null,
                                faceIndex: d,
                                uv: null,
                                uv2: null
                            })
                        }
                    }
                }
            })
        })
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(429)),
            d = r(n(21)),
            f = r(n(58)),
            p = n(69),
            g = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, 0, d.default.LOCATION_MARKER)), t._size = e.size || 20, t._url = e.url, t._groupId = e.groupID || 1, t._x = e.x || t._x, t._y = e.y || t._y, t._dheight = e.height || 2.1, t._gid = e.groupID || 1, t._scene = null, t._renderNode = null, t._map = null, t._callBack = e.callback, t.rotateAnimater = null, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "initSprite",
                    value: function (e) {
                        var t = this,
                            n = new c.default,
                            r = new fm.MeshBasicMaterial,
                            i = !0;
                        e.materialManager.loadTexture(this._url, function (e) {
                            e.minFilter = fm.LinearFilter, e.generateMipmaps = !1, e.flipY = !1, r.map = e, r.needsUpdate = !0, t._renderNode ? (t.picLoading = !1, t._renderNode.layers.set(0)) : i = !1, t._map.renderer.resetLocationsSize()
                        }), r.side = 2, r.transparent = !0, this._renderNode = new fm.Mesh(n, r), this._renderNode.mapNode = this, i && (this.picLoading = !0, this._renderNode.layers.set(2));
                        var a = this._scene.mapcenter;
                        return this._x && this._y || (this._x = a.x, this._y = a.y), this._callBack && this._callBack(this), this.setPosition({
                            x: this._x,
                            y: this._y
                        }), !0
                    }
                }, {
                    key: "setPosition",
                    value: function (e) {
                        if (this._scene) {
                            void 0 !== e.zOffset && (this._dheight = e.zOffset), void 0 !== e.height && (this._dheight = e.height);
                            var t = this._scene.groups[this._gid];
                            if (e.groupID && e.groupID !== this._gid) {
                                var n = t,
                                    r = this._scene.groups[e.groupID];
                                if (!r) return void console.warn(p.tileMessage.noGroup);
                                n.removeLocation(this), r.addLocation(this), t = r, this.isAlwaysShow && this.alwaysShow(), this._gid = e.groupID, this._groupId = this._gid
                            }
                            var i = this._scene.mapcenter;
                            this._x = e.x, this._y = e.y, this._renderNode.position.set(this._x - i.x, this._dheight, -this._y + i.y)
                        } else console.error("Can't change position before map init Marker")
                    }
                }, {
                    key: "rotate",
                    value: function (e) {
                        this._renderNode.rotation.y = e * fm.Math.DEG2RAD
                    }
                }, {
                    key: "rotateTo",
                    value: function (t) {
                        var n = this,
                            e = this.renderNode.rotation.y,
                            r = t.to % 360 * fm.Math.DEG2RAD,
                            i = r,
                            a = 0;
                        r - e != 0 && (a = Math.sin(r - e) / Math.abs(Math.sin(r - e)) * Math.acos(Math.cos(r - e)));
                        var o = e + a,
                            s = e;
                        this.rotateAnimater && (this.rotateAnimater.stop(), this._map.removeAnimater(this.rotateAnimater));
                        var l = new f.default({
                            angle: s
                        }, {
                            angle: o
                        }, t.duration ? 1e3 * t.duration : 500, function () {
                            n._map.removeAnimater(l), n.rotateAnimater = null, n._renderNode.rotation.y = i, t.callback && t.callback()
                        }, function (e) {
                            n._renderNode.rotation.y = e.angle, t.update && t.update()
                        }).start();
                        this._map.addAnimater(l), this.rotateAnimater = l
                    }
                }, {
                    key: "moveTo",
                    value: function (t) {
                        var n = this;
                        if (!this._isRuning) {
                            var e = t.x,
                                r = t.y,
                                i = new f.default({
                                    x: this._x,
                                    y: this._y
                                }, {
                                    x: e,
                                    y: r
                                }, t.time ? 1e3 * t.time : 500, function () {
                                    n._map.removeAnimater(i), n._moveAnimater = null, n._isRuning = !1, t.callback && t.callback()
                                }, function (e) {
                                    n.setPosition({
                                        x: e.x,
                                        y: e.y,
                                        groupID: 0,
                                        height: n._dheight
                                    }), t.update && t.update(e)
                                }).start();
                            this._isRuning = !0, this._map.addAnimater(i), this._moveAnimater = i
                        }
                    }
                }, {
                    key: "stopMoveTo",
                    value: function () {
                        var e = this._map.nodeManager;
                        this._moveAnimater && this._moveAnimater.stop(), e.map.removeAnimater(this._moveAnimater)
                    }
                }, {
                    key: "alwaysShow",
                    value: function () {
                        var e;
                        this._alwaysShow = !0;
                        for (var t = this.parent; t;) {
                            if (t.isGroup) {
                                e = t;
                                break
                            }
                            t = t.parent
                        }
                        e && this.renderNode && (this.renderNode.material.depthTest = !1, e.alwaysShowMarkers.push(this.renderNode))
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this.parent && this.parent.removeLocation(this), this.parent = null, this._renderNode && (this._renderNode.material.dispose(), this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }, {
                    key: "direction",
                    get: function () {
                        return this.renderNode.rotation.y
                    },
                    set: function (e) {
                        this.renderNode.rotation.y = e * fm.Math.DEG2RAD
                    }
                }, {
                    key: "scene",
                    set: function (e) {
                        this._scene = e
                    }
                }, {
                    key: "map",
                    set: function (e) {
                        this._map = e
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this._size
                    }
                }, {
                    key: "renderNode",
                    get: function () {
                        return this._renderNode
                    }
                }, {
                    key: "groupID",
                    get: function () {
                        return this._groupId
                    }
                }, {
                    key: "height",
                    get: function () {
                        return this._dheight
                    }
                }]), n
            }(h.default),
            m = g;
        t.default = m
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(25);
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = function (e) {
                function r() {
                    var e;
                    (0, a.default)(this, r), e = (0, o.default)(this, (0, s.default)(r).call(this));
                    var t = new Float32Array([-.5, 0, -.5, 0, 0, .5, 0, -.5, 1, 0, .5, 0, .5, 1, 1, -.5, 0, .5, 0, 1]),
                        n = new fm.InterleavedBuffer(t, 5);
                    return e.setIndex([0, 1, 2, 0, 2, 3]), e.addAttribute("position", new fm.InterleavedBufferAttribute(n, 3, 0, !1)), e.addAttribute("uv", new fm.InterleavedBufferAttribute(n, 2, 3, !1)), e
                }
                return (0, l.default)(r, e), r
            }(fm.BufferGeometry),
            h = u;
        t.default = h
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(431)),
            c = (r(n(245)), r(n(244)), function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, e, t)), n.type = "Line2", n.isLine2 = !0, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "copy",
                    value: function () {}
                }]), r
            }(h.default)),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(25);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = (r(n(246)), function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, e, t)), n.type = "LineSegments2", n.isLineSegments2 = !0, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "computeLineDistances",
                    value: function () {
                        for (var e = new fm.Vector3, t = new fm.Vector3, n = this.geometry, r = n.attributes.instanceStart, i = n.attributes.instanceEnd, a = new Float32Array(2 * r.data.count), o = 0, s = 0, l = r.data.count; o < l; o++, s += 2) e.fromBufferAttribute(r, o), t.fromBufferAttribute(i, o), a[s] = 0 === s ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t);
                        var u = new fm.InstancedInterleavedBuffer(a, 2, 1);
                        return n.setAttribute("instanceDistanceStart", new fm.InterleavedBufferAttribute(u, 1, 0)), n.setAttribute("instanceDistanceEnd", new fm.InterleavedBufferAttribute(u, 1, 1)), this
                    }
                }, {
                    key: "copy",
                    value: function () {
                        return this
                    }
                }]), r
            }(fm.Mesh)),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(25);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(21)),
            g = r(n(20)),
            m = r(n(155)),
            c = r(n(49)),
            d = r(n(248)),
            v = r(n(115)),
            f = r(n(249)),
            p = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, 0, h.default.POLYGON_MARKER)), t._alpha = void 0 !== e.alpha ? e.alpha : 1, t._color = void 0 !== e.color ? e.color : "#FF0000", t._dheight = e.height || 0, t._lineColor = e.lineColor || e.color || "#FF0000", t._lineWidth = "number" == typeof e.lineWidth ? e.lineWidth : 2, t._points = void 0 !== e.points ? e.points : [], e.points.type && ("rectangle" === e.points.type && e.points.startPoint && e.points.startPoint.x && e.points.startPoint.y ? (t._x = e.points.startPoint.x + e.points.width / 2, t._y = e.points.startPoint.y - e.points.height / 2) : (t._x = e.points.center.x, t._y = e.points.center.y)), t._line = null, t._linePoints = null, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "initPolygon",
                    value: function () {
                        return this.init()
                    }
                }, {
                    key: "init",
                    value: function () {
                        if (!this._points) return !1;
                        if (!this.parent) return !1;
                        if (!this.parent.parent) return !1;
                        var e = this.findParent(g.default);
                        if (!e) return !1;
                        var t = {};
                        t.resolution = new fm.Vector2(e.map.renderer.container.clientWidth, e.map.renderer.container.clientHeight);
                        var n = e.map.renderer.getCameraByViewMode(e.map._viewMode);
                        t.near = n.near, t.far = n.far, t.color = this._lineColor, t.alpha = 1, t.lineWidth = this._lineWidth;
                        var r = this.parent.parent,
                            i = new fm.MeshBasicMaterial;
                        i.transparent = !0, i.opacity = this._alpha, i.color = new fm.Color(this._color), i.side = 2, i.depthTest = !1, r.getCenterPosition();
                        var a, o, s = r.parent.mapcenter;
                        switch (this._x || (this._x = s.x), this._y || (this._y = s.y), this._dheight ? this._height = this._dheight : this._height = 0, this._points.type) {
                            case "circle":
                                a = this.createCircleGeometry(this._points.radius, this._points.segments), o = new Float32Array(a.attributes.position.array.length - 3);
                                for (var l = 0; l < a.attributes.position.array.length; l++) 2 < l && (o[l - 3] = a.attributes.position.array[l]);
                                break;
                            case "rectangle":
                                a = this.createReactGeometry(this._points.width, this._points.height);
                                var u = a.attributes.position.array.length,
                                    h = a.attributes.position.array;
                                o = new Float32Array(u + 3);
                                for (var c = 0; c < u; c++) o[c] = a.attributes.position.array[c];
                                o[u - 6] = h[u - 3], o[u - 5] = h[u - 2], o[u - 4] = h[u - 1], o[u - 3] = h[u - 6], o[u - 2] = h[u - 5], o[u - 1] = h[u - 4], o[u] = h[0], o[u + 1] = h[1], o[u + 2] = h[2];
                                break;
                            default:
                                a = v.default.createShapeBufferGeometryByCenter(this._points, s);
                                var d = a.attributes.position.array.length;
                                o = new Float32Array(d + 3);
                                for (var f = 0; f < d; f++) o[f] = a.attributes.position.array[f];
                                o[d] = a.attributes.position.array[0], o[d + 1] = a.attributes.position.array[1], o[d + 2] = a.attributes.position.array[2]
                        }
                        this._linePoints = o;
                        var p = new m.default;
                        return p.initLinePoints(o, t), this._line = p, this._renderNode = new fm.Mesh(a, i), this._renderNode.mapNode = this, this._renderNode.add(p.renderNode), this._renderNode.rotation.set(Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.set(this._x - s.x, this._height, -this._y + s.y), !0
                    }
                }, {
                    key: "contain",
                    value: function (e) {
                        if (!this._points) return !1;
                        if (!this.parent) return !1;
                        if (!this.parent.parent) return !1;
                        if ("circle" === this._points.type) {
                            var t = Math.sqrt((e.x - this._x) * (e.x - this._x) + (e.y - this._y) * (e.y - this._y));
                            if (t < this._points.radius) return !0
                        } else {
                            if ("rectangle" !== this._points.type) return c.default.pointInPolygon2d(this._points, e, this._points.length);
                            if (Math.abs(e.x - this._x) < this._points.width / 2 && Math.abs(e.y - this._y) < this._points.height / 2) return !0
                        }
                        return !1
                    }
                }, {
                    key: "createReactGeometry",
                    value: function (e, t) {
                        return new fm.PlaneBufferGeometry(e, t)
                    }
                }, {
                    key: "createCircleGeometry",
                    value: function (e, t) {
                        return new fm.CircleBufferGeometry(e, t)
                    }
                }, {
                    key: "createPolygonGeometry",
                    value: function (e, t) {
                        for (var n = new fm.Shape, r = 0; r < e.length; r++) 0 === r ? n.moveTo(e[r].x - t.x, -e[r].y + t.y) : n.lineTo(e[r].x - t.x, -e[r].y + t.y);
                        return n.lineTo(e[0].x - t.x, -e[0].y + t.y), new fm.ShapeBufferGeometry(n)
                    }
                }, {
                    key: "setColor",
                    value: function (e) {
                        this._renderNode.material.color = new fm.Color(e)
                    }
                }, {
                    key: "setLineColor",
                    value: function (e) {
                        this._line._renderNode.material.color = new fm.Color(e)
                    }
                }, {
                    key: "setLineWidth",
                    value: function (e) {
                        this._renderNode.children[0].material.linewidth = e
                    }
                }, {
                    key: "setAlpha",
                    value: function (e) {
                        this._renderNode.material.opacity = e
                    }
                }, {
                    key: "getPoints",
                    value: function () {
                        if ("circle" === this._points.type) {
                            var e = null,
                                t = [];
                            e = this.createCircleGeometry(this._points.radius, this._points.segments);
                            for (var n = 1; n < e.attributes.position.count; n++) t.push({
                                x: e.attributes.position.array[3 * n] + this._x,
                                y: e.attributes.position.array[3 * n + 1] + this._y
                            });
                            return e.dispose(), t
                        }
                        if ("rectangle" !== this._points.type) return this._points;
                        var r = null,
                            i = [];
                        return r = this.createReactGeometry(this._points.width, this._points.height), i.push({
                            x: r.attributes.position.array[0] + this._x,
                            y: r.attributes.position.array[1] + this._y
                        }), i.push({
                            x: r.attributes.position.array[3] + this._x,
                            y: r.attributes.position.array[4] + this._y
                        }), i.push({
                            x: r.attributes.position.array[9] + this._x,
                            y: r.attributes.position.array[10] + this._y
                        }), i.push({
                            x: r.attributes.position.array[6] + this._x,
                            y: r.attributes.position.array[7] + this._y
                        }), r.dispose(), i
                    }
                }, {
                    key: "center",
                    get: function () {
                        for (var e = this.parent.parent, t = (e.parent.mapcenter, []), n = 0; n < this._linePoints.length; n += 3) t.push([this._linePoints[n], this._linePoints[n + 1]]);
                        var r = null;
                        return r = (0, d.default)([t], .01), "circle" != this._points.type && "rectangle" != this._points.type ? {
                            x: this._x + r[0],
                            y: this._y - r[1],
                            z: this._height
                        } : {
                            x: this._x + r[0],
                            y: this._y + r[1],
                            z: this._height
                        }
                    }
                }, {
                    key: "isInitPolygon",
                    get: function () {
                        return this._isInit
                    }
                }]), n
            }(f.default),
            y = p;
        t.default = y
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var o = r(n(2)),
            s = r(n(3)),
            a = function () {
                function a(e, t) {
                    var n = 0 < arguments.length && void 0 !== e ? arguments[0] : [],
                        r = 1 < arguments.length && void 0 !== t ? arguments[1] : l;
                    if ((0, o.default)(this, a), this.data = n, this.length = this.data.length, this.compare = r, 0 < this.length)
                        for (var i = (this.length >> 1) - 1; 0 <= i; i--) this._down(i)
                }
                return (0, s.default)(a, [{
                    key: "push",
                    value: function (e) {
                        this.data.push(e), this.length++, this._up(this.length - 1)
                    }
                }, {
                    key: "pop",
                    value: function () {
                        if (0 !== this.length) {
                            var e = this.data[0],
                                t = this.data.pop();
                            return this.length--, 0 < this.length && (this.data[0] = t, this._down(0)), e
                        }
                    }
                }, {
                    key: "peek",
                    value: function () {
                        return this.data[0]
                    }
                }, {
                    key: "_up",
                    value: function (e) {
                        for (var t = this.data, n = this.compare, r = t[e]; 0 < e;) {
                            var i = e - 1 >> 1,
                                a = t[i];
                            if (0 <= n(r, a)) break;
                            t[e] = a, e = i
                        }
                        t[e] = r
                    }
                }, {
                    key: "_down",
                    value: function (e) {
                        for (var t = this.data, n = this.compare, r = this.length >> 1, i = t[e]; e < r;) {
                            var a = 1 + (e << 1),
                                o = t[a],
                                s = a + 1;
                            if (s < this.length && n(t[s], o) < 0 && (a = s, o = t[s]), 0 <= n(o, i)) break;
                            t[e] = o, e = a
                        }
                        t[e] = i
                    }
                }]), a
            }();

        function l(e, t) {
            return e < t ? -1 : t < e ? 1 : 0
        }
        var u = a;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(21)),
            c = r(n(20)),
            d = r(n(115)),
            f = n(435),
            p = n(436),
            g = r(n(114)),
            m = r(n(250)),
            v = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, 0, h.default.GRADIENT_POLYGON_MARKER, e)), t._scale = void 0 !== e.scale ? e.scale : 1, t._scaleValue = void 0 !== e.scaleValue ? e.scaleValue : 0, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "init",
                    value: function () {
                        if (!this._points) return !1;
                        if (!this.parent) return !1;
                        if (!this.parent.parent) return !1;
                        var e = this.findParent(c.default);
                        if (!e) return !1;
                        var t, n = this.parent.parent,
                            r = n.parent.mapcenter;
                        switch (this._points.type) {
                            case "circle":
                                t = this.createCircleGeometry(this._points.radius, this._points.segments);
                                break;
                            case "rectangle":
                                t = this.createReactGeometry(this._points.width, this._points.height);
                                break;
                            default:
                                g.default.convertPointsCoordsByCenter(this._points, r);
                                var i = this._scalePoints(),
                                    a = new fm.Vector3,
                                    o = new fm.Box3;
                                o.setFromPoints(i), o.getCenter(a), t = d.default.createCenterBufferGeometry(i, a)
                        }
                        var s = new fm.ShaderMaterial({
                            uniforms: {
                                color: {
                                    value: new fm.Color(this._color)
                                },
                                alpha: {
                                    value: this._alpha
                                }
                            },
                            vertexShader: f.GradientVertShader,
                            fragmentShader: p.GradientFragShader,
                            depthTest: !0,
                            depthWrite: !1,
                            transparent: !0
                        });
                        return this._renderNode = new fm.Mesh(t, s), this._renderNode.mapNode = this, this._renderNode.rotation.set(-Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.set(this.position.x, this._height, -this.position.y), !0
                    }
                }, {
                    key: "_scalePoints",
                    value: function () {
                        if (1 === this._scale) return this._points;
                        var e = new fm.Vector3,
                            t = new fm.Box3;
                        return t.setFromPoints(this._points), t.getCenter(e), d.default.scalePoints(this._points, e, this._scale)
                    }
                }, {
                    key: "_scaleValuePoints",
                    value: function () {
                        if (0 === this._scaleValue) return this._points;
                        var e = new fm.Vector3,
                            t = new fm.Box3;
                        return t.setFromPoints(this._points), t.getCenter(e), d.default.scaleValuePoints(this._points, e, this._scaleValue)
                    }
                }, {
                    key: "createReactGeometry",
                    value: function (e, t) {
                        return new fm.PlaneBufferGeometry(e, t)
                    }
                }, {
                    key: "createCircleGeometry",
                    value: function (e, t) {
                        return new fm.CircleBufferGeometry(e, t)
                    }
                }]), n
            }(m.default),
            y = v;
        t.default = y
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.GradientVertShader = void 0;
        var i = "\nattribute float gradientAlpha;\n\nvarying float v_gradientAlpha;\n\nvoid main() {\n  v_gradientAlpha = gradientAlpha;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n ";
        t.GradientVertShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.GradientFragShader = void 0;
        var i = "\n\nuniform vec3 color;\nuniform float alpha;\n\nvarying float v_gradientAlpha;\n\nvoid main() {\n  gl_FragColor = vec4(color, alpha * v_gradientAlpha);\n}\n ";
        t.GradientFragShader = i
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, null, [{
                    key: "polygonArea",
                    value: function (e) {
                        if (e.length < 3) return 0;
                        var t = e.length;
                        if (e[0].x === e[t - 1].x && e[0].y === e[t - 1].y && --t, t < 3) return 0;
                        for (var n = e[0].y * (e[t - 1].x - e[1].x), r = 1; r < t - 1; ++r) n += e[r].y * (e[r - 1].x - e[r + 1].x);
                        return n = e[t - 1].y * (e[t - 2].x - e[0].x), .5 * n
                    }
                }]), e
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(104)),
            h = r(n(6)),
            c = r(n(21)),
            d = r(n(20)),
            f = r(n(115)),
            p = r(n(114)),
            g = r(n(250)),
            m = r(n(439)),
            v = r(n(152)),
            y = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, 0, c.default.EXTRUDE_MARKER, e)), t._extrudeHeight = void 0 !== e.extrudeHeight ? e.extrudeHeight : 1, t._edgesLine = new m.default((0, u.default)(t), e), t
                }
                return (0, h.default)(n, e), (0, o.default)(n, [{
                    key: "init",
                    value: function () {
                        if (!this._points) return !1;
                        if (!this.parent) return !1;
                        if (!this.parent.parent) return !1;
                        var e = this.findParent(d.default);
                        if (!e) return !1;
                        var t, n = this.parent.parent,
                            r = n.parent.mapcenter,
                            i = {
                                depth: this._extrudeHeight
                            };
                        switch (this._points.type) {
                            case "circle":
                                p.default.convertPointCoordsByCenter(this.position, r), t = f.default.createCircleExtrudeBufferGeometry(this._points.radius, this._points.segments, i);
                                break;
                            case "rectangle":
                                p.default.convertPointCoordsByCenter(this.position, r), t = f.default.createReactExtrudeBufferGeometry(this._points.width, this._points.height, i);
                                break;
                            default:
                                p.default.convertPointsCoordsByCenter(this._points, r), t = f.default.createPointsExtrudeBufferGeometry(this._points, i)
                        }
                        var a = e._materialManager.getExtrudeMaterial(this._color, this._alpha);
                        return this._renderNode = new fm.Mesh(t, a), this._renderNode.mapNode = this, this._renderNode.rotation.set(-Math.PI / 2, 0, 0, "XYZ"), this._renderNode.position.set(this.position.x, this._height, -this.position.y), this._edgesLine._lineType === v.default.TOP_LINES_TYPE ? this.initTopLine() : this.initLine(t), !0
                    }
                }, {
                    key: "initLine",
                    value: function (e) {
                        this._edgesLine.createLine(e), this._renderNode.add(this._edgesLine._renderNode)
                    }
                }, {
                    key: "initTopLine",
                    value: function () {
                        var e = f.default.createShapeBufferGeometry(this._points);
                        this.initLine(e), this._edgesLine._renderNode.position.setZ(this._extrudeHeight), e.dispose()
                    }
                }, {
                    key: "setColor",
                    value: function (e) {
                        var t = this.findParent(d.default);
                        this._renderNode.material = t._materialManager.getExtrudeMaterial(e, this._alpha), this._color = e
                    }
                }, {
                    key: "setAlpha",
                    value: function (e) {
                        var t = this.findParent(d.default);
                        this._renderNode.material = t._materialManager.getExtrudeMaterial(this._color, e), this._alpha = e
                    }
                }, {
                    key: "setLineColor",
                    value: function (e) {
                        this._edgesLine && this._edgesLine.setLineColor(e)
                    }
                }, {
                    key: "setLineAlpha",
                    value: function (e) {
                        this._edgesLine && this._edgesLine.setLineAlpha(e)
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.geometry = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0), this._edgesLine && this._edgesLine.dispose()
                    }
                }]), n
            }(g.default),
            _ = y;
        t.default = _
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(21)),
            d = r(n(152)),
            f = r(n(20)),
            p = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, 0, c.default.EDGES_LINES_TYPE)), t = t || {}, n._lineType = void 0 !== t.lineType ? t.lineType : d.default.TOP_LINES_TYPE, n._lineAlpha = void 0 !== t.lineAlpha ? t.lineAlpha : void 0 !== t.alpha ? t.alpha : 1, n._lineColor = void 0 !== t.lineColor ? t.lineColor : void 0 !== t.color ? t.color : "#FF0000", n.parent = e, n._renderNode = null, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "createLine",
                    value: function (e) {
                        var t = new fm.EdgesGeometry(e),
                            n = this.findParent(f.default),
                            r = n._materialManager.getExtrudeMaterial(this._lineColor, this._lineAlpha);
                        this._renderNode = new fm.LineSegments(t, r)
                    }
                }, {
                    key: "setLineColor",
                    value: function (e) {
                        if (e) {
                            var t = this.findParent(f.default);
                            this._renderNode.material = t._materialManager.getExtrudeMaterial(e, this._lineAlpha), this._lineColor = e
                        }
                    }
                }, {
                    key: "setLineAlpha",
                    value: function (e) {
                        if (e) {
                            var t = this.findParent(f.default);
                            this._renderNode.material = t._materialManager.getExtrudeMaterial(this._lineColor, e), this._lineAlpha = e
                        }
                    }
                }, {
                    key: "dispose",
                    value: function () {
                        this._renderNode && (this._renderNode.geometry.dispose(), this._renderNode.material = void 0, this._renderNode.mapNode = void 0, this._renderNode = void 0)
                    }
                }]), r
            }(h.default),
            g = p;
        t.default = g
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8), n(113), n(68);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(7)),
            c = r(n(20)),
            d = r(n(58)),
            f = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, e)), t._visible = !0, t.x = e.x, t.y = e.y, t.domContent = e.domContent, t.fontSize = e.fontsize, t._id = null, t.anchor = e.anchor, t.domWidth = e.domWidth, t.domHeight = e.domHeight, t.height = e.height, t._param = e, t.alpha = e.alpha, t._left = null, t._top = null, t._isRuning = !1, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "initDom",
                    value: function (e) {
                        var t = this.findParent(c.default);
                        if (t) {
                            var n = document.createElement("div"),
                                r = t._map.renderer.renderer.domElement.parentNode;
                            r.style.position = "absolute", r.appendChild(n);
                            var i = null;
                            i = e.height ? e.height + this.parent.height : this.parent.height;
                            var a = t._map.coordMapToScreen(e.x, e.y, i);
                            n.name = "domMarker", n.id = e.id, n.setAttribute("class", "domMarker"), this._id = e.id, this.domNode = n, n.style.fontSize = e.fontSize, n.innerHTML = e.domContent, n.style.width = e.domWidth + "px", n.style.height = e.domHeight + "px", this._left = this._anchor(e, a).left, this._top = this._anchor(e, a).top, n.style.left = this._left, n.style.top = this._top, n.style.position = "absolute"
                        }
                    }
                }, {
                    key: "_anchor",
                    value: function (e, t) {
                        var n = null,
                            r = null;
                        switch (e.anchor) {
                            case 9:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 5:
                                n = t.x + "px", r = t.y + "px";
                                break;
                            case 6:
                                n = t.x - e.domWidth + "px", r = t.y + "px";
                                break;
                            case 7:
                                n = t.x + "px", r = t.y - e.domHeight + "px";
                                break;
                            case 8:
                                n = t.x - e.domWidth + "px", r = t.y - e.domHeight + "px";
                                break;
                            case 1:
                                n = t.x + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 2:
                                n = t.x - e.domWidth + "px", r = t.y - e.domHeight / 2 + "px";
                                break;
                            case 3:
                                n = t.x - e.domWidth / 2 + "px", r = t.y + "px";
                                break;
                            case 4:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight + "px";
                                break;
                            default:
                                n = t.x - e.domWidth / 2 + "px", r = t.y - e.domHeight / 2 + "px"
                        }
                        return {
                            left: n,
                            top: r
                        }
                    }
                }, {
                    key: "setPosition",
                    value: function (e, t, n, r) {
                        var i = this.findParent(c.default);
                        if (!i) return !1;
                        this.x = e, this.y = t;
                        var a = null;
                        0 !== n && (this.gid = n), this.height = r, a = this.height ? this.height + i._map.groupSpace * n : i._map.groupSpace * n;
                        var o = i._map.coordMapToScreen(this.x, this.y, a);
                        this._left = o.left, this._top = o.top, this.domNode.style.left = this._left, this.domNode.style.top = this._top
                    }
                }, {
                    key: "moveToGroup",
                    value: function (e) {
                        this.gid = e
                    }
                }, {
                    key: "moveTo",
                    value: function (t) {
                        var n = this;
                        if (!this._isRuning) {
                            var e = this.findParent(c.default),
                                r = t.x,
                                i = t.y,
                                a = new d.default({
                                    x: this.x,
                                    y: this.y
                                }, {
                                    x: r,
                                    y: i
                                }, 1e3 * t.time, function () {
                                    e.map.removeAnimater(a), n._moveAnimater = null, n._isRuning = !1, t.callback()
                                }, function (e) {
                                    n.setPosition(e.x, e.y, n.groupID, n.height), t.update(e)
                                }).start();
                            this._isRuning = !0, e.map.addAnimater(a), this._moveAnimater = a
                        }
                    }
                }, {
                    key: "stopMoveTo",
                    value: function () {
                        var e = this.findParent(c.default);
                        this._moveAnimater && this._moveAnimater.stop(), e.map.removeAnimater(this._moveAnimater), this._isRuning = !1, this._moveAnimater = null
                    }
                }, {
                    key: "show",
                    set: function (e) {
                        this._show = e, this.domNode.style.display = e ? "block" : "none"
                    },
                    get: function () {
                        return this._show
                    }
                }]), n
            }(h.default),
            p = f;
        t.default = p
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8), n(110);
        var l = r(n(16)),
            s = r(n(27));

        function a(e, t) {
            this.map_ = e, this.texture_ = null, this.config(t)
        }
        a.create = function (e, t) {
            return new a(e, t)
        }, a.prototype = {
            getDeviceDPI: function () {
                var e = [];
                if (void 0 !== window.screen.deviceXDPI) e[0] = window.screen.deviceXDPI, e[1] = window.screen.deviceYDPI;
                else {
                    var t = document.createElement("DIV");
                    t.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden", document.body.appendChild(t), e[0] = (0, s.default)(t.offsetWidth), e[1] = (0, s.default)(t.offsetHeight), t.parentNode.removeChild(t)
                }
                return e
            },
            getDeviceWH: function (e) {
                e = e || {};
                var t = this.map_.maxX - this.map_.minX,
                    n = this.map_.maxY - this.map_.minY,
                    r = {
                        w: Math.round(t),
                        h: Math.round(n)
                    },
                    i = this.getDeviceDPI();
                r.w = (0, s.default)(r.w * i[0] / 25.4), r.h = (0, s.default)(r.h * i[1] / 25.4);
                var a = 1,
                    o = e.maxSize || 2048;
                return (r.w >= o || r.h >= o) && (r.w >= r.h ? (a = r.h / r.w, r.w = o, r.h = (0, s.default)(o * a)) : (a = r.w / r.h, r.h = o, r.w = (0, s.default)(o * a))), r
            },
            getPixXY: function (e, t) {
                var n = (e - this.map_.minX) / (this.map_.maxX - this.map_.minX),
                    r = (this.map_.maxY - t) / (this.map_.maxY - this.map_.minY),
                    i = {
                        x: n,
                        y: r
                    };
                return i.x = i.x * this.options.width, i.y = i.y * this.options.height, i
            },
            config: function (e) {
                var t = this,
                    n = t.getDeviceWH(e),
                    r = n.w,
                    i = n.h;
                t.options = {
                    width: r,
                    height: i,
                    opacity: e.opacity ? 255 * e.opacity : 25500,
                    radius: e.radius ? e.radius : 30,
                    bshadow: e.radius ? e.radius / 20 : 1.5,
                    maxSize: e.mapSize || 2048,
                    boundVal: 15e3,
                    shadowBlur: Math.ceil(+e.radius),
                    points: {
                        max: e.max ? e.max : 100,
                        data: []
                    },
                    gradient: e.gradient ? e.gradient : {
                        .45: "rgb(0,0,255)",
                        .55: "rgb(0,255,255)",
                        .65: "rgb(0,255,0)",
                        .95: "yellow",
                        1: "rgb(255,0,0)"
                    },
                    isHeatPlan: e.isHeatPlan,
                    heatHeight: e.heatHeight
                };
                var a = document.createElement("canvas"),
                    o = a.getContext("2d");
                a.width = r, a.height = i, t.options.ctx = o, t.options.canvas = a
            },
            renderShadow: function (e, t, n, r) {
                var i = this,
                    a = i.options.ctx,
                    o = (i.options.radius, i.options.boundVal),
                    s = (0, l.default)(n / i.options.points.max, 10);
                a.save(), a.shadowColor = "rgba(0, 0, 0, " + s + ")", a.shadowOffsetX = o, a.shadowOffsetY = o, a.shadowBlur = i.options.shadowBlur, a.beginPath(), a.arc(e - o, t - o, i.options.radius, 0, 2 * Math.PI, !0), a.closePath(), a.fill(), a.restore(), r || i.cachePoint(e, t, n)
            },
            colorize: function () {
                for (var e = this, t = e.options.width, n = e.options.height, r = e.options.ctx, i = r.getImageData(0, 0, t, n), a = i.data, o = a.length, s = e.getPalette(), l = e.options.opacity, u = 3; u < o; u += 4) {
                    var h = a[u],
                        c = 4 * h;
                    if (c) {
                        c = Math.floor(c);
                        var d = l < h ? l : h;
                        d < .8 && (d = .8), a[u - 3] = s[c], a[u - 2] = s[c + 1], a[u - 1] = s[c + 2], a[u] = d
                    }
                }
                r.putImageData(i, 0, 0)
            },
            renderToMap: function (e) {
                var t = this,
                    n = t.options.canvas,
                    r = new fm.Texture(n);
                this.setTexture(e, r)
            },
            disposeHeatMap: function (e) {
                if (e) {
                    var t = this.map_.getFMGroup(e).getExtentMeshs()[0];
                    if (t._hasHeatMap)
                        if (t._hasHeatMap = !1, t.material.map && t.material.map.dispose(), this.options.isHeatPlan) t.material.map = null, t.material.mapMixColor = !1, t.material.transparent = !0, t.material.needsUpdate = !0, this.map_.getFMGroup(e)._layers.model[0]._scene.getObjectByName("directionalLight").remove(this.map_.getFMGroup(e)._layers.model[0]._scene.getObjectByName("heatMap"));
                        else {
                            var n = this.map_.getFMGroup(e).getModelMeshs();
                            this.map_.getFMGroup(e)._layers.model[0]._scene.traverse(function (e) {
                                "heatmap" === e.name && e.parent.remove(e)
                            }), n.forEach(function (e) {
                                if ("MultiMaterial" === e.material.type)
                                    for (var t = e.material.materials.length, n = 0, r = 3; n < t;) {
                                        var i = e.material.materials[n];
                                        i.map = null, i.mapMixColor = !1, i.transparent = !0, i.needsUpdate = !0, r = 0 === n ? 3 : 2, n += r
                                    } else {
                                        var a = e.material;
                                        a.map = null, a.mapMixColor = !1, a.transparent = !0, a.needsUpdate = !0
                                    }
                            })
                        }
                }
            },
            getPalette: function () {
                var e = document.createElement("canvas"),
                    t = e.getContext("2d");
                e.width = 1, e.height = 256;
                var n = this,
                    r = n.options.gradient,
                    i = t.createLinearGradient(0, 0, 1, 256);
                for (var a in r) i.addColorStop(a, r[a]);
                return t.fillStyle = i, t.fillRect(0, 0, 1, 256), t.getImageData(0, 0, 1, 256).data
            }
        }, a.prototype.cachePoint = function (e, t, n) {
            var r = this,
                i = r.options.points,
                a = i.data;
            i.max, a.push([e, t, n])
        }, a.prototype.clearPoints = function () {
            this.options.points.data = [], this.clear()
        }, a.prototype.addPoint = function (e, t, n) {
            if (e && t && n) {
                var r = this.getPixXY(e, t);
                if (r) {
                    var i = this;
                    i.clear();
                    for (var a = i.options.points.data, o = a.length, s = 0; s < o; s++) i.renderShadow(a[s][0], a[s][1], a[s][2], !0);
                    i.renderShadow(r.x, r.y, n, !1), i.colorize()
                }
            }
        }, a.prototype.getTexture = function (e) {
            this.clearPoints(), this.addPoints(e);
            var t = this.options.canvas.cloneNode();
            return t.getContext("2d").drawImage(this.options.canvas, 0, 0), new fm.CanvasTexture(t)
        }, a.prototype.setTexture = function (e, u) {
            var t = this.map_.getFMGroup(e).getExtentMeshs()[0];
            t._hasHeatMap && this.disposeHeatMap(e);
            var n = t.material.color,
                r = t.material.opacity;
            if (this.options.isHeatPlan) {
                t._hasHeatMap = !0, t.material.map = u, t.material.map.needsUpdate = !0, t.material.needsUpdate = !0;
                var i = t.clone();
                i.name = "heatMap", i.material.transparent = !0, i.material.opacity = 1, i.material.color = new fm.Color(16777215), i.material.depthTest = !1, i.renderOrder = 12, i.material.needsUpdate = !0, i.scale.z = .001, this.options.heatHeight ? i.position.y += this.options.heatHeight : i.position.y += 4, t.material = new fm.MeshLambertMaterial({
                    color: n,
                    opacity: r,
                    transparent: !0
                }), this.map_.getFMGroup(e)._layers.model[0]._scene.getObjectByName("directionalLight").add(i)
            } else {
                t._hasHeatMap = !0, t.material.mapMixColor = !0, t.material.map = u, t.material.map.needsUpdate = !0, t.material.needsUpdate = !0;
                var a = this.map_.getFMGroup(e).getModelMeshs();
                this.map_.getFMGroup(e)._layers.model[0]._scene.traverse(function (e) {
                    if (e instanceof fm.Mesh)
                        for (var t = 0; t < e.children.length; t++)
                            if (null !== e.children[t].material.map && void 0 !== e.children[t].material.map) {
                                var n = e.geometry,
                                    r = e.material;
                                r.opacity = .8, r.needsUpdate = !0;
                                var i = new fm.MeshLambertMaterial({
                                    map: u,
                                    transparent: !0,
                                    blending: fm.CustomBlending,
                                    blendEquation: fm.AddEquation,
                                    blendSrc: fm.SrcAlphaFactor,
                                    blendDst: fm.OneMinusSrcAlphaFactor
                                });
                                i.opacity = .9;
                                for (var a = [r, i], o = new fm.Group, s = 0; s < a.length; s++) o.add(new fm.Mesh(n, a[s]));
                                var l = new fm.Mesh(n, i);
                                l.name = "heatmap", l.renderOrder = 11, l.material.depthTest = !1, l.material.depthWrite = !1, e.add(l)
                            }
                }), a.forEach(function (e) {
                    if ("MultiMaterial" === e.material.type)
                        for (var t = e.material.materials.length, n = 0, r = 3; n < t;) e.material.materials[n].map = u, e.material.mapMixColor = !0, e.material.materials[n]._color = e.material.materials[n].color.clone(), e.material.materials[n].color = new fm.Color(16777215), e.material.materials[n].map.needsUpdate = !0, e.material.materials[n].needsUpdate = !0, r = 0 === n ? 3 : 2, n += r;
                    else e.material.mapMixColor = !0, e.material.map = u, e.material._color = e.material.color.clone(), 1 === e.material.opacity && (e.material.transparent = !1), e.material.map.needsUpdate = !0, e.material.needsUpdate = !0
                })
            }
        }, a.prototype.setModelMeshTexture = function (e) {
            if (e && texture_)
                if ("MultiMaterial" === e.material.type)
                    for (var t = e.material.materials.length, n = 0, r = 3; n < t;) e.material.materials[n].map = texture_, e.material.materials[n]._color = e.material.materials[n].color.clone(), e.material.materials[n].color = new fm.Color(16777215), e.material.materials[n].transparent = !1, e.material.materials[n].map.needsUpdate = !0, e.material.materials[n].needsUpdate = !0, r = 0 === n ? 3 : 2, n += r;
                else e.material.map = texture_, e.material._color = e.material.color.clone(), e.material.color = new fm.Color(16777215), e.material.transparent = !1, e.material.map.needsUpdate = !0, e.material.needsUpdate = !0
        }, a.prototype.clear = function () {
            var e = this.options.ctx;
            e.clearRect(0, 0, this.options.width, this.options.height)
        }, a.prototype.addPoints = function (e) {
            var t = this;
            t.clear();
            for (var n = t.options.points.data, r = n.length, i = 0; i < r; i++) t.renderShadow(n[i][0], n[i][1], n[i][2], !0);
            for (var a = e.length, o = 0; o < a; o++) {
                var s = this.getPixXY(e[o].x, e[o].y);
                if (!s) return !0;
                t.renderShadow(s.x, s.y, e[o].value, !1)
            }
            t.colorize()
        }, a.prototype.randomPoints = function (e) {
            var t = this,
                n = t.options.width,
                r = t.options.height,
                i = t.options.points.max;
            t.clear();
            for (var a = 0; a < e; a++) {
                var o = Math.floor(Math.random() * n + 1),
                    s = Math.floor(Math.random() * r + 1),
                    l = Math.floor(Math.random() * i + 1);
                t.renderShadow(o, s, l)
            }
            t.colorize()
        };
        var o = a;
        t.default = o
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = (r(n(251)), r(n(443))),
            l = r(n(444)),
            u = r(n(445)),
            h = r(n(448)),
            c = r(n(449)),
            d = function () {
                function n(e, t) {
                    (0, a.default)(this, n), this._data = t || e.getCurrDecodeData(), this._map = e, this.Graphics = fengmap.Graphics, this.DataManager = new fengmap.inner.DataManager, this.singleAttrQuery = new s.default(this._data, this._map), this.bufferQuery = new u.default(this._data), this.multiAttrQuery = new l.default(this._data, this._map), this.circleQuery = new h.default(this._data), this.polygonQuery = new c.default(this._data)
                }
                return (0, o.default)(n, [{
                    key: "query",
                    value: function (e, t) {
                        var n = null;
                        return n = e.queryTypes ? this.getQueryResult(e, e.queryTypes) : e.circle ? this.getQueryResult(e, ["SINGLE", "CIRCLE"]) : this.getQueryResult(e, ["SINGLE"]), t(n), n
                    }
                }, {
                    key: "getQueryResult",
                    value: function (e, t) {
                        for (var n = [], r = null, i = 0; i < t.length; i++) switch (t[i]) {
                            case "SINGLE":
                                n.push(this.singleAttrQuery.query(e));
                                break;
                            case "MULTI":
                                n.push(this.multiAttrQuery.query(e));
                                break;
                            case "BUFFER":
                                n.push(this.bufferQuery.query(e, this._map));
                                break;
                            case "CIRCLE":
                                r = this.circleQuery.query(n, e, this._map), n = [], n.push(r);
                                break;
                            case "POLYGON":
                                r = this.polygonQuery.query(n, e, this._map), n = [], n.push(r);
                                break;
                            default:
                                n.push(this.singleAttrQuery.query(e))
                        }
                        return n[0]
                    }
                }]), n
            }(),
            f = d;
        t.default = f
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(8);
        var p = r(n(16));
        n(13);
        var u = r(n(41)),
            h = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            c = r(n(6)),
            d = r(n(252)),
            f = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, e)), n._map = t, n
                }
                return (0, c.default)(r, e), (0, o.default)(r, [{
                    key: "query",
                    value: function (e) {
                        var t = [],
                            n = e.groupID;
                        n && "number" == typeof n && (n = [n]);
                        var r = !0,
                            i = !1,
                            a = void 0;
                        try {
                            for (var o, s = (0, h.default)(this._data.floors); !(r = (o = s.next()).done); r = !0) {
                                var l = o.value;
                                n ? -1 < n.indexOf(l.gid) && t.push.apply(t, (0, u.default)(this.queryGroup(l, e))) : t.push.apply(t, (0, u.default)(this.queryGroup(l, e)))
                            }
                        } catch (e) {
                            i = !0, a = e
                        } finally {
                            try {
                                r || null == s.return || s.return()
                            } finally {
                                if (i) throw a
                            }
                        }
                        return t
                    }
                }, {
                    key: "queryGroup",
                    value: function (u, h) {
                        var c = this,
                            d = this._data.scene.file_ver,
                            e = h.nodeType ? h.nodeType : fengmap.FMNodeType.ALL;
                        "all" == e && (e = fengmap.FMNodeType.ALL);
                        var f = [];
                        return e !== fengmap.FMNodeType.EXTERNAL_MODEL && e !== fengmap.FMNodeType.ALL || this.everyExternalModel(u, function (e, t, n, r) {
                            var i = null,
                                a = .1,
                                o = .1;
                            if (e && t && n && r) {
                                o = 1 === d ? (i = r.geo.substring(6, r.geo.length - 1).split(" "), a = (0, p.default)(i[0]), (0, p.default)(i[1])) : (i = r.pts, a = i[0], i[1]);
                                var s = t.height,
                                    l = {};
                                u.gid, c.check(e, t, h, n, r.geo, u.gid, l) && f.push({
                                    ID: e.eid,
                                    name: e.name,
                                    ename: e.ename,
                                    groupID: u.gid,
                                    FID: e.fid,
                                    typeID: e.type,
                                    nodeType: fengmap.FMNodeType.EXTERNAL_MODEL,
                                    gdata: t,
                                    target: l.target ? l.target : c._map.getFMGroup(u.gid).getNodeByLayerId("externalModel", e.eid),
                                    mapCoord: {
                                        x: a,
                                        y: o,
                                        z: s
                                    }
                                })
                            }
                        }), e !== fengmap.FMNodeType.MODEL && e !== fengmap.FMNodeType.ALL || this.everyModel(u, function (e, t, n, r) {
                            var i = null,
                                a = 0,
                                o = 0;
                            if (e && t && n && r) {
                                o = 1 === d ? (i = r.geo.substring(6, r.geo.length - 1).split(" "), a = (0, p.default)(i[0]), (0, p.default)(i[1])) : (i = r.pts, a = i[0], i[1]);
                                var s = t.height,
                                    l = {};
                                c.check(e, t, h, n, r.geo, u.gid, l) && f.push({
                                    ID: e.eid,
                                    name: e.name,
                                    ename: e.ename,
                                    groupID: u.gid,
                                    FID: e.fid,
                                    typeID: e.type,
                                    nodeType: fengmap.FMNodeType.MODEL,
                                    gdata: t,
                                    target: l.target ? l.target : c._map.getFMGroup(u.gid).getNodeByLayerId("model", e.eid),
                                    mapCoord: {
                                        x: a,
                                        y: o,
                                        z: s
                                    }
                                })
                            }
                        }), e !== fengmap.FMNodeType.FACILITY && e !== fengmap.FMNodeType.ALL || this.everyFacility(u, function (e, t, n) {
                            var r = null,
                                i = 0,
                                a = 0;
                            if (e && t && n) {
                                a = 1 === d ? (r = t.geo.substring(6, t.geo.length - 1).split(" "), i = (0, p.default)(r[0]), (0, p.default)(r[1])) : (r = t.pts, i = r[0], r[1]);
                                var o = t.height;
                                c.check(e, t, h, n, null, u.gid) && f.push({
                                    ID: e.eid,
                                    name: e.name,
                                    ename: e.ename,
                                    groupID: u.gid,
                                    FID: e.fid,
                                    typeID: e.type,
                                    nodeType: fengmap.FMNodeType.FACILITY,
                                    gdata: t,
                                    target: c._map.getFMGroup(u.gid).getNodeByLayerId("facility", e.eid),
                                    mapCoord: {
                                        x: i,
                                        y: a,
                                        z: o
                                    }
                                })
                            }
                        }), e !== fengmap.FMNodeType.LABEL && e !== fengmap.FMNodeType.ALL || this.everyLabel(u, function (e, t, n) {
                            var r = null,
                                i = 0,
                                a = 0;
                            if (e && t && n) {
                                a = 1 === d ? (r = t.geo.substring(6, t.geo.length - 1).split(" "), i = (0, p.default)(r[0]), (0, p.default)(r[1])) : (r = t.pts, i = r[0], r[1]);
                                var o = t.height;
                                c.check(e, t, h, n, null, u.gid) && f.push({
                                    ID: e.eid,
                                    name: e.name,
                                    ename: e.ename,
                                    groupID: u.gid,
                                    FID: e.fid,
                                    typeID: e.type,
                                    nodeType: fengmap.FMNodeType.LABEL,
                                    gdata: t,
                                    target: c._map.getFMGroup(u.gid).getNodeByLayerId("label", e.eid),
                                    mapCoord: {
                                        x: i,
                                        y: a,
                                        z: o
                                    }
                                })
                            }
                        }), f
                    }
                }]), r
            }(d.default),
            g = f;
        t.default = g
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(53), n(8);
        var p = r(n(16));
        n(13);
        var h = r(n(41)),
            c = r(n(12)),
            a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            d = r(n(252)),
            f = function (e) {
                function r(e, t) {
                    var n;
                    return (0, a.default)(this, r), n = (0, s.default)(this, (0, l.default)(r).call(this, e)), n._map = t, n
                }
                return (0, u.default)(r, e), (0, o.default)(r, [{
                    key: "query",
                    value: function (e) {
                        if (e.pathPoints) {
                            var t = this.distanceSorting(e.groupID, e.pathPoints, e.startPoint, e.bufferRadius);
                            return t
                        }
                        var n = [],
                            r = e.groupID;
                        r && "number" == typeof r && (r = [r]), this._data;
                        var i = !0,
                            a = !1,
                            o = void 0;
                        try {
                            for (var s, l = (0, c.default)(this._data.floors); !(i = (s = l.next()).done); i = !0) {
                                var u = s.value;
                                r ? -1 < r.indexOf(u.gid) && n.push.apply(n, (0, h.default)(this.queryGroup(u, e))) : n.push.apply(n, (0, h.default)(this.queryGroup(u, e)))
                            }
                        } catch (e) {
                            a = !0, o = e
                        } finally {
                            try {
                                i || null == l.return || l.return()
                            } finally {
                                if (a) throw o
                            }
                        }
                        return n
                    }
                }, {
                    key: "queryGroup",
                    value: function (u, h) {
                        var c = this,
                            d = this._data.scene.file_ver,
                            e = h.nodeType ? h.nodeType : fengmap.FMNodeType.ALL;
                        "all" == e && (e = fengmap.FMNodeType.ALL);
                        var f = [];
                        return e !== fengmap.FMNodeType.EXTERNAL_MODEL && e !== fengmap.FMNodeType.ALL || this.everyExternalModel(u, function (e, t, n, r) {
                            var i = null,
                                a = .1,
                                o = .1;
                            o = 1 === d ? (i = r.geo.substring(6, r.geo.length - 1).split(" "), a = (0, p.default)(i[0]), (0, p.default)(i[1])) : (i = r.pts, a = i[0], i[1]);
                            var s = t.height,
                                l = {};
                            c.check(e, t, h, n, r.geo, u.gid, l) && f.push({
                                ID: e.eid,
                                name: e.name,
                                ename: e.ename,
                                groupID: u.gid,
                                FID: e.fid,
                                typeID: e.type,
                                nodeType: fengmap.FMNodeType.MODEL,
                                distance: "number" == typeof l.distance ? l.distance : null,
                                target: l.target ? l.target : c._map.getFMGroup(u.gid).getNodeByLayerId("externalModel", e.eid),
                                mapCoord: {
                                    x: a,
                                    y: o,
                                    z: s
                                }
                            })
                        }), e !== fengmap.FMNodeType.MODEL && e !== fengmap.FMNodeType.ALL || this.everyModel(u, function (e, t, n, r) {
                            var i = null,
                                a = 0,
                                o = 0;
                            o = 1 === d ? (i = r.geo.substring(6, r.geo.length - 1).split(" "), a = (0, p.default)(i[0]), (0, p.default)(i[1])) : (i = r.pts, a = i[0], i[1]);
                            var s = t.height,
                                l = {};
                            c.check(e, t, h, n, r.geo, u.gid, l) && f.push({
                                ID: e.eid,
                                name: e.name,
                                ename: e.ename,
                                groupID: u.gid,
                                FID: e.fid,
                                typeID: e.type,
                                nodeType: fengmap.FMNodeType.MODEL,
                                distance: "number" == typeof l.distance ? l.distance : null,
                                target: l.target ? l.target : c._map.getFMGroup(u.gid).getNodeByLayerId("model", e.eid),
                                mapCoord: {
                                    x: a,
                                    y: o,
                                    z: s
                                }
                            })
                        }), e !== fengmap.FMNodeType.FACILITY && e !== fengmap.FMNodeType.ALL || this.everyFacility(u, function (e, t, n) {
                            var r = null,
                                i = 0,
                                a = 0;
                            a = 1 === d ? (r = t.geo.substring(6, t.geo.length - 1).split(" "), i = (0, p.default)(r[0]), (0, p.default)(r[1])) : (r = t.pts, i = r[0], r[1]);
                            var o = t.height,
                                s = {};
                            c.check(e, t, h, n, null, u.gid, s) && f.push({
                                ID: e.eid,
                                name: e.name,
                                ename: e.ename,
                                groupID: u.gid,
                                FID: e.fid,
                                typeID: e.type,
                                nodeType: fengmap.FMNodeType.FACILITY,
                                distance: "number" == typeof s.distance ? s.distance : null,
                                target: c._map.getFMGroup(u.gid).getNodeByLayerId("facility", e.eid),
                                mapCoord: {
                                    x: i,
                                    y: a,
                                    z: o
                                }
                            })
                        }), e !== fengmap.FMNodeType.LABEL && e !== fengmap.FMNodeType.ALL || this.everyLabel(u, function (e, t, n) {
                            var r = null,
                                i = 0,
                                a = 0;
                            a = 1 === d ? (r = t.geo.substring(6, t.geo.length - 1).split(" "), i = (0, p.default)(r[0]), (0, p.default)(r[1])) : (r = t.pts, i = r[0], r[1]);
                            var o = t.height,
                                s = {};
                            c.check(e, t, h, n, null, u.gid, s) && f.push({
                                ID: e.eid,
                                name: e.name,
                                ename: e.ename,
                                groupID: u.gid,
                                FID: e.fid,
                                typeID: e.type,
                                nodeType: fengmap.FMNodeType.LABEL,
                                distance: "number" == typeof s.distance ? s.distance : null,
                                target: c._map.getFMGroup(u.gid).getNodeByLayerId("label", e.eid),
                                mapCoord: {
                                    x: i,
                                    y: a,
                                    z: o
                                }
                            })
                        }), (h.circle || h.polygon) && f.sort(function (e, t) {
                            return "number" == typeof e.distance && "number" == typeof t.distance ? e.distance - t.distance : 0
                        }), f
                    }
                }]), r
            }(d.default),
            g = f;
        t.default = g
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            h = r(n(446)),
            L = n(447),
            c = function (e) {
                function n(e) {
                    var t;
                    return (0, a.default)(this, n), t = (0, s.default)(this, (0, l.default)(n).call(this, e)), t._map = null, t
                }
                return (0, u.default)(n, e), (0, o.default)(n, [{
                    key: "query",
                    value: function (e, t) {
                        this._map = t;
                        var n = this.distanceSorting(e.groupID, e.pathPoints, e.startPoint, e.bufferRadius);
                        return n
                    }
                }, {
                    key: "_calcBuffer",
                    value: function (e, t) {
                        for (var n = 0; n < e.length; n++) {
                            var r = [];
                            r.push(e[n].x), r.push(e[n].y), e.splice(n, 1, r)
                        }
                        var i = (0, L.straightenPoints)(e),
                            a = (0, L.polylineSegBuffers)(i, t);
                        return a
                    }
                }, {
                    key: "_BMIntersect",
                    value: function (e, t, n) {
                        for (var r = 0; r < n.length; r++) {
                            var i = [];
                            i.push(n[r].x + e.x), i.push(n[r].y + e.y), n.splice(r, 1, i)
                        }
                        var a = (0, L.isSegBuffersIntersecots)(t, n);
                        return a
                    }
                }, {
                    key: "_BFIntersect",
                    value: function (e, t, n) {
                        var r = [n.x + e.x, n.y + e.y],
                            i = [r],
                            a = (0, L.isSegBuffersIntersecots)(t, i);
                        return a
                    }
                }, {
                    key: "distanceSorting",
                    value: function (e, t, n, r) {
                        var i = this._map.getFMGroup(e).mapCoord,
                            a = [],
                            o = [],
                            s = [],
                            l = [],
                            u = [],
                            h = [],
                            c = this._map.nodeManager._scenes[this._map._currentSceneId].groups["" + e]._layers.model[0]._models,
                            d = this._map.nodeManager._scenes[this._map._currentSceneId].groups["" + e]._layers.facility[0]._facility,
                            f = this._calcBuffer(t, r);
                        for (var p in c) {
                            var g = c[p]._renderNode.children[0].geometry.vertices.concat(),
                                m = this._BMIntersect(i, f, g);
                            if (m) {
                                s.push(c[p]);
                                var v = {
                                    model: g,
                                    fid: c[p].FID,
                                    target: s[s.length - 1]
                                };
                                a.push(v)
                            }
                        }
                        for (var y in d) {
                            var _ = d[y]._renderNode.position.clone(),
                                A = this._BFIntersect(i, f, _);
                            if (A) {
                                l.push(c[y]);
                                var x = {
                                    facility: _,
                                    fid: d[y].FID,
                                    target: l[l.length - 1]
                                };
                                o.push(x)
                            }
                        }
                        for (var C = 0; C < a.length; C++) {
                            var I = a[C].model,
                                w = (0, L.distPointToPolygon)([n.x, n.y], I),
                                M = {
                                    distance: w,
                                    fid: a[C].fid,
                                    target: s[C]
                                };
                            u.push(M)
                        }
                        for (var b = 0; b < o.length; b++) {
                            var S = o[b].facility,
                                E = Math.sqrt(Math.pow(n.x - S.x, 2) + Math.pow(n.y - S.y, 2)),
                                T = {
                                    distance: E,
                                    fid: o[b].fid,
                                    target: l[b]
                                };
                            h.push(T)
                        }
                        return this._quickSort(u, 0, u.length - 1), this._quickSort(h, 0, h.length - 1), a = null, o = null, s = null, l = null, {
                            model: u,
                            facility: h
                        }
                    }
                }, {
                    key: "_quickSort",
                    value: function (e, t, n) {
                        for (var r = [
                                [t, n]
                            ]; 0 < r.length;) {
                            var i = r.pop();
                            if (!(i[0] >= i[1])) {
                                for (var a = i[0], o = i[1], s = i[0]; a < o;) {
                                    for (; e[o].distance >= e[s].distance && s < o;) o--;
                                    if (o <= a) break;
                                    for (; e[a].distance <= e[s].distance && a < o;) a++;
                                    var l = e[s];
                                    e[s] = e[o], e[o] = e[a], e[a] = l, s = a
                                }
                                r.push([i[0], s - 1]), r.push([s + 1, i[1]])
                            }
                        }
                    }
                }]), n
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(4)),
            s = r(n(5)),
            l = r(n(6)),
            u = r(n(253)),
            h = function (e) {
                function t(e) {
                    return (0, a.default)(this, t), (0, o.default)(this, (0, s.default)(t).call(this, e))
                }
                return (0, l.default)(t, e), t
            }(u.default),
            c = h;
        t.default = c
    }, function (e, t, n) {
        "use strict";
        var r, i, a, o, s = n(1),
            _ = s(n(47));
        o = function (e) {
            Array.prototype.merge = function (e) {
                for (var t = 0; t < e.length; t++) this.push(e[t]);
                return this
            }, Array.prototype.print = function () {
                for (var e = 0; e < this.length; e++) this[e][0], this[e][1]
            };
            var s = 999999999999,
                n = 3.1415926;

            function a(e) {
                for (var t = [], n = 0; n < e.length; n++) {
                    var r = e[n],
                        i = e[(n + 1) % e.length];
                    t.push({
                        x1: r[0],
                        y1: r[1],
                        x2: i[0],
                        y2: i[1]
                    })
                }
                return t
            }

            function i(e, t) {
                var n = !1;
                if (n = o(e, t), 0 == n) return n;
                var r = a(e),
                    i = a(t);
                return n = u(r, i), !!n || !!h(e[0], t) || !!h(t[0], e)
            }

            function o(e, t) {
                for (var n, r, i, a, o, s, l, u, h = 0; h < e.length; h++) {
                    var c = e[h];
                    n = n > c.x ? n : c.x, i = i < c.x ? i : c.x, r = r > c.y ? r : c.y, a = a < c.y ? a : c.y
                }
                for (h = 0; h < t.length; h++) {
                    var d = t[h];
                    o = o > d.x ? o : d.x, l = l < d.x ? l : d.x, s = s > d.y ? s : d.y, u = u < d.y ? u : d.y
                }
                return !(n <= l || o <= i || s <= a || r <= u)
            }

            function l(e, t, n, r, i, a, o, s) {
                return Math.min(e, n) <= Math.max(i, o) && Math.min(a, s) <= Math.max(t, r) && Math.min(i, o) <= Math.max(e, n) && Math.min(t, r) <= Math.max(a, s) && (l = (i - e) * (r - t) - (n - e) * (a - t), u = (o - e) * (r - t) - (n - e) * (s - t), h = (e - i) * (s - a) - (o - i) * (t - a), c = (n - i) * (s - a) - (o - i) * (r - a), l * u <= 1e-8 && h * c <= 1e-8);
                var l, u, h, c
            }

            function u(e, t) {
                for (var n = 0; n < e.length; n++)
                    for (var r = e[n], i = 0; i < t.length; i++) {
                        var a = t[i];
                        if (l(r.x1, r.y1, r.x2, r.y2, a.x1, a.y1, a.x2, a.y2)) return !0
                    }
                return !1
            }

            function h(e, t) {
                for (var n = e[0], r = e[1], i = !1, a = 0, o = t.length - 1; a < t.length; o = a++) {
                    var s = t[a][0],
                        l = t[a][1],
                        u = t[o][0],
                        h = t[o][1],
                        c = r < l != r < h && n < (u - s) * (r - l) / (h - l) + s;
                    c && (i = !i)
                }
                return i
            }
            var g = function (e, t) {
                1 == arguments.length && (this.x = e[0], this.y = arguments[0][1]), 2 == arguments.length && (this.x = arguments[0], this.y = t)
            };
            g.prototype.plus = function (e) {
                return new g(this.x + e.x, this.y + e.y)
            }, g.prototype.minus = function (e) {
                return new g(this.x - e.x, this.y - e.y)
            }, g.prototype.div = function (e) {
                return new g(this.x / e, this.y / e)
            }, g.prototype.mul = function (e) {
                return "object" == (0, _.default)(e) && e instanceof g ? this.x * e.x + this.y * e.y : "number" == typeof e ? new g(this.x * e, this.y * e) : this
            }, g.prototype.crossMul = function (e) {
                return this.x * e.y - e.x * this.y
            }, g.prototype.len = function () {
                var e = this.x * this.x + this.y * this.y;
                return Math.sqrt(e)
            }, g.prototype.toList = function () {
                return [this.x, this.y]
            };
            var m = function (e, t, n, r) {
                this._row1 = new g(e, t), this._row2 = new g(n, r)
            };
            m.prototype.mul = function (e) {
                if (e instanceof g) return new g(this._row1.mul(e), this._row2.mul(e))
            };
            var v = function (e) {
                    var t = e * n / 180;
                    return new m(Math.cos(t), -Math.sin(t), Math.sin(t), Math.cos(t))
                },
                c = function (e, t, n) {
                    t = new g(t), e = new g(e);
                    for (var r = t.minus(e), i = (r = r.div(r.len()), r = r.mul(n), new m(0, -1, 1, 0)), a = i.mul(r), o = (t.plus(r), e.minus(r), t.plus(a), t.minus(a), e.plus(a), e.minus(a), a.mul(-1)), s = [], l = [], u = 0; u <= 18; u++) {
                        var h = v(10 * u),
                            c = h.mul(a),
                            d = e.plus(c);
                        s.push(d.toList());
                        var f = h.mul(o),
                            p = t.plus(f);
                        l.push(p.toList())
                    }
                    return s.merge(l)
                },
                r = function (e, t) {
                    for (var n = [], r = 0; r < e.length; r++) {
                        var i = e[r];
                        n.push(c([i.x1, i.y1], [i.x2, i.y2], t))
                    }
                    return n
                },
                t = function (e, t) {
                    var n = a(e);
                    return r(n, t)
                },
                d = function (e, t) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        if (i(r, t)) return !0
                    }
                    return !1
                };

            function f(e, t, n, r, i, a) {
                var o = (i - n) * (e - n) + (a - r) * (t - r);
                if (o <= 0) return Math.sqrt((e - n) * (e - n) + (t - r) * (t - r));
                var s = (i - n) * (i - n) + (a - r) * (a - r);
                if (s <= o) return Math.sqrt((e - i) * (e - i) + (t - a) * (t - a));
                var l = o / s,
                    u = n + (i - n) * l,
                    h = r + (a - r) * l;
                return Math.sqrt((e - u) * (e - u) + (h - t) * (h - t))
            }
            var p = function (e, t) {
                    for (var n = s, r = 0; r < t.length; r++) {
                        var i = t[r],
                            a = t[(r + 1) % t.length],
                            o = f(e[0], e[1], i[0], i[1], a[0], a[1]);
                        o < n && (n = o)
                    }
                    return n
                },
                y = function (e) {
                    if (e.length < 3) return e;
                    var t = [];
                    t.push(e[0]);
                    for (var n = 1; n < e.length - 1; n++) {
                        var r = new g(t[t.length - 1]),
                            i = new g(e[n]).minus(r),
                            a = new g(e[n + 1]).minus(new g(e[n])),
                            o = i.crossMul(a);
                        Math.abs(o) < .001 || t.push(e[n])
                    }
                    return t.push(e[e.length - 1]), t
                };
            e.isPolygonIntersects = i, e.isPointInPolygon = h, e.polylineSegBuffers = t, e.isSegBuffersIntersecots = d, e.distPointToPolygon = p, e.straightenPoints = y
        }, "object" === (0, _.default)(t) && void 0 !== e ? o(t) : (i = [t], r = o, a = "function" == typeof r ? r.apply(t, i) : r, void 0 === a || (e.exports = a))
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var A = r(n(16));
        n(13);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            x = r(n(42)),
            h = r(n(254)),
            c = function (e) {
                function t(e) {
                    return (0, a.default)(this, t), (0, s.default)(this, (0, l.default)(t).call(this, e))
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "query",
                    value: function (e, t, n) {
                        var r = t.circle,
                            i = [],
                            a = this._data.scene.file_ver;
                        e: for (var o = 0; o < e[0].length; o++) {
                            var s = e[0][o].gdata;
                            e[0][o].nodeType;
                            var l = null,
                                u = 0,
                                h = 0;
                            if (1 === a) {
                                var c = s.geo;
                                l = c.substring(6, c.length - 1).split(" "), u = (0, A.default)(l[0]), h = (0, A.default)(l[1])
                            } else l = s.pts, u = l[0], h = l[1];
                            var d = r.center,
                                f = Math.sqrt((u - d.x) * (u - d.x) + (h - d.y) * (h - d.y));
                            if (f < r.radius) e[0][o].distance = f, i.push(e[0][o]);
                            else if (5 === e[0][o].nodeType) {
                                var p = 0,
                                    g = null,
                                    m = n.getFMGroup(e[0][o].groupID).getNodeByLayerId("model", e[0][o].ID);
                                m && m._data && (g = m._data.vertices), null == g && (g = 1 === a ? x.default.convertGeo2Geometry(s.geo).vertices : x.default.convertArr2Geometry(s.idxs, s.pts).vertices);
                                for (var v = g.length / 2, y = 0; y < v - 1; y++) {
                                    var _ = 2 * y;
                                    if (p = this.Graphics.pointDistanceToLine(d, {
                                            x: g[_],
                                            y: g[_ + 1]
                                        }, {
                                            x: g[_ + 2],
                                            y: g[_ + 3]
                                        }, {}), p < r.radius) {
                                        e[0][o].distance = f, i.push(e[0][o]);
                                        continue e
                                    }
                                }
                                if (this.Graphics.pointInPolygonVector2d(g, d, g.length)) {
                                    e[0][o].distance = f, i.push(e[0][o]);
                                    continue
                                }
                            }
                        }
                        return i
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var f = r(n(16));
        n(13);
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(4)),
            l = r(n(5)),
            u = r(n(6)),
            p = r(n(42)),
            g = r(n(450)),
            h = r(n(254)),
            c = function (e) {
                function t(e) {
                    return (0, a.default)(this, t), (0, s.default)(this, (0, l.default)(t).call(this, e))
                }
                return (0, u.default)(t, e), (0, o.default)(t, [{
                    key: "query",
                    value: function (e, t, n) {
                        for (var r = this._data.scene.file_ver, i = 2 < t.polygon.length ? new g.default(t.polygon, !0) : null, a = [], o = 0; o < e[0].length; o++) {
                            var s = e[0][o].gdata;
                            e[0][o].nodeType;
                            var l = null,
                                u = null;
                            if (1 === r) {
                                var h = s.geo;
                                l = h.substring(6, h.length - 1).split(" "), u = {
                                    x: (0, f.default)(l[0]),
                                    y: (0, f.default)(l[1])
                                }
                            } else l = s.pts, u = {
                                x: (0, f.default)(l[0]),
                                y: (0, f.default)(l[1])
                            };
                            if (i.contain(u)) e[0][o].distance = i.distanceToPoint(u), a.push(e[0][o]);
                            else if (5 === e[0][o].nodeType) {
                                var c = null,
                                    d = n.getFMGroup(e[0][o].groupID).getNodeByLayerId("model", e[0][o].ID);
                                if (d && d._data && (c = d._data.vertices), null == c && (c = 1 === r ? p.default.convertGeo2Geometry(s.geo).vertices : p.default.convertArr2Geometry(s.idxs, s.pts).vertices), i.containXYArray(c)) {
                                    e[0][o].distance = i.distanceToPoint(u), a.push(e[0][o]);
                                    continue
                                }
                            }
                        }
                        return a
                    }
                }]), t
            }(h.default),
            d = c;
        t.default = d
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(451)),
            l = function () {
                function u(e) {
                    (0, a.default)(this, u), this._points = e, this._bb = new s.default(e);
                    var t = e.length;
                    e[0].x == e[t - 1].x && e[0].y == e[t - 1].y && t--, this._count = t, this._center = fengmap.inner.Graphics.calcCenterOfGravityPoint(e, this._count)
                }
                return (0, o.default)(u, [{
                    key: "contain",
                    value: function (e) {
                        return !!this._bb.contain(e) && fengmap.inner.Graphics.pointInPolygon2d(this._points, e, this._count)
                    }
                }, {
                    key: "containXYArray",
                    value: function (e) {
                        for (var t = e.length / 2, n = [], r = !1, i = 0; i < t; i++) {
                            var a = 2 * i,
                                o = {
                                    x: e[a],
                                    y: e[a + 1]
                                };
                            if (this.contain(o)) {
                                r = !0;
                                break
                            }
                            n.push(o)
                        }
                        if (r) return !0;
                        var s = new u(n);
                        if (fengmap.inner.Graphics.isRectCross(this._bb._min, this._bb._max, s._bb._min, s._bb._max))
                            for (var l = 0; l < this._count; l++)
                                if (s.contain(this._points[l])) {
                                    r = !0;
                                    break
                                } return !!r
                    }
                }, {
                    key: "distanceToPoint",
                    value: function (e) {
                        return fengmap.inner.Graphics.distanceOfTwoPoints(this._center, e)
                    }
                }]), u
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(56);
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function r(e) {
                    if ((0, a.default)(this, r), this._min = {
                            x: Number.MAX_VALUE,
                            y: Number.MAX_VALUE
                        }, this._max = {
                            x: -Number.MAX_VALUE,
                            y: -Number.MAX_VALUE
                        }, e)
                        for (var t = e.length, n = 0; n < t; n++) this.expandBy(e[n])
                }
                return (0, o.default)(r, [{
                    key: "expandBy",
                    value: function (e) {
                        e.x < this._min.x && (this._min.x = e.x), e.y < this._min.y && (this._min.y = e.y), e.x > this._max.x && (this._max.x = e.x), e.y > this._max.y && (this._max.y = e.y)
                    }
                }, {
                    key: "contain",
                    value: function (e) {
                        return !(e.x < this._min.x || e.x > this._max.x || e.y < this._min.y || e.y > this._max.y)
                    }
                }]), r
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                MODULE_SHORTEST: 1,
                MODULE_BEST: 2
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                Left: 0,
                Center: 1,
                Right: 2
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                PRIORITY_DEFAULT: 1,
                PRIORITY_LIFTFIRST: 2,
                PRIORITY_ESCALATORFIRST: 3,
                PRIORITY_STAIRFIRST: 4,
                PRIORITY_LIFTONLY: 5,
                PRIORITY_ESCALATORONLY: 6,
                PRIORITY_STAIRONLY: 7,
                PRIORITY_ACCESSIBLEONLY: 8,
                PRIORITY_LIFTFIRST1: 9,
                PRIORITY_ESCALATORFIRST1: 10,
                PRIORITY_STAIRFIRST1: 11
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                MODE_2D: "top",
                MODE_3D: "3d"
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
                ROUTE_SUCCESS: 1,
                ROUTE_FAILED_NO_FMDBDATA: 2,
                ROUTE_FAILED_TOO_CLOSE: 3,
                ROUTE_FAILED_NO_DATA_START: 4,
                ROUTE_FAILED_NO_DATA_END: 5,
                ROUTE_FAILED_NO_STAIR: 6,
                ROUTE_FAILED_NOTSUPPORT: 7,
                ROUTE_FAILED_CANNOT_CALCULATE: 8,
                ROUTE_FAILED_CANNOT_ARRIVE: 9,
                ROUTE_FAILED_WAYPOINT_CALCULATE_ERROR: 10,
                ROUTE_FAILED_NO_START_ARRIVAL: 11,
                ROUTE_FAILED_NO_END_ARRIVAL: 12,
                ROUTE_FAILED_OUTLINE: 13,
                ROUTE_FAILED_NO_DOOR_START: 14,
                ROUTE_FAILED_NO_DOOR_END: 15
            },
            a = i;
        t.default = a
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e), this.x = void 0, this.y = void 0, this.z = void 0, this.gid = void 0
                }
                return (0, o.default)(e, [{
                    key: "setGeoPoint",
                    value: function (e) {
                        this.x = e.x, this.y = e.y
                    }
                }]), e
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = function e(t, n) {
                (0, a.default)(this, e), this.x = void 0 === t ? 0 : t, this.y = void 0 === n ? 0 : n
            },
            s = o;
        t.default = s
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function r(e, t, n) {
                    (0, a.default)(this, r), this._locOrigion = null, this._locRange = null, this._mapOrigion = null, this._mapAxisX = null, this._mapAxisY = null, this._mapRange = null, e && t && n && this.init(e, t, n)
                }
                return (0, o.default)(r, [{
                    key: "init",
                    value: function (e, t, n) {
                        if (4 != n.length) return !1;
                        this._locOrigion = e, this._locRange = t, this._mapOrigion = n[0], this._mapAxisX = {
                            x: n[1].x - n[0].x,
                            y: n[1].y - n[0].y
                        }, this._mapAxisY = {
                            x: n[3].x - n[0].x,
                            y: n[3].y - n[0].y
                        }, this._mapRange = {
                            x: this._getVectorLen(this._mapAxisX),
                            y: this._getVectorLen(this._mapAxisY)
                        }, this._mapAxisX.x /= this._mapRange.x, this._mapAxisX.y /= this._mapRange.x, this._mapAxisY.x /= this._mapRange.y, this._mapAxisY.y /= this._mapRange.y
                    }
                }, {
                    key: "transform",
                    value: function (e) {
                        var t = {
                                x: (e.x - this._locOrigion.x) / this._locRange.x,
                                y: (e.y - this._locOrigion.y) / this._locRange.y
                            },
                            n = {
                                x: t.x * this._mapRange.x,
                                y: t.y * this._mapRange.y
                            },
                            r = {
                                x: this._mapOrigion.x + this._mapAxisX.x * n.x + this._mapAxisY.x * n.y,
                                y: this._mapOrigion.y + this._mapAxisX.y * n.x + this._mapAxisY.y * n.y
                            };
                        return r
                    }
                }, {
                    key: "_getVectorLen",
                    value: function (e) {
                        return Math.sqrt(e.x * e.x + e.y * e.y)
                    }
                }]), r
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(0);
        r(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var i = {
            NaviNodeType_NULL: -1,
            NaviNodeType_COMMON: 0,
            NaviNodeType_SIDE: 1,
            NaviNodeType_FLOOR: 2,
            NaviNodeType_EXTENT: 3,
            NaviLiftType_NULL: 0,
            NaviLiftType_Lift: 1,
            NaviLiftType_Stair: 2,
            NaviLiftType_Escalator: 3,
            NaviLiftType_Accessible: 4,
            NaviLiftEntry_BOTH: 0,
            NaviLiftEntry_UP: 1,
            NaviLiftEntry_DOWN: 2,
            NaviLiftEntry_FORBID: 3,
            NaviEntranceType_NULL: 0,
            NaviEntranceType_EXIT: 1,
            NaviEntranceType_ENTRANCE: 2,
            NaviEntranceType_ACCESS: 3,
            NaviRoadRank_MAIN: 1,
            NaviRoadRank_MINOR: 2,
            NaviRoadRank_NARROW: 3,
            NaviRoadEntry_BOTH: 0,
            NaviRoadEntry_FORWARD: 1,
            NaviRoadEntry_BACK: 2,
            NaviRoadEntry_FORBID: 3,
            NaviRoadPass_NULL: -1,
            NaviRoadPass_NOT_THROUGH: 0,
            NaviRoadPass_THROUGH: 1,
            NaviZoneType_NULL: -1,
            NaviZoneType_PASS_UNRESTRAINT: 0,
            NaviZoneType_PASS_THROUGH: 1,
            NaviZoneType_PASS_NOT_THROUGH: 2,
            NaviZoneType_NO_ENTRY: 3,
            NaviZoneType_CORRIDOR: 4,
            NaviModelPassType_PASS_THROUGH: 0,
            NaviModelPassType_PASS_NOT_THROUGH: 1,
            NaviModelPassType_NOT_PASS: 2,
            NaviModelPassType_DECORATE: 3,
            NaviRoadHinderType_HINDER_GENERAL: 0,
            NaviRoadHinderType_HINDER_HIGH: 1,
            NaviObstructType_MODEL: 0,
            NaviObstructType_EXTENT: 1
        };
        t.default = i
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0, n(56);
        var a = r(n(2)),
            o = r(n(3)),
            s = function () {
                function e() {
                    (0, a.default)(this, e), this.minX = Number.MAX_VALUE, this.minY = Number.MAX_VALUE, this.maxX = -Number.MAX_VALUE, this.maxY = -Number.MAX_VALUE
                }
                return (0, o.default)(e, [{
                    key: "init",
                    value: function () {
                        this.minX = Number.MAX_VALUE, this.minY = Number.MAX_VALUE, this.maxX = -Number.MAX_VALUE, this.maxY = -Number.MAX_VALUE
                    }
                }, {
                    key: "expandBy",
                    value: function (e) {
                        e && e.x && e.y && (this.minX > e.x && (this.minX = e.x), this.maxX < e.x && (this.maxX = e.x), this.minY > e.y && (this.minY = e.y), this.maxY < e.y && (this.maxY = e.y))
                    }
                }, {
                    key: "isSeparate",
                    value: function (e) {
                        return this.minX > e.maxX || this.minY > e.maxY || this.maxX < e.minX || this.maxY < e.minY
                    }
                }]), e
            }(),
            l = s;
        t.default = l
    }, function (e, t, n) {
        "use strict";
        var r = n(1),
            i = n(0);
        i(t, "__esModule", {
            value: !0
        }), t.default = void 0;
        var a = r(n(2)),
            o = r(n(3)),
            s = r(n(49)),
            l = function () {
                function e() {
                    (0, a.default)(this, e)
                }
                return (0, o.default)(e, null, [{
                    key: "MercatorToWGS84",
                    value: function (e) {
                        var t = {},
                            n = e.x / 20037508.34 * 180,
                            r = e.y / 20037508.34 * 180;
                        return r = 180 / Math.PI * (2 * Math.atan(Math.exp(r * Math.PI / 180)) - Math.PI / 2), t.dLong = n, t.dLat = r, t
                    }
                }, {
                    key: "WGS84ToWebMercator",
                    value: function (e) {
                        var t = {},
                            n = 20037508.34 * e.x / 180,
                            r = Math.log(Math.tan((90 + e.y) * Math.PI / 360)) / (Math.PI / 180);
                        return r = 20037508.34 * r / 180, t.x = n, t.y = r, t
                    }
                }, {
                    key: "Contain",
                    value: function (e, t) {
                        var n = e.length;
                        return s.default.pointInPolygon2d(e, t, n)
                    }
                }, {
                    key: "GetLength",
                    value: function (e, t) {
                        var n = e.x - t.x,
                            r = e.y - t.y;
                        return Math.sqrt(n * n + r * r)
                    }
                }, {
                    key: "GetArea",
                    value: function (e) {
                        return s.default.calcPolygonArea2d(e)
                    }
                }, {
                    key: "ScreenToWebMercator",
                    value: function () {}
                }, {
                    key: "WebMercatorToScreen",
                    value: function () {}
                }, {
                    key: "CoordTransform",
                    value: function () {}
                }]), e
            }(),
            u = l;
        t.default = u
    }, function (e, t, n) {
        "use strict";
        var r = n(1);
        n(110);
        var p = r(n(16)),
            i = r(n(81));

        function g(e, t, n, r, i, a) {
            var o = (e + n) / 2,
                s = (t + r) / 2,
                l = ((e - n) * (e - n) + (t - r) * (t - r)) / 4,
                u = Math.sqrt(l),
                h = Math.sqrt(i * i - l),
                c = u / h,
                d = u * c,
                f = Math.PI / 2,
                p = 1,
                g = (n - e) / (t - r),
                m = -1,
                v = (e - n) / (t - r),
                y = Math.sqrt(p * p + g * g),
                _ = Math.sqrt(m * m + v * v),
                A = p / y,
                x = g / y,
                C = m / _,
                I = v / _,
                w = {
                    x: o + d * A,
                    y: s + d * x,
                    theta: f
                },
                M = {
                    x: o + d * C,
                    y: s + d * I,
                    theta: f
                };
            return 0 < (n - e) * (w.y - t) - (r - t) * (w.x - e) ? 0 === a ? w : M : 0 === a ? M : w
        }

        function s(e, t, n, r) {
            for (var i = 0; i < e.length; i++) switch (e[i]) {
                case "m":
                    t.moveTo(r.x + (0, p.default)(e[i + 1]), r.y + (0, p.default)(e[i + 2])), n.x = r.x + (0, p.default)(e[i + 1]), n.y = r.y + (0, p.default)(e[i + 2]), r.x = n.x, r.y = n.y, i += 2;
                    break;
                case "M":
                    t.moveTo((0, p.default)(e[i + 1]), (0, p.default)(e[i + 2])), n.x = (0, p.default)(e[i + 1]), n.y = (0, p.default)(e[i + 2]), r.x = n.x, r.y = n.y, i += 2;
                    break;
                case "l":
                    t.lineTo(n.x + (0, p.default)(e[i + 1]), n.y + (0, p.default)(e[i + 2])), n.x = n.x + (0, p.default)(e[i + 1]), n.y = n.y + (0, p.default)(e[i + 2]), i += 2;
                    break;
                case "L":
                    t.lineTo((0, p.default)(e[i + 1]), (0, p.default)(e[i + 2])), n.x = (0, p.default)(e[i + 1]), n.y = (0, p.default)(e[i + 2]), i += 2;
                    break;
                case "A":
                    var a = (0, p.default)(e[i + 1]),
                        o = (0, p.default)(e[i + 2]),
                        s = ((0, p.default)(e[i + 3]), Math.PI, (0, p.default)(e[i + 4]), (0, p.default)(e[i + 5])),
                        l = n.x,
                        u = n.y,
                        h = (0, p.default)(e[i + 6]),
                        c = (0, p.default)(e[i + 7]);
                    if (a === o) {
                        var d = g(l, u, h, c, a, s);
                        t.arcTo(d.x, d.y, h, c, d.theta), n.x = h, n.y = c
                    }
                    i += 7;
                    break;
                case "a":
                    if (a = (0, p.default)(e[i + 1]), o = (0, p.default)(e[i + 2]), (0, p.default)(e[i + 3]), Math.PI, (0, p.default)(e[i + 4]), s = (0, p.default)(e[i + 5]), l = n.x, u = n.y, h = l + (0, p.default)(e[i + 6]), c = u + (0, p.default)(e[i + 7]), a === o) {
                        var f = g(l, u, h, c, a, s);
                        t.arcTo(f.x, f.y, h, c, f.theta), n.x = h, n.y = c
                    }
                    i += 7;
                    break;
                case "h":
                    t.lineTo(n.x + (0, p.default)(e[i + 1]), n.y), n.x = n.x + (0, p.default)(e[i + 1]), i += 1;
                    break;
                case "H":
                    t.lineTo((0, p.default)(e[i + 1]), n.y), n.x = (0, p.default)(e[i + 1]), i += 1;
                    break;
                case "z":
                case "Z":
                    t.lineTo(r.x, r.y)
            }
        }
        var l = ["M", "0", "15.07", "L", "0.69", "1.92", "A", "2", "2", "0", "0", "1", "2.66", "0", "L", "11.8", "0", "l", "-0.07", "1.37", "H", "3.09", "A", "1.09", "1.09", "0", "0", "0", "2", "2.44", "l", "-0.2", "4.44", "h", "9.37", "l", "-0.07", "1.37", "H", "1.72", "l", "-0.36", "6.82", "Z"],
            u = ["M", "13.79", "11", "l", "-0.08", "1.63", "a", "1", "1", "0", "0", "0", "1", "1.08", "h", "8.53", "l", "-0.07", "1.36", "h", "-9", "A", "1.84", "1.84", "0", "0", "1", "12.31", "13", "l", "0.48", "-9.16", "h", "8.9", "a", "2", "2", "0", "0", "1", "2", "2", "L", "23.53", "9", "A", "2.11", "2.11", "0", "0", "1", "21.47", "11", "Z", "m", "8.4", "-2.49", "l", "0.08", "-2.16", "a", "1.07", "1.07", "0", "0", "0", "-1.09", "-1.09", "H", "14.09", "l", "-0.22", "4.33", "H", "21", "A", "1.15", "1.15", "0", "0", "0", "22.19", "8.51", "Z"],
            h = ["M", "33.94", "3.86", "a", "1.93", "1.93", "0", "0", "1", "2", "1.95", "l", "-0.47", "9.27", "H", "34.07", "l", "0.45", "-8.72", "a", "1.09", "1.09", "0", "0", "0", "-1.09", "-1.1", "H", "26.3", "l", "-0.51", "9.82", "H", "24.41", "L", "25", "3.85", "Z"],
            c = ["M", "36.48", "17.72", "H", "45", "a", "1.16", "1.16", "0", "0", "0", "1.16", "-1.22", "l", "0.07", "-1.43", "H", "38.72", "a", "2", "2", "0", "0", "1", "-2", "-2.06", "l", "0.37", "-7.19", "a", "2", "2", "0", "0", "1", "2.15", "-2", "H", "48.2", "l", "-0.69", "13.28", "a", "2.09", "2.09", "0", "0", "1", "-2.06", "2", "h", "-9", "Z", "m", "9.85", "-4.05", "l", "0.44", "-8.45", "H", "39.53", "a", "1.07", "1.07", "0", "0", "0", "-1.08", "1.1", "l", "-0.32", "6.27", "a", "1.16", "1.16", "0", "0", "0", "1.1", "1.1", "Z"],
            d = ["M", "57.43", "11.59", "L", "63.48", "0", "h", "1.83", "l", "-0.79", "15.05", "H", "63.15", "l", "0.67", "-12.79", "L", "57.67", "14", "h", "-0.75", "L", "52.07", "2.34", "l", "-0.64", "12.72", "H", "50", "L", "50.83", "0", "H", "52.6", "Z"],
            f = ["M", "69.6", "10.2", "l", "-2.37", "4.87", "h", "-1.5", "L", "73.09", "0", "h", "1.49", "l", "5.77", "15.05", "h", "-1.5", "L", "77", "10.2", "Z", "m", "6.86", "-1.39", "L", "73.74", "1.73", "L", "70.28", "8.81", "Z"],
            m = ["M", "82.95", "15.07", "H", "81.57", "L", "82.35", "0", "h", "10", "a", "1.94", "1.94", "0", "0", "1", "1.85", "2", "L", "93.89", "7.4", "a", "2", "2", "0", "0", "1", "-2", "1.92", "H", "83.25", "Z", "m", "8.43", "-7.15", "a", "1.13", "1.13", "0", "0", "0", "1.09", "-1.09", "l", "0.35", "-4.37", "a", "1.1", "1.1", "0", "0", "0", "-1.08", "-1.06", "H", "83.66", "l", "-0.34", "6.53", "Z"];

        function a() {
            var e = document.createElement("canvas"),
                t = e.getContext("2d");
            e.width = 500, e.height = 120, e.style.width = "500px", e.style.height = "120px";
            var n = {
                    x: 0,
                    y: 0
                },
                r = {
                    x: 0,
                    y: 0
                };
            t.transform(5, 0, 0, 5, 10, 10);
            var i = t.createLinearGradient(5.9, 15.07, 5.9, 0);
            i.addColorStop(0, "#232323"), i.addColorStop(1, "#585858"), t.fillStyle = i, t.beginPath(), s(l, t, r, n), t.closePath(), t.fill(), t.beginPath(), s(u, t, r, n), t.closePath(), t.fill(), t.beginPath(), s(h, t, r, n), t.closePath(), t.fill(), t.beginPath(), s(c, t, r, n), t.closePath(), t.fill();
            var a = t.createLinearGradient(57.68, 15.07, 57.68, 0);
            a.addColorStop(0, "#77bf00"), a.addColorStop(1, "#addc0c"), t.fillStyle = a, t.beginPath(), s(d, t, r, n), t.closePath(), t.fill(), t.beginPath(), s(f, t, r, n), t.closePath(), t.fill(), t.beginPath(), s(m, t, r, n), t.closePath(), t.fill();
            var o = new fm.CanvasTexture(e);
            return o
        }
        i.default.f = l, i.default.e = u, i.default.n = h, i.default.g = c, i.default.m = d, i.default.a = f, i.default.p = m, i.default.d = a
    }], r = {}, i.m = n, i.c = r, i.d = function (e, t, n) {
        i.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: n
        })
    }, i.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, i.t = function (t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) i.d(n, r, function (e) {
                return t[e]
            }.bind(null, r));
        return n
    }, i.n = function (e) {
        var t = e && e.__esModule ? function () {
            return e.default
        } : function () {
            return e
        };
        return i.d(t, "a", t), t
    }, i.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, i.p = "", i(i.s = 255)).default;

    function i(e) {
        if (r[e]) return r[e].exports;
        var t = r[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return n[e].call(t.exports, t, t.exports, i), t.l = !0, t.exports
    }
    var n, r
}, "object" == typeof exports && "object" == typeof module ? module.exports = c() : "function" == typeof define && define.amd ? define([], c) : "object" == typeof exports ? exports.fengmap = c() : b.fengmap = c();